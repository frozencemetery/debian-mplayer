--- xine-lib-1.0.1.orig/src/libffmpeg/libavcodec/4xm.c
+++ xine-lib-1.0.1/src/libffmpeg/libavcodec/4xm.c
@@ -606,7 +606,7 @@
     }
 
     frame_4cc= get32(buf);
-    if(buf_size != get32(buf+4)+8){
+    if(buf_size != get32(buf+4)+8 || buf_size < 20){
         av_log(f->avctx, AV_LOG_ERROR, "size missmatch %d %d\n", buf_size, get32(buf+4));
     }
 
@@ -634,6 +634,10 @@
         cfrm= &f->cfrm[i];
         
         cfrm->data= av_fast_realloc(cfrm->data, &cfrm->allocated_size, cfrm->size + data_size + FF_INPUT_BUFFER_PADDING_SIZE);
+        if(!cfrm->data){ //explicit check needed as memcpy below might not catch a NULL
+            av_log(f->avctx, AV_LOG_ERROR, "realloc falure");
+            return -1;
+        }
         
         memcpy(cfrm->data + cfrm->size, buf+20, data_size);
         cfrm->size += data_size;
--- xine-lib-1.0.1.orig/src/libffmpeg/libavcodec/utils.c
+++ xine-lib-1.0.1/src/libffmpeg/libavcodec/utils.c
@@ -200,27 +200,11 @@
         buf->last_pic_num= *picture_number;
     }else{
         int h_chroma_shift, v_chroma_shift;
-        int s_align, pixel_size;
+        int s_align, pixel_size, size[3];
+        AVPicture picture;
         
         avcodec_get_chroma_sub_sample(s->pix_fmt, &h_chroma_shift, &v_chroma_shift);
         
-        switch(s->pix_fmt){
-        case PIX_FMT_RGB555:
-        case PIX_FMT_RGB565:
-        case PIX_FMT_YUV422:
-            pixel_size=2;
-            break;
-        case PIX_FMT_RGB24:
-        case PIX_FMT_BGR24:
-            pixel_size=3;
-            break;
-        case PIX_FMT_RGBA32:
-            pixel_size=4;
-            break;
-        default:
-            pixel_size=1;
-        }
-
         avcodec_align_dimensions(s, &w, &h);
 #if defined(ARCH_POWERPC) || defined(HAVE_MMI) //FIXME some cleaner check
         s_align= 16;
@@ -232,21 +216,41 @@
             w+= EDGE_WIDTH*2;
             h+= EDGE_WIDTH*2;
         }
+
+        avpicture_fill(&picture, NULL, s->pix_fmt, w, h);
+        pixel_size= picture.linesize[0]*8 / w;
+//av_log(NULL, AV_LOG_ERROR, "%d %d %d %d\n", (int)picture.data[1], w, h, s->pix_fmt);
+        assert(pixel_size>=1);
+            //FIXME next ensures that linesize= 2^x uvlinesize, thats needed because some MC code assumes it
+        if(pixel_size == 3*8)
+            w= ALIGN(w, s_align<<h_chroma_shift);
+        else
+            w= ALIGN(pixel_size*w, s_align<<(h_chroma_shift+3)) / pixel_size;
+        size[1] = avpicture_fill(&picture, NULL, s->pix_fmt, w, h);
+        size[0] = picture.linesize[0] * h;
+        size[1] -= size[0];
+        if(picture.data[2])
+            size[1]= size[2]= size[1]/2;
+        else
+            size[2]= 0;
         
         buf->last_pic_num= -256*256*256*64;
+        memset(buf->base, 0, sizeof(buf->base));
+        memset(buf->data, 0, sizeof(buf->data));
 
-        for(i=0; i<3; i++){
+        for(i=0; i<3 && size[i]; i++){
             const int h_shift= i==0 ? 0 : h_chroma_shift;
             const int v_shift= i==0 ? 0 : v_chroma_shift;
 
-            //FIXME next ensures that linesize= 2^x uvlinesize, thats needed because some MC code assumes it
-            buf->linesize[i]= ALIGN(pixel_size*w>>h_shift, s_align<<(h_chroma_shift-h_shift)); 
+            buf->linesize[i]= picture.linesize[i];
 
-            buf->base[i]= av_mallocz((buf->linesize[i]*h>>v_shift)+16); //FIXME 16
+            buf->base[i]= av_malloc(size[i]+16); //FIXME 16
             if(buf->base[i]==NULL) return -1;
-            memset(buf->base[i], 128, buf->linesize[i]*h>>v_shift);
         
-            if(s->flags&CODEC_FLAG_EMU_EDGE)
+            memset(buf->base[i], 128, size[i]);
+
+            // no edge if EDEG EMU or not planar YUV, we check for PAL8 redundantly to protect against a exploitable bug regression ...
+            if((s->flags&CODEC_FLAG_EMU_EDGE) || (s->pix_fmt == PIX_FMT_PAL8) || !size[2])
                 buf->data[i] = buf->base[i];
             else
                 buf->data[i] = buf->base[i] + ALIGN((buf->linesize[i]*EDGE_WIDTH>>v_shift) + (EDGE_WIDTH>>h_shift), s_align);
--- xine-lib-1.0.1.orig/src/input/libreal/real.c
+++ xine-lib-1.0.1/src/input/libreal/real.c
@@ -482,7 +482,7 @@
 
     lprintf("calling asmrp_match with:\n%s\n%u\n", desc->stream[i]->asm_rule_book, bandwidth);
 
-    n=asmrp_match(desc->stream[i]->asm_rule_book, bandwidth, rulematches);
+    n=asmrp_match(desc->stream[i]->asm_rule_book, bandwidth, rulematches, sizeof(rulematches)/sizeof(rulematches[0]));
     for (j=0; j<n; j++) {
       lprintf("asmrp rule match: %u for stream %u\n", rulematches[j], desc->stream[i]->stream_id);
       sprintf(b,"stream=%u;rule=%u,", desc->stream[i]->stream_id, rulematches[j]);
--- xine-lib-1.0.1.orig/src/input/libreal/asmrp.c
+++ xine-lib-1.0.1/src/input/libreal/asmrp.c
@@ -604,7 +604,7 @@
   return ret;
 }
 
-static int asmrp_eval (asmrp_t *p, int *matches) {
+static int asmrp_eval (asmrp_t *p, int *matches, int matchsize) {
 
   int rule_num, num_matches;
 
@@ -613,7 +613,7 @@
   asmrp_get_sym (p);
 
   rule_num = 0; num_matches = 0;
-  while (p->sym != ASMRP_SYM_EOF) {
+  while (p->sym != ASMRP_SYM_EOF && num_matches < matchsize - 1) {
 
     if (asmrp_rule (p)) {
       lprintf ("rule #%d is true\n", rule_num);
@@ -629,7 +629,7 @@
   return num_matches;
 }
 
-int asmrp_match (const char *rules, int bandwidth, int *matches) {
+int asmrp_match (const char *rules, int bandwidth, int *matches, int matchsize) {
 
   asmrp_t *p;
   int      num_matches;
@@ -641,7 +641,7 @@
   asmrp_set_id (p, "Bandwidth", bandwidth);
   asmrp_set_id (p, "OldPNMPlayer", 0);
 
-  num_matches = asmrp_eval (p, matches);
+  num_matches = asmrp_eval (p, matches, matchsize);
 
   asmrp_dispose (p);
 
--- xine-lib-1.0.1.orig/src/input/libreal/asmrp.h
+++ xine-lib-1.0.1/src/input/libreal/asmrp.h
@@ -37,6 +37,6 @@
 #ifndef HAVE_ASMRP_H
 #define HAVE_ASMRP_H
 
-int asmrp_match (const char *rules, int bandwidth, int *matches) ;
+int asmrp_match (const char *rules, int bandwidth, int *matches, int matchesizxe) ;
 
 #endif
--- xine-lib-1.0.1.orig/src/input/input_cdda.c
+++ xine-lib-1.0.1/src/input/input_cdda.c
@@ -1473,7 +1473,7 @@
     return;
   }
   else {
-    fprintf(fd, filecontent);
+    fprintf(fd, "%s", filecontent);
     fclose(fd);
   }
   
--- xine-lib-1.0.1.orig/src/input/input_http.c
+++ xine-lib-1.0.1/src/input/input_http.c
@@ -891,6 +891,12 @@
 	len = 0;
     } else
       len ++;
+    if ( len >= buflen ) {
+      _x_message(this->stream, XINE_MSG_PERMISSION_ERROR, this->mrl, NULL);
+      xine_log (this->stream->xine, XINE_LOG_MSG,
+		_("input_http: buffer exhausted after %d bytes."), buflen);
+      return 0;
+    }
   }
 
   lprintf ("end of headers\n");
--- xine-lib-1.0.1.orig/src/demuxers/demux_avi.c
+++ xine-lib-1.0.1/src/demuxers/demux_avi.c
@@ -1043,7 +1043,14 @@
          lprintf("Invalid Header, bIndexSubType != 0\n");
       }
 
-      superindex->aIndex = malloc (superindex->wLongsPerEntry * superindex->nEntriesInUse * sizeof (uint32_t));
+      if (superindex->nEntriesInUse > n / sizeof (avisuperindex_entry))
+      {
+         lprintf("broken index !, dwSize=%d, entries=%d\n", n, superindex->nEntriesInUse);
+         i += 8 + n;
+         continue;
+      }
+
+      superindex->aIndex = malloc (superindex->nEntriesInUse * sizeof (avisuperindex_entry));
       /* position of ix## chunks */
       for (j = 0; j < superindex->nEntriesInUse; ++j) {
         superindex->aIndex[j].qwOffset = LE_64 (a);   a += 8;
--- xine-lib-1.0.1.orig/debian/control
+++ xine-lib-1.0.1/debian/control
@@ -3,14 +3,14 @@
 Priority: optional
 Maintainer: Siggi Langauf <siggi@debian.org>
 Uploaders: Philipp Matthias Hahn <pmhahn@debian.org>
-Build-Depends: debhelper (>= 4.0.4), aalib1-dev (>= 1.4p5-2), libcaca-dev, xlibs-dev (>> 4.1), xlibs-static-dev, libesd0-dev, zlib1g-dev | libz-dev, libartsc0-dev (>>1.1.0), liblircclient-dev, libogg-dev, libvorbis-dev, libtheora-dev, libasound2-dev, libflac-dev (>>1.1.0), libmodplug-dev, libgnomevfs2-dev, libsmbclient-dev, libspeex-dev, libmng-dev, libpng12-dev | libpng-dev, libfreetype6-dev
+Build-Depends: debhelper (>= 4.0.4), aalib1-dev (>= 1.4p5-2), libcaca-dev, xlibs-dev (>> 4.1), xlibs-static-dev, libesd0-dev, zlib1g-dev | libz-dev, libartsc0-dev (>>1.1.0), liblircclient-dev, libogg-dev, libvorbis-dev, libtheora-dev, libasound2-dev, libflac-dev (>>1.1.0), libmodplug-dev, libgnomevfs2-dev, libsmbclient-dev, libspeex-dev, libmng-dev, libpng12-dev | libpng-dev, libfreetype6-dev, libsdl1.2-dev (>=1.1.5)
 Build-Conflicts: libdvdnav-dev
 Standards-Version: 3.5.9
 
 Package: libxine-dev
 Architecture: any
 Section: libdevel
-Depends: libxine1 (= ${Source-Version}), libc6-dev, xlibs-dev, zlib1g-dev | libz-dev, slang1-dev, libfreetype6-dev
+Depends: libxine1 (= ${Source-Version}), libc6-dev, xlibs-dev, zlib1g-dev | libz-dev, slang1-dev | slang1-utf8-dev, libfreetype6-dev
 Conflicts: xine-ui (<< 0.9.10)
 Description: the xine video player library, development packages
  This contains development files (headers, documentation and the like)
--- xine-lib-1.0.1.orig/debian/rules
+++ xine-lib-1.0.1/debian/rules
@@ -96,12 +96,15 @@
 	#dh_install --autodest --sourcedir=debian/tmp --list-missing
 	dh_install --autodest
 	dh_installdocs
+	#ugly hack, documentation should never have been in /u/s/d/xine/...
+	mv debian/tmp/usr/share/doc/xine/{faq,README*} \
+           debian/libxine1/usr/share/doc/libxine1
 	dh_installchangelogs -k ChangeLog
 	dh_link
 	dh_strip
 	dh_compress
 	dh_fixperms
-	dh_makeshlibs -V 'libxine1 (>= 1-rc3a)'
+	dh_makeshlibs -V 'libxine1 (>= 1.0.1)'
 	dh_installdeb
 #	dh_shlibdeps
 	chmod +x debian/shlibdeps.sh
--- xine-lib-1.0.1.orig/debian/changelog
+++ xine-lib-1.0.1/debian/changelog
@@ -1,9 +1,53 @@
-xine-lib (1.0.1-0) unstable; urgency=high
+xine-lib (1.0.1-1sarge5) stable-security; urgency=high
 
-  * new upstream release
-    * fixes MMST and RTSP vulnerabilities (CAN-2005-1195, closes #305343)
+  * Fix buffer overflow in Real Media handler. (CVE-2006-6172)
+
+ -- Moritz Muehlenhoff <jmm@debian.org>  Wed, 27 Dec 2006 17:44:18 +0100
+
+xine-lib (1.0.1-1sarge4) stable-security; urgency=high
+
+  * Non-maintainer upload by the Security Team.
+  * Fix integer overflow in AVI header parsing (CVE-2006-4799)
+  * Fix buffer overflow in 4XM code (CVE-2006-4800)
+ 
+ -- Moritz Muehlenhoff <jmm@debian.org>  Sun, 19 Nov 2006 18:35:58 +0000
+
+xine-lib (1.0.1-1sarge3) stable-security; urgency=high
+
+  * Non-maintainer upload by the Security Team.
+  * Applied patch by Diego Petten to fix buffer overflow in the HTTP input
+    plugin [src/input/input_http.c, CVE-2006-2802]
+
+ -- Martin Schulze <joey@infodrom.org>  Thu,  8 Jun 2006 19:12:12 +0200
+
+xine-lib (1.0.1-1sarge2) stable-security; urgency=high
 
- -- Siggi Langauf <siggi@debian.org>  Mon, 25 Apr 2005 19:05:02 +0200
+  * Non-maintainer upload by the Security Team.
+  * Fix heap overflow in avcodec_default_get_buffer() from local
+    libavcodec copy (CVE-2005-4048)
+
+ -- Moritz Muehlenhoff <jmm@debian.org>  Tue, 14 Mar 2006 22:55:03 +0000
+
+xine-lib (1.0.1-1sarge1) stable-security; urgency=high
+
+  * Non-maintainer upload by the Security Team
+  * Applied patch by Ulf Härnhammar to fix a format string vulnerability
+    [src/input/input_cdda.c, CAN-2005-2967]
+
+ -- Martin Schulze <joey@infodrom.org>  Tue,  4 Oct 2005 19:30:12 +0200
+
+xine-lib (1.0.1-1) unstable; urgency=high
+
+  * new upstream release
+    * fixes MMST and RTSP vulnerabilities (CAN-2005-1195, closes: #305343)
+    * presumably fixes Ogg/Vorbis/Theora audio sync (closes: #301901)
+    * fixes typo in xine-check subsystem (closes: #292341)
+  * build-depends on libsdl1.2 (closes: #297435)
+  * allow installing libxine1-dev with slang1-utf8-dev (closes: #304865)
+  * moved documentation to policy compliant directories (closes: #303463)
+  * made Vorbis and Theora hard dependancies (workaround closes: #288331)
+  
+ -- Siggi Langauf <siggi@localhost.localdomain>  Wed, 27 Apr 2005 12:41:46 +0200
 
 xine-lib (1.0-1) unstable; urgency=high
 
--- xine-lib-1.0.1.orig/debian/shlibdeps.sh
+++ xine-lib-1.0.1/debian/shlibdeps.sh
@@ -22,14 +22,18 @@
           $installdir/usr/lib/xine/plugins/$ver/xineplug_inp_smb.so
 "
 
-RECOMMENDED="$installdir/usr/lib/xine/plugins/$ver/xineplug_decode_vorbis.so
+RECOMMENDED="
              $installdir/usr/lib/xine/plugins/$ver/xineplug_ao_out_oss.so
 	     $installdir/usr/lib/xine/plugins/$ver/xineplug_vo_out_xv.so
 	     $installdir/usr/lib/xine/plugins/$ver/xineplug_dmx_ogg.so
-             $installdir/usr/lib/xine/plugins/$ver/xineplug_decode_theora.so
              $installdir/usr/lib/xine/plugins/$ver/xineplug_dmx_mng.so
 "
 
+#these two do interdepend, so make them required for now:
+# $installdir/usr/lib/xine/plugins/$ver/xineplug_decode_vorbis.so
+# $installdir/usr/lib/xine/plugins/$ver/xineplug_decode_theora.so
+
+
 #start with all executables and shared objects
 REQUIRED=`find $installdir -type f \( -name \*.so -o -perm +111 \)`
 
--- xine-lib-1.0.1.orig/debian/libxine1.install
+++ xine-lib-1.0.1/debian/libxine1.install
@@ -2,12 +2,5 @@
 debian/tmp/usr/lib/xine/plugins/*/post/*.so
 debian/tmp/usr/lib/xine/plugins/*/*.so
 debian/tmp/usr/lib/xine/plugins/*/vidix/*.so
-debian/tmp/usr/share/doc/xine/faq
-debian/tmp/usr/share/doc/xine/README
-debian/tmp/usr/share/doc/xine/README.dvb
-debian/tmp/usr/share/doc/xine/README.dxr3
-debian/tmp/usr/share/doc/xine/README.network_dvd
-debian/tmp/usr/share/doc/xine/README.opengl
-debian/tmp/usr/share/doc/xine/README.syncfb
 debian/tmp/usr/share/locale
 debian/tmp/usr/share/xine
