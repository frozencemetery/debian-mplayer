From: Reinhard Tartler <siretart@tauware.de>
Subject: Backport libmpcodecs/ve_x264.c from trunk
Bug: https://bugs.launchpad.net/bugs/539555

--- a/libmpcodecs/ve_x264.c
+++ b/libmpcodecs/ve_x264.c
@@ -59,20 +59,6 @@ static int turbo = 0;
 static x264_param_t param;
 static int parse_error = 0;
 
-static int encode_nals(uint8_t *buf, int size, x264_nal_t *nals, int nnal){
-    uint8_t *p = buf;
-    int i;
-
-    for(i = 0; i < nnal; i++){
-        int s = x264_nal_encode(p, &size, 1, nals + i);
-        if(s < 0)
-            return -1;
-        p += s;
-    }
-
-    return p - buf;
-}
-
 static int put_image(struct vf_instance_s *vf, mp_image_t *mpi, double pts);
 static int encode_frame(struct vf_instance_s *vf, x264_picture_t *pic_in);
 
@@ -148,7 +134,7 @@ void x264enc_set_param(const m_option_t*
     }
 }
 
-static int config(struct vf_instance_s* vf, int width, int height, int d_width, int d_height, unsigned int flags, unsigned int outfmt) {
+static int config(struct vf_instance_s *vf, int width, int height, int d_width, int d_height, unsigned int flags, unsigned int outfmt) {
     h264_module_t *mod=(h264_module_t*)vf->priv;
 
     if(parse_error)
@@ -158,7 +144,7 @@ static int config(struct vf_instance_s* 
     mod->mux->bih->biHeight = height;
     mod->mux->bih->biSizeImage = width * height * 3;
     mod->mux->aspect = (float)d_width/d_height;
-    
+
     // make sure param is initialized
     x264enc_set_param(NULL, "");
     param.i_width = width;
@@ -181,7 +167,7 @@ static int config(struct vf_instance_s* 
         mp_msg(MSGT_MENCODER, MSGL_ERR, "Wrong colorspace.\n");
         return 0;
     }
-    
+
     mod->x264 = x264_encoder_open(&param);
     if(!mod->x264) {
         mp_msg(MSGT_MENCODER, MSGL_ERR, "x264_encoder_open failed.\n");
@@ -189,46 +175,38 @@ static int config(struct vf_instance_s* 
     }
 
     if(!param.b_repeat_headers){
-        uint8_t *extradata;
         x264_nal_t *nal;
-        int extradata_size, nnal, i, s = 0;
+        int extradata_size, nnal;
 
-        x264_encoder_headers(mod->x264, &nal, &nnal);
-
-        /* 5 bytes NAL header + worst case escaping */
-        for(i = 0; i < nnal; i++)
-            s += 5 + nal[i].i_payload * 4 / 3;
-
-        extradata = malloc(s);
-        extradata_size = encode_nals(extradata, s, nal, nnal);
+        extradata_size = x264_encoder_headers(mod->x264, &nal, &nnal);
 
         mod->mux->bih= realloc(mod->mux->bih, sizeof(BITMAPINFOHEADER) + extradata_size);
-        memcpy(mod->mux->bih + 1, extradata, extradata_size);
+        memcpy(mod->mux->bih + 1, nal->p_payload, extradata_size);
         mod->mux->bih->biSize= sizeof(BITMAPINFOHEADER) + extradata_size;
     }
-    
-    if (param.i_bframe > 1 && param.b_bframe_pyramid)
+
+    if (param.i_bframe > 1 && param.i_bframe_pyramid)
         mod->mux->decoder_delay = 2;
     else
         mod->mux->decoder_delay = param.i_bframe ? 1 : 0;
-    
+
     return 1;
 }
 
-static int control(struct vf_instance_s* vf, int request, void *data)
+static int control(struct vf_instance_s *vf, int request, void *data)
 {
     h264_module_t *mod=(h264_module_t*)vf->priv;
     switch(request){
         case VFCTRL_FLUSH_FRAMES:
-            if(param.i_bframe)
-                while(encode_frame(vf, NULL) > 0);
+            while (x264_encoder_delayed_frames(mod->x264) > 0)
+                encode_frame(vf, NULL);
             return CONTROL_TRUE;
         default:
             return CONTROL_UNKNOWN;
     }
 }
 
-static int query_format(struct vf_instance_s* vf, unsigned int fmt)
+static int query_format(struct vf_instance_s *vf, unsigned int fmt)
 {
     switch(fmt) {
     case IMGFMT_I420:
@@ -251,7 +229,7 @@ static int put_image(struct vf_instance_
 {
     h264_module_t *mod=(h264_module_t*)vf->priv;
     int i;
-    
+
     memset(&mod->pic, 0, sizeof(x264_picture_t));
     mod->pic.img.i_csp=param.i_csp;
     mod->pic.img.i_plane=3;
@@ -271,24 +249,18 @@ static int encode_frame(struct vf_instan
     x264_picture_t pic_out;
     x264_nal_t *nal;
     int i_nal;
-    int i_size = 0;
-    int i;
+    int i_size;
 
-    if(x264_encoder_encode(mod->x264, &nal, &i_nal, pic_in, &pic_out) < 0) {
+    i_size = x264_encoder_encode(mod->x264, &nal, &i_nal, pic_in, &pic_out);
+
+    if(i_size<0) {
         mp_msg(MSGT_MENCODER, MSGL_ERR, "x264_encoder_encode failed\n");
         return -1;
     }
-    
-    for(i=0; i < i_nal; i++) {
-        int i_data = mod->mux->buffer_size - i_size;
-        i_size += x264_nal_encode(mod->mux->buffer + i_size, &i_data, 1, &nal[i]);
-    }
     if(i_size>0) {
-        int keyframe = (pic_out.i_type == X264_TYPE_IDR) ||
-                       (pic_out.i_type == X264_TYPE_I
-                        && param.i_frame_reference == 1
-                        && !param.i_bframe);
-        muxer_write_chunk(mod->mux, i_size, keyframe?0x10:0, MP_NOPTS_VALUE, MP_NOPTS_VALUE);
+        int keyframe = pic_out.b_keyframe;
+        memcpy(mod->mux->buffer, nal->p_payload, i_size);
+        muxer_write_chunk(mod->mux, i_size, keyframe?AVIIF_KEYFRAME:0, MP_NOPTS_VALUE, MP_NOPTS_VALUE);
     }
     else
         ++mod->mux->encoder_delay;
