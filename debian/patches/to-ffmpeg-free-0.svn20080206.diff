#! /bin/sh /usr/share/dpatch/dpatch-run
## to-ffmpeg-free-0.svn20080206.diff by  <mennucc1@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: update internal ffmpeg code to ffmpeg-free 0.svn20080206

@DPATCH@
diff -u mplayer-1.0~rc2-12/libavcodec/4xm.c ffmpeg-free-0.svn20080206/libavcodec/4xm.c
--- mplayer-1.0~rc2-12/libavcodec/4xm.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/4xm.c	2008-03-20 19:10:57.000000000 +0100
@@ -131,8 +131,8 @@
     AVFrame current_picture, last_picture;
     GetBitContext pre_gb;          ///< ac/dc prefix
     GetBitContext gb;
-    uint8_t *bytestream;
-    uint16_t *wordstream;
+    const uint8_t *bytestream;
+    const uint16_t *wordstream;
     int mv[256];
     VLC pre_vlc;
     int last_dc;
@@ -301,7 +301,7 @@
     const int index= size2index[log2h][log2w];
     const int h= 1<<log2h;
     int code= get_vlc2(&f->gb, block_type_vlc[1-(f->version>1)][index].table, BLOCK_TYPE_VLC_BITS, 1);
-    uint16_t *start= f->last_picture.data[0];
+    uint16_t *start= (uint16_t*)f->last_picture.data[0];
     uint16_t *end= start + stride*(f->avctx->height-h+1) - (1<<log2w);
 
     assert(code>=0 && code<=6);
@@ -343,11 +343,7 @@
     }
 }
 
-static int get32(void *p){
-    return le2me_32(*(uint32_t*)p);
-}
-
-static int decode_p_frame(FourXContext *f, uint8_t *buf, int length){
+static int decode_p_frame(FourXContext *f, const uint8_t *buf, int length){
     int x, y;
     const int width= f->avctx->width;
     const int height= f->avctx->height;
@@ -358,9 +354,9 @@
 
     if(f->version>1){
         extra=20;
-        bitstream_size= get32(buf+8);
-        wordstream_size= get32(buf+12);
-        bytestream_size= get32(buf+16);
+        bitstream_size= AV_RL32(buf+8);
+        wordstream_size= AV_RL32(buf+12);
+        bytestream_size= AV_RL32(buf+16);
     }else{
         extra=0;
         bitstream_size = AV_RL16(buf-4);
@@ -379,10 +375,10 @@
     }
 
     f->bitstream_buffer= av_fast_realloc(f->bitstream_buffer, &f->bitstream_buffer_size, bitstream_size + FF_INPUT_BUFFER_PADDING_SIZE);
-    f->dsp.bswap_buf((uint32_t*)f->bitstream_buffer, (uint32_t*)(buf + extra), bitstream_size/4);
+    f->dsp.bswap_buf((uint32_t*)f->bitstream_buffer, (const uint32_t*)(buf + extra), bitstream_size/4);
     init_get_bits(&f->gb, f->bitstream_buffer, 8*bitstream_size);
 
-    f->wordstream= (uint16_t*)(buf + extra + bitstream_size);
+    f->wordstream= (const uint16_t*)(buf + extra + bitstream_size);
     f->bytestream= buf + extra + bitstream_size + wordstream_size;
 
     init_mv(f);
@@ -396,12 +392,12 @@
     }
 
     if(   bitstream_size != (get_bits_count(&f->gb)+31)/32*4
-       || (((char*)f->wordstream - (char*)buf + 2)&~2) != extra + bitstream_size + wordstream_size
-       || (((char*)f->bytestream - (char*)buf + 3)&~3) != extra + bitstream_size + wordstream_size + bytestream_size)
+       || (((const char*)f->wordstream - (const char*)buf + 2)&~2) != extra + bitstream_size + wordstream_size
+       || (((const char*)f->bytestream - (const char*)buf + 3)&~3) != extra + bitstream_size + wordstream_size + bytestream_size)
         av_log(f->avctx, AV_LOG_ERROR, " %d %td %td bytes left\n",
             bitstream_size - (get_bits_count(&f->gb)+31)/32*4,
-            -(((char*)f->bytestream - (char*)buf + 3)&~3) + (extra + bitstream_size + wordstream_size + bytestream_size),
-            -(((char*)f->wordstream - (char*)buf + 2)&~2) + (extra + bitstream_size + wordstream_size)
+            -(((const char*)f->bytestream - (const char*)buf + 3)&~3) + (extra + bitstream_size + wordstream_size + bytestream_size),
+            -(((const char*)f->wordstream - (const char*)buf + 2)&~2) + (extra + bitstream_size + wordstream_size)
         );
 
     return 0;
@@ -512,14 +508,14 @@
     return 0;
 }
 
-static uint8_t *read_huffman_tables(FourXContext *f, uint8_t * const buf){
+static const uint8_t *read_huffman_tables(FourXContext *f, const uint8_t * const buf){
     int frequency[512];
     uint8_t flag[512];
     int up[512];
     uint8_t len_tab[257];
     int bits_tab[257];
     int start, end;
-    uint8_t *ptr= buf;
+    const uint8_t *ptr= buf;
     int j;
 
     memset(frequency, 0, sizeof(frequency));
@@ -596,7 +592,7 @@
     return red/3*1024 + green/3*32 + blue/3;
 }
 
-static int decode_i2_frame(FourXContext *f, uint8_t *buf, int length){
+static int decode_i2_frame(FourXContext *f, const uint8_t *buf, int length){
     int x, y, x2, y2;
     const int width= f->avctx->width;
     const int height= f->avctx->height;
@@ -632,16 +628,16 @@
     return 0;
 }
 
-static int decode_i_frame(FourXContext *f, uint8_t *buf, int length){
+static int decode_i_frame(FourXContext *f, const uint8_t *buf, int length){
     int x, y;
     const int width= f->avctx->width;
     const int height= f->avctx->height;
     uint16_t *dst= (uint16_t*)f->current_picture.data[0];
     const int stride= f->current_picture.linesize[0]>>1;
-    const unsigned int bitstream_size= get32(buf);
-    const int token_count av_unused = get32(buf + bitstream_size + 8);
-    unsigned int prestream_size= 4*get32(buf + bitstream_size + 4);
-    uint8_t *prestream= buf + bitstream_size + 12;
+    const unsigned int bitstream_size= AV_RL32(buf);
+    const int token_count av_unused = AV_RL32(buf + bitstream_size + 8);
+    unsigned int prestream_size= 4*AV_RL32(buf + bitstream_size + 4);
+    const uint8_t *prestream= buf + bitstream_size + 12;
 
     if(prestream_size + bitstream_size + 12 != length
        || bitstream_size > (1<<26)
@@ -657,7 +653,7 @@
     prestream_size= length + buf - prestream;
 
     f->bitstream_buffer= av_fast_realloc(f->bitstream_buffer, &f->bitstream_buffer_size, prestream_size + FF_INPUT_BUFFER_PADDING_SIZE);
-    f->dsp.bswap_buf((uint32_t*)f->bitstream_buffer, (uint32_t*)prestream, prestream_size/4);
+    f->dsp.bswap_buf((uint32_t*)f->bitstream_buffer, (const uint32_t*)prestream, prestream_size/4);
     init_get_bits(&f->pre_gb, f->bitstream_buffer, 8*prestream_size);
 
     f->last_dc= 0*128*8*8;
@@ -680,23 +676,23 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     FourXContext * const f = avctx->priv_data;
     AVFrame *picture = data;
     AVFrame *p, temp;
     int i, frame_4cc, frame_size;
 
-    frame_4cc= get32(buf);
-    if(buf_size != get32(buf+4)+8 || buf_size < 20){
-        av_log(f->avctx, AV_LOG_ERROR, "size mismatch %d %d\n", buf_size, get32(buf+4));
+    frame_4cc= AV_RL32(buf);
+    if(buf_size != AV_RL32(buf+4)+8 || buf_size < 20){
+        av_log(f->avctx, AV_LOG_ERROR, "size mismatch %d %d\n", buf_size, AV_RL32(buf+4));
     }
 
     if(frame_4cc == ff_get_fourcc("cfrm")){
         int free_index=-1;
         const int data_size= buf_size - 20;
-        const int id= get32(buf+12);
-        const int whole_size= get32(buf+16);
+        const int id= AV_RL32(buf+12);
+        const int whole_size= AV_RL32(buf+16);
         CFrameBuffer *cfrm;
 
         for(i=0; i<CFRAME_BUFFER_COUNT; i++){
diff -u mplayer-1.0~rc2-12/libavcodec/8bps.c ffmpeg-free-0.svn20080206/libavcodec/8bps.c
--- mplayer-1.0~rc2-12/libavcodec/8bps.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/8bps.c	2008-03-20 19:10:57.000000000 +0100
@@ -57,14 +57,14 @@
  * Decode a frame
  *
  */
-static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size)
 {
         EightBpsContext * const c = avctx->priv_data;
-        unsigned char *encoded = (unsigned char *)buf;
+        const unsigned char *encoded = buf;
         unsigned char *pixptr, *pixptr_end;
         unsigned int height = avctx->height; // Real image height
         unsigned int dlen, p, row;
-        unsigned char *lp, *dp;
+        const unsigned char *lp, *dp;
         unsigned char count;
         unsigned int px_inc;
         unsigned int planes = c->planes;
@@ -97,7 +97,7 @@
                 for(row = 0; row < height; row++) {
                         pixptr = c->pic.data[0] + row * c->pic.linesize[0] + planemap[p];
                         pixptr_end = pixptr + c->pic.linesize[0];
-                        dlen = be2me_16(*(unsigned short *)(lp+row*2));
+                        dlen = be2me_16(*(const unsigned short *)(lp+row*2));
                         /* Decode a row of this plane */
                         while(dlen > 0) {
                                 if(dp + 1 >= buf+buf_size) return -1;
diff -u mplayer-1.0~rc2-12/libavcodec/aac_ac3_parser.c ffmpeg-free-0.svn20080206/libavcodec/aac_ac3_parser.c
--- mplayer-1.0~rc2-12/libavcodec/aac_ac3_parser.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/aac_ac3_parser.c	2008-03-20 19:10:57.000000000 +0100
@@ -37,16 +37,18 @@
 
     buf_ptr = buf;
     while (buf_size > 0) {
+        int size_needed= s->frame_size ? s->frame_size : s->header_size;
         len = s->inbuf_ptr - s->inbuf;
-        if (s->frame_size == 0) {
-            /* no header seen : find one. We need at least s->header_size
-               bytes to parse it */
-            len = FFMIN(s->header_size - len, buf_size);
 
+        if(len<size_needed){
+            len = FFMIN(size_needed - len, buf_size);
             memcpy(s->inbuf_ptr, buf_ptr, len);
-            buf_ptr += len;
+            buf_ptr      += len;
             s->inbuf_ptr += len;
-            buf_size -= len;
+            buf_size     -= len;
+        }
+
+        if (s->frame_size == 0) {
             if ((s->inbuf_ptr - s->inbuf) == s->header_size) {
                 len = s->sync(s->inbuf, &channels, &sample_rate, &bit_rate,
                               &samples);
@@ -58,11 +60,13 @@
                     s->frame_size = len;
                     /* update codec info */
                     avctx->sample_rate = sample_rate;
-                    /* set channels,except if the user explicitly requests 1 or 2 channels, XXX/FIXME this is a bit ugly */
-                    if(avctx->codec_id == CODEC_ID_AC3){
-                        if(avctx->channels!=1 && avctx->channels!=2){
-                            avctx->channels = channels;
-                        }
+                    /* allow downmixing to stereo (or mono for AC3) */
+                    if(avctx->request_channels > 0 &&
+                            avctx->request_channels < channels &&
+                            (avctx->request_channels <= 2 ||
+                            (avctx->request_channels == 1 &&
+                            avctx->codec_id == CODEC_ID_AC3))) {
+                        avctx->channels = avctx->request_channels;
                     } else {
                         avctx->channels = channels;
                     }
@@ -71,13 +75,6 @@
                 }
             }
         } else {
-            len = FFMIN(s->frame_size - len, buf_size);
-
-            memcpy(s->inbuf_ptr, buf_ptr, len);
-            buf_ptr += len;
-            s->inbuf_ptr += len;
-            buf_size -= len;
-
             if(s->inbuf_ptr - s->inbuf == s->frame_size){
                 *poutbuf = s->inbuf;
                 *poutbuf_size = s->frame_size;
diff -u mplayer-1.0~rc2-12/libavcodec/aac_ac3_parser.h ffmpeg-free-0.svn20080206/libavcodec/aac_ac3_parser.h
--- mplayer-1.0~rc2-12/libavcodec/aac_ac3_parser.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/aac_ac3_parser.h	2007-10-17 11:37:46.000000000 +0200
@@ -20,8 +20,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AAC_AC3_PARSER_H
-#define AAC_AC3_PARSER_H
+#ifndef FFMPEG_AAC_AC3_PARSER_H
+#define FFMPEG_AAC_AC3_PARSER_H
 
 #include <stdint.h>
 #include "avcodec.h"
@@ -40,4 +40,4 @@
                      const uint8_t **poutbuf, int *poutbuf_size,
                      const uint8_t *buf, int buf_size);
 
-#endif /* AAC_AC3_PARSER_H */
+#endif /* FFMPEG_AAC_AC3_PARSER_H */
diff -u mplayer-1.0~rc2-12/libavcodec/aac_parser.c ffmpeg-free-0.svn20080206/libavcodec/aac_parser.c
--- mplayer-1.0~rc2-12/libavcodec/aac_parser.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/aac_parser.c	2008-03-20 19:10:57.000000000 +0100
@@ -67,6 +67,9 @@
     skip_bits1(&bits);          /* copyright_identification_bit */
     skip_bits1(&bits);          /* copyright_identification_start */
     size = get_bits(&bits, 13); /* aac_frame_length */
+    if(size < AAC_HEADER_SIZE)
+        return 0;
+
     skip_bits(&bits, 11);       /* adts_buffer_fullness */
     rdb = get_bits(&bits, 2);   /* number_of_raw_data_blocks_in_frame */
 
diff -u mplayer-1.0~rc2-12/libavcodec/aasc.c ffmpeg-free-0.svn20080206/libavcodec/aasc.c
--- mplayer-1.0~rc2-12/libavcodec/aasc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/aasc.c	2008-03-20 19:10:57.000000000 +0100
@@ -58,7 +58,7 @@
 
 static int aasc_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
-                              uint8_t *buf, int buf_size)
+                              const uint8_t *buf, int buf_size)
 {
     AascContext *s = avctx->priv_data;
     int stream_ptr = 4;
diff -u mplayer-1.0~rc2-12/libavcodec/ac3.c ffmpeg-free-0.svn20080206/libavcodec/ac3.c
--- mplayer-1.0~rc2-12/libavcodec/ac3.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ac3.c	2008-03-20 19:10:57.000000000 +0100
@@ -28,8 +28,8 @@
 #include "ac3.h"
 #include "bitstream.h"
 
-static uint8_t bndtab[51];
-static uint8_t masktab[253];
+static uint8_t band_start_tab[51];
+static uint8_t bin_to_band_tab[253];
 
 static inline int calc_lowcomp1(int a, int b0, int b1, int c)
 {
@@ -53,7 +53,7 @@
 }
 
 void ff_ac3_bit_alloc_calc_psd(int8_t *exp, int start, int end, int16_t *psd,
-                               int16_t *bndpsd)
+                               int16_t *band_psd)
 {
     int bin, i, j, k, end1, v;
 
@@ -64,26 +64,26 @@
 
     /* PSD integration */
     j=start;
-    k=masktab[start];
+    k=bin_to_band_tab[start];
     do {
         v=psd[j];
         j++;
-        end1 = FFMIN(bndtab[k+1], end);
+        end1 = FFMIN(band_start_tab[k+1], end);
         for(i=j;i<end1;i++) {
             /* logadd */
             int adr = FFMIN(FFABS(v - psd[j]) >> 1, 255);
-            v = FFMAX(v, psd[j]) + ff_ac3_latab[adr];
+            v = FFMAX(v, psd[j]) + ff_ac3_log_add_tab[adr];
             j++;
         }
-        bndpsd[k]=v;
+        band_psd[k]=v;
         k++;
-    } while (end > bndtab[k]);
+    } while (end > band_start_tab[k]);
 }
 
-void ff_ac3_bit_alloc_calc_mask(AC3BitAllocParameters *s, int16_t *bndpsd,
-                                int start, int end, int fgain, int is_lfe,
-                                int deltbae, int deltnseg, uint8_t *deltoffst,
-                                uint8_t *deltlen, uint8_t *deltba,
+void ff_ac3_bit_alloc_calc_mask(AC3BitAllocParameters *s, int16_t *band_psd,
+                                int start, int end, int fast_gain, int is_lfe,
+                                int dba_mode, int dba_nsegs, uint8_t *dba_offsets,
+                                uint8_t *dba_lengths, uint8_t *dba_values,
                                 int16_t *mask)
 {
     int16_t excite[50]; /* excitation */
@@ -92,24 +92,24 @@
     int lowcomp, fastleak, slowleak;
 
     /* excitation function */
-    bndstrt = masktab[start];
-    bndend = masktab[end-1] + 1;
+    bndstrt = bin_to_band_tab[start];
+    bndend = bin_to_band_tab[end-1] + 1;
 
     if (bndstrt == 0) {
         lowcomp = 0;
-        lowcomp = calc_lowcomp1(lowcomp, bndpsd[0], bndpsd[1], 384);
-        excite[0] = bndpsd[0] - fgain - lowcomp;
-        lowcomp = calc_lowcomp1(lowcomp, bndpsd[1], bndpsd[2], 384);
-        excite[1] = bndpsd[1] - fgain - lowcomp;
+        lowcomp = calc_lowcomp1(lowcomp, band_psd[0], band_psd[1], 384);
+        excite[0] = band_psd[0] - fast_gain - lowcomp;
+        lowcomp = calc_lowcomp1(lowcomp, band_psd[1], band_psd[2], 384);
+        excite[1] = band_psd[1] - fast_gain - lowcomp;
         begin = 7;
         for (bin = 2; bin < 7; bin++) {
             if (!(is_lfe && bin == 6))
-                lowcomp = calc_lowcomp1(lowcomp, bndpsd[bin], bndpsd[bin+1], 384);
-            fastleak = bndpsd[bin] - fgain;
-            slowleak = bndpsd[bin] - s->sgain;
+                lowcomp = calc_lowcomp1(lowcomp, band_psd[bin], band_psd[bin+1], 384);
+            fastleak = band_psd[bin] - fast_gain;
+            slowleak = band_psd[bin] - s->slow_gain;
             excite[bin] = fastleak - lowcomp;
             if (!(is_lfe && bin == 6)) {
-                if (bndpsd[bin] <= bndpsd[bin+1]) {
+                if (band_psd[bin] <= band_psd[bin+1]) {
                     begin = bin + 1;
                     break;
                 }
@@ -121,10 +121,10 @@
 
         for (bin = begin; bin < end1; bin++) {
             if (!(is_lfe && bin == 6))
-                lowcomp = calc_lowcomp(lowcomp, bndpsd[bin], bndpsd[bin+1], bin);
+                lowcomp = calc_lowcomp(lowcomp, band_psd[bin], band_psd[bin+1], bin);
 
-            fastleak = FFMAX(fastleak - s->fdecay, bndpsd[bin] - fgain);
-            slowleak = FFMAX(slowleak - s->sdecay, bndpsd[bin] - s->sgain);
+            fastleak = FFMAX(fastleak - s->fast_decay, band_psd[bin] - fast_gain);
+            slowleak = FFMAX(slowleak - s->slow_decay, band_psd[bin] - s->slow_gain);
             excite[bin] = FFMAX(fastleak - lowcomp, slowleak);
         }
         begin = 22;
@@ -132,39 +132,39 @@
         /* coupling channel */
         begin = bndstrt;
 
-        fastleak = (s->cplfleak << 8) + 768;
-        slowleak = (s->cplsleak << 8) + 768;
+        fastleak = (s->cpl_fast_leak << 8) + 768;
+        slowleak = (s->cpl_slow_leak << 8) + 768;
     }
 
     for (bin = begin; bin < bndend; bin++) {
-        fastleak = FFMAX(fastleak - s->fdecay, bndpsd[bin] - fgain);
-        slowleak = FFMAX(slowleak - s->sdecay, bndpsd[bin] - s->sgain);
+        fastleak = FFMAX(fastleak - s->fast_decay, band_psd[bin] - fast_gain);
+        slowleak = FFMAX(slowleak - s->slow_decay, band_psd[bin] - s->slow_gain);
         excite[bin] = FFMAX(fastleak, slowleak);
     }
 
     /* compute masking curve */
 
     for (bin = bndstrt; bin < bndend; bin++) {
-        tmp = s->dbknee - bndpsd[bin];
+        tmp = s->db_per_bit - band_psd[bin];
         if (tmp > 0) {
             excite[bin] += tmp >> 2;
         }
-        mask[bin] = FFMAX(ff_ac3_hth[bin >> s->halfratecod][s->fscod], excite[bin]);
+        mask[bin] = FFMAX(ff_ac3_hearing_threshold_tab[bin >> s->sr_shift][s->sr_code], excite[bin]);
     }
 
     /* delta bit allocation */
 
-    if (deltbae == DBA_REUSE || deltbae == DBA_NEW) {
+    if (dba_mode == DBA_REUSE || dba_mode == DBA_NEW) {
         int band, seg, delta;
         band = 0;
-        for (seg = 0; seg < deltnseg; seg++) {
-            band += deltoffst[seg];
-            if (deltba[seg] >= 4) {
-                delta = (deltba[seg] - 3) << 7;
+        for (seg = 0; seg < dba_nsegs; seg++) {
+            band += dba_offsets[seg];
+            if (dba_values[seg] >= 4) {
+                delta = (dba_values[seg] - 3) << 7;
             } else {
-                delta = (deltba[seg] - 4) << 7;
+                delta = (dba_values[seg] - 4) << 7;
             }
-            for (k = 0; k < deltlen[seg]; k++) {
+            for (k = 0; k < dba_lengths[seg]; k++) {
                 mask[band] += delta;
                 band++;
             }
@@ -173,49 +173,49 @@
 }
 
 void ff_ac3_bit_alloc_calc_bap(int16_t *mask, int16_t *psd, int start, int end,
-                               int snroffset, int floor, uint8_t *bap)
+                               int snr_offset, int floor, uint8_t *bap)
 {
     int i, j, k, end1, v, address;
 
-    /* special case, if snroffset is -960, set all bap's to zero */
-    if(snroffset == -960) {
+    /* special case, if snr offset is -960, set all bap's to zero */
+    if(snr_offset == -960) {
         memset(bap, 0, 256);
         return;
     }
 
     i = start;
-    j = masktab[start];
+    j = bin_to_band_tab[start];
     do {
-        v = (FFMAX(mask[j] - snroffset - floor, 0) & 0x1FE0) + floor;
-        end1 = FFMIN(bndtab[j] + ff_ac3_bndsz[j], end);
+        v = (FFMAX(mask[j] - snr_offset - floor, 0) & 0x1FE0) + floor;
+        end1 = FFMIN(band_start_tab[j] + ff_ac3_critical_band_size_tab[j], end);
         for (k = i; k < end1; k++) {
             address = av_clip((psd[i] - v) >> 5, 0, 63);
-            bap[i] = ff_ac3_baptab[address];
+            bap[i] = ff_ac3_bap_tab[address];
             i++;
         }
-    } while (end > bndtab[j++]);
+    } while (end > band_start_tab[j++]);
 }
 
 /* AC3 bit allocation. The algorithm is the one described in the AC3
    spec. */
 void ac3_parametric_bit_allocation(AC3BitAllocParameters *s, uint8_t *bap,
                                    int8_t *exp, int start, int end,
-                                   int snroffset, int fgain, int is_lfe,
-                                   int deltbae,int deltnseg,
-                                   uint8_t *deltoffst, uint8_t *deltlen,
-                                   uint8_t *deltba)
+                                   int snr_offset, int fast_gain, int is_lfe,
+                                   int dba_mode, int dba_nsegs,
+                                   uint8_t *dba_offsets, uint8_t *dba_lengths,
+                                   uint8_t *dba_values)
 {
     int16_t psd[256];   /* scaled exponents */
-    int16_t bndpsd[50]; /* interpolated exponents */
+    int16_t band_psd[50]; /* interpolated exponents */
     int16_t mask[50];   /* masking value */
 
-    ff_ac3_bit_alloc_calc_psd(exp, start, end, psd, bndpsd);
+    ff_ac3_bit_alloc_calc_psd(exp, start, end, psd, band_psd);
 
-    ff_ac3_bit_alloc_calc_mask(s, bndpsd, start, end, fgain, is_lfe,
-                               deltbae, deltnseg, deltoffst, deltlen, deltba,
+    ff_ac3_bit_alloc_calc_mask(s, band_psd, start, end, fast_gain, is_lfe,
+                               dba_mode, dba_nsegs, dba_offsets, dba_lengths, dba_values,
                                mask);
 
-    ff_ac3_bit_alloc_calc_bap(mask, psd, start, end, snroffset, s->floor, bap);
+    ff_ac3_bit_alloc_calc_bap(mask, psd, start, end, snr_offset, s->floor, bap);
 }
 
 /**
@@ -230,10 +230,10 @@
     k = 0;
     l = 0;
     for(i=0;i<50;i++) {
-        bndtab[i] = l;
-        v = ff_ac3_bndsz[i];
-        for(j=0;j<v;j++) masktab[k++]=i;
+        band_start_tab[i] = l;
+        v = ff_ac3_critical_band_size_tab[i];
+        for(j=0;j<v;j++) bin_to_band_tab[k++]=i;
         l += v;
     }
-    bndtab[50] = l;
+    band_start_tab[50] = l;
 }
diff -u mplayer-1.0~rc2-12/libavcodec/ac3dec.c ffmpeg-free-0.svn20080206/libavcodec/ac3dec.c
--- mplayer-1.0~rc2-12/libavcodec/ac3dec.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ac3dec.c	2008-03-20 19:10:57.000000000 +0100
@@ -35,6 +35,7 @@
 #include "avcodec.h"
 #include "ac3_parser.h"
 #include "bitstream.h"
+#include "crc.h"
 #include "dsputil.h"
 #include "random.h"
 
@@ -65,16 +66,13 @@
  * Quantization table: levels for symmetric. bits for asymmetric.
  * reference: Table 7.18 Mapping of bap to Quantizer
  */
-static const uint8_t qntztab[16] = {
+static const uint8_t quantization_tab[16] = {
     0, 3, 5, 7, 11, 15,
     5, 6, 7, 8, 9, 10, 11, 12, 14, 16
 };
 
 /** dynamic range table. converts codes to scale factors. */
-static float dynrng_tab[256];
-
-/** dialogue normalization table */
-static float dialnorm_tab[32];
+static float dynamic_range_tab[256];
 
 /** Adjustments in dB gain */
 #define LEVEL_MINUS_3DB         0.7071067811865476
@@ -97,13 +95,13 @@
  * Table for center mix levels
  * reference: Section 5.4.2.4 cmixlev
  */
-static const uint8_t clevs[4] = { 2, 3, 4, 3 };
+static const uint8_t center_levels[4] = { 2, 3, 4, 3 };
 
 /**
  * Table for surround mix levels
  * reference: Section 5.4.2.5 surmixlev
  */
-static const uint8_t slevs[4] = { 2, 4, 0, 4 };
+static const uint8_t surround_levels[4] = { 2, 4, 0, 4 };
 
 /**
  * Table for default stereo downmixing coefficients
@@ -128,52 +126,52 @@
 #define AC3_OUTPUT_LFEON  8
 
 typedef struct {
-    int acmod;                              ///< audio coding mode
-    int dsurmod;                            ///< dolby surround mode
-    int blksw[AC3_MAX_CHANNELS];            ///< block switch flags
-    int dithflag[AC3_MAX_CHANNELS];         ///< dither flags
+    int channel_mode;                       ///< channel mode (acmod)
+    int block_switch[AC3_MAX_CHANNELS];     ///< block switch flags
+    int dither_flag[AC3_MAX_CHANNELS];      ///< dither flags
     int dither_all;                         ///< true if all channels are dithered
-    int cplinu;                             ///< coupling in use
-    int chincpl[AC3_MAX_CHANNELS];          ///< channel in coupling
-    int phsflginu;                          ///< phase flags in use
-    int cplbndstrc[18];                     ///< coupling band structure
-    int rematstr;                           ///< rematrixing strategy
-    int nrematbnd;                          ///< number of rematrixing bands
-    int rematflg[4];                        ///< rematrixing flags
-    int expstr[AC3_MAX_CHANNELS];           ///< exponent strategies
-    int snroffst[AC3_MAX_CHANNELS];         ///< signal-to-noise ratio offsets
-    int fgain[AC3_MAX_CHANNELS];            ///< fast gain values (signal-to-mask ratio)
-    int deltbae[AC3_MAX_CHANNELS];          ///< delta bit allocation exists
-    int deltnseg[AC3_MAX_CHANNELS];         ///< number of delta segments
-    uint8_t deltoffst[AC3_MAX_CHANNELS][8]; ///< delta segment offsets
-    uint8_t deltlen[AC3_MAX_CHANNELS][8];   ///< delta segment lengths
-    uint8_t deltba[AC3_MAX_CHANNELS][8];    ///< delta values for each segment
+    int cpl_in_use;                         ///< coupling in use
+    int channel_in_cpl[AC3_MAX_CHANNELS];   ///< channel in coupling
+    int phase_flags_in_use;                 ///< phase flags in use
+    int phase_flags[18];                    ///< phase flags
+    int cpl_band_struct[18];                ///< coupling band structure
+    int num_rematrixing_bands;              ///< number of rematrixing bands
+    int rematrixing_flags[4];               ///< rematrixing flags
+    int exp_strategy[AC3_MAX_CHANNELS];     ///< exponent strategies
+    int snr_offset[AC3_MAX_CHANNELS];       ///< signal-to-noise ratio offsets
+    int fast_gain[AC3_MAX_CHANNELS];        ///< fast gain values (signal-to-mask ratio)
+    int dba_mode[AC3_MAX_CHANNELS];         ///< delta bit allocation mode
+    int dba_nsegs[AC3_MAX_CHANNELS];        ///< number of delta segments
+    uint8_t dba_offsets[AC3_MAX_CHANNELS][8]; ///< delta segment offsets
+    uint8_t dba_lengths[AC3_MAX_CHANNELS][8]; ///< delta segment lengths
+    uint8_t dba_values[AC3_MAX_CHANNELS][8];  ///< delta values for each segment
 
-    int sampling_rate;                      ///< sample frequency, in Hz
+    int sample_rate;                        ///< sample frequency, in Hz
     int bit_rate;                           ///< stream bit rate, in bits-per-second
     int frame_size;                         ///< current frame size, in bytes
 
-    int nchans;                             ///< number of total channels
-    int nfchans;                            ///< number of full-bandwidth channels
-    int lfeon;                              ///< lfe channel in use
+    int channels;                           ///< number of total channels
+    int fbw_channels;                       ///< number of full-bandwidth channels
+    int lfe_on;                             ///< lfe channel in use
     int lfe_ch;                             ///< index of LFE channel
     int output_mode;                        ///< output channel configuration
     int out_channels;                       ///< number of output channels
 
+    int center_mix_level;                   ///< Center mix level index
+    int surround_mix_level;                 ///< Surround mix level index
     float downmix_coeffs[AC3_MAX_CHANNELS][2];  ///< stereo downmix coefficients
-    float dialnorm[2];                      ///< dialogue normalization
-    float dynrng[2];                        ///< dynamic range
-    float cplco[AC3_MAX_CHANNELS][18];      ///< coupling coordinates
-    int   ncplbnd;                          ///< number of coupling bands
-    int   ncplsubnd;                        ///< number of coupling sub bands
-    int   startmant[AC3_MAX_CHANNELS];      ///< start frequency bin
-    int   endmant[AC3_MAX_CHANNELS];        ///< end frequency bin
+    float dynamic_range[2];                 ///< dynamic range
+    float cpl_coords[AC3_MAX_CHANNELS][18]; ///< coupling coordinates
+    int   num_cpl_bands;                    ///< number of coupling bands
+    int   num_cpl_subbands;                 ///< number of coupling sub bands
+    int   start_freq[AC3_MAX_CHANNELS];     ///< start frequency bin
+    int   end_freq[AC3_MAX_CHANNELS];       ///< end frequency bin
     AC3BitAllocParameters bit_alloc_params; ///< bit allocation parameters
 
     int8_t  dexps[AC3_MAX_CHANNELS][256];   ///< decoded exponents
     uint8_t bap[AC3_MAX_CHANNELS][256];     ///< bit allocation pointers
     int16_t psd[AC3_MAX_CHANNELS][256];     ///< scaled exponents
-    int16_t bndpsd[AC3_MAX_CHANNELS][50];   ///< interpolated exponents
+    int16_t band_psd[AC3_MAX_CHANNELS][50]; ///< interpolated exponents
     int16_t mask[AC3_MAX_CHANNELS][50];     ///< masking curve values
 
     DECLARE_ALIGNED_16(float, transform_coeffs[AC3_MAX_CHANNELS][256]);  ///< transform coefficients
@@ -193,36 +191,12 @@
     DECLARE_ALIGNED_16(float, window[256]);                         ///< window coefficients
 
     /* Miscellaneous. */
-    GetBitContext gb;                       ///< bitstream reader
+    GetBitContext gbc;                      ///< bitstream reader
     AVRandomState dith_state;               ///< for dither generation
     AVCodecContext *avctx;                  ///< parent context
 } AC3DecodeContext;
 
 /**
- * Generate a Kaiser-Bessel Derived Window.
- */
-static void ac3_window_init(float *window)
-{
-   int i, j;
-   double sum = 0.0, bessel, tmp;
-   double local_window[256];
-   double alpha2 = (5.0 * M_PI / 256.0) * (5.0 * M_PI / 256.0);
-
-   for (i = 0; i < 256; i++) {
-       tmp = i * (256 - i) * alpha2;
-       bessel = 1.0;
-       for (j = 100; j > 0; j--) /* default to 100 iterations */
-           bessel = bessel * tmp / (j * j) + 1;
-       sum += bessel;
-       local_window[i] = sum;
-   }
-
-   sum++;
-   for (i = 0; i < 256; i++)
-       window[i] = sqrt(local_window[i] / sum);
-}
-
-/**
  * Symmetrical Dequantization
  * reference: Section 7.3.3 Expansion of Mantissas for Symmetrical Quantization
  *            Tables 7.19 to 7.23
@@ -273,16 +247,8 @@
        reference: Section 7.7.1 Dynamic Range Control */
     for(i=0; i<256; i++) {
         int v = (i >> 5) - ((i >> 7) << 3) - 5;
-        dynrng_tab[i] = powf(2.0f, v) * ((i & 0x1F) | 0x20);
-    }
-
-    /* generate dialogue normalization table
-       references: Section 5.4.2.8 dialnorm
-                   Section 7.6 Dialogue Normalization */
-    for(i=1; i<32; i++) {
-        dialnorm_tab[i] = expf((i-31) * M_LN10 / 20.0f);
+        dynamic_range_tab[i] = powf(2.0f, v) * ((i & 0x1F) | 0x20);
     }
-    dialnorm_tab[0] = dialnorm_tab[31];
 
     /* generate scale factors for exponents and asymmetrical dequantization
        reference: Section 7.3.2 Expansion of Mantissas for Asymmetric Quantization */
@@ -304,24 +270,31 @@
  */
 static int ac3_decode_init(AVCodecContext *avctx)
 {
-    AC3DecodeContext *ctx = avctx->priv_data;
-    ctx->avctx = avctx;
+    AC3DecodeContext *s = avctx->priv_data;
+    s->avctx = avctx;
 
     ac3_common_init();
     ac3_tables_init();
-    ff_mdct_init(&ctx->imdct_256, 8, 1);
-    ff_mdct_init(&ctx->imdct_512, 9, 1);
-    ac3_window_init(ctx->window);
-    dsputil_init(&ctx->dsp, avctx);
-    av_init_random(0, &ctx->dith_state);
+    ff_mdct_init(&s->imdct_256, 8, 1);
+    ff_mdct_init(&s->imdct_512, 9, 1);
+    ff_kbd_window_init(s->window, 5.0, 256);
+    dsputil_init(&s->dsp, avctx);
+    av_init_random(0, &s->dith_state);
 
     /* set bias values for float to int16 conversion */
-    if(ctx->dsp.float_to_int16 == ff_float_to_int16_c) {
-        ctx->add_bias = 385.0f;
-        ctx->mul_bias = 1.0f;
+    if(s->dsp.float_to_int16 == ff_float_to_int16_c) {
+        s->add_bias = 385.0f;
+        s->mul_bias = 1.0f;
     } else {
-        ctx->add_bias = 0.0f;
-        ctx->mul_bias = 32767.0f;
+        s->add_bias = 0.0f;
+        s->mul_bias = 32767.0f;
+    }
+
+    /* allow downmixing to stereo or mono */
+    if (avctx->channels > 0 && avctx->request_channels > 0 &&
+            avctx->request_channels < avctx->channels &&
+            avctx->request_channels <= 2) {
+        avctx->channels = avctx->request_channels;
     }
 
     return 0;
@@ -332,118 +305,130 @@
  * GetBitContext within AC3DecodeContext must point to
  * start of the synchronized ac3 bitstream.
  */
-static int ac3_parse_header(AC3DecodeContext *ctx)
+static int ac3_parse_header(AC3DecodeContext *s)
 {
     AC3HeaderInfo hdr;
-    GetBitContext *gb = &ctx->gb;
-    float cmixlev, surmixlev;
+    GetBitContext *gbc = &s->gbc;
     int err, i;
 
-    err = ff_ac3_parse_header(gb->buffer, &hdr);
+    err = ff_ac3_parse_header(gbc->buffer, &hdr);
     if(err)
         return err;
 
+    if(hdr.bitstream_id > 10)
+        return AC3_PARSE_ERROR_BSID;
+
     /* get decoding parameters from header info */
-    ctx->bit_alloc_params.fscod       = hdr.fscod;
-    ctx->acmod                        = hdr.acmod;
-    cmixlev                           = gain_levels[clevs[hdr.cmixlev]];
-    surmixlev                         = gain_levels[slevs[hdr.surmixlev]];
-    ctx->dsurmod                      = hdr.dsurmod;
-    ctx->lfeon                        = hdr.lfeon;
-    ctx->bit_alloc_params.halfratecod = hdr.halfratecod;
-    ctx->sampling_rate                = hdr.sample_rate;
-    ctx->bit_rate                     = hdr.bit_rate;
-    ctx->nchans                       = hdr.channels;
-    ctx->nfchans                      = ctx->nchans - ctx->lfeon;
-    ctx->lfe_ch                       = ctx->nfchans + 1;
-    ctx->frame_size                   = hdr.frame_size;
+    s->bit_alloc_params.sr_code     = hdr.sr_code;
+    s->channel_mode                 = hdr.channel_mode;
+    s->lfe_on                       = hdr.lfe_on;
+    s->bit_alloc_params.sr_shift    = hdr.sr_shift;
+    s->sample_rate                  = hdr.sample_rate;
+    s->bit_rate                     = hdr.bit_rate;
+    s->channels                     = hdr.channels;
+    s->fbw_channels                 = s->channels - s->lfe_on;
+    s->lfe_ch                       = s->fbw_channels + 1;
+    s->frame_size                   = hdr.frame_size;
 
     /* set default output to all source channels */
-    ctx->out_channels = ctx->nchans;
-    ctx->output_mode = ctx->acmod;
-    if(ctx->lfeon)
-        ctx->output_mode |= AC3_OUTPUT_LFEON;
+    s->out_channels = s->channels;
+    s->output_mode = s->channel_mode;
+    if(s->lfe_on)
+        s->output_mode |= AC3_OUTPUT_LFEON;
+
+    /* set default mix levels */
+    s->center_mix_level   = 3;  // -4.5dB
+    s->surround_mix_level = 4;  // -6.0dB
 
     /* skip over portion of header which has already been read */
-    skip_bits(gb, 16); // skip the sync_word
-    skip_bits(gb, 16); // skip crc1
-    skip_bits(gb, 8);  // skip fscod and frmsizecod
-    skip_bits(gb, 11); // skip bsid, bsmod, and acmod
-    if(ctx->acmod == AC3_ACMOD_STEREO) {
-        skip_bits(gb, 2); // skip dsurmod
+    skip_bits(gbc, 16); // skip the sync_word
+    skip_bits(gbc, 16); // skip crc1
+    skip_bits(gbc, 8);  // skip fscod and frmsizecod
+    skip_bits(gbc, 11); // skip bsid, bsmod, and acmod
+    if(s->channel_mode == AC3_CHMODE_STEREO) {
+        skip_bits(gbc, 2); // skip dsurmod
     } else {
-        if((ctx->acmod & 1) && ctx->acmod != AC3_ACMOD_MONO)
-            skip_bits(gb, 2); // skip cmixlev
-        if(ctx->acmod & 4)
-            skip_bits(gb, 2); // skip surmixlev
+        if((s->channel_mode & 1) && s->channel_mode != AC3_CHMODE_MONO)
+            s->center_mix_level = center_levels[get_bits(gbc, 2)];
+        if(s->channel_mode & 4)
+            s->surround_mix_level = surround_levels[get_bits(gbc, 2)];
     }
-    skip_bits1(gb); // skip lfeon
+    skip_bits1(gbc); // skip lfeon
 
     /* read the rest of the bsi. read twice for dual mono mode. */
-    i = !(ctx->acmod);
+    i = !(s->channel_mode);
     do {
-        ctx->dialnorm[i] = dialnorm_tab[get_bits(gb, 5)]; // dialogue normalization
-        if (get_bits1(gb))
-            skip_bits(gb, 8); //skip compression
-        if (get_bits1(gb))
-            skip_bits(gb, 8); //skip language code
-        if (get_bits1(gb))
-            skip_bits(gb, 7); //skip audio production information
+        skip_bits(gbc, 5); // skip dialog normalization
+        if (get_bits1(gbc))
+            skip_bits(gbc, 8); //skip compression
+        if (get_bits1(gbc))
+            skip_bits(gbc, 8); //skip language code
+        if (get_bits1(gbc))
+            skip_bits(gbc, 7); //skip audio production information
     } while (i--);
 
-    skip_bits(gb, 2); //skip copyright bit and original bitstream bit
+    skip_bits(gbc, 2); //skip copyright bit and original bitstream bit
 
     /* skip the timecodes (or extra bitstream information for Alternate Syntax)
        TODO: read & use the xbsi1 downmix levels */
-    if (get_bits1(gb))
-        skip_bits(gb, 14); //skip timecode1 / xbsi1
-    if (get_bits1(gb))
-        skip_bits(gb, 14); //skip timecode2 / xbsi2
+    if (get_bits1(gbc))
+        skip_bits(gbc, 14); //skip timecode1 / xbsi1
+    if (get_bits1(gbc))
+        skip_bits(gbc, 14); //skip timecode2 / xbsi2
 
     /* skip additional bitstream info */
-    if (get_bits1(gb)) {
-        i = get_bits(gb, 6);
+    if (get_bits1(gbc)) {
+        i = get_bits(gbc, 6);
         do {
-            skip_bits(gb, 8);
+            skip_bits(gbc, 8);
         } while(i--);
     }
 
-    /* set stereo downmixing coefficients
-       reference: Section 7.8.2 Downmixing Into Two Channels */
-    for(i=0; i<ctx->nfchans; i++) {
-        ctx->downmix_coeffs[i][0] = gain_levels[ac3_default_coeffs[ctx->acmod][i][0]];
-        ctx->downmix_coeffs[i][1] = gain_levels[ac3_default_coeffs[ctx->acmod][i][1]];
-    }
-    if(ctx->acmod > 1 && ctx->acmod & 1) {
-        ctx->downmix_coeffs[1][0] = ctx->downmix_coeffs[1][1] = cmixlev;
-    }
-    if(ctx->acmod == AC3_ACMOD_2F1R || ctx->acmod == AC3_ACMOD_3F1R) {
-        int nf = ctx->acmod - 2;
-        ctx->downmix_coeffs[nf][0] = ctx->downmix_coeffs[nf][1] = surmixlev * LEVEL_MINUS_3DB;
-    }
-    if(ctx->acmod == AC3_ACMOD_2F2R || ctx->acmod == AC3_ACMOD_3F2R) {
-        int nf = ctx->acmod - 4;
-        ctx->downmix_coeffs[nf][0] = ctx->downmix_coeffs[nf+1][1] = surmixlev;
-    }
-
     return 0;
 }
 
 /**
+ * Set stereo downmixing coefficients based on frame header info.
+ * reference: Section 7.8.2 Downmixing Into Two Channels
+ */
+static void set_downmix_coeffs(AC3DecodeContext *s)
+{
+    int i;
+    float cmix = gain_levels[s->center_mix_level];
+    float smix = gain_levels[s->surround_mix_level];
+
+    for(i=0; i<s->fbw_channels; i++) {
+        s->downmix_coeffs[i][0] = gain_levels[ac3_default_coeffs[s->channel_mode][i][0]];
+        s->downmix_coeffs[i][1] = gain_levels[ac3_default_coeffs[s->channel_mode][i][1]];
+    }
+    if(s->channel_mode > 1 && s->channel_mode & 1) {
+        s->downmix_coeffs[1][0] = s->downmix_coeffs[1][1] = cmix;
+    }
+    if(s->channel_mode == AC3_CHMODE_2F1R || s->channel_mode == AC3_CHMODE_3F1R) {
+        int nf = s->channel_mode - 2;
+        s->downmix_coeffs[nf][0] = s->downmix_coeffs[nf][1] = smix * LEVEL_MINUS_3DB;
+    }
+    if(s->channel_mode == AC3_CHMODE_2F2R || s->channel_mode == AC3_CHMODE_3F2R) {
+        int nf = s->channel_mode - 4;
+        s->downmix_coeffs[nf][0] = s->downmix_coeffs[nf+1][1] = smix;
+    }
+}
+
+/**
  * Decode the grouped exponents according to exponent strategy.
  * reference: Section 7.1.3 Exponent Decoding
  */
-static void decode_exponents(GetBitContext *gb, int expstr, int ngrps,
+static void decode_exponents(GetBitContext *gbc, int exp_strategy, int ngrps,
                              uint8_t absexp, int8_t *dexps)
 {
-    int i, j, grp, grpsize;
+    int i, j, grp, group_size;
     int dexp[256];
     int expacc, prevexp;
 
     /* unpack groups */
-    grpsize = expstr + (expstr == EXP_D45);
+    group_size = exp_strategy + (exp_strategy == EXP_D45);
     for(grp=0,i=0; grp<ngrps; grp++) {
-        expacc = get_bits(gb, 7);
+        expacc = get_bits(gbc, 7);
         dexp[i++] = exp_ungroup_tab[expacc][0];
         dexp[i++] = exp_ungroup_tab[expacc][1];
         dexp[i++] = exp_ungroup_tab[expacc][2];
@@ -453,8 +438,8 @@
     prevexp = absexp;
     for(i=0; i<ngrps*3; i++) {
         prevexp = av_clip(prevexp + dexp[i]-2, 0, 24);
-        for(j=0; j<grpsize; j++) {
-            dexps[(i*grpsize)+j] = prevexp;
+        for(j=0; j<group_size; j++) {
+            dexps[(i*group_size)+j] = prevexp;
         }
     }
 }
@@ -464,23 +449,26 @@
  * range using the coupling coefficients and coupling coordinates.
  * reference: Section 7.4.3 Coupling Coordinate Format
  */
-static void uncouple_channels(AC3DecodeContext *ctx)
+static void uncouple_channels(AC3DecodeContext *s)
 {
     int i, j, ch, bnd, subbnd;
 
     subbnd = -1;
-    i = ctx->startmant[CPL_CH];
-    for(bnd=0; bnd<ctx->ncplbnd; bnd++) {
+    i = s->start_freq[CPL_CH];
+    for(bnd=0; bnd<s->num_cpl_bands; bnd++) {
         do {
             subbnd++;
             for(j=0; j<12; j++) {
-                for(ch=1; ch<=ctx->nfchans; ch++) {
-                    if(ctx->chincpl[ch])
-                        ctx->transform_coeffs[ch][i] = ctx->transform_coeffs[CPL_CH][i] * ctx->cplco[ch][bnd] * 8.0f;
+                for(ch=1; ch<=s->fbw_channels; ch++) {
+                    if(s->channel_in_cpl[ch]) {
+                        s->transform_coeffs[ch][i] = s->transform_coeffs[CPL_CH][i] * s->cpl_coords[ch][bnd] * 8.0f;
+                        if (ch == 2 && s->phase_flags[bnd])
+                            s->transform_coeffs[ch][i] = -s->transform_coeffs[ch][i];
+                    }
                 }
                 i++;
             }
-        } while(ctx->cplbndstrc[subbnd]);
+        } while(s->cpl_band_struct[subbnd]);
     }
 }
 
@@ -500,30 +488,30 @@
  * Get the transform coefficients for a particular channel
  * reference: Section 7.3 Quantization and Decoding of Mantissas
  */
-static int get_transform_coeffs_ch(AC3DecodeContext *ctx, int ch_index, mant_groups *m)
+static int get_transform_coeffs_ch(AC3DecodeContext *s, int ch_index, mant_groups *m)
 {
-    GetBitContext *gb = &ctx->gb;
+    GetBitContext *gbc = &s->gbc;
     int i, gcode, tbap, start, end;
     uint8_t *exps;
     uint8_t *bap;
     float *coeffs;
 
-    exps = ctx->dexps[ch_index];
-    bap = ctx->bap[ch_index];
-    coeffs = ctx->transform_coeffs[ch_index];
-    start = ctx->startmant[ch_index];
-    end = ctx->endmant[ch_index];
+    exps = s->dexps[ch_index];
+    bap = s->bap[ch_index];
+    coeffs = s->transform_coeffs[ch_index];
+    start = s->start_freq[ch_index];
+    end = s->end_freq[ch_index];
 
     for (i = start; i < end; i++) {
         tbap = bap[i];
         switch (tbap) {
             case 0:
-                coeffs[i] = ((av_random(&ctx->dith_state) & 0xFFFF) / 65535.0f) - 0.5f;
+                coeffs[i] = ((av_random(&s->dith_state) & 0xFFFF) / 65535.0f) - 0.5f;
                 break;
 
             case 1:
                 if(m->b1ptr > 2) {
-                    gcode = get_bits(gb, 5);
+                    gcode = get_bits(gbc, 5);
                     m->b1_mant[0] = b1_mantissas[gcode][0];
                     m->b1_mant[1] = b1_mantissas[gcode][1];
                     m->b1_mant[2] = b1_mantissas[gcode][2];
@@ -534,7 +522,7 @@
 
             case 2:
                 if(m->b2ptr > 2) {
-                    gcode = get_bits(gb, 7);
+                    gcode = get_bits(gbc, 7);
                     m->b2_mant[0] = b2_mantissas[gcode][0];
                     m->b2_mant[1] = b2_mantissas[gcode][1];
                     m->b2_mant[2] = b2_mantissas[gcode][2];
@@ -544,12 +532,12 @@
                 break;
 
             case 3:
-                coeffs[i] = b3_mantissas[get_bits(gb, 3)];
+                coeffs[i] = b3_mantissas[get_bits(gbc, 3)];
                 break;
 
             case 4:
                 if(m->b4ptr > 1) {
-                    gcode = get_bits(gb, 7);
+                    gcode = get_bits(gbc, 7);
                     m->b4_mant[0] = b4_mantissas[gcode][0];
                     m->b4_mant[1] = b4_mantissas[gcode][1];
                     m->b4ptr = 0;
@@ -558,12 +546,12 @@
                 break;
 
             case 5:
-                coeffs[i] = b5_mantissas[get_bits(gb, 4)];
+                coeffs[i] = b5_mantissas[get_bits(gbc, 4)];
                 break;
 
             default:
                 /* asymmetric dequantization */
-                coeffs[i] = get_sbits(gb, qntztab[tbap]) * scale_factors[qntztab[tbap]-1];
+                coeffs[i] = get_sbits(gbc, quantization_tab[tbap]) * scale_factors[quantization_tab[tbap]-1];
                 break;
         }
         coeffs[i] *= scale_factors[exps[i]];
@@ -576,28 +564,28 @@
  * Remove random dithering from coefficients with zero-bit mantissas
  * reference: Section 7.3.4 Dither for Zero Bit Mantissas (bap=0)
  */
-static void remove_dithering(AC3DecodeContext *ctx) {
+static void remove_dithering(AC3DecodeContext *s) {
     int ch, i;
     int end=0;
     float *coeffs;
     uint8_t *bap;
 
-    for(ch=1; ch<=ctx->nfchans; ch++) {
-        if(!ctx->dithflag[ch]) {
-            coeffs = ctx->transform_coeffs[ch];
-            bap = ctx->bap[ch];
-            if(ctx->chincpl[ch])
-                end = ctx->startmant[CPL_CH];
+    for(ch=1; ch<=s->fbw_channels; ch++) {
+        if(!s->dither_flag[ch]) {
+            coeffs = s->transform_coeffs[ch];
+            bap = s->bap[ch];
+            if(s->channel_in_cpl[ch])
+                end = s->start_freq[CPL_CH];
             else
-                end = ctx->endmant[ch];
+                end = s->end_freq[ch];
             for(i=0; i<end; i++) {
-                if(bap[i] == 0)
+                if(!bap[i])
                     coeffs[i] = 0.0f;
             }
-            if(ctx->chincpl[ch]) {
-                bap = ctx->bap[CPL_CH];
-                for(; i<ctx->endmant[CPL_CH]; i++) {
-                    if(bap[i] == 0)
+            if(s->channel_in_cpl[ch]) {
+                bap = s->bap[CPL_CH];
+                for(; i<s->end_freq[CPL_CH]; i++) {
+                    if(!bap[i])
                         coeffs[i] = 0.0f;
                 }
             }
@@ -608,7 +596,7 @@
 /**
  * Get the transform coefficients.
  */
-static int get_transform_coeffs(AC3DecodeContext * ctx)
+static int get_transform_coeffs(AC3DecodeContext *s)
 {
     int ch, end;
     int got_cplchan = 0;
@@ -616,33 +604,33 @@
 
     m.b1ptr = m.b2ptr = m.b4ptr = 3;
 
-    for (ch = 1; ch <= ctx->nchans; ch++) {
+    for (ch = 1; ch <= s->channels; ch++) {
         /* transform coefficients for full-bandwidth channel */
-        if (get_transform_coeffs_ch(ctx, ch, &m))
+        if (get_transform_coeffs_ch(s, ch, &m))
             return -1;
         /* tranform coefficients for coupling channel come right after the
            coefficients for the first coupled channel*/
-        if (ctx->chincpl[ch])  {
+        if (s->channel_in_cpl[ch])  {
             if (!got_cplchan) {
-                if (get_transform_coeffs_ch(ctx, CPL_CH, &m)) {
-                    av_log(ctx->avctx, AV_LOG_ERROR, "error in decoupling channels\n");
+                if (get_transform_coeffs_ch(s, CPL_CH, &m)) {
+                    av_log(s->avctx, AV_LOG_ERROR, "error in decoupling channels\n");
                     return -1;
                 }
-                uncouple_channels(ctx);
+                uncouple_channels(s);
                 got_cplchan = 1;
             }
-            end = ctx->endmant[CPL_CH];
+            end = s->end_freq[CPL_CH];
         } else {
-            end = ctx->endmant[ch];
+            end = s->end_freq[ch];
         }
         do
-            ctx->transform_coeffs[ch][end] = 0;
+            s->transform_coeffs[ch][end] = 0;
         while(++end < 256);
     }
 
     /* if any channel doesn't use dithering, zero appropriate coefficients */
-    if(!ctx->dither_all)
-        remove_dithering(ctx);
+    if(!s->dither_all)
+        remove_dithering(s);
 
     return 0;
 }
@@ -651,22 +639,22 @@
  * Stereo rematrixing.
  * reference: Section 7.5.4 Rematrixing : Decoding Technique
  */
-static void do_rematrixing(AC3DecodeContext *ctx)
+static void do_rematrixing(AC3DecodeContext *s)
 {
     int bnd, i;
     int end, bndend;
     float tmp0, tmp1;
 
-    end = FFMIN(ctx->endmant[1], ctx->endmant[2]);
+    end = FFMIN(s->end_freq[1], s->end_freq[2]);
 
-    for(bnd=0; bnd<ctx->nrematbnd; bnd++) {
-        if(ctx->rematflg[bnd]) {
+    for(bnd=0; bnd<s->num_rematrixing_bands; bnd++) {
+        if(s->rematrixing_flags[bnd]) {
             bndend = FFMIN(end, rematrix_band_tab[bnd+1]);
             for(i=rematrix_band_tab[bnd]; i<bndend; i++) {
-                tmp0 = ctx->transform_coeffs[1][i];
-                tmp1 = ctx->transform_coeffs[2][i];
-                ctx->transform_coeffs[1][i] = tmp0 + tmp1;
-                ctx->transform_coeffs[2][i] = tmp0 - tmp1;
+                tmp0 = s->transform_coeffs[1][i];
+                tmp1 = s->transform_coeffs[2][i];
+                s->transform_coeffs[1][i] = tmp0 + tmp1;
+                s->transform_coeffs[2][i] = tmp0 - tmp1;
             }
         }
     }
@@ -675,21 +663,21 @@
 /**
  * Perform the 256-point IMDCT
  */
-static void do_imdct_256(AC3DecodeContext *ctx, int chindex)
+static void do_imdct_256(AC3DecodeContext *s, int chindex)
 {
     int i, k;
     DECLARE_ALIGNED_16(float, x[128]);
     FFTComplex z[2][64];
-    float *o_ptr = ctx->tmp_output;
+    float *o_ptr = s->tmp_output;
 
     for(i=0; i<2; i++) {
         /* de-interleave coefficients */
         for(k=0; k<128; k++) {
-            x[k] = ctx->transform_coeffs[chindex][2*k+i];
+            x[k] = s->transform_coeffs[chindex][2*k+i];
         }
 
         /* run standard IMDCT */
-        ctx->imdct_256.fft.imdct_calc(&ctx->imdct_256, o_ptr, x, ctx->tmp_imdct);
+        s->imdct_256.fft.imdct_calc(&s->imdct_256, o_ptr, x, s->tmp_imdct);
 
         /* reverse the post-rotation & reordering from standard IMDCT */
         for(k=0; k<32; k++) {
@@ -718,59 +706,57 @@
  * Convert frequency domain coefficients to time-domain audio samples.
  * reference: Section 7.9.4 Transformation Equations
  */
-static inline void do_imdct(AC3DecodeContext *ctx)
+static inline void do_imdct(AC3DecodeContext *s)
 {
     int ch;
-    int nchans;
+    int channels;
 
     /* Don't perform the IMDCT on the LFE channel unless it's used in the output */
-    nchans = ctx->nfchans;
-    if(ctx->output_mode & AC3_OUTPUT_LFEON)
-        nchans++;
-
-    for (ch=1; ch<=nchans; ch++) {
-        if (ctx->blksw[ch]) {
-            do_imdct_256(ctx, ch);
+    channels = s->fbw_channels;
+    if(s->output_mode & AC3_OUTPUT_LFEON)
+        channels++;
+
+    for (ch=1; ch<=channels; ch++) {
+        if (s->block_switch[ch]) {
+            do_imdct_256(s, ch);
         } else {
-            ctx->imdct_512.fft.imdct_calc(&ctx->imdct_512, ctx->tmp_output,
-                                          ctx->transform_coeffs[ch],
-                                          ctx->tmp_imdct);
+            s->imdct_512.fft.imdct_calc(&s->imdct_512, s->tmp_output,
+                                        s->transform_coeffs[ch], s->tmp_imdct);
         }
         /* For the first half of the block, apply the window, add the delay
            from the previous block, and send to output */
-        ctx->dsp.vector_fmul_add_add(ctx->output[ch-1], ctx->tmp_output,
-                                     ctx->window, ctx->delay[ch-1], 0, 256, 1);
+        s->dsp.vector_fmul_add_add(s->output[ch-1], s->tmp_output,
+                                     s->window, s->delay[ch-1], 0, 256, 1);
         /* For the second half of the block, apply the window and store the
            samples to delay, to be combined with the next block */
-        ctx->dsp.vector_fmul_reverse(ctx->delay[ch-1], ctx->tmp_output+256,
-                                     ctx->window, 256);
+        s->dsp.vector_fmul_reverse(s->delay[ch-1], s->tmp_output+256,
+                                   s->window, 256);
     }
 }
 
 /**
  * Downmix the output to mono or stereo.
  */
-static void ac3_downmix(float samples[AC3_MAX_CHANNELS][256], int nfchans,
-                        int output_mode, float coef[AC3_MAX_CHANNELS][2])
+static void ac3_downmix(AC3DecodeContext *s)
 {
     int i, j;
     float v0, v1, s0, s1;
 
     for(i=0; i<256; i++) {
         v0 = v1 = s0 = s1 = 0.0f;
-        for(j=0; j<nfchans; j++) {
-            v0 += samples[j][i] * coef[j][0];
-            v1 += samples[j][i] * coef[j][1];
-            s0 += coef[j][0];
-            s1 += coef[j][1];
+        for(j=0; j<s->fbw_channels; j++) {
+            v0 += s->output[j][i] * s->downmix_coeffs[j][0];
+            v1 += s->output[j][i] * s->downmix_coeffs[j][1];
+            s0 += s->downmix_coeffs[j][0];
+            s1 += s->downmix_coeffs[j][1];
         }
         v0 /= s0;
         v1 /= s1;
-        if(output_mode == AC3_ACMOD_MONO) {
-            samples[0][i] = (v0 + v1) * LEVEL_MINUS_3DB;
-        } else if(output_mode == AC3_ACMOD_STEREO) {
-            samples[0][i] = v0;
-            samples[1][i] = v1;
+        if(s->output_mode == AC3_CHMODE_MONO) {
+            s->output[0][i] = (v0 + v1) * LEVEL_MINUS_3DB;
+        } else if(s->output_mode == AC3_CHMODE_STEREO) {
+            s->output[0][i] = v0;
+            s->output[1][i] = v1;
         }
     }
 }
@@ -778,305 +764,304 @@
 /**
  * Parse an audio block from AC-3 bitstream.
  */
-static int ac3_parse_audio_block(AC3DecodeContext *ctx, int blk)
+static int ac3_parse_audio_block(AC3DecodeContext *s, int blk)
 {
-    int nfchans = ctx->nfchans;
-    int acmod = ctx->acmod;
+    int fbw_channels = s->fbw_channels;
+    int channel_mode = s->channel_mode;
     int i, bnd, seg, ch;
-    GetBitContext *gb = &ctx->gb;
+    GetBitContext *gbc = &s->gbc;
     uint8_t bit_alloc_stages[AC3_MAX_CHANNELS];
 
     memset(bit_alloc_stages, 0, AC3_MAX_CHANNELS);
 
     /* block switch flags */
-    for (ch = 1; ch <= nfchans; ch++)
-        ctx->blksw[ch] = get_bits1(gb);
+    for (ch = 1; ch <= fbw_channels; ch++)
+        s->block_switch[ch] = get_bits1(gbc);
 
     /* dithering flags */
-    ctx->dither_all = 1;
-    for (ch = 1; ch <= nfchans; ch++) {
-        ctx->dithflag[ch] = get_bits1(gb);
-        if(!ctx->dithflag[ch])
-            ctx->dither_all = 0;
+    s->dither_all = 1;
+    for (ch = 1; ch <= fbw_channels; ch++) {
+        s->dither_flag[ch] = get_bits1(gbc);
+        if(!s->dither_flag[ch])
+            s->dither_all = 0;
     }
 
     /* dynamic range */
-    i = !(ctx->acmod);
+    i = !(s->channel_mode);
     do {
-        if(get_bits1(gb)) {
-            ctx->dynrng[i] = dynrng_tab[get_bits(gb, 8)];
+        if(get_bits1(gbc)) {
+            s->dynamic_range[i] = ((dynamic_range_tab[get_bits(gbc, 8)]-1.0) *
+                                  s->avctx->drc_scale)+1.0;
         } else if(blk == 0) {
-            ctx->dynrng[i] = 1.0f;
+            s->dynamic_range[i] = 1.0f;
         }
     } while(i--);
 
     /* coupling strategy */
-    if (get_bits1(gb)) {
+    if (get_bits1(gbc)) {
         memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);
-        ctx->cplinu = get_bits1(gb);
-        if (ctx->cplinu) {
+        s->cpl_in_use = get_bits1(gbc);
+        if (s->cpl_in_use) {
             /* coupling in use */
-            int cplbegf, cplendf;
+            int cpl_begin_freq, cpl_end_freq;
 
             /* determine which channels are coupled */
-            for (ch = 1; ch <= nfchans; ch++)
-                ctx->chincpl[ch] = get_bits1(gb);
+            for (ch = 1; ch <= fbw_channels; ch++)
+                s->channel_in_cpl[ch] = get_bits1(gbc);
 
             /* phase flags in use */
-            if (acmod == AC3_ACMOD_STEREO)
-                ctx->phsflginu = get_bits1(gb);
+            if (channel_mode == AC3_CHMODE_STEREO)
+                s->phase_flags_in_use = get_bits1(gbc);
 
             /* coupling frequency range and band structure */
-            cplbegf = get_bits(gb, 4);
-            cplendf = get_bits(gb, 4);
-            if (3 + cplendf - cplbegf < 0) {
-                av_log(ctx->avctx, AV_LOG_ERROR, "cplendf = %d < cplbegf = %d\n", cplendf, cplbegf);
+            cpl_begin_freq = get_bits(gbc, 4);
+            cpl_end_freq = get_bits(gbc, 4);
+            if (3 + cpl_end_freq - cpl_begin_freq < 0) {
+                av_log(s->avctx, AV_LOG_ERROR, "3+cplendf = %d < cplbegf = %d\n", 3+cpl_end_freq, cpl_begin_freq);
                 return -1;
             }
-            ctx->ncplbnd = ctx->ncplsubnd = 3 + cplendf - cplbegf;
-            ctx->startmant[CPL_CH] = cplbegf * 12 + 37;
-            ctx->endmant[CPL_CH] = cplendf * 12 + 73;
-            for (bnd = 0; bnd < ctx->ncplsubnd - 1; bnd++) {
-                if (get_bits1(gb)) {
-                    ctx->cplbndstrc[bnd] = 1;
-                    ctx->ncplbnd--;
+            s->num_cpl_bands = s->num_cpl_subbands = 3 + cpl_end_freq - cpl_begin_freq;
+            s->start_freq[CPL_CH] = cpl_begin_freq * 12 + 37;
+            s->end_freq[CPL_CH] = cpl_end_freq * 12 + 73;
+            for (bnd = 0; bnd < s->num_cpl_subbands - 1; bnd++) {
+                if (get_bits1(gbc)) {
+                    s->cpl_band_struct[bnd] = 1;
+                    s->num_cpl_bands--;
                 }
             }
+            s->cpl_band_struct[s->num_cpl_subbands-1] = 0;
         } else {
             /* coupling not in use */
-            for (ch = 1; ch <= nfchans; ch++)
-                ctx->chincpl[ch] = 0;
+            for (ch = 1; ch <= fbw_channels; ch++)
+                s->channel_in_cpl[ch] = 0;
         }
     }
 
     /* coupling coordinates */
-    if (ctx->cplinu) {
-        int cplcoe = 0;
+    if (s->cpl_in_use) {
+        int cpl_coords_exist = 0;
 
-        for (ch = 1; ch <= nfchans; ch++) {
-            if (ctx->chincpl[ch]) {
-                if (get_bits1(gb)) {
-                    int mstrcplco, cplcoexp, cplcomant;
-                    cplcoe = 1;
-                    mstrcplco = 3 * get_bits(gb, 2);
-                    for (bnd = 0; bnd < ctx->ncplbnd; bnd++) {
-                        cplcoexp = get_bits(gb, 4);
-                        cplcomant = get_bits(gb, 4);
-                        if (cplcoexp == 15)
-                            ctx->cplco[ch][bnd] = cplcomant / 16.0f;
+        for (ch = 1; ch <= fbw_channels; ch++) {
+            if (s->channel_in_cpl[ch]) {
+                if (get_bits1(gbc)) {
+                    int master_cpl_coord, cpl_coord_exp, cpl_coord_mant;
+                    cpl_coords_exist = 1;
+                    master_cpl_coord = 3 * get_bits(gbc, 2);
+                    for (bnd = 0; bnd < s->num_cpl_bands; bnd++) {
+                        cpl_coord_exp = get_bits(gbc, 4);
+                        cpl_coord_mant = get_bits(gbc, 4);
+                        if (cpl_coord_exp == 15)
+                            s->cpl_coords[ch][bnd] = cpl_coord_mant / 16.0f;
                         else
-                            ctx->cplco[ch][bnd] = (cplcomant + 16.0f) / 32.0f;
-                        ctx->cplco[ch][bnd] *= scale_factors[cplcoexp + mstrcplco];
+                            s->cpl_coords[ch][bnd] = (cpl_coord_mant + 16.0f) / 32.0f;
+                        s->cpl_coords[ch][bnd] *= scale_factors[cpl_coord_exp + master_cpl_coord];
                     }
                 }
             }
         }
         /* phase flags */
-        if (acmod == AC3_ACMOD_STEREO && ctx->phsflginu && cplcoe) {
-            for (bnd = 0; bnd < ctx->ncplbnd; bnd++) {
-                if (get_bits1(gb))
-                    ctx->cplco[2][bnd] = -ctx->cplco[2][bnd];
+        if (channel_mode == AC3_CHMODE_STEREO && cpl_coords_exist) {
+            for (bnd = 0; bnd < s->num_cpl_bands; bnd++) {
+                s->phase_flags[bnd] = s->phase_flags_in_use? get_bits1(gbc) : 0;
             }
         }
     }
 
     /* stereo rematrixing strategy and band structure */
-    if (acmod == AC3_ACMOD_STEREO) {
-        ctx->rematstr = get_bits1(gb);
-        if (ctx->rematstr) {
-            ctx->nrematbnd = 4;
-            if(ctx->cplinu && ctx->startmant[CPL_CH] <= 61)
-                ctx->nrematbnd -= 1 + (ctx->startmant[CPL_CH] == 37);
-            for(bnd=0; bnd<ctx->nrematbnd; bnd++)
-                ctx->rematflg[bnd] = get_bits1(gb);
+    if (channel_mode == AC3_CHMODE_STEREO) {
+        if (get_bits1(gbc)) {
+            s->num_rematrixing_bands = 4;
+            if(s->cpl_in_use && s->start_freq[CPL_CH] <= 61)
+                s->num_rematrixing_bands -= 1 + (s->start_freq[CPL_CH] == 37);
+            for(bnd=0; bnd<s->num_rematrixing_bands; bnd++)
+                s->rematrixing_flags[bnd] = get_bits1(gbc);
         }
     }
 
     /* exponent strategies for each channel */
-    ctx->expstr[CPL_CH] = EXP_REUSE;
-    ctx->expstr[ctx->lfe_ch] = EXP_REUSE;
-    for (ch = !ctx->cplinu; ch <= ctx->nchans; ch++) {
-        if(ch == ctx->lfe_ch)
-            ctx->expstr[ch] = get_bits(gb, 1);
+    s->exp_strategy[CPL_CH] = EXP_REUSE;
+    s->exp_strategy[s->lfe_ch] = EXP_REUSE;
+    for (ch = !s->cpl_in_use; ch <= s->channels; ch++) {
+        if(ch == s->lfe_ch)
+            s->exp_strategy[ch] = get_bits(gbc, 1);
         else
-            ctx->expstr[ch] = get_bits(gb, 2);
-        if(ctx->expstr[ch] != EXP_REUSE)
+            s->exp_strategy[ch] = get_bits(gbc, 2);
+        if(s->exp_strategy[ch] != EXP_REUSE)
             bit_alloc_stages[ch] = 3;
     }
 
     /* channel bandwidth */
-    for (ch = 1; ch <= nfchans; ch++) {
-        ctx->startmant[ch] = 0;
-        if (ctx->expstr[ch] != EXP_REUSE) {
-            int prev = ctx->endmant[ch];
-            if (ctx->chincpl[ch])
-                ctx->endmant[ch] = ctx->startmant[CPL_CH];
+    for (ch = 1; ch <= fbw_channels; ch++) {
+        s->start_freq[ch] = 0;
+        if (s->exp_strategy[ch] != EXP_REUSE) {
+            int prev = s->end_freq[ch];
+            if (s->channel_in_cpl[ch])
+                s->end_freq[ch] = s->start_freq[CPL_CH];
             else {
-                int chbwcod = get_bits(gb, 6);
-                if (chbwcod > 60) {
-                    av_log(ctx->avctx, AV_LOG_ERROR, "chbwcod = %d > 60", chbwcod);
+                int bandwidth_code = get_bits(gbc, 6);
+                if (bandwidth_code > 60) {
+                    av_log(s->avctx, AV_LOG_ERROR, "bandwidth code = %d > 60", bandwidth_code);
                     return -1;
                 }
-                ctx->endmant[ch] = chbwcod * 3 + 73;
+                s->end_freq[ch] = bandwidth_code * 3 + 73;
             }
-            if(blk > 0 && ctx->endmant[ch] != prev)
+            if(blk > 0 && s->end_freq[ch] != prev)
                 memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);
         }
     }
-    ctx->startmant[ctx->lfe_ch] = 0;
-    ctx->endmant[ctx->lfe_ch] = 7;
+    s->start_freq[s->lfe_ch] = 0;
+    s->end_freq[s->lfe_ch] = 7;
 
     /* decode exponents for each channel */
-    for (ch = !ctx->cplinu; ch <= ctx->nchans; ch++) {
-        if (ctx->expstr[ch] != EXP_REUSE) {
-            int grpsize, ngrps;
-            grpsize = 3 << (ctx->expstr[ch] - 1);
+    for (ch = !s->cpl_in_use; ch <= s->channels; ch++) {
+        if (s->exp_strategy[ch] != EXP_REUSE) {
+            int group_size, num_groups;
+            group_size = 3 << (s->exp_strategy[ch] - 1);
             if(ch == CPL_CH)
-                ngrps = (ctx->endmant[ch] - ctx->startmant[ch]) / grpsize;
-            else if(ch == ctx->lfe_ch)
-                ngrps = 2;
+                num_groups = (s->end_freq[ch] - s->start_freq[ch]) / group_size;
+            else if(ch == s->lfe_ch)
+                num_groups = 2;
             else
-                ngrps = (ctx->endmant[ch] + grpsize - 4) / grpsize;
-            ctx->dexps[ch][0] = get_bits(gb, 4) << !ch;
-            decode_exponents(gb, ctx->expstr[ch], ngrps, ctx->dexps[ch][0],
-                             &ctx->dexps[ch][ctx->startmant[ch]+!!ch]);
-            if(ch != CPL_CH && ch != ctx->lfe_ch)
-                skip_bits(gb, 2); /* skip gainrng */
+                num_groups = (s->end_freq[ch] + group_size - 4) / group_size;
+            s->dexps[ch][0] = get_bits(gbc, 4) << !ch;
+            decode_exponents(gbc, s->exp_strategy[ch], num_groups, s->dexps[ch][0],
+                             &s->dexps[ch][s->start_freq[ch]+!!ch]);
+            if(ch != CPL_CH && ch != s->lfe_ch)
+                skip_bits(gbc, 2); /* skip gainrng */
         }
     }
 
     /* bit allocation information */
-    if (get_bits1(gb)) {
-        ctx->bit_alloc_params.sdecay = ff_sdecaytab[get_bits(gb, 2)] >> ctx->bit_alloc_params.halfratecod;
-        ctx->bit_alloc_params.fdecay = ff_fdecaytab[get_bits(gb, 2)] >> ctx->bit_alloc_params.halfratecod;
-        ctx->bit_alloc_params.sgain  = ff_sgaintab[get_bits(gb, 2)];
-        ctx->bit_alloc_params.dbknee = ff_dbkneetab[get_bits(gb, 2)];
-        ctx->bit_alloc_params.floor  = ff_floortab[get_bits(gb, 3)];
-        for(ch=!ctx->cplinu; ch<=ctx->nchans; ch++) {
+    if (get_bits1(gbc)) {
+        s->bit_alloc_params.slow_decay = ff_ac3_slow_decay_tab[get_bits(gbc, 2)] >> s->bit_alloc_params.sr_shift;
+        s->bit_alloc_params.fast_decay = ff_ac3_fast_decay_tab[get_bits(gbc, 2)] >> s->bit_alloc_params.sr_shift;
+        s->bit_alloc_params.slow_gain  = ff_ac3_slow_gain_tab[get_bits(gbc, 2)];
+        s->bit_alloc_params.db_per_bit = ff_ac3_db_per_bit_tab[get_bits(gbc, 2)];
+        s->bit_alloc_params.floor  = ff_ac3_floor_tab[get_bits(gbc, 3)];
+        for(ch=!s->cpl_in_use; ch<=s->channels; ch++) {
             bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);
         }
     }
 
     /* signal-to-noise ratio offsets and fast gains (signal-to-mask ratios) */
-    if (get_bits1(gb)) {
+    if (get_bits1(gbc)) {
         int csnr;
-        csnr = (get_bits(gb, 6) - 15) << 4;
-        for (ch = !ctx->cplinu; ch <= ctx->nchans; ch++) { /* snr offset and fast gain */
-            ctx->snroffst[ch] = (csnr + get_bits(gb, 4)) << 2;
-            ctx->fgain[ch] = ff_fgaintab[get_bits(gb, 3)];
+        csnr = (get_bits(gbc, 6) - 15) << 4;
+        for (ch = !s->cpl_in_use; ch <= s->channels; ch++) { /* snr offset and fast gain */
+            s->snr_offset[ch] = (csnr + get_bits(gbc, 4)) << 2;
+            s->fast_gain[ch] = ff_ac3_fast_gain_tab[get_bits(gbc, 3)];
         }
         memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);
     }
 
     /* coupling leak information */
-    if (ctx->cplinu && get_bits1(gb)) {
-        ctx->bit_alloc_params.cplfleak = get_bits(gb, 3);
-        ctx->bit_alloc_params.cplsleak = get_bits(gb, 3);
+    if (s->cpl_in_use && get_bits1(gbc)) {
+        s->bit_alloc_params.cpl_fast_leak = get_bits(gbc, 3);
+        s->bit_alloc_params.cpl_slow_leak = get_bits(gbc, 3);
         bit_alloc_stages[CPL_CH] = FFMAX(bit_alloc_stages[CPL_CH], 2);
     }
 
     /* delta bit allocation information */
-    if (get_bits1(gb)) {
+    if (get_bits1(gbc)) {
         /* delta bit allocation exists (strategy) */
-        for (ch = !ctx->cplinu; ch <= nfchans; ch++) {
-            ctx->deltbae[ch] = get_bits(gb, 2);
-            if (ctx->deltbae[ch] == DBA_RESERVED) {
-                av_log(ctx->avctx, AV_LOG_ERROR, "delta bit allocation strategy reserved\n");
+        for (ch = !s->cpl_in_use; ch <= fbw_channels; ch++) {
+            s->dba_mode[ch] = get_bits(gbc, 2);
+            if (s->dba_mode[ch] == DBA_RESERVED) {
+                av_log(s->avctx, AV_LOG_ERROR, "delta bit allocation strategy reserved\n");
                 return -1;
             }
             bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);
         }
         /* channel delta offset, len and bit allocation */
-        for (ch = !ctx->cplinu; ch <= nfchans; ch++) {
-            if (ctx->deltbae[ch] == DBA_NEW) {
-                ctx->deltnseg[ch] = get_bits(gb, 3);
-                for (seg = 0; seg <= ctx->deltnseg[ch]; seg++) {
-                    ctx->deltoffst[ch][seg] = get_bits(gb, 5);
-                    ctx->deltlen[ch][seg] = get_bits(gb, 4);
-                    ctx->deltba[ch][seg] = get_bits(gb, 3);
+        for (ch = !s->cpl_in_use; ch <= fbw_channels; ch++) {
+            if (s->dba_mode[ch] == DBA_NEW) {
+                s->dba_nsegs[ch] = get_bits(gbc, 3);
+                for (seg = 0; seg <= s->dba_nsegs[ch]; seg++) {
+                    s->dba_offsets[ch][seg] = get_bits(gbc, 5);
+                    s->dba_lengths[ch][seg] = get_bits(gbc, 4);
+                    s->dba_values[ch][seg] = get_bits(gbc, 3);
                 }
             }
         }
     } else if(blk == 0) {
-        for(ch=0; ch<=ctx->nchans; ch++) {
-            ctx->deltbae[ch] = DBA_NONE;
+        for(ch=0; ch<=s->channels; ch++) {
+            s->dba_mode[ch] = DBA_NONE;
         }
     }
 
     /* Bit allocation */
-    for(ch=!ctx->cplinu; ch<=ctx->nchans; ch++) {
+    for(ch=!s->cpl_in_use; ch<=s->channels; ch++) {
         if(bit_alloc_stages[ch] > 2) {
             /* Exponent mapping into PSD and PSD integration */
-            ff_ac3_bit_alloc_calc_psd(ctx->dexps[ch],
-                                      ctx->startmant[ch], ctx->endmant[ch],
-                                      ctx->psd[ch], ctx->bndpsd[ch]);
+            ff_ac3_bit_alloc_calc_psd(s->dexps[ch],
+                                      s->start_freq[ch], s->end_freq[ch],
+                                      s->psd[ch], s->band_psd[ch]);
         }
         if(bit_alloc_stages[ch] > 1) {
             /* Compute excitation function, Compute masking curve, and
                Apply delta bit allocation */
-            ff_ac3_bit_alloc_calc_mask(&ctx->bit_alloc_params, ctx->bndpsd[ch],
-                                       ctx->startmant[ch], ctx->endmant[ch],
-                                       ctx->fgain[ch], (ch == ctx->lfe_ch),
-                                       ctx->deltbae[ch], ctx->deltnseg[ch],
-                                       ctx->deltoffst[ch], ctx->deltlen[ch],
-                                       ctx->deltba[ch], ctx->mask[ch]);
+            ff_ac3_bit_alloc_calc_mask(&s->bit_alloc_params, s->band_psd[ch],
+                                       s->start_freq[ch], s->end_freq[ch],
+                                       s->fast_gain[ch], (ch == s->lfe_ch),
+                                       s->dba_mode[ch], s->dba_nsegs[ch],
+                                       s->dba_offsets[ch], s->dba_lengths[ch],
+                                       s->dba_values[ch], s->mask[ch]);
         }
         if(bit_alloc_stages[ch] > 0) {
             /* Compute bit allocation */
-            ff_ac3_bit_alloc_calc_bap(ctx->mask[ch], ctx->psd[ch],
-                                      ctx->startmant[ch], ctx->endmant[ch],
-                                      ctx->snroffst[ch],
-                                      ctx->bit_alloc_params.floor,
-                                      ctx->bap[ch]);
+            ff_ac3_bit_alloc_calc_bap(s->mask[ch], s->psd[ch],
+                                      s->start_freq[ch], s->end_freq[ch],
+                                      s->snr_offset[ch],
+                                      s->bit_alloc_params.floor,
+                                      s->bap[ch]);
         }
     }
 
     /* unused dummy data */
-    if (get_bits1(gb)) {
-        int skipl = get_bits(gb, 9);
+    if (get_bits1(gbc)) {
+        int skipl = get_bits(gbc, 9);
         while(skipl--)
-            skip_bits(gb, 8);
+            skip_bits(gbc, 8);
     }
 
     /* unpack the transform coefficients
        this also uncouples channels if coupling is in use. */
-    if (get_transform_coeffs(ctx)) {
-        av_log(ctx->avctx, AV_LOG_ERROR, "Error in routine get_transform_coeffs\n");
+    if (get_transform_coeffs(s)) {
+        av_log(s->avctx, AV_LOG_ERROR, "Error in routine get_transform_coeffs\n");
         return -1;
     }
 
     /* recover coefficients if rematrixing is in use */
-    if(ctx->acmod == AC3_ACMOD_STEREO)
-        do_rematrixing(ctx);
+    if(s->channel_mode == AC3_CHMODE_STEREO)
+        do_rematrixing(s);
 
-    /* apply scaling to coefficients (headroom, dialnorm, dynrng) */
-    for(ch=1; ch<=ctx->nchans; ch++) {
-        float gain = 2.0f * ctx->mul_bias;
-        if(ctx->acmod == AC3_ACMOD_DUALMONO) {
-            gain *= ctx->dialnorm[ch-1] * ctx->dynrng[ch-1];
+    /* apply scaling to coefficients (headroom, dynrng) */
+    for(ch=1; ch<=s->channels; ch++) {
+        float gain = 2.0f * s->mul_bias;
+        if(s->channel_mode == AC3_CHMODE_DUALMONO) {
+            gain *= s->dynamic_range[ch-1];
         } else {
-            gain *= ctx->dialnorm[0] * ctx->dynrng[0];
+            gain *= s->dynamic_range[0];
         }
-        for(i=0; i<ctx->endmant[ch]; i++) {
-            ctx->transform_coeffs[ch][i] *= gain;
+        for(i=0; i<s->end_freq[ch]; i++) {
+            s->transform_coeffs[ch][i] *= gain;
         }
     }
 
-    do_imdct(ctx);
+    do_imdct(s);
 
     /* downmix output if needed */
-    if(ctx->nchans != ctx->out_channels && !((ctx->output_mode & AC3_OUTPUT_LFEON) &&
-            ctx->nfchans == ctx->out_channels)) {
-        ac3_downmix(ctx->output, ctx->nfchans, ctx->output_mode,
-                    ctx->downmix_coeffs);
+    if(s->channels != s->out_channels && !((s->output_mode & AC3_OUTPUT_LFEON) &&
+            s->fbw_channels == s->out_channels)) {
+        ac3_downmix(s);
     }
 
     /* convert float to 16-bit integer */
-    for(ch=0; ch<ctx->out_channels; ch++) {
+    for(ch=0; ch<s->out_channels; ch++) {
         for(i=0; i<256; i++) {
-            ctx->output[ch][i] += ctx->add_bias;
+            s->output[ch][i] += s->add_bias;
         }
-        ctx->dsp.float_to_int16(ctx->int_output[ch], ctx->output[ch], 256);
+        s->dsp.float_to_int16(s->int_output[ch], s->output[ch], 256);
     }
 
     return 0;
@@ -1087,15 +1072,15 @@
  */
 static int ac3_decode_frame(AVCodecContext * avctx, void *data, int *data_size, uint8_t *buf, int buf_size)
 {
-    AC3DecodeContext *ctx = (AC3DecodeContext *)avctx->priv_data;
+    AC3DecodeContext *s = avctx->priv_data;
     int16_t *out_samples = (int16_t *)data;
     int i, blk, ch, err;
 
     /* initialize the GetBitContext with the start of valid AC-3 Frame */
-    init_get_bits(&ctx->gb, buf, buf_size * 8);
+    init_get_bits(&s->gbc, buf, buf_size * 8);
 
     /* parse the syncinfo */
-    err = ac3_parse_header(ctx);
+    err = ac3_parse_header(s);
     if(err) {
         switch(err) {
             case AC3_PARSE_ERROR_SYNC:
@@ -1117,48 +1102,52 @@
         return -1;
     }
 
-    avctx->sample_rate = ctx->sampling_rate;
-    avctx->bit_rate = ctx->bit_rate;
-
     /* check that reported frame size fits in input buffer */
-    if(ctx->frame_size > buf_size) {
+    if(s->frame_size > buf_size) {
         av_log(avctx, AV_LOG_ERROR, "incomplete frame\n");
         return -1;
     }
 
-    /* channel config */
-    ctx->out_channels = ctx->nchans;
-    if (avctx->channels == 0) {
-        avctx->channels = ctx->out_channels;
-    } else if(ctx->out_channels < avctx->channels) {
-        av_log(avctx, AV_LOG_ERROR, "Cannot upmix AC3 from %d to %d channels.\n",
-               ctx->out_channels, avctx->channels);
-        return -1;
+    /* check for crc mismatch */
+    if(avctx->error_resilience >= FF_ER_CAREFUL) {
+        if(av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, &buf[2], s->frame_size-2)) {
+            av_log(avctx, AV_LOG_ERROR, "frame CRC mismatch\n");
+            return -1;
+        }
+        /* TODO: error concealment */
     }
-    if(avctx->channels == 2) {
-        ctx->output_mode = AC3_ACMOD_STEREO;
-    } else if(avctx->channels == 1) {
-        ctx->output_mode = AC3_ACMOD_MONO;
-    } else if(avctx->channels != ctx->out_channels) {
-        av_log(avctx, AV_LOG_ERROR, "Cannot downmix AC3 from %d to %d channels.\n",
-               ctx->out_channels, avctx->channels);
-        return -1;
+
+    avctx->sample_rate = s->sample_rate;
+    avctx->bit_rate = s->bit_rate;
+
+    /* channel config */
+    s->out_channels = s->channels;
+    if (avctx->request_channels > 0 && avctx->request_channels <= 2 &&
+            avctx->request_channels < s->channels) {
+        s->out_channels = avctx->request_channels;
+        s->output_mode  = avctx->request_channels == 1 ? AC3_CHMODE_MONO : AC3_CHMODE_STEREO;
+    }
+    avctx->channels = s->out_channels;
+
+    /* set downmixing coefficients if needed */
+    if(s->channels != s->out_channels && !((s->output_mode & AC3_OUTPUT_LFEON) &&
+            s->fbw_channels == s->out_channels)) {
+        set_downmix_coeffs(s);
     }
-    ctx->out_channels = avctx->channels;
 
     /* parse the audio blocks */
     for (blk = 0; blk < NB_BLOCKS; blk++) {
-        if (ac3_parse_audio_block(ctx, blk)) {
+        if (ac3_parse_audio_block(s, blk)) {
             av_log(avctx, AV_LOG_ERROR, "error parsing the audio block\n");
             *data_size = 0;
-            return ctx->frame_size;
+            return s->frame_size;
         }
         for (i = 0; i < 256; i++)
-            for (ch = 0; ch < ctx->out_channels; ch++)
-                *(out_samples++) = ctx->int_output[ch][i];
+            for (ch = 0; ch < s->out_channels; ch++)
+                *(out_samples++) = s->int_output[ch][i];
     }
     *data_size = NB_BLOCKS * 256 * avctx->channels * sizeof (int16_t);
-    return ctx->frame_size;
+    return s->frame_size;
 }
 
 /**
@@ -1166,9 +1155,9 @@
  */
 static int ac3_decode_end(AVCodecContext *avctx)
 {
-    AC3DecodeContext *ctx = (AC3DecodeContext *)avctx->priv_data;
-    ff_mdct_end(&ctx->imdct_512);
-    ff_mdct_end(&ctx->imdct_256);
+    AC3DecodeContext *s = avctx->priv_data;
+    ff_mdct_end(&s->imdct_512);
+    ff_mdct_end(&s->imdct_256);
 
     return 0;
 }
diff -u mplayer-1.0~rc2-12/libavcodec/ac3enc.c ffmpeg-free-0.svn20080206/libavcodec/ac3enc.c
--- mplayer-1.0~rc2-12/libavcodec/ac3enc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ac3enc.c	2008-03-20 19:10:57.000000000 +0100
@@ -37,34 +37,33 @@
     int lfe_channel;
     int bit_rate;
     unsigned int sample_rate;
-    unsigned int bsid;
+    unsigned int bitstream_id;
     unsigned int frame_size_min; /* minimum frame size in case rounding is necessary */
     unsigned int frame_size; /* current frame size in words */
     unsigned int bits_written;
     unsigned int samples_written;
-    int halfratecod;
-    unsigned int frmsizecod;
-    unsigned int fscod; /* frequency */
-    unsigned int acmod;
+    int sr_shift;
+    unsigned int frame_size_code;
+    unsigned int sr_code; /* frequency */
+    unsigned int channel_mode;
     int lfe;
-    unsigned int bsmod;
+    unsigned int bitstream_mode;
     short last_samples[AC3_MAX_CHANNELS][256];
     unsigned int chbwcod[AC3_MAX_CHANNELS];
     int nb_coefs[AC3_MAX_CHANNELS];
 
     /* bitrate allocation control */
-    int sgaincod, sdecaycod, fdecaycod, dbkneecod, floorcod;
+    int slow_gain_code, slow_decay_code, fast_decay_code, db_per_bit_code, floor_code;
     AC3BitAllocParameters bit_alloc;
-    int csnroffst;
-    int fgaincod[AC3_MAX_CHANNELS];
-    int fsnroffst[AC3_MAX_CHANNELS];
+    int coarse_snr_offset;
+    int fast_gain_code[AC3_MAX_CHANNELS];
+    int fine_snr_offset[AC3_MAX_CHANNELS];
     /* mantissa encoding */
     int mant1_cnt, mant2_cnt, mant4_cnt;
 } AC3EncodeContext;
 
 static int16_t costab[64];
 static int16_t sintab[64];
-static int16_t fft_rev[512];
 static int16_t xcos1[128];
 static int16_t xsin1[128];
 
@@ -74,8 +73,6 @@
 /* new exponents are sent if their Norm 1 exceed this number */
 #define EXP_DIFF_THRESHOLD 1000
 
-static void fft_init(int ln);
-
 static inline int16_t fix15(float a)
 {
     int v;
@@ -93,7 +90,7 @@
 
 static void fft_init(int ln)
 {
-    int i, j, m, n;
+    int i, n;
     float alpha;
 
     n = 1 << ln;
@@ -103,14 +100,6 @@
         costab[i] = fix15(cos(alpha));
         sintab[i] = fix15(sin(alpha));
     }
-
-    for(i=0;i<n;i++) {
-        m=0;
-        for(j=0;j<ln;j++) {
-            m |= ((i >> j) & 1) << (ln-j-1);
-        }
-        fft_rev[i]=m;
-    }
 }
 
 /* butter fly op */
@@ -148,14 +137,9 @@
 
     /* reverse */
     for(j=0;j<np;j++) {
-        int k;
-        IComplex tmp;
-        k = fft_rev[j];
-        if (k < j) {
-            tmp = z[k];
-            z[k] = z[j];
-            z[j] = tmp;
-        }
+        int k = ff_reverse[j] >> (8 - ln);
+        if (k < j)
+            FFSWAP(IComplex, z[k], z[j]);
     }
 
     /* pass 0 */
@@ -438,7 +422,7 @@
                               int16_t mask[NB_BLOCKS][AC3_MAX_CHANNELS][50])
 {
     int blk, ch;
-    int16_t bndpsd[NB_BLOCKS][AC3_MAX_CHANNELS][50];
+    int16_t band_psd[NB_BLOCKS][AC3_MAX_CHANNELS][50];
 
     for(blk=0; blk<NB_BLOCKS; blk++) {
         for(ch=0;ch<s->nb_all_channels;ch++) {
@@ -448,10 +432,10 @@
             } else {
                 ff_ac3_bit_alloc_calc_psd(encoded_exp[blk][ch], 0,
                                           s->nb_coefs[ch],
-                                          psd[blk][ch], bndpsd[blk][ch]);
-                ff_ac3_bit_alloc_calc_mask(&s->bit_alloc, bndpsd[blk][ch],
+                                          psd[blk][ch], band_psd[blk][ch]);
+                ff_ac3_bit_alloc_calc_mask(&s->bit_alloc, band_psd[blk][ch],
                                            0, s->nb_coefs[ch],
-                                           ff_fgaintab[s->fgaincod[ch]],
+                                           ff_ac3_fast_gain_tab[s->fast_gain_code[ch]],
                                            ch == s->lfe_channel,
                                            DBA_NONE, 0, NULL, NULL, NULL,
                                            mask[blk][ch]);
@@ -464,12 +448,12 @@
                      int16_t mask[NB_BLOCKS][AC3_MAX_CHANNELS][50],
                      int16_t psd[NB_BLOCKS][AC3_MAX_CHANNELS][N/2],
                      uint8_t bap[NB_BLOCKS][AC3_MAX_CHANNELS][N/2],
-                     int frame_bits, int csnroffst, int fsnroffst)
+                     int frame_bits, int coarse_snr_offset, int fine_snr_offset)
 {
     int i, ch;
-    int snroffset;
+    int snr_offset;
 
-    snroffset = (((csnroffst - 15) << 4) + fsnroffst) << 2;
+    snr_offset = (((coarse_snr_offset - 15) << 4) + fine_snr_offset) << 2;
 
     /* compute size */
     for(i=0;i<NB_BLOCKS;i++) {
@@ -478,7 +462,7 @@
         s->mant4_cnt = 0;
         for(ch=0;ch<s->nb_all_channels;ch++) {
             ff_ac3_bit_alloc_calc_bap(mask[i][ch], psd[i][ch], 0,
-                                      s->nb_coefs[ch], snroffset,
+                                      s->nb_coefs[ch], snr_offset,
                                       s->bit_alloc.floor, bap[i][ch]);
             frame_bits += compute_mantissa_size(s, bap[i][ch],
                                                  s->nb_coefs[ch]);
@@ -486,7 +470,7 @@
     }
 #if 0
     printf("csnr=%d fsnr=%d frame_bits=%d diff=%d\n",
-           csnroffst, fsnroffst, frame_bits,
+           coarse_snr_offset, fine_snr_offset, frame_bits,
            16 * s->frame_size - ((frame_bits + 7) & ~7));
 #endif
     return 16 * s->frame_size - frame_bits;
@@ -501,40 +485,40 @@
                                   int frame_bits)
 {
     int i, ch;
-    int csnroffst, fsnroffst;
+    int coarse_snr_offset, fine_snr_offset;
     uint8_t bap1[NB_BLOCKS][AC3_MAX_CHANNELS][N/2];
     int16_t psd[NB_BLOCKS][AC3_MAX_CHANNELS][N/2];
     int16_t mask[NB_BLOCKS][AC3_MAX_CHANNELS][50];
     static int frame_bits_inc[8] = { 0, 0, 2, 2, 2, 4, 2, 4 };
 
     /* init default parameters */
-    s->sdecaycod = 2;
-    s->fdecaycod = 1;
-    s->sgaincod = 1;
-    s->dbkneecod = 2;
-    s->floorcod = 4;
+    s->slow_decay_code = 2;
+    s->fast_decay_code = 1;
+    s->slow_gain_code = 1;
+    s->db_per_bit_code = 2;
+    s->floor_code = 4;
     for(ch=0;ch<s->nb_all_channels;ch++)
-        s->fgaincod[ch] = 4;
+        s->fast_gain_code[ch] = 4;
 
     /* compute real values */
-    s->bit_alloc.fscod = s->fscod;
-    s->bit_alloc.halfratecod = s->halfratecod;
-    s->bit_alloc.sdecay = ff_sdecaytab[s->sdecaycod] >> s->halfratecod;
-    s->bit_alloc.fdecay = ff_fdecaytab[s->fdecaycod] >> s->halfratecod;
-    s->bit_alloc.sgain = ff_sgaintab[s->sgaincod];
-    s->bit_alloc.dbknee = ff_dbkneetab[s->dbkneecod];
-    s->bit_alloc.floor = ff_floortab[s->floorcod];
+    s->bit_alloc.sr_code = s->sr_code;
+    s->bit_alloc.sr_shift = s->sr_shift;
+    s->bit_alloc.slow_decay = ff_ac3_slow_decay_tab[s->slow_decay_code] >> s->sr_shift;
+    s->bit_alloc.fast_decay = ff_ac3_fast_decay_tab[s->fast_decay_code] >> s->sr_shift;
+    s->bit_alloc.slow_gain = ff_ac3_slow_gain_tab[s->slow_gain_code];
+    s->bit_alloc.db_per_bit = ff_ac3_db_per_bit_tab[s->db_per_bit_code];
+    s->bit_alloc.floor = ff_ac3_floor_tab[s->floor_code];
 
     /* header size */
     frame_bits += 65;
-    // if (s->acmod == 2)
+    // if (s->channel_mode == 2)
     //    frame_bits += 2;
-    frame_bits += frame_bits_inc[s->acmod];
+    frame_bits += frame_bits_inc[s->channel_mode];
 
     /* audio blocks */
     for(i=0;i<NB_BLOCKS;i++) {
         frame_bits += s->nb_channels * 2 + 2; /* blksw * c, dithflag * c, dynrnge, cplstre */
-        if (s->acmod == AC3_ACMOD_STEREO) {
+        if (s->channel_mode == AC3_CHMODE_STEREO) {
             frame_bits++; /* rematstr */
             if(i==0) frame_bits += 4;
         }
@@ -568,43 +552,43 @@
     /* now the big work begins : do the bit allocation. Modify the snr
        offset until we can pack everything in the requested frame size */
 
-    csnroffst = s->csnroffst;
-    while (csnroffst >= 0 &&
-           bit_alloc(s, mask, psd, bap, frame_bits, csnroffst, 0) < 0)
-        csnroffst -= SNR_INC1;
-    if (csnroffst < 0) {
-        av_log(NULL, AV_LOG_ERROR, "Bit allocation failed, try increasing the bitrate, -ab 384 for example!\n");
+    coarse_snr_offset = s->coarse_snr_offset;
+    while (coarse_snr_offset >= 0 &&
+           bit_alloc(s, mask, psd, bap, frame_bits, coarse_snr_offset, 0) < 0)
+        coarse_snr_offset -= SNR_INC1;
+    if (coarse_snr_offset < 0) {
+        av_log(NULL, AV_LOG_ERROR, "Bit allocation failed. Try increasing the bitrate.\n");
         return -1;
     }
-    while ((csnroffst + SNR_INC1) <= 63 &&
+    while ((coarse_snr_offset + SNR_INC1) <= 63 &&
            bit_alloc(s, mask, psd, bap1, frame_bits,
-                     csnroffst + SNR_INC1, 0) >= 0) {
-        csnroffst += SNR_INC1;
+                     coarse_snr_offset + SNR_INC1, 0) >= 0) {
+        coarse_snr_offset += SNR_INC1;
         memcpy(bap, bap1, sizeof(bap1));
     }
-    while ((csnroffst + 1) <= 63 &&
-           bit_alloc(s, mask, psd, bap1, frame_bits, csnroffst + 1, 0) >= 0) {
-        csnroffst++;
+    while ((coarse_snr_offset + 1) <= 63 &&
+           bit_alloc(s, mask, psd, bap1, frame_bits, coarse_snr_offset + 1, 0) >= 0) {
+        coarse_snr_offset++;
         memcpy(bap, bap1, sizeof(bap1));
     }
 
-    fsnroffst = 0;
-    while ((fsnroffst + SNR_INC1) <= 15 &&
+    fine_snr_offset = 0;
+    while ((fine_snr_offset + SNR_INC1) <= 15 &&
            bit_alloc(s, mask, psd, bap1, frame_bits,
-                     csnroffst, fsnroffst + SNR_INC1) >= 0) {
-        fsnroffst += SNR_INC1;
+                     coarse_snr_offset, fine_snr_offset + SNR_INC1) >= 0) {
+        fine_snr_offset += SNR_INC1;
         memcpy(bap, bap1, sizeof(bap1));
     }
-    while ((fsnroffst + 1) <= 15 &&
+    while ((fine_snr_offset + 1) <= 15 &&
            bit_alloc(s, mask, psd, bap1, frame_bits,
-                     csnroffst, fsnroffst + 1) >= 0) {
-        fsnroffst++;
+                     coarse_snr_offset, fine_snr_offset + 1) >= 0) {
+        fine_snr_offset++;
         memcpy(bap, bap1, sizeof(bap1));
     }
 
-    s->csnroffst = csnroffst;
+    s->coarse_snr_offset = coarse_snr_offset;
     for(ch=0;ch<s->nb_all_channels;ch++)
-        s->fsnroffst[ch] = fsnroffst;
+        s->fine_snr_offset[ch] = fine_snr_offset;
 #if defined(DEBUG_BITALLOC)
     {
         int j;
@@ -632,7 +616,8 @@
     AC3EncodeContext *s = avctx->priv_data;
     int i, j, ch;
     float alpha;
-    static const uint8_t acmod_defs[6] = {
+    int bw_code;
+    static const uint8_t channel_mode_defs[6] = {
         0x01, /* C */
         0x02, /* L R */
         0x03, /* L C R */
@@ -648,7 +633,7 @@
     /* number of channels */
     if (channels < 1 || channels > 6)
         return -1;
-    s->acmod = acmod_defs[channels - 1];
+    s->channel_mode = channel_mode_defs[channels - 1];
     s->lfe = (channels == 6) ? 1 : 0;
     s->nb_all_channels = channels;
     s->nb_channels = channels > 5 ? 5 : channels;
@@ -657,45 +642,53 @@
     /* frequency */
     for(i=0;i<3;i++) {
         for(j=0;j<3;j++)
-            if ((ff_ac3_freqs[j] >> i) == freq)
+            if ((ff_ac3_sample_rate_tab[j] >> i) == freq)
                 goto found;
     }
     return -1;
  found:
     s->sample_rate = freq;
-    s->halfratecod = i;
-    s->fscod = j;
-    s->bsid = 8 + s->halfratecod;
-    s->bsmod = 0; /* complete main audio service */
+    s->sr_shift = i;
+    s->sr_code = j;
+    s->bitstream_id = 8 + s->sr_shift;
+    s->bitstream_mode = 0; /* complete main audio service */
 
     /* bitrate & frame size */
-    bitrate /= 1000;
     for(i=0;i<19;i++) {
-        if ((ff_ac3_bitratetab[i] >> s->halfratecod) == bitrate)
+        if ((ff_ac3_bitrate_tab[i] >> s->sr_shift)*1000 == bitrate)
             break;
     }
     if (i == 19)
         return -1;
     s->bit_rate = bitrate;
-    s->frmsizecod = i << 1;
-    s->frame_size_min = ff_ac3_frame_sizes[s->frmsizecod][s->fscod];
+    s->frame_size_code = i << 1;
+    s->frame_size_min = ff_ac3_frame_size_tab[s->frame_size_code][s->sr_code];
     s->bits_written = 0;
     s->samples_written = 0;
     s->frame_size = s->frame_size_min;
 
     /* bit allocation init */
-    for(ch=0;ch<s->nb_channels;ch++) {
-        /* bandwidth for each channel */
+    if(avctx->cutoff) {
+        /* calculate bandwidth based on user-specified cutoff frequency */
+        int cutoff = av_clip(avctx->cutoff, 1, s->sample_rate >> 1);
+        int fbw_coeffs = cutoff * 512 / s->sample_rate;
+        bw_code = av_clip((fbw_coeffs - 73) / 3, 0, 60);
+    } else {
+        /* use default bandwidth setting */
         /* XXX: should compute the bandwidth according to the frame
            size, so that we avoid anoying high freq artefacts */
-        s->chbwcod[ch] = 50; /* sample bandwidth as mpeg audio layer 2 table 0 */
-        s->nb_coefs[ch] = ((s->chbwcod[ch] + 12) * 3) + 37;
+        bw_code = 50;
+    }
+    for(ch=0;ch<s->nb_channels;ch++) {
+        /* bandwidth for each channel */
+        s->chbwcod[ch] = bw_code;
+        s->nb_coefs[ch] = bw_code * 3 + 73;
     }
     if (s->lfe) {
         s->nb_coefs[s->lfe_channel] = 7; /* fixed */
     }
     /* initial snr offset */
-    s->csnroffst = 40;
+    s->coarse_snr_offset = 40;
 
     /* mdct init */
     fft_init(MDCT_NBITS - 2);
@@ -718,16 +711,16 @@
 
     put_bits(&s->pb, 16, 0x0b77); /* frame header */
     put_bits(&s->pb, 16, 0); /* crc1: will be filled later */
-    put_bits(&s->pb, 2, s->fscod);
-    put_bits(&s->pb, 6, s->frmsizecod + (s->frame_size - s->frame_size_min));
-    put_bits(&s->pb, 5, s->bsid);
-    put_bits(&s->pb, 3, s->bsmod);
-    put_bits(&s->pb, 3, s->acmod);
-    if ((s->acmod & 0x01) && s->acmod != AC3_ACMOD_MONO)
+    put_bits(&s->pb, 2, s->sr_code);
+    put_bits(&s->pb, 6, s->frame_size_code + (s->frame_size - s->frame_size_min));
+    put_bits(&s->pb, 5, s->bitstream_id);
+    put_bits(&s->pb, 3, s->bitstream_mode);
+    put_bits(&s->pb, 3, s->channel_mode);
+    if ((s->channel_mode & 0x01) && s->channel_mode != AC3_CHMODE_MONO)
         put_bits(&s->pb, 2, 1); /* XXX -4.5 dB */
-    if (s->acmod & 0x04)
+    if (s->channel_mode & 0x04)
         put_bits(&s->pb, 2, 1); /* XXX -6 dB */
-    if (s->acmod == AC3_ACMOD_STEREO)
+    if (s->channel_mode == AC3_CHMODE_STEREO)
         put_bits(&s->pb, 2, 0); /* surround not indicated */
     put_bits(&s->pb, 1, s->lfe); /* LFE */
     put_bits(&s->pb, 5, 31); /* dialog norm: -31 db */
@@ -738,7 +731,7 @@
     put_bits(&s->pb, 1, 1); /* original bitstream */
     put_bits(&s->pb, 1, 0); /* no time code 1 */
     put_bits(&s->pb, 1, 0); /* no time code 2 */
-    put_bits(&s->pb, 1, 0); /* no addtional bit stream info */
+    put_bits(&s->pb, 1, 0); /* no additional bit stream info */
 }
 
 /* symetric quantization on 'levels' levels */
@@ -810,7 +803,7 @@
         put_bits(&s->pb, 1, 0); /* no new coupling strategy */
     }
 
-    if (s->acmod == AC3_ACMOD_STEREO)
+    if (s->channel_mode == AC3_CHMODE_STEREO)
       {
         if(block_num==0)
           {
@@ -900,20 +893,20 @@
     baie = (block_num == 0);
     put_bits(&s->pb, 1, baie);
     if (baie) {
-        put_bits(&s->pb, 2, s->sdecaycod);
-        put_bits(&s->pb, 2, s->fdecaycod);
-        put_bits(&s->pb, 2, s->sgaincod);
-        put_bits(&s->pb, 2, s->dbkneecod);
-        put_bits(&s->pb, 3, s->floorcod);
+        put_bits(&s->pb, 2, s->slow_decay_code);
+        put_bits(&s->pb, 2, s->fast_decay_code);
+        put_bits(&s->pb, 2, s->slow_gain_code);
+        put_bits(&s->pb, 2, s->db_per_bit_code);
+        put_bits(&s->pb, 3, s->floor_code);
     }
 
     /* snr offset */
     put_bits(&s->pb, 1, baie); /* always present with bai */
     if (baie) {
-        put_bits(&s->pb, 6, s->csnroffst);
+        put_bits(&s->pb, 6, s->coarse_snr_offset);
         for(ch=0;ch<s->nb_all_channels;ch++) {
-            put_bits(&s->pb, 4, s->fsnroffst[ch]);
-            put_bits(&s->pb, 3, s->fgaincod[ch]);
+            put_bits(&s->pb, 4, s->fine_snr_offset[ch]);
+            put_bits(&s->pb, 3, s->fast_gain_code[ch]);
         }
     }
 
@@ -1132,13 +1125,16 @@
     /* Now we must compute both crcs : this is not so easy for crc1
        because it is at the beginning of the data... */
     frame_size_58 = (frame_size >> 1) + (frame_size >> 3);
-    crc1 = bswap_16(av_crc(av_crc8005, 0, frame + 4, 2 * frame_size_58 - 4));
+    crc1 = bswap_16(av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0,
+                           frame + 4, 2 * frame_size_58 - 4));
     /* XXX: could precompute crc_inv */
     crc_inv = pow_poly((CRC16_POLY >> 1), (16 * frame_size_58) - 16, CRC16_POLY);
     crc1 = mul_poly(crc_inv, crc1, CRC16_POLY);
     AV_WB16(frame+2,crc1);
 
-    crc2 = bswap_16(av_crc(av_crc8005, 0, frame + 2 * frame_size_58, (frame_size - frame_size_58) * 2 - 2));
+    crc2 = bswap_16(av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0,
+                           frame + 2 * frame_size_58,
+                           (frame_size - frame_size_58) * 2 - 2));
     AV_WB16(frame+2*frame_size-2,crc2);
 
     //    printf("n=%d frame_size=%d\n", n, frame_size);
@@ -1240,11 +1236,11 @@
     }
 
     /* adjust for fractional frame sizes */
-    while(s->bits_written >= s->bit_rate*1000 && s->samples_written >= s->sample_rate) {
-        s->bits_written -= s->bit_rate*1000;
+    while(s->bits_written >= s->bit_rate && s->samples_written >= s->sample_rate) {
+        s->bits_written -= s->bit_rate;
         s->samples_written -= s->sample_rate;
     }
-    s->frame_size = s->frame_size_min + (s->bits_written * s->sample_rate < s->samples_written * s->bit_rate*1000);
+    s->frame_size = s->frame_size_min + (s->bits_written * s->sample_rate < s->samples_written * s->bit_rate);
     s->bits_written += s->frame_size * 16;
     s->samples_written += AC3_FRAME_SIZE;
 
diff -u mplayer-1.0~rc2-12/libavcodec/ac3.h ffmpeg-free-0.svn20080206/libavcodec/ac3.h
--- mplayer-1.0~rc2-12/libavcodec/ac3.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ac3.h	2008-01-05 18:04:57.000000000 +0100
@@ -24,8 +24,8 @@
  * Common code between AC3 encoder and decoder.
  */
 
-#ifndef AC3_H
-#define AC3_H
+#ifndef FFMPEG_AC3_H
+#define FFMPEG_AC3_H
 
 #include "ac3tab.h"
 
@@ -53,21 +53,21 @@
 
 /** Channel mode (audio coding mode) */
 typedef enum {
-    AC3_ACMOD_DUALMONO = 0,
-    AC3_ACMOD_MONO,
-    AC3_ACMOD_STEREO,
-    AC3_ACMOD_3F,
-    AC3_ACMOD_2F1R,
-    AC3_ACMOD_3F1R,
-    AC3_ACMOD_2F2R,
-    AC3_ACMOD_3F2R
+    AC3_CHMODE_DUALMONO = 0,
+    AC3_CHMODE_MONO,
+    AC3_CHMODE_STEREO,
+    AC3_CHMODE_3F,
+    AC3_CHMODE_2F1R,
+    AC3_CHMODE_3F1R,
+    AC3_CHMODE_2F2R,
+    AC3_CHMODE_3F2R
 } AC3ChannelMode;
 
 typedef struct AC3BitAllocParameters {
-    int fscod; /* frequency */
-    int halfratecod;
-    int sgain, sdecay, fdecay, dbknee, floor;
-    int cplfleak, cplsleak;
+    int sr_code;
+    int sr_shift;
+    int slow_gain, slow_decay, fast_decay, db_per_bit, floor;
+    int cpl_fast_leak, cpl_slow_leak;
 } AC3BitAllocParameters;
 
 /**
@@ -80,21 +80,16 @@
      */
     uint16_t sync_word;
     uint16_t crc1;
-    uint8_t fscod;
-    uint8_t frmsizecod;
-    uint8_t bsid;
-    uint8_t bsmod;
-    uint8_t acmod;
-    uint8_t cmixlev;
-    uint8_t surmixlev;
-    uint8_t dsurmod;
-    uint8_t lfeon;
+    uint8_t sr_code;
+    uint8_t bitstream_id;
+    uint8_t channel_mode;
+    uint8_t lfe_on;
     /** @} */
 
     /** @defgroup derived Derived values
      * @{
      */
-    uint8_t halfratecod;
+    uint8_t sr_shift;
     uint16_t sample_rate;
     uint32_t bit_rate;
     uint8_t channels;
@@ -117,10 +112,10 @@
  * @param[in]  start      starting bin location
  * @param[in]  end        ending bin location
  * @param[out] psd        signal power for each frequency bin
- * @param[out] bndpsd     signal power for each critical band
+ * @param[out] band_psd   signal power for each critical band
  */
 void ff_ac3_bit_alloc_calc_psd(int8_t *exp, int start, int end, int16_t *psd,
-                               int16_t *bndpsd);
+                               int16_t *band_psd);
 
 /**
  * Calculates the masking curve.
@@ -130,23 +125,23 @@
  * allocation information is provided, it is used for adjusting the masking
  * curve, usually to give a closer match to a better psychoacoustic model.
  *
- * @param[in]  s          adjustable bit allocation parameters
- * @param[in]  bndpsd     signal power for each critical band
- * @param[in]  start      starting bin location
- * @param[in]  end        ending bin location
- * @param[in]  fgain      fast gain (estimated signal-to-mask ratio)
- * @param[in]  is_lfe     whether or not the channel being processed is the LFE
- * @param[in]  deltbae    delta bit allocation exists (none, reuse, or new)
- * @param[in]  deltnseg   number of delta segments
- * @param[in]  deltoffst  location offsets for each segment
- * @param[in]  deltlen    length of each segment
- * @param[in]  deltba     delta bit allocation for each segment
- * @param[out] mask       calculated masking curve
+ * @param[in]  s            adjustable bit allocation parameters
+ * @param[in]  band_psd     signal power for each critical band
+ * @param[in]  start        starting bin location
+ * @param[in]  end          ending bin location
+ * @param[in]  fast_gain    fast gain (estimated signal-to-mask ratio)
+ * @param[in]  is_lfe       whether or not the channel being processed is the LFE
+ * @param[in]  dba_mode     delta bit allocation mode (none, reuse, or new)
+ * @param[in]  dba_nsegs    number of delta segments
+ * @param[in]  dba_offsets  location offsets for each segment
+ * @param[in]  dba_lengths  length of each segment
+ * @param[in]  dba_values   delta bit allocation for each segment
+ * @param[out] mask         calculated masking curve
  */
-void ff_ac3_bit_alloc_calc_mask(AC3BitAllocParameters *s, int16_t *bndpsd,
-                                int start, int end, int fgain, int is_lfe,
-                                int deltbae, int deltnseg, uint8_t *deltoffst,
-                                uint8_t *deltlen, uint8_t *deltba,
+void ff_ac3_bit_alloc_calc_mask(AC3BitAllocParameters *s, int16_t *band_psd,
+                                int start, int end, int fast_gain, int is_lfe,
+                                int dba_mode, int dba_nsegs, uint8_t *dba_offsets,
+                                uint8_t *dba_lengths, uint8_t *dba_values,
                                 int16_t *mask);
 
 /**
@@ -159,17 +154,18 @@
  * @param[in]  psd        signal power for each frequency bin
  * @param[in]  start      starting bin location
  * @param[in]  end        ending bin location
- * @param[in]  snroffset  SNR adjustment
+ * @param[in]  snr_offset SNR adjustment
  * @param[in]  floor      noise floor
  * @param[out] bap        bit allocation pointers
  */
 void ff_ac3_bit_alloc_calc_bap(int16_t *mask, int16_t *psd, int start, int end,
-                               int snroffset, int floor, uint8_t *bap);
+                               int snr_offset, int floor, uint8_t *bap);
 
 void ac3_parametric_bit_allocation(AC3BitAllocParameters *s, uint8_t *bap,
                                    int8_t *exp, int start, int end,
-                                   int snroffset, int fgain, int is_lfe,
-                                   int deltbae,int deltnseg,
-                                   uint8_t *deltoffst, uint8_t *deltlen, uint8_t *deltba);
+                                   int snr_offset, int fast_gain, int is_lfe,
+                                   int dba_mode, int dba_nsegs,
+                                   uint8_t *dba_offsets, uint8_t *dba_lengths,
+                                   uint8_t *dba_values);
 
-#endif /* AC3_H */
+#endif /* FFMPEG_AC3_H */
diff -u mplayer-1.0~rc2-12/libavcodec/ac3_parser.c ffmpeg-free-0.svn20080206/libavcodec/ac3_parser.c
--- mplayer-1.0~rc2-12/libavcodec/ac3_parser.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ac3_parser.c	2008-03-20 19:10:57.000000000 +0100
@@ -37,6 +37,8 @@
 int ff_ac3_parse_header(const uint8_t buf[7], AC3HeaderInfo *hdr)
 {
     GetBitContext gbc;
+    int frame_size_code;
+    int num_blocks;
 
     memset(hdr, 0, sizeof(*hdr));
 
@@ -46,40 +48,73 @@
     if(hdr->sync_word != 0x0B77)
         return AC3_PARSE_ERROR_SYNC;
 
-    /* read ahead to bsid to make sure this is AC-3, not E-AC-3 */
-    hdr->bsid = show_bits_long(&gbc, 29) & 0x1F;
-    if(hdr->bsid > 10)
+    /* read ahead to bsid to distinguish between AC-3 and E-AC-3 */
+    hdr->bitstream_id = show_bits_long(&gbc, 29) & 0x1F;
+    if(hdr->bitstream_id > 16)
         return AC3_PARSE_ERROR_BSID;
 
-    hdr->crc1 = get_bits(&gbc, 16);
-    hdr->fscod = get_bits(&gbc, 2);
-    if(hdr->fscod == 3)
-        return AC3_PARSE_ERROR_SAMPLE_RATE;
-
-    hdr->frmsizecod = get_bits(&gbc, 6);
-    if(hdr->frmsizecod > 37)
-        return AC3_PARSE_ERROR_FRAME_SIZE;
-
-    skip_bits(&gbc, 5); // skip bsid, already got it
-
-    hdr->bsmod = get_bits(&gbc, 3);
-    hdr->acmod = get_bits(&gbc, 3);
-    if((hdr->acmod & 1) && hdr->acmod != AC3_ACMOD_MONO) {
-        hdr->cmixlev = get_bits(&gbc, 2);
-    }
-    if(hdr->acmod & 4) {
-        hdr->surmixlev = get_bits(&gbc, 2);
-    }
-    if(hdr->acmod == AC3_ACMOD_STEREO) {
-        hdr->dsurmod = get_bits(&gbc, 2);
-    }
-    hdr->lfeon = get_bits1(&gbc);
+    if(hdr->bitstream_id <= 10) {
+        /* Normal AC-3 */
+        hdr->crc1 = get_bits(&gbc, 16);
+        hdr->sr_code = get_bits(&gbc, 2);
+        if(hdr->sr_code == 3)
+            return AC3_PARSE_ERROR_SAMPLE_RATE;
+
+        frame_size_code = get_bits(&gbc, 6);
+        if(frame_size_code > 37)
+            return AC3_PARSE_ERROR_FRAME_SIZE;
+
+        skip_bits(&gbc, 5); // skip bsid, already got it
+
+        skip_bits(&gbc, 3); // skip bitstream mode
+        hdr->channel_mode = get_bits(&gbc, 3);
+        if((hdr->channel_mode & 1) && hdr->channel_mode != AC3_CHMODE_MONO) {
+            skip_bits(&gbc, 2); // skip center mix level
+        }
+        if(hdr->channel_mode & 4) {
+            skip_bits(&gbc, 2); // skip surround mix level
+        }
+        if(hdr->channel_mode == AC3_CHMODE_STEREO) {
+            skip_bits(&gbc, 2); // skip dolby surround mode
+        }
+        hdr->lfe_on = get_bits1(&gbc);
 
-    hdr->halfratecod = FFMAX(hdr->bsid, 8) - 8;
-    hdr->sample_rate = ff_ac3_freqs[hdr->fscod] >> hdr->halfratecod;
-    hdr->bit_rate = (ff_ac3_bitratetab[hdr->frmsizecod>>1] * 1000) >> hdr->halfratecod;
-    hdr->channels = ff_ac3_channels[hdr->acmod] + hdr->lfeon;
-    hdr->frame_size = ff_ac3_frame_sizes[hdr->frmsizecod][hdr->fscod] * 2;
+        hdr->sr_shift = FFMAX(hdr->bitstream_id, 8) - 8;
+        hdr->sample_rate = ff_ac3_sample_rate_tab[hdr->sr_code] >> hdr->sr_shift;
+        hdr->bit_rate = (ff_ac3_bitrate_tab[frame_size_code>>1] * 1000) >> hdr->sr_shift;
+        hdr->channels = ff_ac3_channels_tab[hdr->channel_mode] + hdr->lfe_on;
+        hdr->frame_size = ff_ac3_frame_size_tab[frame_size_code][hdr->sr_code] * 2;
+    } else {
+        /* Enhanced AC-3 */
+        hdr->crc1 = 0;
+        skip_bits(&gbc, 2); // skip stream type
+        skip_bits(&gbc, 3); // skip substream id
+
+        hdr->frame_size = (get_bits(&gbc, 11) + 1) << 1;
+        if(hdr->frame_size < AC3_HEADER_SIZE)
+            return AC3_PARSE_ERROR_FRAME_SIZE;
+
+        hdr->sr_code = get_bits(&gbc, 2);
+        if (hdr->sr_code == 3) {
+            int sr_code2 = get_bits(&gbc, 2);
+            if(sr_code2 == 3)
+                return AC3_PARSE_ERROR_SAMPLE_RATE;
+            hdr->sample_rate = ff_ac3_sample_rate_tab[sr_code2] / 2;
+            hdr->sr_shift = 1;
+            num_blocks = 6;
+        } else {
+            num_blocks = eac3_blocks[get_bits(&gbc, 2)];
+            hdr->sample_rate = ff_ac3_sample_rate_tab[hdr->sr_code];
+            hdr->sr_shift = 0;
+        }
+
+        hdr->channel_mode = get_bits(&gbc, 3);
+        hdr->lfe_on = get_bits1(&gbc);
+
+        hdr->bit_rate = (uint32_t)(8.0 * hdr->frame_size * hdr->sample_rate /
+                        (num_blocks * 256.0));
+        hdr->channels = ff_ac3_channels_tab[hdr->channel_mode] + hdr->lfe_on;
+    }
 
     return 0;
 }
@@ -88,59 +123,18 @@
                     int *bit_rate, int *samples)
 {
     int err;
-    unsigned int fscod, acmod, bsid, lfeon;
-    unsigned int strmtyp, substreamid, frmsiz, fscod2, numblkscod;
-    GetBitContext bits;
     AC3HeaderInfo hdr;
 
     err = ff_ac3_parse_header(buf, &hdr);
 
-    if(err < 0 && err != -2)
+    if(err < 0)
         return 0;
 
-    bsid = hdr.bsid;
-    if(bsid <= 10) {             /* Normal AC-3 */
-        *sample_rate = hdr.sample_rate;
-        *bit_rate = hdr.bit_rate;
-        *channels = hdr.channels;
-        *samples = AC3_FRAME_SIZE;
-        return hdr.frame_size;
-    } else if (bsid > 10 && bsid <= 16) { /* Enhanced AC-3 */
-        init_get_bits(&bits, &buf[2], (AC3_HEADER_SIZE-2) * 8);
-        strmtyp = get_bits(&bits, 2);
-        substreamid = get_bits(&bits, 3);
-
-        if (strmtyp != 0 || substreamid != 0)
-            return 0;   /* Currently don't support additional streams */
-
-        frmsiz = get_bits(&bits, 11) + 1;
-        fscod = get_bits(&bits, 2);
-        if (fscod == 3) {
-            fscod2 = get_bits(&bits, 2);
-            numblkscod = 3;
-
-            if(fscod2 == 3)
-                return 0;
-
-            *sample_rate = ff_ac3_freqs[fscod2] / 2;
-        } else {
-            numblkscod = get_bits(&bits, 2);
-
-            *sample_rate = ff_ac3_freqs[fscod];
-        }
-
-        acmod = get_bits(&bits, 3);
-        lfeon = get_bits1(&bits);
-
-        *samples = eac3_blocks[numblkscod] * 256;
-        *bit_rate = frmsiz * (*sample_rate) * 16 / (*samples);
-        *channels = ff_ac3_channels[acmod] + lfeon;
-
-        return frmsiz * 2;
-    }
-
-    /* Unsupported bitstream version */
-    return 0;
+    *sample_rate = hdr.sample_rate;
+    *bit_rate = hdr.bit_rate;
+    *channels = hdr.channels;
+    *samples = AC3_FRAME_SIZE;
+    return hdr.frame_size;
 }
 
 static int ac3_parse_init(AVCodecParserContext *s1)
diff -u mplayer-1.0~rc2-12/libavcodec/ac3_parser.h ffmpeg-free-0.svn20080206/libavcodec/ac3_parser.h
--- mplayer-1.0~rc2-12/libavcodec/ac3_parser.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ac3_parser.h	2007-10-17 11:37:46.000000000 +0200
@@ -20,8 +20,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AC3_PARSER_H
-#define AC3_PARSER_H
+#ifndef FFMPEG_AC3_PARSER_H
+#define FFMPEG_AC3_PARSER_H
 
 #include "ac3.h"
 
@@ -44,4 +44,4 @@
  */
 int ff_ac3_parse_header(const uint8_t buf[7], AC3HeaderInfo *hdr);
 
-#endif /* AC3_PARSER_H */
+#endif /* FFMPEG_AC3_PARSER_H */
diff -u mplayer-1.0~rc2-12/libavcodec/ac3tab.c ffmpeg-free-0.svn20080206/libavcodec/ac3tab.c
--- mplayer-1.0~rc2-12/libavcodec/ac3tab.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ac3tab.c	2008-03-20 19:10:57.000000000 +0100
@@ -30,7 +30,7 @@
  * Possible frame sizes.
  * from ATSC A/52 Table 5.18 Frame Size Code Table.
  */
-const uint16_t ff_ac3_frame_sizes[38][3] = {
+const uint16_t ff_ac3_frame_size_tab[38][3] = {
     { 64,   69,   96   },
     { 64,   70,   96   },
     { 80,   87,   120  },
@@ -75,15 +75,15 @@
  * Maps audio coding mode (acmod) to number of full-bandwidth channels.
  * from ATSC A/52 Table 5.8 Audio Coding Mode
  */
-const uint8_t ff_ac3_channels[8] = {
+const uint8_t ff_ac3_channels_tab[8] = {
     2, 1, 2, 3, 3, 4, 4, 5
 };
 
 /* possible frequencies */
-const uint16_t ff_ac3_freqs[3] = { 48000, 44100, 32000 };
+const uint16_t ff_ac3_sample_rate_tab[3] = { 48000, 44100, 32000 };
 
 /* possible bitrates */
-const uint16_t ff_ac3_bitratetab[19] = {
+const uint16_t ff_ac3_bitrate_tab[19] = {
     32, 40, 48, 56, 64, 80, 96, 112, 128,
     160, 192, 224, 256, 320, 384, 448, 512, 576, 640
 };
@@ -126,7 +126,7 @@
 32767,32767,32767,32767,32767,32767,32767,32767,
 };
 
-const uint8_t ff_ac3_latab[260]= {
+const uint8_t ff_ac3_log_add_tab[260]= {
 0x40,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,
 0x36,0x35,0x34,0x34,0x33,0x32,0x31,0x30,0x2f,0x2f,
 0x2e,0x2d,0x2c,0x2c,0x2b,0x2a,0x29,0x29,0x28,0x27,
@@ -155,7 +155,7 @@
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 };
 
-const uint16_t ff_ac3_hth[50][3]= {
+const uint16_t ff_ac3_hearing_threshold_tab[50][3]= {
 { 0x04d0,0x04f0,0x0580 },
 { 0x04d0,0x04f0,0x0580 },
 { 0x0440,0x0460,0x04b0 },
@@ -208,7 +208,7 @@
 { 0x0840,0x0840,0x04e0 },
 };
 
-const uint8_t ff_ac3_baptab[64]= {
+const uint8_t ff_ac3_bap_tab[64]= {
     0, 1, 1, 1, 1, 1, 2, 2, 3, 3,
     3, 4, 4, 5, 5, 6, 6, 6, 6, 7,
     7, 7, 7, 8, 8, 8, 8, 9, 9, 9,
@@ -218,31 +218,31 @@
     15, 15, 15, 15,
 };
 
-const uint8_t ff_sdecaytab[4]={
+const uint8_t ff_ac3_slow_decay_tab[4]={
     0x0f, 0x11, 0x13, 0x15,
 };
 
-const uint8_t ff_fdecaytab[4]={
+const uint8_t ff_ac3_fast_decay_tab[4]={
     0x3f, 0x53, 0x67, 0x7b,
 };
 
-const uint16_t ff_sgaintab[4]= {
+const uint16_t ff_ac3_slow_gain_tab[4]= {
     0x540, 0x4d8, 0x478, 0x410,
 };
 
-const uint16_t ff_dbkneetab[4]= {
+const uint16_t ff_ac3_db_per_bit_tab[4]= {
     0x000, 0x700, 0x900, 0xb00,
 };
 
-const int16_t ff_floortab[8]= {
+const int16_t ff_ac3_floor_tab[8]= {
     0x2f0, 0x2b0, 0x270, 0x230, 0x1f0, 0x170, 0x0f0, 0xf800,
 };
 
-const uint16_t ff_fgaintab[8]= {
+const uint16_t ff_ac3_fast_gain_tab[8]= {
     0x080, 0x100, 0x180, 0x200, 0x280, 0x300, 0x380, 0x400,
 };
 
-const uint8_t ff_ac3_bndsz[50]={
+const uint8_t ff_ac3_critical_band_size_tab[50]={
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3,
     3, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 24, 24, 24, 24, 24
diff -u mplayer-1.0~rc2-12/libavcodec/ac3tab.h ffmpeg-free-0.svn20080206/libavcodec/ac3tab.h
--- mplayer-1.0~rc2-12/libavcodec/ac3tab.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ac3tab.h	2007-12-09 04:21:33.000000000 +0100
@@ -19,25 +19,25 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AC3TAB_H
-#define AC3TAB_H
+#ifndef FFMPEG_AC3TAB_H
+#define FFMPEG_AC3TAB_H
 
 #include "common.h"
 
-extern const uint16_t ff_ac3_frame_sizes[38][3];
-extern const uint8_t  ff_ac3_channels[8];
-extern const uint16_t ff_ac3_freqs[3];
-extern const uint16_t ff_ac3_bitratetab[19];
+extern const uint16_t ff_ac3_frame_size_tab[38][3];
+extern const uint8_t  ff_ac3_channels_tab[8];
+extern const uint16_t ff_ac3_sample_rate_tab[3];
+extern const uint16_t ff_ac3_bitrate_tab[19];
 extern const int16_t  ff_ac3_window[256];
-extern const uint8_t  ff_ac3_latab[260];
-extern const uint16_t ff_ac3_hth[50][3];
-extern const uint8_t  ff_ac3_baptab[64];
-extern const uint8_t  ff_sdecaytab[4];
-extern const uint8_t  ff_fdecaytab[4];
-extern const uint16_t ff_sgaintab[4];
-extern const uint16_t ff_dbkneetab[4];
-extern const int16_t  ff_floortab[8];
-extern const uint16_t ff_fgaintab[8];
-extern const uint8_t  ff_ac3_bndsz[50];
+extern const uint8_t  ff_ac3_log_add_tab[260];
+extern const uint16_t ff_ac3_hearing_threshold_tab[50][3];
+extern const uint8_t  ff_ac3_bap_tab[64];
+extern const uint8_t  ff_ac3_slow_decay_tab[4];
+extern const uint8_t  ff_ac3_fast_decay_tab[4];
+extern const uint16_t ff_ac3_slow_gain_tab[4];
+extern const uint16_t ff_ac3_db_per_bit_tab[4];
+extern const int16_t  ff_ac3_floor_tab[8];
+extern const uint16_t ff_ac3_fast_gain_tab[8];
+extern const uint8_t  ff_ac3_critical_band_size_tab[50];
 
-#endif /* AC3TAB_H */
+#endif /* FFMPEG_AC3TAB_H */
diff -u mplayer-1.0~rc2-12/libavcodec/adpcm.c ffmpeg-free-0.svn20080206/libavcodec/adpcm.c
--- mplayer-1.0~rc2-12/libavcodec/adpcm.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/adpcm.c	2008-03-20 19:10:57.000000000 +0100
@@ -30,6 +30,10 @@
  *   by Mike Melanson (melanson@pcisys.net)
  * CD-ROM XA ADPCM codec by BERO
  * EA ADPCM decoder by Robin Kay (komadori@myrealbox.com)
+ * EA ADPCM R1/R2/R3 decoder by Peter Ross (pross@xvid.org)
+ * EA IMA EACS decoder by Peter Ross (pross@xvid.org)
+ * EA IMA SEAD decoder by Peter Ross (pross@xvid.org)
+ * EA ADPCM XAS decoder by Peter Ross (pross@xvid.org)
  * THP ADPCM decoder by Marco Gerards (mgerards@xs4all.nl)
  *
  * Features and limitations:
@@ -144,8 +148,7 @@
 
 typedef struct ADPCMContext {
     int channel; /* for stereo MOVs, decode left, then decode right, then tell it's decoded */
-    ADPCMChannelStatus status[2];
-    short sample_buffer[32]; /* hold left samples while waiting for right samples */
+    ADPCMChannelStatus status[6];
 } ADPCMContext;
 
 /* XXX: implement encoding */
@@ -156,11 +159,6 @@
     if (avctx->channels > 2)
         return -1; /* only stereo or mono =) */
     switch(avctx->codec->id) {
-    case CODEC_ID_ADPCM_IMA_QT:
-        av_log(avctx, AV_LOG_ERROR, "ADPCM: codec adpcm_ima_qt unsupported for encoding !\n");
-        avctx->frame_size = 64; /* XXX: can multiple of avctx->channels * 64 (left and right blocks are interleaved) */
-        return -1;
-        break;
     case CODEC_ID_ADPCM_IMA_WAV:
         avctx->frame_size = (BLKSIZE - 4 * avctx->channels) * 8 / (4 * avctx->channels) + 1; /* each 16 bits sample gives one nibble */
                                                              /* and we have 4 bytes per channel overhead */
@@ -444,8 +442,6 @@
 /*    n = (BLKSIZE - 4 * avctx->channels) / (2 * 8 * avctx->channels); */
 
     switch(avctx->codec->id) {
-    case CODEC_ID_ADPCM_IMA_QT: /* XXX: can't test until we get .mov writer */
-        break;
     case CODEC_ID_ADPCM_IMA_WAV:
         n = avctx->frame_size / 8;
             c->status[0].prev_sample = (signed short)samples[0]; /* XXX */
@@ -455,7 +451,7 @@
             *dst++ = 0; /* unknown */
             samples++;
             if (avctx->channels == 2) {
-                c->status[1].prev_sample = (signed short)samples[1];
+                c->status[1].prev_sample = (signed short)samples[0];
 /*                c->status[1].step_index = 0; */
                 bytestream_put_le16(&dst, c->status[1].prev_sample);
                 *dst++ = (unsigned char)c->status[1].step_index;
@@ -483,17 +479,17 @@
                 }
             } else
             for (; n>0; n--) {
-                *dst = adpcm_ima_compress_sample(&c->status[0], samples[0]) & 0x0F;
-                *dst |= (adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels]) << 4) & 0xF0;
+                *dst = adpcm_ima_compress_sample(&c->status[0], samples[0]);
+                *dst |= adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels]) << 4;
                 dst++;
-                *dst = adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels * 2]) & 0x0F;
-                *dst |= (adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels * 3]) << 4) & 0xF0;
+                *dst = adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels * 2]);
+                *dst |= adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels * 3]) << 4;
                 dst++;
-                *dst = adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels * 4]) & 0x0F;
-                *dst |= (adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels * 5]) << 4) & 0xF0;
+                *dst = adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels * 4]);
+                *dst |= adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels * 5]) << 4;
                 dst++;
-                *dst = adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels * 6]) & 0x0F;
-                *dst |= (adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels * 7]) << 4) & 0xF0;
+                *dst = adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels * 6]);
+                *dst |= adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels * 7]) << 4;
                 dst++;
                 /* right channel */
                 if (avctx->channels == 2) {
@@ -544,9 +540,9 @@
             }
         } else {
             for (i=1; i<avctx->frame_size; i++) {
-                put_bits(&pb, 4, adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels*i]) & 0xF);
+                put_bits(&pb, 4, adpcm_ima_compress_sample(&c->status[0], samples[avctx->channels*i]));
                 if (avctx->channels == 2)
-                    put_bits(&pb, 4, adpcm_ima_compress_sample(&c->status[1], samples[2*i+1]) & 0xF);
+                    put_bits(&pb, 4, adpcm_ima_compress_sample(&c->status[1], samples[2*i+1]));
             }
         }
         flush_put_bits(&pb);
@@ -636,16 +632,19 @@
 static int adpcm_decode_init(AVCodecContext * avctx)
 {
     ADPCMContext *c = avctx->priv_data;
+    unsigned int max_channels = 2;
 
-    if(avctx->channels > 2U){
+    switch(avctx->codec->id) {
+    case CODEC_ID_ADPCM_EA_R1:
+    case CODEC_ID_ADPCM_EA_R2:
+    case CODEC_ID_ADPCM_EA_R3:
+        max_channels = 6;
+        break;
+    }
+    if(avctx->channels > max_channels){
         return -1;
     }
 
-    c->channel = 0;
-    c->status[0].predictor = c->status[1].predictor = 0;
-    c->status[0].step_index = c->status[1].step_index = 0;
-    c->status[0].step = c->status[1].step = 0;
-
     switch(avctx->codec->id) {
     case CODEC_ID_ADPCM_CT:
         c->status[0].step = c->status[1].step = 511;
@@ -842,7 +841,7 @@
 
 static int adpcm_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     ADPCMContext *c = avctx->priv_data;
     ADPCMChannelStatus *cs;
@@ -850,7 +849,7 @@
     int block_predictor[2];
     short *samples;
     short *samples_end;
-    uint8_t *src;
+    const uint8_t *src;
     int st; /* stereo */
 
     /* DK3 ADPCM accounting variables */
@@ -937,11 +936,9 @@
 
         for(i=0; i<avctx->channels; i++){
             cs = &(c->status[i]);
-            cs->predictor = (int16_t)(src[0] + (src[1]<<8));
+            cs->predictor = *samples++ = (int16_t)(src[0] + (src[1]<<8));
             src+=2;
 
-        // XXX: is this correct ??: *samples++ = cs->predictor;
-
             cs->step_index = *src++;
             if (cs->step_index > 88){
                 av_log(avctx, AV_LOG_ERROR, "ERROR: step_index = %i\n", cs->step_index);
@@ -1124,8 +1121,6 @@
         }
         break;
     case CODEC_ID_ADPCM_XA:
-        c->status[0].sample1 = c->status[0].sample2 =
-        c->status[1].sample1 = c->status[1].sample2 = 0;
         while (buf_size >= 128) {
             xa_decode(samples, src, &c->status[0], &c->status[1],
                 avctx->channels);
@@ -1134,6 +1129,30 @@
             buf_size -= 128;
         }
         break;
+    case CODEC_ID_ADPCM_IMA_EA_EACS:
+        samples_in_chunk = bytestream_get_le32(&src) >> (1-st);
+
+        if (samples_in_chunk > buf_size-4-(8<<st)) {
+            src += buf_size - 4;
+            break;
+        }
+
+        for (i=0; i<=st; i++)
+            c->status[i].step_index = bytestream_get_le32(&src);
+        for (i=0; i<=st; i++)
+            c->status[i].predictor  = bytestream_get_le32(&src);
+
+        for (; samples_in_chunk; samples_in_chunk--, src++) {
+            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  *src>>4,   3);
+            *samples++ = adpcm_ima_expand_nibble(&c->status[st], *src&0x0F, 3);
+        }
+        break;
+    case CODEC_ID_ADPCM_IMA_EA_SEAD:
+        for (; src < buf+buf_size; src++) {
+            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[0] >> 4, 6);
+            *samples++ = adpcm_ima_expand_nibble(&c->status[st],src[0]&0x0F, 6);
+        }
+        break;
     case CODEC_ID_ADPCM_EA:
         samples_in_chunk = AV_RL32(src);
         if (samples_in_chunk >= ((buf_size - 12) * 2)) {
@@ -1182,6 +1201,117 @@
             }
         }
         break;
+    case CODEC_ID_ADPCM_EA_R1:
+    case CODEC_ID_ADPCM_EA_R2:
+    case CODEC_ID_ADPCM_EA_R3: {
+        /* channel numbering
+           2chan: 0=fl, 1=fr
+           4chan: 0=fl, 1=rl, 2=fr, 3=rr
+           6chan: 0=fl, 1=c,  2=fr, 3=rl,  4=rr, 5=sub */
+        const int big_endian = avctx->codec->id == CODEC_ID_ADPCM_EA_R3;
+        int32_t previous_sample, current_sample, next_sample;
+        int32_t coeff1, coeff2;
+        uint8_t shift;
+        unsigned int channel;
+        uint16_t *samplesC;
+        const uint8_t *srcC;
+
+        samples_in_chunk = (big_endian ? bytestream_get_be32(&src)
+                                       : bytestream_get_le32(&src)) / 28;
+        if (samples_in_chunk > UINT32_MAX/(28*avctx->channels) ||
+            28*samples_in_chunk*avctx->channels > samples_end-samples) {
+            src += buf_size - 4;
+            break;
+        }
+
+        for (channel=0; channel<avctx->channels; channel++) {
+            srcC = src + (big_endian ? bytestream_get_be32(&src)
+                                     : bytestream_get_le32(&src))
+                       + (avctx->channels-channel-1) * 4;
+            samplesC = samples + channel;
+
+            if (avctx->codec->id == CODEC_ID_ADPCM_EA_R1) {
+                current_sample  = (int16_t)bytestream_get_le16(&srcC);
+                previous_sample = (int16_t)bytestream_get_le16(&srcC);
+            } else {
+                current_sample  = c->status[channel].predictor;
+                previous_sample = c->status[channel].prev_sample;
+            }
+
+            for (count1=0; count1<samples_in_chunk; count1++) {
+                if (*srcC == 0xEE) {  /* only seen in R2 and R3 */
+                    srcC++;
+                    current_sample  = (int16_t)bytestream_get_be16(&srcC);
+                    previous_sample = (int16_t)bytestream_get_be16(&srcC);
+
+                    for (count2=0; count2<28; count2++) {
+                        *samplesC = (int16_t)bytestream_get_be16(&srcC);
+                        samplesC += avctx->channels;
+                    }
+                } else {
+                    coeff1 = ea_adpcm_table[ (*srcC>>4) & 0x0F     ];
+                    coeff2 = ea_adpcm_table[((*srcC>>4) & 0x0F) + 4];
+                    shift = (*srcC++ & 0x0F) + 8;
+
+                    for (count2=0; count2<28; count2++) {
+                        if (count2 & 1)
+                            next_sample = ((*srcC++ & 0x0F) << 28) >> shift;
+                        else
+                            next_sample = ((*srcC   & 0xF0) << 24) >> shift;
+
+                        next_sample += (current_sample  * coeff1) +
+                                       (previous_sample * coeff2);
+                        next_sample = av_clip_int16(next_sample >> 8);
+
+                        previous_sample = current_sample;
+                        current_sample  = next_sample;
+                        *samplesC = current_sample;
+                        samplesC += avctx->channels;
+                    }
+                }
+            }
+
+            if (avctx->codec->id != CODEC_ID_ADPCM_EA_R1) {
+                c->status[channel].predictor   = current_sample;
+                c->status[channel].prev_sample = previous_sample;
+            }
+        }
+
+        src = src + buf_size - (4 + 4*avctx->channels);
+        samples += 28 * samples_in_chunk * avctx->channels;
+        break;
+    }
+    case CODEC_ID_ADPCM_EA_XAS:
+        if (samples_end-samples < 32*4*avctx->channels
+            || buf_size < (4+15)*4*avctx->channels) {
+            src += buf_size;
+            break;
+        }
+        for (channel=0; channel<avctx->channels; channel++) {
+            int coeff[2][4], shift[4];
+            short *s2, *s = &samples[channel];
+            for (n=0; n<4; n++, s+=32*avctx->channels) {
+                for (i=0; i<2; i++)
+                    coeff[i][n] = ea_adpcm_table[(src[0]&0x0F)+4*i];
+                shift[n] = (src[2]&0x0F) + 8;
+                for (s2=s, i=0; i<2; i++, src+=2, s2+=avctx->channels)
+                    s2[0] = (src[0]&0xF0) + (src[1]<<8);
+            }
+
+            for (m=2; m<32; m+=2) {
+                s = &samples[m*avctx->channels + channel];
+                for (n=0; n<4; n++, src++, s+=32*avctx->channels) {
+                    for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) {
+                        int level = ((*src & (0xF0>>i)) << (24+i)) >> shift[n];
+                        int pred  = s2[-1*avctx->channels] * coeff[0][n]
+                                  + s2[-2*avctx->channels] * coeff[1][n];
+                        s2[0] = av_clip_int16((level + pred + 0x80) >> 8);
+                    }
+                }
+            }
+        }
+        samples += 32*4*avctx->channels;
+        break;
     case CODEC_ID_ADPCM_IMA_AMV:
     case CODEC_ID_ADPCM_IMA_SMJPEG:
         c->status[0].predictor = (int16_t)bytestream_get_le16(&src);
@@ -1446,23 +1576,27 @@
 #define ADPCM_CODEC(id, name)                   \
 ADPCM_ENCODER(id,name) ADPCM_DECODER(id,name)
 
-ADPCM_CODEC(CODEC_ID_ADPCM_4XM, adpcm_4xm);
-ADPCM_CODEC(CODEC_ID_ADPCM_CT, adpcm_ct);
-ADPCM_CODEC(CODEC_ID_ADPCM_EA, adpcm_ea);
-ADPCM_CODEC(CODEC_ID_ADPCM_IMA_AMV, adpcm_ima_amv);
-ADPCM_CODEC(CODEC_ID_ADPCM_IMA_DK3, adpcm_ima_dk3);
-ADPCM_CODEC(CODEC_ID_ADPCM_IMA_DK4, adpcm_ima_dk4);
-ADPCM_CODEC(CODEC_ID_ADPCM_IMA_QT, adpcm_ima_qt);
-ADPCM_CODEC(CODEC_ID_ADPCM_IMA_SMJPEG, adpcm_ima_smjpeg);
-ADPCM_CODEC(CODEC_ID_ADPCM_IMA_WAV, adpcm_ima_wav);
-ADPCM_CODEC(CODEC_ID_ADPCM_IMA_WS, adpcm_ima_ws);
-ADPCM_CODEC(CODEC_ID_ADPCM_MS, adpcm_ms);
-ADPCM_CODEC(CODEC_ID_ADPCM_SBPRO_4, adpcm_sbpro_4);
-ADPCM_CODEC(CODEC_ID_ADPCM_SBPRO_3, adpcm_sbpro_3);
-ADPCM_CODEC(CODEC_ID_ADPCM_SBPRO_2, adpcm_sbpro_2);
-ADPCM_CODEC(CODEC_ID_ADPCM_SWF, adpcm_swf);
-ADPCM_CODEC(CODEC_ID_ADPCM_THP, adpcm_thp);
-ADPCM_CODEC(CODEC_ID_ADPCM_XA, adpcm_xa);
-ADPCM_CODEC(CODEC_ID_ADPCM_YAMAHA, adpcm_yamaha);
-
-#undef ADPCM_CODEC
+ADPCM_DECODER(CODEC_ID_ADPCM_4XM, adpcm_4xm);
+ADPCM_DECODER(CODEC_ID_ADPCM_CT, adpcm_ct);
+ADPCM_DECODER(CODEC_ID_ADPCM_EA, adpcm_ea);
+ADPCM_DECODER(CODEC_ID_ADPCM_EA_R1, adpcm_ea_r1);
+ADPCM_DECODER(CODEC_ID_ADPCM_EA_R2, adpcm_ea_r2);
+ADPCM_DECODER(CODEC_ID_ADPCM_EA_R3, adpcm_ea_r3);
+ADPCM_DECODER(CODEC_ID_ADPCM_EA_XAS, adpcm_ea_xas);
+ADPCM_DECODER(CODEC_ID_ADPCM_IMA_AMV, adpcm_ima_amv);
+ADPCM_DECODER(CODEC_ID_ADPCM_IMA_DK3, adpcm_ima_dk3);
+ADPCM_DECODER(CODEC_ID_ADPCM_IMA_DK4, adpcm_ima_dk4);
+ADPCM_DECODER(CODEC_ID_ADPCM_IMA_EA_EACS, adpcm_ima_ea_eacs);
+ADPCM_DECODER(CODEC_ID_ADPCM_IMA_EA_SEAD, adpcm_ima_ea_sead);
+ADPCM_DECODER(CODEC_ID_ADPCM_IMA_QT, adpcm_ima_qt);
+ADPCM_DECODER(CODEC_ID_ADPCM_IMA_SMJPEG, adpcm_ima_smjpeg);
+ADPCM_CODEC  (CODEC_ID_ADPCM_IMA_WAV, adpcm_ima_wav);
+ADPCM_DECODER(CODEC_ID_ADPCM_IMA_WS, adpcm_ima_ws);
+ADPCM_CODEC  (CODEC_ID_ADPCM_MS, adpcm_ms);
+ADPCM_DECODER(CODEC_ID_ADPCM_SBPRO_4, adpcm_sbpro_4);
+ADPCM_DECODER(CODEC_ID_ADPCM_SBPRO_3, adpcm_sbpro_3);
+ADPCM_DECODER(CODEC_ID_ADPCM_SBPRO_2, adpcm_sbpro_2);
+ADPCM_CODEC  (CODEC_ID_ADPCM_SWF, adpcm_swf);
+ADPCM_DECODER(CODEC_ID_ADPCM_THP, adpcm_thp);
+ADPCM_DECODER(CODEC_ID_ADPCM_XA, adpcm_xa);
+ADPCM_CODEC  (CODEC_ID_ADPCM_YAMAHA, adpcm_yamaha);
Only in mplayer-1.0~rc2-12/libavcodec: adx.c
Only in ffmpeg-free-0.svn20080206/libavcodec: adxdec.c
Only in ffmpeg-free-0.svn20080206/libavcodec: adxenc.c
Only in ffmpeg-free-0.svn20080206/libavcodec: adx.h
diff -u mplayer-1.0~rc2-12/libavcodec/alac.c ffmpeg-free-0.svn20080206/libavcodec/alac.c
--- mplayer-1.0~rc2-12/libavcodec/alac.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/alac.c	2008-03-20 19:10:57.000000000 +0100
@@ -107,7 +107,7 @@
 
 static int alac_set_info(ALACContext *alac)
 {
-    unsigned char *ptr = alac->avctx->extradata;
+    const unsigned char *ptr = alac->avctx->extradata;
 
     ptr += 4; /* size */
     ptr += 4; /* alac */
@@ -325,15 +325,15 @@
 
 #if 0
     /* 4 and 8 are very common cases (the only ones i've seen). these
-     * should be unrolled and optimised
+     * should be unrolled and optimized
      */
     if (predictor_coef_num == 4) {
-        /* FIXME: optimised general case */
+        /* FIXME: optimized general case */
         return;
     }
 
     if (predictor_coef_table == 8) {
-        /* FIXME: optimised general case */
+        /* FIXME: optimized general case */
         return;
     }
 #endif
@@ -439,7 +439,7 @@
 
 static int alac_decode_frame(AVCodecContext *avctx,
                              void *outbuffer, int *outputsize,
-                             uint8_t *inbuffer, int input_buffer_size)
+                             const uint8_t *inbuffer, int input_buffer_size)
 {
     ALACContext *alac = avctx->priv_data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/allcodecs.c ffmpeg-free-0.svn20080206/libavcodec/allcodecs.c
--- mplayer-1.0~rc2-12/libavcodec/allcodecs.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/allcodecs.c	2008-03-20 19:10:57.000000000 +0100
@@ -53,9 +53,9 @@
  */
 void avcodec_register_all(void)
 {
-    static int inited = 0;
+    static int inited;
 
-    if (inited != 0)
+    if (inited)
         return;
     inited = 1;
 
@@ -73,7 +73,7 @@
     REGISTER_DECODER (CLJR, cljr);
     REGISTER_DECODER (CSCD, cscd);
     REGISTER_DECODER (CYUV, cyuv);
-    REGISTER_DECODER (DNXHD, dnxhd);
+    REGISTER_ENCDEC  (DNXHD, dnxhd);
     REGISTER_DECODER (DSICINVIDEO, dsicinvideo);
     REGISTER_ENCDEC  (DVVIDEO, dvvideo);
     REGISTER_DECODER (DXA, dxa);
@@ -86,10 +86,9 @@
     REGISTER_DECODER (FOURXM, fourxm);
     REGISTER_DECODER (FRAPS, fraps);
     REGISTER_ENCDEC  (GIF, gif);
-    REGISTER_ENCDEC  (H261, h261);
-    REGISTER_ENCDEC  (H263, h263);
+    REGISTER_DECODER  (H261, h261);
+    REGISTER_DECODER  (H263, h263);
     REGISTER_DECODER (H263I, h263i);
-    REGISTER_ENCODER (H263P, h263p);
     REGISTER_DECODER (H264, h264);
     REGISTER_ENCDEC  (HUFFYUV, huffyuv);
     REGISTER_DECODER (IDCIN, idcin);
@@ -98,8 +97,6 @@
     REGISTER_DECODER (INTERPLAY_VIDEO, interplay_video);
     REGISTER_ENCDEC  (JPEGLS, jpegls);
     REGISTER_DECODER (KMVC, kmvc);
-    REGISTER_ENCODER (LIBX264, libx264);
-    REGISTER_ENCODER (LIBXVID, libxvid);
     REGISTER_ENCODER (LJPEG, ljpeg);
     REGISTER_DECODER (LOCO, loco);
     REGISTER_DECODER (MDEC, mdec);
@@ -108,18 +105,19 @@
     REGISTER_DECODER (MMVIDEO, mmvideo);
     REGISTER_DECODER (MPEG_XVMC, mpeg_xvmc);
     REGISTER_ENCDEC  (MPEG1VIDEO, mpeg1video);
-    REGISTER_ENCDEC  (MPEG2VIDEO, mpeg2video);
-    REGISTER_ENCDEC  (MPEG4, mpeg4);
+    REGISTER_DECODER  (MPEG2VIDEO, mpeg2video);
+    REGISTER_DECODER  (MPEG4, mpeg4);
     REGISTER_DECODER (MPEGVIDEO, mpegvideo);
-    REGISTER_ENCDEC  (MSMPEG4V1, msmpeg4v1);
-    REGISTER_ENCDEC  (MSMPEG4V2, msmpeg4v2);
-    REGISTER_ENCDEC  (MSMPEG4V3, msmpeg4v3);
+    REGISTER_DECODER  (MSMPEG4V1, msmpeg4v1);
+    REGISTER_DECODER  (MSMPEG4V2, msmpeg4v2);
+    REGISTER_DECODER  (MSMPEG4V3, msmpeg4v3);
     REGISTER_DECODER (MSRLE, msrle);
     REGISTER_DECODER (MSVIDEO1, msvideo1);
     REGISTER_DECODER (MSZH, mszh);
     REGISTER_DECODER (NUV, nuv);
     REGISTER_ENCODER (PAM, pam);
     REGISTER_ENCODER (PBM, pbm);
+    REGISTER_DECODER (PCX, pcx);
     REGISTER_ENCODER (PGM, pgm);
     REGISTER_ENCODER (PGMYUV, pgmyuv);
     REGISTER_ENCDEC  (PNG, png);
@@ -138,6 +136,7 @@
     REGISTER_DECODER (SMC, smc);
     REGISTER_ENCDEC  (SNOW, snow);
     REGISTER_DECODER (SP5X, sp5x);
+    REGISTER_DECODER (SUNRAST, sunrast);
     REGISTER_ENCDEC  (SVQ1, svq1);
     REGISTER_DECODER (SVQ3, svq3);
     REGISTER_ENCDEC  (TARGA, targa);
@@ -150,6 +149,7 @@
     REGISTER_DECODER (TSCC, tscc);
     REGISTER_DECODER (TXD, txd);
     REGISTER_DECODER (ULTI, ulti);
+    REGISTER_DECODER (VB, vb);
     REGISTER_DECODER (VC1, vc1);
     REGISTER_DECODER (VCR1, vcr1);
     REGISTER_DECODER (VMDVIDEO, vmdvideo);
@@ -181,17 +181,6 @@
     REGISTER_DECODER (DSICINAUDIO, dsicinaudio);
     REGISTER_ENCDEC  (FLAC, flac);
     REGISTER_DECODER (IMC, imc);
-    REGISTER_ENCDEC  (LIBAMR_NB, libamr_nb);
-    REGISTER_ENCDEC  (LIBAMR_WB, libamr_wb);
-    REGISTER_DECODER (LIBA52, liba52);
-    REGISTER_ENCODER (LIBFAAC, libfaac);
-    REGISTER_DECODER (LIBFAAD, libfaad);
-    REGISTER_ENCDEC  (LIBGSM, libgsm);
-    REGISTER_ENCDEC  (LIBGSM_MS, libgsm_ms);
-    REGISTER_ENCODER (LIBMP3LAME, libmp3lame);
-    REGISTER_ENCODER (LIBTHEORA, libtheora);
-    if (!ENABLE_VORBIS_ENCODER)  REGISTER_ENCODER (LIBVORBIS, libvorbis);
-    if (!ENABLE_VORBIS_DECODER)  REGISTER_DECODER (LIBVORBIS, libvorbis);
     REGISTER_DECODER (MACE3, mace3);
     REGISTER_DECODER (MACE6, mace6);
     REGISTER_ENCDEC  (MP2, mp2);
@@ -199,6 +188,8 @@
     REGISTER_DECODER (MP3ADU, mp3adu);
     REGISTER_DECODER (MP3ON4, mp3on4);
     REGISTER_DECODER (MPC7, mpc7);
+    REGISTER_DECODER (MPC8, mpc8);
+    REGISTER_DECODER (NELLYMOSER, nellymoser);
     REGISTER_DECODER (QDM2, qdm2);
     REGISTER_DECODER (RA_144, ra_144);
     REGISTER_DECODER (RA_288, ra_288);
@@ -221,6 +212,7 @@
     REGISTER_ENCDEC  (PCM_S8, pcm_s8);
     REGISTER_ENCDEC  (PCM_S16BE, pcm_s16be);
     REGISTER_ENCDEC  (PCM_S16LE, pcm_s16le);
+    REGISTER_DECODER (PCM_S16LE_PLANAR, pcm_s16le_planar);
     REGISTER_ENCDEC  (PCM_S24BE, pcm_s24be);
     REGISTER_ENCDEC  (PCM_S24DAUD, pcm_s24daud);
     REGISTER_ENCDEC  (PCM_S24LE, pcm_s24le);
@@ -242,31 +234,51 @@
     REGISTER_DECODER (XAN_DPCM, xan_dpcm);
 
     /* adpcm codecs */
-    REGISTER_ENCDEC  (ADPCM_4XM, adpcm_4xm);
+    REGISTER_DECODER (ADPCM_4XM, adpcm_4xm);
     REGISTER_ENCDEC  (ADPCM_ADX, adpcm_adx);
-    REGISTER_ENCDEC  (ADPCM_CT, adpcm_ct);
-    REGISTER_ENCDEC  (ADPCM_EA, adpcm_ea);
+    REGISTER_DECODER (ADPCM_CT, adpcm_ct);
+    REGISTER_DECODER (ADPCM_EA, adpcm_ea);
+    REGISTER_DECODER (ADPCM_EA_R1, adpcm_ea_r1);
+    REGISTER_DECODER (ADPCM_EA_R2, adpcm_ea_r2);
+    REGISTER_DECODER (ADPCM_EA_R3, adpcm_ea_r3);
+    REGISTER_DECODER (ADPCM_EA_XAS, adpcm_ea_xas);
     REGISTER_ENCDEC  (ADPCM_G726, adpcm_g726);
     REGISTER_DECODER (ADPCM_IMA_AMV, adpcm_ima_amv);
-    REGISTER_ENCDEC  (ADPCM_IMA_DK3, adpcm_ima_dk3);
-    REGISTER_ENCDEC  (ADPCM_IMA_DK4, adpcm_ima_dk4);
-    REGISTER_ENCDEC  (ADPCM_IMA_QT, adpcm_ima_qt);
-    REGISTER_ENCDEC  (ADPCM_IMA_SMJPEG, adpcm_ima_smjpeg);
+    REGISTER_DECODER (ADPCM_IMA_DK3, adpcm_ima_dk3);
+    REGISTER_DECODER (ADPCM_IMA_DK4, adpcm_ima_dk4);
+    REGISTER_DECODER (ADPCM_IMA_EA_EACS, adpcm_ima_ea_eacs);
+    REGISTER_DECODER (ADPCM_IMA_EA_SEAD, adpcm_ima_ea_sead);
+    REGISTER_DECODER (ADPCM_IMA_QT, adpcm_ima_qt);
+    REGISTER_DECODER (ADPCM_IMA_SMJPEG, adpcm_ima_smjpeg);
     REGISTER_ENCDEC  (ADPCM_IMA_WAV, adpcm_ima_wav);
-    REGISTER_ENCDEC  (ADPCM_IMA_WS, adpcm_ima_ws);
+    REGISTER_DECODER (ADPCM_IMA_WS, adpcm_ima_ws);
     REGISTER_ENCDEC  (ADPCM_MS, adpcm_ms);
-    REGISTER_ENCDEC  (ADPCM_SBPRO_2, adpcm_sbpro_2);
-    REGISTER_ENCDEC  (ADPCM_SBPRO_3, adpcm_sbpro_3);
-    REGISTER_ENCDEC  (ADPCM_SBPRO_4, adpcm_sbpro_4);
+    REGISTER_DECODER (ADPCM_SBPRO_2, adpcm_sbpro_2);
+    REGISTER_DECODER (ADPCM_SBPRO_3, adpcm_sbpro_3);
+    REGISTER_DECODER (ADPCM_SBPRO_4, adpcm_sbpro_4);
     REGISTER_ENCDEC  (ADPCM_SWF, adpcm_swf);
     REGISTER_DECODER (ADPCM_THP, adpcm_thp);
-    REGISTER_ENCDEC  (ADPCM_XA, adpcm_xa);
+    REGISTER_DECODER (ADPCM_XA, adpcm_xa);
     REGISTER_ENCDEC  (ADPCM_YAMAHA, adpcm_yamaha);
 
     /* subtitles */
     REGISTER_ENCDEC  (DVBSUB, dvbsub);
     REGISTER_ENCDEC  (DVDSUB, dvdsub);
 
+    /* external libraries */
+    REGISTER_DECODER (LIBA52, liba52);
+    REGISTER_ENCDEC  (LIBAMR_NB, libamr_nb);
+    REGISTER_ENCDEC  (LIBAMR_WB, libamr_wb);
+    REGISTER_ENCODER (LIBFAAC, libfaac);
+    REGISTER_DECODER (LIBFAAD, libfaad);
+    REGISTER_ENCDEC  (LIBGSM, libgsm);
+    REGISTER_ENCDEC  (LIBGSM_MS, libgsm_ms);
+    REGISTER_ENCODER (LIBMP3LAME, libmp3lame);
+    REGISTER_ENCODER (LIBTHEORA, libtheora);
+    REGISTER_ENCODER (LIBVORBIS, libvorbis);
+    REGISTER_ENCODER (LIBX264, libx264);
+    REGISTER_ENCODER (LIBXVID, libxvid);
+
     /* parsers */
     REGISTER_PARSER  (AAC, aac);
     REGISTER_PARSER  (AC3, ac3);
@@ -278,6 +290,7 @@
     REGISTER_PARSER  (H263, h263);
     REGISTER_PARSER  (H264, h264);
     REGISTER_PARSER  (MJPEG, mjpeg);
+    REGISTER_PARSER  (MLP, mlp);
     REGISTER_PARSER  (MPEG4VIDEO, mpeg4video);
     REGISTER_PARSER  (MPEGAUDIO, mpegaudio);
     REGISTER_PARSER  (MPEGVIDEO, mpegvideo);
@@ -291,7 +304,9 @@
     REGISTER_BSF     (MJPEGA_DUMP_HEADER, mjpega_dump_header);
     REGISTER_BSF     (MP3_HEADER_COMPRESS, mp3_header_compress);
     REGISTER_BSF     (MP3_HEADER_DECOMPRESS, mp3_header_decompress);
+    REGISTER_BSF     (MOV2TEXTSUB, mov2textsub);
     REGISTER_BSF     (NOISE, noise);
     REGISTER_BSF     (REMOVE_EXTRADATA, remove_extradata);
+    REGISTER_BSF     (TEXT2MOVSUB, text2movsub);
 }
 
Common subdirectories: mplayer-1.0~rc2-12/libavcodec/alpha and ffmpeg-free-0.svn20080206/libavcodec/alpha
diff -u mplayer-1.0~rc2-12/libavcodec/apedec.c ffmpeg-free-0.svn20080206/libavcodec/apedec.c
--- mplayer-1.0~rc2-12/libavcodec/apedec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/apedec.c	2008-03-20 19:10:57.000000000 +0100
@@ -154,8 +154,8 @@
 
     uint8_t *data;                           ///< current frame data
     uint8_t *data_end;                       ///< frame data end
-    uint8_t *ptr;                            ///< current position in frame data
-    uint8_t *last_ptr;                       ///< position where last 4608-sample block ended
+    const uint8_t *ptr;                      ///< current position in frame data
+    const uint8_t *last_ptr;                 ///< position where last 4608-sample block ended
 } APEContext;
 
 // TODO: dsputilize
@@ -490,7 +490,7 @@
     /* Keep a count of the blocks decoded in this frame */
     ctx->blocksdecoded = 0;
 
-    /* Initialise the rice structs */
+    /* Initialize the rice structs */
     ctx->riceX.k = 10;
     ctx->riceX.ksum = (1 << ctx->riceX.k) * 16;
     ctx->riceY.k = 10;
@@ -514,7 +514,7 @@
     memset(p->historybuffer, 0, PREDICTOR_SIZE * sizeof(int32_t));
     p->buf = p->historybuffer;
 
-    /* Initialise and zero the co-efficients */
+    /* Initialize and zero the coefficients */
     memcpy(p->coeffsA[0], initial_coeffs, sizeof(initial_coeffs));
     memcpy(p->coeffsA[1], initial_coeffs, sizeof(initial_coeffs));
     memset(p->coeffsB, 0, sizeof(p->coeffsB));
@@ -834,7 +834,7 @@
 
 static int ape_decode_frame(AVCodecContext * avctx,
                             void *data, int *data_size,
-                            uint8_t * buf, int buf_size)
+                            const uint8_t * buf, int buf_size)
 {
     APEContext *s = avctx->priv_data;
     int16_t *samples = data;
@@ -856,7 +856,7 @@
 
     if(!s->samples){
         s->data = av_realloc(s->data, (buf_size + 3) & ~3);
-        s->dsp.bswap_buf(s->data, buf, buf_size >> 2);
+        s->dsp.bswap_buf((uint32_t*)s->data, (const uint32_t*)buf, buf_size >> 2);
         s->ptr = s->last_ptr = s->data;
         s->data_end = s->data + buf_size;
 
Common subdirectories: mplayer-1.0~rc2-12/libavcodec/armv4l and ffmpeg-free-0.svn20080206/libavcodec/armv4l
diff -u mplayer-1.0~rc2-12/libavcodec/asv1.c ffmpeg-free-0.svn20080206/libavcodec/asv1.c
--- mplayer-1.0~rc2-12/libavcodec/asv1.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/asv1.c	2008-03-20 19:10:57.000000000 +0100
@@ -387,7 +387,7 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     ASV1Context * const a = avctx->priv_data;
     AVFrame *picture = data;
@@ -408,7 +408,7 @@
     a->bitstream_buffer= av_fast_realloc(a->bitstream_buffer, &a->bitstream_buffer_size, buf_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
     if(avctx->codec_id == CODEC_ID_ASV1)
-        a->dsp.bswap_buf((uint32_t*)a->bitstream_buffer, (uint32_t*)buf, buf_size/4);
+        a->dsp.bswap_buf((uint32_t*)a->bitstream_buffer, (const uint32_t*)buf, buf_size/4);
     else{
         int i;
         for(i=0; i<buf_size; i++)
diff -u mplayer-1.0~rc2-12/libavcodec/atrac3.c ffmpeg-free-0.svn20080206/libavcodec/atrac3.c
--- mplayer-1.0~rc2-12/libavcodec/atrac3.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/atrac3.c	2008-03-20 19:10:57.000000000 +0100
@@ -225,14 +225,14 @@
  * @param out       pointer to 8 bit array of outdata
  */
 
-static int decode_bytes(uint8_t* inbuffer, uint8_t* out, int bytes){
+static int decode_bytes(const uint8_t* inbuffer, uint8_t* out, int bytes){
     int i, off;
     uint32_t c;
-    uint32_t* buf;
+    const uint32_t* buf;
     uint32_t* obuf = (uint32_t*) out;
 
     off = (int)((long)inbuffer & 3);
-    buf = (uint32_t*) (inbuffer - off);
+    buf = (const uint32_t*) (inbuffer - off);
     c = be2me_32((0x537F6103 >> (off*8)) | (0x537F6103 << (32-(off*8))));
     bytes += 3 + off;
     for (i = 0; i < bytes/4; i++)
@@ -868,7 +868,7 @@
 
 static int atrac3_decode_frame(AVCodecContext *avctx,
             void *data, int *data_size,
-            uint8_t *buf, int buf_size) {
+            const uint8_t *buf, int buf_size) {
     ATRAC3Context *q = avctx->priv_data;
     int result = 0, i;
     uint8_t* databuf;
@@ -919,7 +919,7 @@
 static int atrac3_decode_init(AVCodecContext *avctx)
 {
     int i;
-    uint8_t *edata_ptr = avctx->extradata;
+    const uint8_t *edata_ptr = avctx->extradata;
     ATRAC3Context *q = avctx->priv_data;
 
     /* Take data from the AVCodecContext (RM container). */
diff -u mplayer-1.0~rc2-12/libavcodec/atrac3data.h ffmpeg-free-0.svn20080206/libavcodec/atrac3data.h
--- mplayer-1.0~rc2-12/libavcodec/atrac3data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/atrac3data.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * Atrac 3 AKA RealAudio 8 compatible decoder data
  */
 
-#ifndef AVCODEC_ATRAC3DATA_H
-#define AVCODEC_ATRAC3DATA_H
+#ifndef FFMPEG_ATRAC3DATA_H
+#define FFMPEG_ATRAC3DATA_H
 
 #include <stdint.h>
 
@@ -137,4 +137,4 @@
 /* joint stereo related tables */
 static const float matrixCoeffs[8] = {0.0, 2.0, 2.0, 2.0, 0.0, 0.0, 1.0, 1.0};
 
-#endif // AVCODEC_ATRAC3DATA_H
+#endif /* FFMPEG_ATRAC3DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/avcodec.h ffmpeg-free-0.svn20080206/libavcodec/avcodec.h
--- mplayer-1.0~rc2-12/libavcodec/avcodec.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/avcodec.h	2008-06-18 12:09:30.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_H
-#define AVCODEC_H
+#ifndef FFMPEG_AVCODEC_H
+#define FFMPEG_AVCODEC_H
 
 /**
  * @file avcodec.h
@@ -30,11 +30,19 @@
 #include "avutil.h"
 #include <sys/types.h> /* size_t */
 
+#if !defined INT64_C
+#if defined __WORDSIZE && __WORDSIZE == 64
+#define INT64_C(c) c ## L
+#else
+#define INT64_C(c) c ## LL
+#endif
+#endif
+
 #define AV_STRINGIFY(s)         AV_TOSTRING(s)
 #define AV_TOSTRING(s) #s
 
-#define LIBAVCODEC_VERSION_INT  ((51<<16)+(44<<8)+0)
-#define LIBAVCODEC_VERSION      51.44.0
+#define LIBAVCODEC_VERSION_INT  ((51<<16)+(50<<8)+0)
+#define LIBAVCODEC_VERSION      51.50.0
 #define LIBAVCODEC_BUILD        LIBAVCODEC_VERSION_INT
 
 #define LIBAVCODEC_IDENT        "Lavc" AV_STRINGIFY(LIBAVCODEC_VERSION)
@@ -58,7 +66,7 @@
 enum CodecID {
     CODEC_ID_NONE,
     CODEC_ID_MPEG1VIDEO,
-    CODEC_ID_MPEG2VIDEO, /* preferred ID for MPEG-1/2 video decoding */
+    CODEC_ID_MPEG2VIDEO, ///< preferred ID for MPEG-1/2 video decoding
     CODEC_ID_MPEG2VIDEO_XVMC,
     CODEC_ID_H261,
     CODEC_ID_H263,
@@ -168,6 +176,9 @@
     CODEC_ID_TXD,
     CODEC_ID_VP6A,
     CODEC_ID_AMV,
+    CODEC_ID_VB,
+    CODEC_ID_PCX,
+    CODEC_ID_SUNRAST,
 
     /* various PCM "codecs" */
     CODEC_ID_PCM_S16LE= 0x10000,
@@ -188,6 +199,7 @@
     CODEC_ID_PCM_U24BE,
     CODEC_ID_PCM_S24DAUD,
     CODEC_ID_PCM_ZORK,
+    CODEC_ID_PCM_S16LE_PLANAR,
 
     /* various ADPCM codecs */
     CODEC_ID_ADPCM_IMA_QT= 0x11000,
@@ -210,6 +222,12 @@
     CODEC_ID_ADPCM_SBPRO_2,
     CODEC_ID_ADPCM_THP,
     CODEC_ID_ADPCM_IMA_AMV,
+    CODEC_ID_ADPCM_EA_R1,
+    CODEC_ID_ADPCM_EA_R3,
+    CODEC_ID_ADPCM_EA_R2,
+    CODEC_ID_ADPCM_IMA_EA_SEAD,
+    CODEC_ID_ADPCM_IMA_EA_EACS,
+    CODEC_ID_ADPCM_EA_XAS,
 
     /* AMR */
     CODEC_ID_AMR_NB= 0x12000,
@@ -226,7 +244,7 @@
     CODEC_ID_SOL_DPCM,
 
     CODEC_ID_MP2= 0x15000,
-    CODEC_ID_MP3, /* preferred ID for decoding MPEG audio layer 1, 2 or 3 */
+    CODEC_ID_MP3, ///< preferred ID for decoding MPEG audio layer 1, 2 or 3
     CODEC_ID_AAC,
 #if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
     CODEC_ID_MPEG4AAC,
@@ -248,7 +266,7 @@
     CODEC_ID_SHORTEN,
     CODEC_ID_ALAC,
     CODEC_ID_WESTWOOD_SND1,
-    CODEC_ID_GSM, /* as in Berlin toast format */
+    CODEC_ID_GSM, ///< as in Berlin toast format
     CODEC_ID_QDM2,
     CODEC_ID_COOK,
     CODEC_ID_TRUESPEECH,
@@ -264,14 +282,21 @@
     CODEC_ID_ATRAC3,
     CODEC_ID_VOXWARE,
     CODEC_ID_APE,
+    CODEC_ID_NELLYMOSER,
+    CODEC_ID_MUSEPACK8,
 
     /* subtitle codecs */
     CODEC_ID_DVD_SUBTITLE= 0x17000,
     CODEC_ID_DVB_SUBTITLE,
-    CODEC_ID_TEXT,  /* raw UTF-8 text */
+    CODEC_ID_TEXT,  ///< raw UTF-8 text
     CODEC_ID_XSUB,
+    CODEC_ID_SSA,
+    CODEC_ID_MOV_TEXT,
+
+    /* other specific kind of codecs (generaly used for attachments) */
+    CODEC_ID_TTF= 0x18000,
 
-    CODEC_ID_MPEG2TS= 0x20000, /* _FAKE_ codec to indicate a raw MPEG-2 TS
+    CODEC_ID_MPEG2TS= 0x20000, /**< _FAKE_ codec to indicate a raw MPEG-2 TS
                                 * stream (only used by libavformat) */
 };
 
@@ -287,11 +312,14 @@
     CODEC_TYPE_AUDIO,
     CODEC_TYPE_DATA,
     CODEC_TYPE_SUBTITLE,
+    CODEC_TYPE_ATTACHMENT,
     CODEC_TYPE_NB
 };
 
-/* Currently unused, may be used if 24/32 bits samples are ever supported. */
-/* all in native-endian format */
+/**
+ * Currently unused, may be used if 24/32 bits samples are ever supported.
+ * all in native-endian format
+ */
 enum SampleFormat {
     SAMPLE_FMT_NONE = -1,
     SAMPLE_FMT_U8,              ///< unsigned 8 bits
@@ -319,17 +347,19 @@
  */
 #define FF_MIN_BUFFER_SIZE 16384
 
-/* motion estimation type, EPZS by default */
+/**
+ * motion estimation type.
+ */
 enum Motion_Est_ID {
-    ME_ZERO = 1,
+    ME_ZERO = 1,    ///< no search, that is use 0,0 vector whenever one is needed
     ME_FULL,
     ME_LOG,
     ME_PHODS,
-    ME_EPZS,
-    ME_X1,
-    ME_HEX,
-    ME_UMH,
-    ME_ITER,
+    ME_EPZS,        ///< enhanced predictive zonal search
+    ME_X1,          ///< reserved for experiments
+    ME_HEX,         ///< hexagon based search
+    ME_UMH,         ///< uneven multi-hexagon search
+    ME_ITER,        ///< iterative search
 };
 
 enum AVDiscard{
@@ -363,9 +393,11 @@
 #define CODEC_FLAG_GMC    0x0020  ///< Use GMC.
 #define CODEC_FLAG_MV0    0x0040  ///< Always try a MB with MV=<0,0>.
 #define CODEC_FLAG_PART   0x0080  ///< Use data partitioning.
-/* The parent program guarantees that the input for B-frames containing
+/**
+ * The parent program guarantees that the input for B-frames containing
  * streams is not written to for at least s->max_b_frames+1 frames, if
- * this is not set the input will be copied. */
+ * this is not set the input will be copied.
+ */
 #define CODEC_FLAG_INPUT_PRESERVED 0x0100
 #define CODEC_FLAG_PASS1           0x0200   ///< Use internal 2pass ratecontrol in first pass mode.
 #define CODEC_FLAG_PASS2           0x0400   ///< Use internal 2pass ratecontrol in second pass mode.
@@ -729,6 +761,12 @@
 
 /**
  * Audio Video Frame.
+ * New fields can be added to the end of FF_COMMON_FRAME with minor version
+ * bumps.
+ * Removal, reordering and changes to existing fields require a major
+ * version bump. No fields should be added into AVFrame before or after
+ * FF_COMMON_FRAME!
+ * sizeof(AVFrame) must not be used outside libav*.
  */
 typedef struct AVFrame {
     FF_COMMON_FRAME
@@ -737,7 +775,11 @@
 #define DEFAULT_FRAME_RATE_BASE 1001000
 
 /**
- * main external API structure
+ * main external API structure.
+ * New fields can be added to the end with minor version bumps.
+ * Removal, reordering and changes to existing fields require a major
+ * version bump.
+ * sizeof(AVCodecContext) must not be used outside libav*.
  */
 typedef struct AVCodecContext {
     /**
@@ -1258,8 +1300,10 @@
     float dark_masking;
 
 
+#if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
     /* for binary compatibility */
     int unused;
+#endif
 
     /**
      * IDCT algorithm, see FF_IDCT_* below.
@@ -1286,6 +1330,7 @@
 #define FF_IDCT_SIMPLEARMV5TE 16
 #define FF_IDCT_SIMPLEARMV6   17
 #define FF_IDCT_SIMPLEVIS     18
+#define FF_IDCT_WMV2          19
 
     /**
      * slice count
@@ -1320,15 +1365,15 @@
     unsigned dsp_mask;
 #define FF_MM_FORCE    0x80000000 /* Force usage of selected flags (OR) */
     /* lower 16 bits - CPU features */
-#define FF_MM_MMX      0x0001 /* standard MMX */
-#define FF_MM_3DNOW    0x0004 /* AMD 3DNOW */
-#define FF_MM_MMXEXT   0x0002 /* SSE integer functions or AMD MMX ext */
-#define FF_MM_SSE      0x0008 /* SSE functions */
-#define FF_MM_SSE2     0x0010 /* PIV SSE2 functions */
-#define FF_MM_3DNOWEXT 0x0020 /* AMD 3DNowExt */
-#define FF_MM_SSE3     0x0040 /* Prescott SSE3 functions */
-#define FF_MM_SSSE3    0x0080 /* Conroe SSSE3 functions */
-#define FF_MM_IWMMXT   0x0100 /* XScale IWMMXT */
+#define FF_MM_MMX      0x0001 ///< standard MMX
+#define FF_MM_3DNOW    0x0004 ///< AMD 3DNOW
+#define FF_MM_MMXEXT   0x0002 ///< SSE integer functions or AMD MMX ext
+#define FF_MM_SSE      0x0008 ///< SSE functions
+#define FF_MM_SSE2     0x0010 ///< PIV SSE2 functions
+#define FF_MM_3DNOWEXT 0x0020 ///< AMD 3DNowExt
+#define FF_MM_SSE3     0x0040 ///< Prescott SSE3 functions
+#define FF_MM_SSSE3    0x0080 ///< Conroe SSSE3 functions
+#define FF_MM_IWMMXT   0x0100 ///< XScale IWMMXT
 
     /**
      * bits per sample/pixel from the demuxer (needed for huffyuv).
@@ -2028,11 +2073,11 @@
      * - decoding: unused
      */
     int partitions;
-#define X264_PART_I4X4 0x001  /* Analyse i4x4 */
-#define X264_PART_I8X8 0x002  /* Analyse i8x8 (requires 8x8 transform) */
-#define X264_PART_P8X8 0x010  /* Analyse p16x8, p8x16 and p8x8 */
-#define X264_PART_P4X4 0x020  /* Analyse p8x4, p4x8, p4x4 */
-#define X264_PART_B8X8 0x100  /* Analyse b16x8, b8x16 and b8x8 */
+#define X264_PART_I4X4 0x001  /* Analyze i4x4 */
+#define X264_PART_I8X8 0x002  /* Analyze i8x8 (requires 8x8 transform) */
+#define X264_PART_P8X8 0x010  /* Analyze p16x8, p8x16 and p8x8 */
+#define X264_PART_P4X4 0x020  /* Analyze p8x4, p4x8, p4x4 */
+#define X264_PART_B8X8 0x100  /* Analyze b16x8, b8x16 and b8x8 */
 
     /**
      * direct MV prediction mode - 0 (none), 1 (spatial), 2 (temporal)
@@ -2042,7 +2087,7 @@
     int directpred;
 
     /**
-     * Audio cutoff bandwidth (0 means "automatic"), currently used only by FAAC.
+     * Audio cutoff bandwidth (0 means "automatic")
      * - encoding: Set by user.
      * - decoding: unused
      */
@@ -2135,6 +2180,14 @@
      * - decoding: Set by user.
      */
     int request_channels;
+
+    /**
+     * Percentage of dynamic range compression to be applied by the decoder.
+     * The default value is 1.0, corresponding to full compression.
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+    float drc_scale;
 } AVCodecContext;
 
 /**
@@ -2155,7 +2208,7 @@
     int (*encode)(AVCodecContext *, uint8_t *buf, int buf_size, void *data);
     int (*close)(AVCodecContext *);
     int (*decode)(AVCodecContext *, void *outdata, int *outdata_size,
-                  uint8_t *buf, int buf_size);
+                  const uint8_t *buf, int buf_size);
     int capabilities;
     struct AVCodec *next;
     void (*flush)(AVCodecContext *);
@@ -2382,9 +2435,9 @@
  * Print in buf the string corresponding to the pixel format with
  * number pix_fmt, or an header if pix_fmt is negative.
  *
- * @param buf[in] the buffer where to write the string
- * @param buf_size[in] the size of buf
- * @param pix_fmt[in] the number of the pixel format to print the corresponding info string, or
+ * @param[in] buf the buffer where to write the string
+ * @param[in] buf_size the size of buf
+ * @param[in] pix_fmt the number of the pixel format to print the corresponding info string, or
  * a negative value to print the corresponding header.
  * Meaningful values for obtaining a pixel format info vary from 0 to PIX_FMT_NB -1.
  */
@@ -2417,7 +2470,10 @@
 
 /* external high level API */
 
+#if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
 extern AVCodec *first_avcodec;
+#endif
+AVCodec *av_codec_next(AVCodec *c);
 
 /* returns LIBAVCODEC_VERSION_INT constant */
 unsigned avcodec_version(void);
@@ -2435,7 +2491,7 @@
 void register_avcodec(AVCodec *format);
 
 /**
- * Finds an encoder with a matching codec ID.
+ * Finds a registered encoder with a matching codec ID.
  *
  * @param id CodecID of the requested encoder
  * @return An encoder if one was found, NULL otherwise.
@@ -2443,7 +2499,7 @@
 AVCodec *avcodec_find_encoder(enum CodecID id);
 
 /**
- * Finds an encoder with the specified name.
+ * Finds a registered encoder with the specified name.
  *
  * @param name name of the requested encoder
  * @return An encoder if one was found, NULL otherwise.
@@ -2451,7 +2507,7 @@
 AVCodec *avcodec_find_encoder_by_name(const char *name);
 
 /**
- * Finds a decoder with a matching codec ID.
+ * Finds a registered decoder with a matching codec ID.
  *
  * @param id CodecID of the requested decoder
  * @return A decoder if one was found, NULL otherwise.
@@ -2459,7 +2515,7 @@
 AVCodec *avcodec_find_decoder(enum CodecID id);
 
 /**
- * Finds an decoder with the specified name.
+ * Finds a registered decoder with the specified name.
  *
  * @param name name of the requested decoder
  * @return A decoder if one was found, NULL otherwise.
@@ -2563,7 +2619,7 @@
  */
 attribute_deprecated int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                          int *frame_size_ptr,
-                         uint8_t *buf, int buf_size);
+                         const uint8_t *buf, int buf_size);
 
 /**
  * Decodes an audio frame from \p buf into \p samples.
@@ -2603,7 +2659,7 @@
  */
 int avcodec_decode_audio2(AVCodecContext *avctx, int16_t *samples,
                          int *frame_size_ptr,
-                         uint8_t *buf, int buf_size);
+                         const uint8_t *buf, int buf_size);
 
 /**
  * Decodes a video frame from \p buf into \p picture.
@@ -2638,7 +2694,7 @@
  */
 int avcodec_decode_video(AVCodecContext *avctx, AVFrame *picture,
                          int *got_picture_ptr,
-                         uint8_t *buf, int buf_size);
+                         const uint8_t *buf, int buf_size);
 
 /* Decode a subtitle message. Return -1 if error, otherwise return the
  * number of bytes used. If no subtitle could be decompressed,
@@ -2663,8 +2719,10 @@
  * @param[out] buf the output buffer
  * @param[in] buf_size the output buffer size
  * @param[in] samples the input buffer containing the samples
- * @return On error a negative value is returned, on succes zero or the number
- * of bytes used from the input buffer.
+ * The number of samples read from this buffer is frame_size*channels,
+ * both of which are defined in \p avctx.
+ * @return On error a negative value is returned, on success zero or the number
+ * of bytes used to encode the data read from the input buffer.
  */
 int avcodec_encode_audio(AVCodecContext *avctx, uint8_t *buf, int buf_size,
                          const short *samples);
@@ -2771,7 +2829,10 @@
     struct AVCodecParser *next;
 } AVCodecParser;
 
+#if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
 extern AVCodecParser *av_first_parser;
+#endif
+AVCodecParser *av_parser_next(AVCodecParser *c);
 
 void av_register_codec_parser(AVCodecParser *parser);
 AVCodecParserContext *av_parser_init(int codec_id);
@@ -2814,6 +2875,7 @@
                                const uint8_t *buf, int buf_size, int keyframe);
 void av_bitstream_filter_close(AVBitStreamFilterContext *bsf);
 
+AVBitStreamFilter *av_bitstream_filter_next(AVBitStreamFilter *f);
 
 /* memory */
 
@@ -2932,4 +2994,4 @@
 #define AVERROR_NOENT       AVERROR(ENOENT)  /**< No such file or directory. */
 #define AVERROR_PATCHWELCOME    -MKTAG('P','A','W','E') /**< Not yet implemented in FFmpeg. Patches welcome. */
 
-#endif /* AVCODEC_H */
+#endif /* FFMPEG_AVCODEC_H */
diff -u mplayer-1.0~rc2-12/libavcodec/avs.c ffmpeg-free-0.svn20080206/libavcodec/avs.c
--- mplayer-1.0~rc2-12/libavcodec/avs.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/avs.c	2008-03-20 19:10:57.000000000 +0100
@@ -44,12 +44,13 @@
 
 static int
 avs_decode_frame(AVCodecContext * avctx,
-                 void *data, int *data_size, uint8_t * buf, int buf_size)
+                 void *data, int *data_size, const uint8_t * buf, int buf_size)
 {
     avs_context_t *const avs = avctx->priv_data;
     AVFrame *picture = data;
     AVFrame *const p = (AVFrame *) & avs->picture;
-    uint8_t *table, *vect, *out;
+    const uint8_t *table, *vect;
+    uint8_t *out;
     int i, j, x, y, stride, vect_w = 3, vect_h = 3;
     int sub_type;
     avs_block_type_t type;
diff -u mplayer-1.0~rc2-12/libavcodec/bethsoftvideo.c ffmpeg-free-0.svn20080206/libavcodec/bethsoftvideo.c
--- mplayer-1.0~rc2-12/libavcodec/bethsoftvideo.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/bethsoftvideo.c	2008-03-20 19:10:57.000000000 +0100
@@ -46,7 +46,7 @@
     return 0;
 }
 
-static void set_palette(AVFrame * frame, uint8_t * palette_buffer)
+static void set_palette(AVFrame * frame, const uint8_t * palette_buffer)
 {
     uint32_t * palette = (uint32_t *)frame->data[1];
     int a;
@@ -58,7 +58,7 @@
 
 static int bethsoftvid_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
-                              uint8_t *buf, int buf_size)
+                              const uint8_t *buf, int buf_size)
 {
     BethsoftvidContext * vid = avctx->priv_data;
     char block_type;
diff -u mplayer-1.0~rc2-12/libavcodec/bethsoftvideo.h ffmpeg-free-0.svn20080206/libavcodec/bethsoftvideo.h
--- mplayer-1.0~rc2-12/libavcodec/bethsoftvideo.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/bethsoftvideo.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_BETHSOFTVIDEO_H
-#define AVCODEC_BETHSOFTVIDEO_H
+#ifndef FFMPEG_BETHSOFTVIDEO_H
+#define FFMPEG_BETHSOFTVIDEO_H
 
 enum BethsoftVidBlockType
 {
@@ -33,4 +33,4 @@
     EOF_BLOCK           = 0x14,
 };
 
-#endif // AVCODEC_BETHSOFTVIDEO_H
+#endif /* FFMPEG_BETHSOFTVIDEO_H */
Common subdirectories: mplayer-1.0~rc2-12/libavcodec/bfin and ffmpeg-free-0.svn20080206/libavcodec/bfin
diff -u mplayer-1.0~rc2-12/libavcodec/bitstream.c ffmpeg-free-0.svn20080206/libavcodec/bitstream.c
--- mplayer-1.0~rc2-12/libavcodec/bitstream.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/bitstream.c	2008-03-20 19:10:57.000000000 +0100
@@ -50,7 +50,7 @@
 #endif
 }
 
-void ff_put_string(PutBitContext * pbc, char *s, int put_zero)
+void ff_put_string(PutBitContext * pbc, const char *s, int put_zero)
 {
     while(*s){
         put_bits(pbc, 8, *s);
@@ -60,9 +60,9 @@
         put_bits(pbc, 8, 0);
 }
 
-void ff_copy_bits(PutBitContext *pb, uint8_t *src, int length)
+void ff_copy_bits(PutBitContext *pb, const uint8_t *src, int length)
 {
-    const uint16_t *srcw= (uint16_t*)src;
+    const uint16_t *srcw= (const uint16_t*)src;
     int words= length>>4;
     int bits= length&15;
     int i;
diff -u mplayer-1.0~rc2-12/libavcodec/bitstream_filter.c ffmpeg-free-0.svn20080206/libavcodec/bitstream_filter.c
--- mplayer-1.0~rc2-12/libavcodec/bitstream_filter.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/bitstream_filter.c	2008-03-20 19:10:57.000000000 +0100
@@ -22,6 +22,11 @@
 
 AVBitStreamFilter *first_bitstream_filter= NULL;
 
+AVBitStreamFilter *av_bitstream_filter_next(AVBitStreamFilter *f){
+    if(f) return f->next;
+    else  return first_bitstream_filter;
+}
+
 void av_register_bitstream_filter(AVBitStreamFilter *bsf){
     bsf->next = first_bitstream_filter;
     first_bitstream_filter= bsf;
diff -u mplayer-1.0~rc2-12/libavcodec/bitstream.h ffmpeg-free-0.svn20080206/libavcodec/bitstream.h
--- mplayer-1.0~rc2-12/libavcodec/bitstream.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/bitstream.h	2008-02-04 01:49:14.000000000 +0100
@@ -23,8 +23,8 @@
  * bitstream api header.
  */
 
-#ifndef BITSTREAM_H
-#define BITSTREAM_H
+#ifndef FFMPEG_BITSTREAM_H
+#define FFMPEG_BITSTREAM_H
 
 #include <stdint.h>
 #include <stdlib.h>
@@ -137,8 +137,8 @@
 }
 
 void align_put_bits(PutBitContext *s);
-void ff_put_string(PutBitContext * pbc, char *s, int put_zero);
-void ff_copy_bits(PutBitContext *pb, uint8_t *src, int length);
+void ff_put_string(PutBitContext * pbc, const char *s, int put_zero);
+void ff_copy_bits(PutBitContext *pb, const uint8_t *src, int length);
 
 /* bit input */
 /* buffer, buffer_end and size_in_bits must be present and used by every reader */
@@ -950,4 +950,11 @@
         return get_bits1(gb) + 1;
 }
 
-#endif /* BITSTREAM_H */
+static inline int decode210(GetBitContext *gb){
+    if (get_bits1(gb))
+        return 0;
+    else
+        return 2 - get_bits1(gb);
+}
+
+#endif /* FFMPEG_BITSTREAM_H */
diff -u mplayer-1.0~rc2-12/libavcodec/bmp.c ffmpeg-free-0.svn20080206/libavcodec/bmp.c
--- mplayer-1.0~rc2-12/libavcodec/bmp.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/bmp.c	2008-03-20 19:10:57.000000000 +0100
@@ -34,7 +34,7 @@
 
 static int bmp_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     BMPContext *s = avctx->priv_data;
     AVFrame *picture = data;
@@ -48,7 +48,7 @@
     uint32_t rgb[3];
     uint8_t *ptr;
     int dsize;
-    uint8_t *buf0 = buf;
+    const uint8_t *buf0 = buf;
 
     if(buf_size < 14){
         av_log(avctx, AV_LOG_ERROR, "buf size too small (%d)\n", buf_size);
@@ -193,7 +193,7 @@
         break;
     case 16:
         for(i = 0; i < avctx->height; i++){
-            uint16_t *src = (uint16_t *) buf;
+            const uint16_t *src = (const uint16_t *) buf;
             uint16_t *dst = (uint16_t *) ptr;
 
             for(j = 0; j < avctx->width; j++)
@@ -205,7 +205,7 @@
         break;
     case 32:
         for(i = 0; i < avctx->height; i++){
-            uint8_t *src = buf;
+            const uint8_t *src = buf;
             uint8_t *dst = ptr;
 
             for(j = 0; j < avctx->width; j++){
diff -u mplayer-1.0~rc2-12/libavcodec/bmp.h ffmpeg-free-0.svn20080206/libavcodec/bmp.h
--- mplayer-1.0~rc2-12/libavcodec/bmp.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/bmp.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_BMP_H
-#define AVCODEC_BMP_H
+#ifndef FFMPEG_BMP_H
+#define FFMPEG_BMP_H
 
 #include "avcodec.h"
 
@@ -35,4 +35,4 @@
     BMP_BITFIELDS   =3,
 } BiCompression;
 
-#endif // AVCODEC_BMP_H
+#endif /* FFMPEG_BMP_H */
diff -u mplayer-1.0~rc2-12/libavcodec/bytestream.h ffmpeg-free-0.svn20080206/libavcodec/bytestream.h
--- mplayer-1.0~rc2-12/libavcodec/bytestream.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/bytestream.h	2008-02-01 04:26:31.000000000 +0100
@@ -25,7 +25,7 @@
 #include "common.h"
 
 #define DEF_T(type, name, bytes, read, write)                             \
-static av_always_inline type bytestream_get_ ## name(uint8_t **b){\
+static av_always_inline type bytestream_get_ ## name(const uint8_t **b){\
     (*b) += bytes;\
     return read(*b - bytes);\
 }\
@@ -53,7 +53,7 @@
 #undef DEF64
 #undef DEF_T
 
-static av_always_inline unsigned int bytestream_get_buffer(uint8_t **b, uint8_t *dst, unsigned int size)
+static av_always_inline unsigned int bytestream_get_buffer(const uint8_t **b, uint8_t *dst, unsigned int size)
 {
     memcpy(dst, *b, size);
     (*b) += size;
diff -u mplayer-1.0~rc2-12/libavcodec/c93.c ffmpeg-free-0.svn20080206/libavcodec/c93.c
--- mplayer-1.0~rc2-12/libavcodec/c93.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/c93.c	2008-03-20 19:10:57.000000000 +0100
@@ -113,7 +113,7 @@
 }
 
 static int decode_frame(AVCodecContext *avctx, void *data,
-                            int *data_size, uint8_t * buf, int buf_size)
+                            int *data_size, const uint8_t * buf, int buf_size)
 {
     C93DecoderContext * const c93 = avctx->priv_data;
     AVFrame * const newpic = &c93->pictures[c93->currentpic];
@@ -144,7 +144,7 @@
 
     if (*buf++ & C93_HAS_PALETTE) {
         uint32_t *palette = (uint32_t *) newpic->data[1];
-        uint8_t *palbuf = buf + buf_size - 768 - 1;
+        const uint8_t *palbuf = buf + buf_size - 768 - 1;
         for (i = 0; i < 256; i++) {
             palette[i] = bytestream_get_be24(&palbuf);
         }
diff -u mplayer-1.0~rc2-12/libavcodec/cabac.c ffmpeg-free-0.svn20080206/libavcodec/cabac.c
--- mplayer-1.0~rc2-12/libavcodec/cabac.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/cabac.c	2008-03-20 19:10:57.000000000 +0100
@@ -178,13 +178,14 @@
     }
 }
 
-#if 0 //selftest
+#ifdef TEST
 #undef random
 #define SIZE 10240
 
 #include "avcodec.h"
+#include "cabac.h"
 
-int main(){
+int main(void){
     CABACContext c;
     uint8_t b[9*SIZE];
     uint8_t r[9*SIZE];
@@ -192,7 +193,7 @@
     uint8_t state[10]= {0};
 
     ff_init_cabac_encoder(&c, b, SIZE);
-    ff_init_cabac_states(&c, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64);
+    ff_init_cabac_states(&c);
 
     for(i=0; i<SIZE; i++){
         r[i]= random()%7;
@@ -262,4 +263,4 @@
     return 0;
 }
 
-#endif
+#endif /* TEST */
diff -u mplayer-1.0~rc2-12/libavcodec/cabac.h ffmpeg-free-0.svn20080206/libavcodec/cabac.h
--- mplayer-1.0~rc2-12/libavcodec/cabac.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/cabac.h	2008-01-23 11:19:39.000000000 +0100
@@ -24,8 +24,8 @@
  * Context Adaptive Binary Arithmetic Coder.
  */
 
-#ifndef CABAC_H
-#define CABAC_H
+#ifndef FFMPEG_CABAC_H
+#define FFMPEG_CABAC_H
 
 #include "bitstream.h"
 
@@ -90,6 +90,7 @@
     }
 }
 
+#ifdef TEST
 static void put_cabac(CABACContext *c, uint8_t * const state, int bit){
     int RangeLPS= ff_h264_lps_range[2*(c->range&0xC0) + *state];
 
@@ -259,6 +260,7 @@
             put_cabac_bypass(c, sign);
     }
 }
+#endif /* TEST */
 
 static void refill(CABACContext *c){
 #if CABAC_BITS == 16
@@ -270,6 +272,7 @@
     c->bytestream+= CABAC_BITS/8;
 }
 
+#if ! ( defined(ARCH_X86) && defined(HAVE_7REGS) && defined(HAVE_EBX_AVAILABLE) && !defined(BROKEN_RELOCATIONS) )
 static void refill2(CABACContext *c){
     int i, x;
 
@@ -287,6 +290,7 @@
     c->low += x<<i;
     c->bytestream+= CABAC_BITS/8;
 }
+#endif
 
 static inline void renorm_cabac_decoder(CABACContext *c){
     while(c->range < 0x100){
@@ -734,7 +738,7 @@
     return coeff_count;
 }
 
-static int decode_significance_8x8_x86(CABACContext *c, uint8_t *significant_coeff_ctx_base, int *index, uint8_t *sig_off){
+static int decode_significance_8x8_x86(CABACContext *c, uint8_t *significant_coeff_ctx_base, int *index, const uint8_t *sig_off){
     int minusindex= 4-(int)index;
     int coeff_count;
     long last=0;
@@ -805,6 +809,7 @@
     }
 }
 
+#if 0
 /**
  * Get (truncated) unary binarization.
  */
@@ -860,5 +865,6 @@
     }else
         return i;
 }
+#endif /* 0 */
 
-#endif /* CABAC_H */
+#endif /* FFMPEG_CABAC_H */
diff -u mplayer-1.0~rc2-12/libavcodec/cavsdata.h ffmpeg-free-0.svn20080206/libavcodec/cavsdata.h
--- mplayer-1.0~rc2-12/libavcodec/cavsdata.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/cavsdata.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_CAVSDATA_H
-#define AVCODEC_CAVSDATA_H
+#ifndef FFMPEG_CAVSDATA_H
+#define FFMPEG_CAVSDATA_H
 
 #include "cavs.h"
 
@@ -502,4 +502,4 @@
 const int_fast8_t ff_left_modifier_c[7] = { 5,-1, 2,-1, 6, 5, 6};
 const int_fast8_t ff_top_modifier_c[7]  = { 4, 1,-1,-1, 4, 6, 6};
 
-#endif // AVCODEC_CAVSDATA_H
+#endif /* FFMPEG_CAVSDATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/cavsdec.c ffmpeg-free-0.svn20080206/libavcodec/cavsdec.c
--- mplayer-1.0~rc2-12/libavcodec/cavsdec.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/cavsdec.c	2008-03-20 19:10:57.000000000 +0100
@@ -614,7 +614,7 @@
 }
 
 static int cavs_decode_frame(AVCodecContext * avctx,void *data, int *data_size,
-                             uint8_t * buf, int buf_size) {
+                             const uint8_t * buf, int buf_size) {
     AVSContext *h = avctx->priv_data;
     MpegEncContext *s = &h->s;
     int input_size;
diff -u mplayer-1.0~rc2-12/libavcodec/cavs.h ffmpeg-free-0.svn20080206/libavcodec/cavs.h
--- mplayer-1.0~rc2-12/libavcodec/cavs.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/cavs.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef CAVS_H
-#define CAVS_H
+#ifndef FFMPEG_CAVS_H
+#define FFMPEG_CAVS_H
 
 #include "dsputil.h"
 #include "mpegvideo.h"
@@ -311,4 +311,4 @@
 int ff_cavs_init(AVCodecContext *avctx);
 int ff_cavs_end (AVCodecContext *avctx);
 
-#endif /* CAVS_H */
+#endif /* FFMPEG_CAVS_H */
diff -u mplayer-1.0~rc2-12/libavcodec/cinepak.c ffmpeg-free-0.svn20080206/libavcodec/cinepak.c
--- mplayer-1.0~rc2-12/libavcodec/cinepak.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/cinepak.c	2008-03-20 19:10:57.000000000 +0100
@@ -59,7 +59,7 @@
     DSPContext dsp;
     AVFrame frame;
 
-    unsigned char *data;
+    const unsigned char *data;
     int size;
 
     int width, height;
@@ -72,9 +72,9 @@
 } CinepakContext;
 
 static void cinepak_decode_codebook (cvid_codebook_t *codebook,
-                                     int chunk_id, int size, uint8_t *data)
+                                     int chunk_id, int size, const uint8_t *data)
 {
-    uint8_t *eod = (data + size);
+    const uint8_t *eod = (data + size);
     uint32_t flag, mask;
     int      i, n;
 
@@ -121,9 +121,9 @@
 }
 
 static int cinepak_decode_vectors (CinepakContext *s, cvid_strip_t *strip,
-                                   int chunk_id, int size, uint8_t *data)
+                                   int chunk_id, int size, const uint8_t *data)
 {
-    uint8_t         *eod = (data + size);
+    const uint8_t   *eod = (data + size);
     uint32_t         flag, mask;
     cvid_codebook_t *codebook;
     unsigned int     x, y;
@@ -264,9 +264,9 @@
 }
 
 static int cinepak_decode_strip (CinepakContext *s,
-                                 cvid_strip_t *strip, uint8_t *data, int size)
+                                 cvid_strip_t *strip, const uint8_t *data, int size)
 {
-    uint8_t *eod = (data + size);
+    const uint8_t *eod = (data + size);
     int      chunk_id, chunk_size;
 
     /* coordinate sanity checks */
@@ -317,7 +317,7 @@
 
 static int cinepak_decode (CinepakContext *s)
 {
-    uint8_t      *eod = (s->data + s->size);
+    const uint8_t  *eod = (s->data + s->size);
     int           i, result, strip_size, frame_flags, num_strips;
     int           y0 = 0;
     int           encoded_buf_size;
@@ -414,7 +414,7 @@
 
 static int cinepak_decode_frame(AVCodecContext *avctx,
                                 void *data, int *data_size,
-                                uint8_t *buf, int buf_size)
+                                const uint8_t *buf, int buf_size)
 {
     CinepakContext *s = avctx->priv_data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/cljr.c ffmpeg-free-0.svn20080206/libavcodec/cljr.c
--- mplayer-1.0~rc2-12/libavcodec/cljr.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/cljr.c	2008-03-20 19:10:57.000000000 +0100
@@ -37,7 +37,7 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     CLJRContext * const a = avctx->priv_data;
     AVFrame *picture = data;
diff -u mplayer-1.0~rc2-12/libavcodec/colorspace.h ffmpeg-free-0.svn20080206/libavcodec/colorspace.h
--- mplayer-1.0~rc2-12/libavcodec/colorspace.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/colorspace.h	2007-10-17 11:31:06.000000000 +0200
@@ -24,6 +24,9 @@
  * Various defines for YUV<->RGB conversion
  */
 
+#ifndef FFMPEG_COLORSPACE_H
+#define FFMPEG_COLORSPACE_H
+
 #define SCALEBITS 10
 #define ONE_HALF  (1 << (SCALEBITS - 1))
 #define FIX(x)    ((int) ((x) * (1<<SCALEBITS) + 0.5))
@@ -105,3 +108,4 @@
 (((FIX(0.50000*224.0/255.0) * r1 - FIX(0.41869*224.0/255.0) * g1 -           \
    FIX(0.08131*224.0/255.0) * b1 + (ONE_HALF << shift) - 1) >> (SCALEBITS + shift)) + 128)
 
+#endif /* FFMPEG_COLORSPACE_H */
diff -u mplayer-1.0~rc2-12/libavcodec/cook.c ffmpeg-free-0.svn20080206/libavcodec/cook.c
--- mplayer-1.0~rc2-12/libavcodec/cook.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/cook.c	2008-03-20 19:10:57.000000000 +0100
@@ -145,7 +145,7 @@
     float               decode_buffer_2[1024];
     float               decode_buffer_0[1060]; /* static allocation for joint decode */
 
-    float               *cplscales[5];
+    const float         *cplscales[5];
 } COOKContext;
 
 /* debug functions */
@@ -264,7 +264,7 @@
     return 0;
 }
 
-static float *maybe_reformat_buffer32 (COOKContext *q, float *ptr, int n)
+static const float *maybe_reformat_buffer32 (COOKContext *q, const float *ptr, int n)
 {
     if (1)
         return ptr;
@@ -301,10 +301,10 @@
 #define DECODE_BYTES_PAD1(bytes) (3 - ((bytes)+3) % 4)
 #define DECODE_BYTES_PAD2(bytes) ((bytes) % 4 + DECODE_BYTES_PAD1(2 * (bytes)))
 
-static inline int decode_bytes(uint8_t* inbuffer, uint8_t* out, int bytes){
+static inline int decode_bytes(const uint8_t* inbuffer, uint8_t* out, int bytes){
     int i, off;
     uint32_t c;
-    uint32_t* buf;
+    const uint32_t* buf;
     uint32_t* obuf = (uint32_t*) out;
     /* FIXME: 64 bit platforms would be able to do 64 bits at a time.
      * I'm too lazy though, should be something like
@@ -313,7 +313,7 @@
      * Buffer alignment needs to be checked. */
 
     off = (int)((long)inbuffer & 3);
-    buf = (uint32_t*) (inbuffer - off);
+    buf = (const uint32_t*) (inbuffer - off);
     c = be2me_32((0x37c511f2 >> (off*8)) | (0x37c511f2 << (32-(off*8))));
     bytes += 3 + off;
     for (i = 0; i < bytes/4; i++)
@@ -832,7 +832,7 @@
     float *decode_buffer = q->decode_buffer_0;
     int idx, cpl_tmp;
     float f1,f2;
-    float* cplscale;
+    const float* cplscale;
 
     memset(decouple_tab, 0, sizeof(decouple_tab));
     memset(decode_buffer, 0, sizeof(decode_buffer));
@@ -875,7 +875,7 @@
  */
 
 static inline void
-decode_bytes_and_gain(COOKContext *q, uint8_t *inbuffer,
+decode_bytes_and_gain(COOKContext *q, const uint8_t *inbuffer,
                       cook_gains *gains_ptr)
 {
     int offset;
@@ -944,7 +944,7 @@
  */
 
 
-static int decode_subpacket(COOKContext *q, uint8_t *inbuffer,
+static int decode_subpacket(COOKContext *q, const uint8_t *inbuffer,
                             int sub_packet_size, int16_t *outbuffer) {
     /* packet dump */
 //    for (i=0 ; i<sub_packet_size ; i++) {
@@ -989,7 +989,7 @@
 
 static int cook_decode_frame(AVCodecContext *avctx,
             void *data, int *data_size,
-            uint8_t *buf, int buf_size) {
+            const uint8_t *buf, int buf_size) {
     COOKContext *q = avctx->priv_data;
 
     if (buf_size < avctx->block_align)
@@ -1038,7 +1038,7 @@
 static int cook_decode_init(AVCodecContext *avctx)
 {
     COOKContext *q = avctx->priv_data;
-    uint8_t *edata_ptr = avctx->extradata;
+    const uint8_t *edata_ptr = avctx->extradata;
 
     /* Take care of the codec specific extradata. */
     if (avctx->extradata_size <= 0) {
diff -u mplayer-1.0~rc2-12/libavcodec/cookdata.h ffmpeg-free-0.svn20080206/libavcodec/cookdata.h
--- mplayer-1.0~rc2-12/libavcodec/cookdata.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/cookdata.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * Cook AKA RealAudio G2 compatible decoderdata
  */
 
-#ifndef AVCODEC_COOKDATA_H
-#define AVCODEC_COOKDATA_H
+#ifndef FFMPEG_COOKDATA_H
+#define FFMPEG_COOKDATA_H
 
 #include <stdint.h>
 
@@ -562,4 +562,4 @@
     cplscale2, cplscale3, cplscale4, cplscale5, cplscale6,
 };
 
-#endif // AVCODEC_COOKDATA_H
+#endif /* FFMPEG_COOKDATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/cscd.c ffmpeg-free-0.svn20080206/libavcodec/cscd.c
--- mplayer-1.0~rc2-12/libavcodec/cscd.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/cscd.c	2008-03-20 19:10:57.000000000 +0100
@@ -35,7 +35,7 @@
     unsigned char* decomp_buf;
 } CamStudioContext;
 
-static void copy_frame_default(AVFrame *f, uint8_t *src,
+static void copy_frame_default(AVFrame *f, const uint8_t *src,
                                int linelen, int height) {
     int i;
     uint8_t *dst = f->data[0];
@@ -47,7 +47,7 @@
     }
 }
 
-static void add_frame_default(AVFrame *f, uint8_t *src,
+static void add_frame_default(AVFrame *f, const uint8_t *src,
                               int linelen, int height) {
     int i, j;
     uint8_t *dst = f->data[0];
@@ -65,7 +65,7 @@
 #define add_frame_16 add_frame_default
 #define add_frame_32 add_frame_default
 #else
-static void copy_frame_16(AVFrame *f, uint8_t *src,
+static void copy_frame_16(AVFrame *f, const uint8_t *src,
                           int linelen, int height) {
     int i, j;
     uint8_t *dst = f->data[0];
@@ -81,7 +81,7 @@
     }
 }
 
-static void copy_frame_32(AVFrame *f, uint8_t *src,
+static void copy_frame_32(AVFrame *f, const uint8_t *src,
                           int linelen, int height) {
     int i, j;
     uint8_t *dst = f->data[0];
@@ -99,7 +99,7 @@
     }
 }
 
-static void add_frame_16(AVFrame *f, uint8_t *src,
+static void add_frame_16(AVFrame *f, const uint8_t *src,
                          int linelen, int height) {
     int i, j;
     uint8_t *dst = f->data[0];
@@ -115,7 +115,7 @@
     }
 }
 
-static void add_frame_32(AVFrame *f, uint8_t *src,
+static void add_frame_32(AVFrame *f, const uint8_t *src,
                          int linelen, int height) {
     int i, j;
     uint8_t *dst = f->data[0];
@@ -135,7 +135,7 @@
 #endif
 
 static int decode_frame(AVCodecContext *avctx, void *data, int *data_size,
-                        uint8_t *buf, int buf_size) {
+                        const uint8_t *buf, int buf_size) {
     CamStudioContext *c = avctx->priv_data;
     AVFrame *picture = data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/cyuv.c ffmpeg-free-0.svn20080206/libavcodec/cyuv.c
--- mplayer-1.0~rc2-12/libavcodec/cyuv.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/cyuv.c	2008-03-20 19:10:57.000000000 +0100
@@ -61,7 +61,7 @@
 
 static int cyuv_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     CyuvDecodeContext *s=avctx->priv_data;
 
@@ -73,9 +73,9 @@
     int v_ptr;
 
     /* prediction error tables (make it clear that they are signed values) */
-    signed char *y_table = (signed char*)buf +  0;
-    signed char *u_table = (signed char*)buf + 16;
-    signed char *v_table = (signed char*)buf + 32;
+    const signed char *y_table = (const signed char*)buf +  0;
+    const signed char *u_table = (const signed char*)buf + 16;
+    const signed char *v_table = (const signed char*)buf + 32;
 
     unsigned char y_pred, u_pred, v_pred;
     int stream_ptr;
diff -u mplayer-1.0~rc2-12/libavcodec/dca.c ffmpeg-free-0.svn20080206/libavcodec/dca.c
--- mplayer-1.0~rc2-12/libavcodec/dca.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dca.c	2008-03-20 19:10:57.000000000 +0100
@@ -453,15 +453,15 @@
     }
 
     for (j = 0; j < s->prim_channels; j++) {
-        uint32_t *scale_table;
+        const uint32_t *scale_table;
         int scale_sum;
 
         memset(s->scale_factor[j], 0, s->subband_activity[j] * sizeof(s->scale_factor[0][0][0]) * 2);
 
         if (s->scalefactor_huffman[j] == 6)
-            scale_table = (uint32_t *) scale_factor_quant7;
+            scale_table = scale_factor_quant7;
         else
-            scale_table = (uint32_t *) scale_factor_quant6;
+            scale_table = scale_factor_quant6;
 
         /* When huffman coded, only the difference is encoded */
         scale_sum = 0;
@@ -646,7 +646,7 @@
                             float samples_in[32][8], float *samples_out,
                             float scale, float bias)
 {
-    float *prCoeff;
+    const float *prCoeff;
     int i, j, k;
     float praXin[33], *raXin = &praXin[1];
 
@@ -659,9 +659,9 @@
 
     /* Select filter */
     if (!s->multirate_inter)    /* Non-perfect reconstruction */
-        prCoeff = (float *) fir_32bands_nonperfect;
+        prCoeff = fir_32bands_nonperfect;
     else                        /* Perfect reconstruction */
-        prCoeff = (float *) fir_32bands_perfect;
+        prCoeff = fir_32bands_perfect;
 
     /* Reconstructed channel sample index */
     for (subindex = 0; subindex < 8; subindex++) {
@@ -842,7 +842,7 @@
     int k, l;
     int subsubframe = s->current_subsubframe;
 
-    float *quant_step_table;
+    const float *quant_step_table;
 
     /* FIXME */
     float subband_samples[DCA_PRIM_CHANNELS_MAX][DCA_SUBBANDS][8];
@@ -853,9 +853,9 @@
 
     /* Select quantization step size table */
     if (s->bit_rate == 0x1f)
-        quant_step_table = (float *) lossless_quant_d;
+        quant_step_table = lossless_quant_d;
     else
-        quant_step_table = (float *) lossy_quant_d;
+        quant_step_table = lossy_quant_d;
 
     for (k = 0; k < s->prim_channels; k++) {
         for (l = 0; l < s->vq_start_subband[k]; l++) {
@@ -1001,7 +1001,7 @@
                               s->lfe_data + lfe_samples +
                               2 * s->lfe * subsubframe,
                               &s->samples[256 * i_channels],
-                              8388608.0, s->bias);
+                              256.0, 0 /* s->bias */);
         /* Outputs 20bits pcm samples */
     }
 
@@ -1091,12 +1091,13 @@
 /**
  * Convert bitstream to one representation based on sync marker
  */
-static int dca_convert_bitstream(uint8_t * src, int src_size, uint8_t * dst,
+static int dca_convert_bitstream(const uint8_t * src, int src_size, uint8_t * dst,
                           int max_size)
 {
     uint32_t mrk;
     int i, tmp;
-    uint16_t *ssrc = (uint16_t *) src, *sdst = (uint16_t *) dst;
+    const uint16_t *ssrc = (const uint16_t *) src;
+    uint16_t *sdst = (uint16_t *) dst;
     PutBitContext pb;
 
     if((unsigned)src_size > (unsigned)max_size) {
@@ -1133,7 +1134,7 @@
  */
 static int dca_decode_frame(AVCodecContext * avctx,
                             void *data, int *data_size,
-                            uint8_t * buf, int buf_size)
+                            const uint8_t * buf, int buf_size)
 {
 
     int i, j, k;
@@ -1159,23 +1160,12 @@
     avctx->bit_rate = s->bit_rate;
 
     channels = s->prim_channels + !!s->lfe;
-    avctx->channels = avctx->request_channels;
-    if(avctx->channels == 0) {
-        avctx->channels = channels;
-    } else if(channels < avctx->channels) {
-        av_log(avctx, AV_LOG_WARNING, "DTS source channels are less than "
-               "specified: output to %d channels.\n", channels);
-        avctx->channels = channels;
-    }
-    if(avctx->channels == 2) {
+    if(avctx->request_channels == 2 && s->prim_channels > 2) {
+        channels = 2;
         s->output = DCA_STEREO;
-    } else if(avctx->channels != channels) {
-        av_log(avctx, AV_LOG_ERROR, "Cannot downmix DTS to %d channels.\n",
-               avctx->channels);
-        return -1;
     }
 
-    channels = avctx->channels;
+    avctx->channels = channels;
     if(*data_size < (s->sample_blocks / 8) * 256 * sizeof(int16_t) * channels)
         return -1;
     *data_size = 0;
@@ -1241,6 +1231,13 @@
     pre_calc_cosmod(s);
 
     dsputil_init(&s->dsp, avctx);
+
+    /* allow downmixing to stereo */
+    if (avctx->channels > 0 && avctx->request_channels < avctx->channels &&
+            avctx->request_channels == 2) {
+        avctx->channels = avctx->request_channels;
+    }
+
     return 0;
 }
 
diff -u mplayer-1.0~rc2-12/libavcodec/dcadata.h ffmpeg-free-0.svn20080206/libavcodec/dcadata.h
--- mplayer-1.0~rc2-12/libavcodec/dcadata.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dcadata.h	2007-12-02 23:04:21.000000000 +0100
@@ -24,8 +24,8 @@
  * @file dcadata.c
  */
 
-#ifndef AVCODEC_DCADATA_H
-#define AVCODEC_DCADATA_H
+#ifndef FFMPEG_DCADATA_H
+#define FFMPEG_DCADATA_H
 
 #include <stdint.h>
 
@@ -7314,7 +7314,7 @@
 +1.390191784E-007
 };
 
-//FIXME the coeffs are symetric
+//FIXME the coeffs are symmetric
 static const float lfe_fir_64[] =
 {
 2.6584343868307770E-004,
@@ -7831,7 +7831,7 @@
 2.6584343868307770E-004
 };
 
-//FIXME the coeffs are symetric
+//FIXME the coeffs are symmetric
 
 static const float lfe_fir_128[] =
 {
@@ -8349,7 +8349,7 @@
 0.00053168571
 };
 
-/* 10^-(dB/20), with dB beeing a list of dB values rangeing from 0 to -72 */
+/* 10^-(dB/20), with dB being a list of dB values ranging from 0 to -72 */
 /* do a 20*log10(dca_downmix_coeffs) to reconvert the values */
 
 static const float dca_downmix_coeffs[65] = {
@@ -8471,4 +8471,4 @@
 
 */
 
-#endif // AVCODEC_DCADATA_H
+#endif /* FFMPEG_DCADATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/dca.h ffmpeg-free-0.svn20080206/libavcodec/dca.h
--- mplayer-1.0~rc2-12/libavcodec/dca.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dca.h	2007-10-17 11:37:46.000000000 +0200
@@ -22,8 +22,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_DCA_H
-#define AVCODEC_DCA_H
+#ifndef FFMPEG_DCA_H
+#define FFMPEG_DCA_H
 
 /** DCA syncwords, also used for bitstream type detection */
 #define DCA_MARKER_RAW_BE 0x7FFE8001
@@ -31,4 +31,4 @@
 #define DCA_MARKER_14B_BE 0x1FFFE800
 #define DCA_MARKER_14B_LE 0xFF1F00E8
 
-#endif // AVCODEC_DCA_H
+#endif /* FFMPEG_DCA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/dcahuff.h ffmpeg-free-0.svn20080206/libavcodec/dcahuff.h
--- mplayer-1.0~rc2-12/libavcodec/dcahuff.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dcahuff.h	2007-10-17 11:37:46.000000000 +0200
@@ -20,8 +20,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_DCAHUFF_H
-#define AVCODEC_DCAHUFF_H
+#ifndef FFMPEG_DCAHUFF_H
+#define FFMPEG_DCAHUFF_H
 
 #include <stdint.h>
 #include <stdlib.h>
@@ -1073,4 +1073,4 @@
     bitalloc_129_bits_e, bitalloc_129_bits_f, bitalloc_129_bits_g, NULL }
 };
 
-#endif // AVCODEC_DCAHUFF_H
+#endif /* FFMPEG_DCAHUFF_H */
diff -u mplayer-1.0~rc2-12/libavcodec/dct-test.c ffmpeg-free-0.svn20080206/libavcodec/dct-test.c
--- mplayer-1.0~rc2-12/libavcodec/dct-test.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dct-test.c	2008-03-20 19:10:57.000000000 +0100
@@ -91,7 +91,7 @@
   DCT_ERROR("IJG-LLM-INT",     0, ff_jpeg_fdct_islow, fdct, NO_PERM),
   DCT_ERROR("REF-DBL",         1, idct,               idct, NO_PERM),
   DCT_ERROR("INT",             1, j_rev_dct,          idct, MMX_PERM),
-  DCT_ERROR("SIMPLE-C",        1, simple_idct,        idct, NO_PERM),
+  DCT_ERROR("SIMPLE-C",        1, ff_simple_idct,     idct, NO_PERM),
 
 #ifdef HAVE_MMX
   DCT_ERROR("MMX",             0, ff_fdct_mmx,        fdct, NO_PERM),
@@ -559,7 +559,7 @@
     printf("ffmpeg DCT/IDCT test\n");
 
     if (test_248_dct) {
-        idct248_error("SIMPLE-C", simple_idct248_put);
+        idct248_error("SIMPLE-C", ff_simple_idct248_put);
     } else {
       for (i=0;algos[i].name;i++)
         if (algos[i].is_idct == test_idct) {
diff -u mplayer-1.0~rc2-12/libavcodec/dnxhddata.c ffmpeg-free-0.svn20080206/libavcodec/dnxhddata.c
--- mplayer-1.0~rc2-12/libavcodec/dnxhddata.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dnxhddata.c	2008-03-20 19:10:57.000000000 +0100
@@ -19,9 +19,10 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "avcodec.h"
 #include "dnxhddata.h"
 
-static const uint8_t dnxhd_1237_luma_weigth[] = {
+static const uint8_t dnxhd_1237_luma_weight[] = {
      0,  32,  33,  34, 34, 36, 37, 36,
     36,  37,  38,  38, 38, 39, 41, 44,
     43,  41,  40,  41, 46, 49, 47, 46,
@@ -32,7 +33,7 @@
     97, 100, 104, 102, 98, 98, 99, 99,
 };
 
-static const uint8_t dnxhd_1237_chroma_weigth[] = {
+static const uint8_t dnxhd_1237_chroma_weight[] = {
      0,  32,  36,  39, 39, 38, 39,  41,
     45,  51,  57,  58, 53, 48, 47,  51,
     55,  58,  66,  75, 81, 83, 82,  78,
@@ -43,7 +44,7 @@
     97, 100, 104, 102, 98, 98, 99,  99,
 };
 
-static const uint8_t dnxhd_1238_luma_weigth[] = {
+static const uint8_t dnxhd_1238_luma_weight[] = {
      0, 32, 32, 33, 34, 33, 33, 33,
     33, 33, 33, 33, 33, 35, 37, 37,
     36, 36, 35, 36, 38, 38, 36, 35,
@@ -54,7 +55,7 @@
     51, 53, 55, 57, 58, 59, 57, 57,
 };
 
-static const uint8_t dnxhd_1238_chroma_weigth[] = {
+static const uint8_t dnxhd_1238_chroma_weight[] = {
      0, 32, 35, 35, 35, 34, 34, 35,
     39, 43, 45, 45, 41, 39, 40, 41,
     42, 44, 48, 55, 59, 63, 65, 59,
@@ -65,7 +66,29 @@
     82, 77, 80, 86, 84, 82, 82, 82,
 };
 
-static const uint8_t dnxhd_1242_luma_weigth[] = {
+static const uint8_t dnxhd_1241_luma_weight[] = {
+     0, 32, 33, 34, 34, 35, 36, 37,
+    36, 37, 38, 38, 38, 39, 39, 40,
+    40, 38, 38, 39, 38, 37, 39, 41,
+    41, 42, 43, 45, 45, 46, 47, 46,
+    45, 43, 39, 37, 37, 40, 44, 45,
+    45, 46, 46, 46, 47, 47, 46, 44,
+    42, 43, 45, 47, 48, 49, 50, 49,
+    48, 46, 47, 48, 48, 49, 49, 49,
+};
+
+static const uint8_t dnxhd_1241_chroma_weight[] = {
+     0, 32, 36, 38, 37, 37, 40, 41,
+    40, 40, 42, 42, 41, 41, 41, 41,
+    42, 43, 44, 44, 45, 46, 46, 45,
+    44, 45, 45, 45, 45, 46, 47, 46,
+    45, 44, 42, 41, 43, 45, 45, 47,
+    48, 48, 48, 46, 47, 47, 46, 47,
+    46, 45, 45, 47, 48, 49, 50, 49,
+    48, 46, 48, 49, 48, 49, 49, 49,
+};
+
+static const uint8_t dnxhd_1242_luma_weight[] = {
      0, 32, 33, 33, 34, 35, 36, 35,
     33, 33, 35, 36, 37, 37, 38, 37,
     37, 37, 36, 37, 37, 37, 38, 39,
@@ -76,7 +99,7 @@
     49, 51, 52, 51, 49, 47, 47, 47,
 };
 
-static const uint8_t dnxhd_1242_chroma_weigth[] = {
+static const uint8_t dnxhd_1242_chroma_weight[] = {
      0, 32, 37, 42, 45, 45, 45, 44,
     38, 37, 40, 42, 44, 49, 51, 47,
     41, 40, 43, 44, 46, 48, 51, 54,
@@ -87,7 +110,7 @@
     55, 59, 63, 62, 60, 60, 60, 60,
  };
 
-static const uint8_t dnxhd_1243_luma_weigth[] = {
+static const uint8_t dnxhd_1243_luma_weight[] = {
      0, 32, 32, 33, 33, 35, 35, 35,
     35, 35, 35, 35, 34, 35, 38, 40,
     39, 37, 37, 37, 36, 35, 36, 38,
@@ -98,7 +121,7 @@
     46, 44, 45, 47, 47, 48, 47, 47,
 };
 
-static const uint8_t dnxhd_1243_chroma_weigth[] = {
+static const uint8_t dnxhd_1243_chroma_weight[] = {
      0, 32, 36, 37, 36, 37, 39, 39,
     41, 43, 43, 42, 41, 41, 41, 42,
     43, 43, 43, 44, 44, 44, 46, 47,
@@ -109,6 +132,49 @@
     46, 45, 46, 47, 47, 48, 47, 47,
 };
 
+static const uint8_t dnxhd_1251_luma_weight[] = {
+     0, 32, 32, 34, 34, 34, 34, 35,
+    35, 35, 36, 37, 36, 36, 35, 36,
+    38, 38, 38, 38, 38, 38, 38, 38,
+    38, 38, 39, 41, 44, 43, 41, 40,
+    40, 40, 40, 39, 40, 41, 40, 39,
+    40, 43, 46, 46, 44, 44, 44, 42,
+    41, 43, 46, 48, 50, 55, 58, 53,
+    48, 50, 55, 58, 61, 62, 62, 62,
+};
+
+static const uint8_t dnxhd_1251_chroma_weight[] = {
+     0, 32, 35, 36, 36, 35, 36, 39,
+    41, 43, 45, 44, 41, 39, 40, 42,
+    43, 43, 45, 48, 48, 48, 50, 50,
+    50, 51, 51, 51, 51, 52, 53, 54,
+    51, 49, 51, 52, 52, 56, 57, 55,
+    54, 54, 55, 56, 55, 58, 58, 58,
+    60, 61, 62, 62, 59, 57, 58, 58,
+    61, 59, 59, 59, 61, 62, 62, 62,
+};
+
+static const uint8_t dnxhd_1252_luma_weight[] = {
+      0,  32,  34, 35, 36, 36, 36, 37,
+     36,  37,  39, 40, 41, 40, 40, 40,
+     41,  41,  42, 41, 41, 43, 44, 44,
+     45,  46,  48, 55, 60, 57, 52, 50,
+     49,  49,  52, 52, 53, 55, 58, 62,
+     65,  73,  82, 82, 80, 78, 73, 68,
+     71,  82,  90, 90, 88, 87, 90, 95,
+    100, 107, 103, 97, 95, 93, 99, 99,
+};
+static const uint8_t dnxhd_1252_chroma_weight[] = {
+      0,  32,  35,  36,  37,  37,  38,  40,
+     42,  46,  49,  50,  50,  49,  49,  53,
+     56,  56,  57,  58,  60,  62,  64,  65,
+     63,  64,  64,  65,  66,  65,  67,  71,
+     72,  74,  74,  74,  74,  77,  81,  78,
+     72,  73,  82,  85,  89,  88,  84,  80,
+     90, 100,  90,  90,  88,  87,  90,  95,
+    114, 128, 125, 129, 134, 125, 116, 116,
+};
+
 static const uint8_t dnxhd_1237_dc_codes[12] = {
     0, 12, 13, 1, 2, 3, 4, 5, 14, 30, 62, 63,
 };
@@ -189,31 +255,164 @@
     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 20, 21, 17, 18, 19, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
 };
 
+static const uint8_t dnxhd_1241_dc_codes[14] = {
+    10, 62, 11, 12, 13, 0, 1, 2, 3, 4, 14, 30, 126, 127,
+};
+
+static const uint8_t dnxhd_1241_dc_bits[14] = {
+    4, 6, 4, 4, 4, 3, 3, 3, 3, 3, 4, 5, 7, 7,
+};
+static const uint16_t dnxhd_1241_ac_codes[257] = {
+    0, 1, 4, 10, 11, 24, 25, 26, 54, 55, 56, 57, 116, 117, 118, 119, 240, 241, 242, 243, 244, 245, 492, 493, 494, 495, 496, 497, 498, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 8140, 8141, 8142, 8143, 8144, 8145, 8146, 8147, 8148, 8149, 8150, 8151, 8152, 8153, 8154, 8155, 8156, 8157, 16316, 16317, 16318, 16319, 16320, 16321, 16322, 16323, 16324, 16325, 16326, 16327, 16328, 16329, 16330, 16331, 16332, 16333, 16334, 16335, 16336, 16337, 32676, 32677, 32678, 32679, 32680, 32681, 32682, 32683, 32684, 32685, 32686, 32687, 32688, 32689, 32690, 32691, 32692, 32693, 32694, 32695, 32696, 32697, 32698, 32699, 32700, 32701, 32702, 32703, 32704, 32705, 32706, 32707, 32708, 65418, 65419, 65420, 65421, 65422, 65423, 65424, 65425, 65426, 65427, 65428, 65429, 65430, 65431, 65432, 65433, 65434, 65435, 65436, 65437, 65438, 65439, 65440, 65441, 65442, 65443, 65444, 65445, 65446, 65447, 65448, 65449, 65450, 65451, 65452, 65453, 65454, 65455, 65456, 65457, 65458, 65459, 65460, 65461, 65462, 65463, 65464, 65465, 65466, 65467, 65468, 65469, 65470, 65471, 65472, 65473, 65474, 65475, 65476, 65477, 65478, 65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486, 65487, 65488, 65489, 65490, 65491, 65492, 65493, 65494, 65495, 65496, 65497, 65498, 65499, 65500, 65501, 65502, 65503, 65504, 65505, 65506, 65507, 65508, 65509, 65510, 65511, 65512, 65513, 65514, 65515, 65516, 65517, 65518, 65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526, 65527, 65528, 65529, 65530, 65531, 65532, 65533, 65534, 65535,
+};
+
+static const uint8_t dnxhd_1241_ac_bits[257] = {
+    2, 2, 3, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+};
+
+static const uint8_t dnxhd_1241_ac_level[257] = {
+    1, 1, 2, 3, 0, 4, 5, 2, 6, 7, 8, 3, 9, 10, 11, 4, 12, 13, 14, 15, 16, 5, 17, 18, 19, 20, 21, 6, 7, 22, 23, 24, 25, 26, 27, 28, 29, 8, 9, 30, 31, 32, 33, 34, 35, 36, 37, 38, 10, 11, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 12, 13, 14, 15, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 1, 16, 17, 18, 19, 64, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 21, 22, 23, 24, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 25, 26, 27, 28, 29, 30, 31, 32, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
+};
+
+static const uint8_t dnxhd_1241_ac_run_flag[257] = {
+    0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+};
+
+static const uint8_t dnxhd_1241_ac_index_flag[257] = {
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+};
+
+static const uint16_t dnxhd_1241_run_codes[62] = {
+    0, 4, 10, 11, 24, 25, 26, 27, 56, 57, 58, 59, 120, 242, 486, 487, 488, 489, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023,
+};
+
+static const uint8_t dnxhd_1241_run_bits[62] = {
+    1, 3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+};
+
+static const uint8_t dnxhd_1241_run[62] = {
+    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 20, 17, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
+};
+
+static const uint8_t dnxhd_1251_dc_codes[12] = {
+    0, 12, 13, 1, 2, 3, 4, 5, 14, 30, 62, 63,
+};
+static const uint8_t dnxhd_1251_dc_bits[12] = {
+    3, 4, 4, 3, 3, 3, 3, 3, 4, 5, 6, 6,
+};
+static const uint16_t dnxhd_1251_ac_codes[257] = {
+    0, 1, 4, 10, 11, 24, 25, 26, 54, 55, 56, 57, 116, 117, 118, 119, 240, 241, 242, 243, 244, 245, 492, 493, 494, 495, 496, 497, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 8134, 8135, 8136, 8137, 8138, 8139, 8140, 8141, 8142, 8143, 8144, 8145, 8146, 8147, 8148, 8149, 8150, 8151, 8152, 8153, 8154, 8155, 8156, 16314, 16315, 16316, 16317, 16318, 16319, 16320, 16321, 16322, 16323, 16324, 16325, 16326, 16327, 16328, 16329, 16330, 16331, 16332, 16333, 16334, 16335, 16336, 16337, 16338, 16339, 32680, 32681, 32682, 32683, 32684, 32685, 32686, 32687, 32688, 32689, 32690, 32691, 32692, 32693, 32694, 32695, 32696, 32697, 32698, 32699, 32700, 32701, 32702, 32703, 32704, 32705, 32706, 32707, 32708, 32709, 32710, 32711, 32712, 32713, 32714, 65430, 65431, 65432, 65433, 65434, 65435, 65436, 65437, 65438, 65439, 65440, 65441, 65442, 65443, 65444, 65445, 65446, 65447, 65448, 65449, 65450, 65451, 65452, 65453, 65454, 65455, 65456, 65457, 65458, 65459, 65460, 65461, 65462, 65463, 65464, 65465, 65466, 65467, 65468, 65469, 65470, 65471, 65472, 65473, 65474, 65475, 65476, 65477, 65478, 65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486, 65487, 65488, 65489, 65490, 65491, 65492, 65493, 65494, 65495, 65496, 65497, 65498, 65499, 65500, 65501, 65502, 65503, 65504, 65505, 65506, 65507, 65508, 65509, 65510, 65511, 65512, 65513, 65514, 65515, 65516, 65517, 65518, 65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526, 65527, 65528, 65529, 65530, 65531, 65532, 65533, 65534, 65535,
+};
+static const uint8_t dnxhd_1251_ac_bits[257] = {
+    2, 2, 3, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+};
+static const uint8_t dnxhd_1251_ac_level[257] = {
+    1, 1, 2, 3, 0, 4, 5, 2, 6, 7, 8, 3, 9, 10, 11, 4, 12, 13, 14, 15, 16, 5, 17, 18, 19, 20, 21, 6, 22, 23, 24, 25, 26, 27, 28, 29, 7, 8, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 9, 10, 11, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 12, 13, 14, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 1, 2, 3, 4, 5, 6, 7, 8, 15, 16, 17, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 18, 19, 20, 21, 22, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 23, 24, 25, 26, 27, 28, 59, 60, 61, 62, 63, 64, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
+};
+static const uint8_t dnxhd_1251_ac_run_flag[257] = {
+    0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+};
+static const uint8_t dnxhd_1251_ac_index_flag[257] = {
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+};
+static const uint16_t dnxhd_1251_run_codes[62] = {
+    0, 4, 5, 12, 26, 27, 28, 58, 118, 119, 120, 242, 486, 487, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023,
+};
+static const uint8_t dnxhd_1251_run_bits[62] = {
+    1, 3, 3, 4, 5, 5, 5, 6, 7, 7, 7, 8, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+};
+static const uint8_t dnxhd_1251_run[62] = {
+    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
+};
+
+static const uint8_t dnxhd_1252_dc_codes[12] = {
+    0, 12, 13, 1, 2, 3, 4, 5, 14, 30, 62, 63,
+};
+static const uint8_t dnxhd_1252_dc_bits[12] = {
+    3, 4, 4, 3, 3, 3, 3, 3, 4, 5, 6, 6,
+};
+static const uint16_t dnxhd_1252_ac_codes[257] = {
+    0, 1, 4, 10, 11, 12, 26, 27, 56, 57, 58, 118, 119, 120, 242, 243, 244, 245, 246, 247, 496, 497, 498, 499, 500, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 8144, 8145, 8146, 8147, 8148, 8149, 8150, 8151, 8152, 8153, 8154, 8155, 8156, 8157, 8158, 16318, 16319, 16320, 16321, 16322, 16323, 16324, 16325, 16326, 16327, 16328, 16329, 16330, 16331, 16332, 16333, 16334, 16335, 32672, 32673, 32674, 32675, 32676, 32677, 32678, 32679, 32680, 32681, 32682, 32683, 32684, 32685, 32686, 32687, 32688, 32689, 32690, 32691, 32692, 32693, 32694, 65390, 65391, 65392, 65393, 65394, 65395, 65396, 65397, 65398, 65399, 65400, 65401, 65402, 65403, 65404, 65405, 65406, 65407, 65408, 65409, 65410, 65411, 65412, 65413, 65414, 65415, 65416, 65417, 65418, 65419, 65420, 65421, 65422, 65423, 65424, 65425, 65426, 65427, 65428, 65429, 65430, 65431, 65432, 65433, 65434, 65435, 65436, 65437, 65438, 65439, 65440, 65441, 65442, 65443, 65444, 65445, 65446, 65447, 65448, 65449, 65450, 65451, 65452, 65453, 65454, 65455, 65456, 65457, 65458, 65459, 65460, 65461, 65462, 65463, 65464, 65465, 65466, 65467, 65468, 65469, 65470, 65471, 65472, 65473, 65474, 65475, 65476, 65477, 65478, 65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486, 65487, 65488, 65489, 65490, 65491, 65492, 65493, 65494, 65495, 65496, 65497, 65498, 65499, 65500, 65501, 65502, 65503, 65504, 65505, 65506, 65507, 65508, 65509, 65510, 65511, 65512, 65513, 65514, 65515, 65516, 65517, 65518, 65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526, 65527, 65528, 65529, 65530, 65531, 65532, 65533, 65534, 65535,
+};
+static const uint8_t dnxhd_1252_ac_bits[257] = {
+    2, 2, 3, 4, 4, 4, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+};
+static const uint8_t dnxhd_1252_ac_level[257] = {
+    1, 1, 2, 3, 2, 0, 4, 5, 6, 7, 3, 8, 9, 10, 11, 12, 13, 14, 4, 5, 15, 16, 17, 18, 6, 19, 20, 21, 22, 23, 24, 7, 8, 25, 26, 27, 28, 29, 30, 31, 32, 9, 10, 33, 34, 35, 36, 37, 38, 39, 40, 41, 11, 12, 13, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 14, 15, 16, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 1, 2, 3, 17, 18, 19, 20, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 21, 22, 23, 24, 25, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
+};
+static const uint8_t dnxhd_1252_ac_run_flag[257] = {
+    0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+};
+static const uint8_t dnxhd_1252_ac_index_flag[257] = {
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+};
+static const uint16_t dnxhd_1252_run_codes[62] = {
+    0, 4, 5, 12, 26, 27, 28, 58, 118, 119, 120, 242, 486, 487, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023,
+};
+static const uint8_t dnxhd_1252_run_bits[62] = {
+    1, 3, 3, 4, 5, 5, 5, 6, 7, 7, 7, 8, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+};
+static const uint8_t dnxhd_1252_run[62] = {
+    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
+};
+
 const CIDEntry ff_dnxhd_cid_table[] = {
     { 1237, 1920, 1080, 0, 606208, 606208, 4, 8,
-      dnxhd_1237_luma_weigth, dnxhd_1237_chroma_weigth,
+      dnxhd_1237_luma_weight, dnxhd_1237_chroma_weight,
       dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
       dnxhd_1237_ac_codes, dnxhd_1237_ac_bits, dnxhd_1237_ac_level,
       dnxhd_1237_ac_run_flag, dnxhd_1237_ac_index_flag,
-      dnxhd_1237_run_codes, dnxhd_1237_run_bits, dnxhd_1237_run },
+      dnxhd_1237_run_codes, dnxhd_1237_run_bits, dnxhd_1237_run,
+      { 115, 120, 145, 240, 290 } },
     { 1238, 1920, 1080, 0, 917504, 917504, 4, 8,
-      dnxhd_1238_luma_weigth, dnxhd_1238_chroma_weigth,
+      dnxhd_1238_luma_weight, dnxhd_1238_chroma_weight,
       dnxhd_1238_dc_codes, dnxhd_1238_dc_bits,
       dnxhd_1238_ac_codes, dnxhd_1238_ac_bits, dnxhd_1238_ac_level,
       dnxhd_1238_ac_run_flag, dnxhd_1238_ac_index_flag,
-      dnxhd_1238_run_codes, dnxhd_1238_run_bits, dnxhd_1238_run },
+      dnxhd_1238_run_codes, dnxhd_1238_run_bits, dnxhd_1238_run,
+      { 175, 185, 220, 365, 440 } },
+    { 1241, 1920, 1080, 1, 917504, 458752, 6, 10,
+      dnxhd_1241_luma_weight, dnxhd_1241_chroma_weight,
+      dnxhd_1241_dc_codes, dnxhd_1241_dc_bits,
+      dnxhd_1241_ac_codes, dnxhd_1241_ac_bits, dnxhd_1241_ac_level,
+      dnxhd_1241_ac_run_flag, dnxhd_1241_ac_index_flag,
+      dnxhd_1241_run_codes, dnxhd_1241_run_bits, dnxhd_1241_run,
+      { 185, 220 } },
     { 1242, 1920, 1080, 1, 606208, 303104, 4, 8,
-      dnxhd_1242_luma_weigth, dnxhd_1242_chroma_weigth,
+      dnxhd_1242_luma_weight, dnxhd_1242_chroma_weight,
       dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
       dnxhd_1237_ac_codes, dnxhd_1237_ac_bits, dnxhd_1237_ac_level,
       dnxhd_1237_ac_run_flag, dnxhd_1237_ac_index_flag,
-      dnxhd_1237_run_codes, dnxhd_1237_run_bits, dnxhd_1237_run },
+      dnxhd_1237_run_codes, dnxhd_1237_run_bits, dnxhd_1237_run,
+      { 120, 145 } },
     { 1243, 1920, 1080, 1, 917504, 458752, 4, 8,
-      dnxhd_1243_luma_weigth, dnxhd_1243_chroma_weigth,
+      dnxhd_1243_luma_weight, dnxhd_1243_chroma_weight,
       dnxhd_1238_dc_codes, dnxhd_1238_dc_bits,
       dnxhd_1238_ac_codes, dnxhd_1238_ac_bits, dnxhd_1238_ac_level,
       dnxhd_1238_ac_run_flag, dnxhd_1238_ac_index_flag,
-      dnxhd_1238_run_codes, dnxhd_1238_run_bits, dnxhd_1238_run },
+      dnxhd_1238_run_codes, dnxhd_1238_run_bits, dnxhd_1238_run,
+      { 185, 220 } },
+    { 1251, 1280,  720, 0, 458752, 458752, 4, 8,
+      dnxhd_1251_luma_weight, dnxhd_1251_chroma_weight,
+      dnxhd_1251_dc_codes, dnxhd_1251_dc_bits,
+      dnxhd_1251_ac_codes, dnxhd_1251_ac_bits, dnxhd_1251_ac_level,
+      dnxhd_1251_ac_run_flag, dnxhd_1251_ac_index_flag,
+      dnxhd_1251_run_codes, dnxhd_1251_run_bits, dnxhd_1251_run,
+      { 90, 110, 175, 220 } },
+    { 1252, 1280,  720, 0, 303104, 303104, 4, 8,
+      dnxhd_1252_luma_weight, dnxhd_1252_chroma_weight,
+      dnxhd_1252_dc_codes, dnxhd_1252_dc_bits,
+      dnxhd_1252_ac_codes, dnxhd_1252_ac_bits, dnxhd_1252_ac_level,
+      dnxhd_1252_ac_run_flag, dnxhd_1252_ac_index_flag,
+      dnxhd_1252_run_codes, dnxhd_1252_run_bits, dnxhd_1252_run,
+      { 60, 75, 115, 145 } },
+    { 1253, 1920, 1080, 0, 188416, 188416, 4, 8,
+      dnxhd_1237_luma_weight, dnxhd_1237_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1237_ac_codes, dnxhd_1237_ac_bits, dnxhd_1237_ac_level,
+      dnxhd_1237_ac_run_flag, dnxhd_1237_ac_index_flag,
+      dnxhd_1237_run_codes, dnxhd_1237_run_bits, dnxhd_1237_run,
+      { 36, 45, 75, 90 } },
 };
 
 int ff_dnxhd_get_cid_table(int cid)
@@ -224,3 +423,21 @@
             return i;
     return -1;
 }
+
+int ff_dnxhd_find_cid(AVCodecContext *avctx)
+{
+    int i, j;
+    int mbs = avctx->bit_rate/1000000;
+    for (i = 0; i < sizeof(ff_dnxhd_cid_table)/sizeof(CIDEntry); i++) {
+        const CIDEntry *cid = &ff_dnxhd_cid_table[i];
+        if (cid->width == avctx->width && cid->height == avctx->height &&
+            cid->interlaced == !!(avctx->flags & CODEC_FLAG_INTERLACED_DCT) &&
+            cid->bit_depth == 8) { // until 10 bit is supported
+            for (j = 0; j < sizeof(cid->bit_rates); j++) {
+                if (cid->bit_rates[j] == mbs)
+                    return cid->cid;
+            }
+        }
+    }
+    return 0;
+}
diff -u mplayer-1.0~rc2-12/libavcodec/dnxhddata.h ffmpeg-free-0.svn20080206/libavcodec/dnxhddata.h
--- mplayer-1.0~rc2-12/libavcodec/dnxhddata.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dnxhddata.h	2007-12-18 14:52:07.000000000 +0100
@@ -19,10 +19,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_DNXHDDATA_H
-#define AVCODEC_DNXHDDATA_H
+#ifndef FFMPEG_DNXHDDATA_H
+#define FFMPEG_DNXHDDATA_H
 
 #include <stdint.h>
+#include "avcodec.h"
 
 typedef struct {
     int cid;
@@ -32,17 +33,19 @@
     unsigned int coding_unit_size;
     int index_bits;
     int bit_depth;
-    const uint8_t *luma_weigth, *chroma_weigth;
+    const uint8_t *luma_weight, *chroma_weight;
     const uint8_t *dc_codes, *dc_bits;
     const uint16_t *ac_codes;
     const uint8_t *ac_bits, *ac_level;
     const uint8_t *ac_run_flag, *ac_index_flag;
     const uint16_t *run_codes;
     const uint8_t *run_bits, *run;
+    int bit_rates[5]; ///< Helpher to choose variants, rounded to nearest 5Mb/s
 } CIDEntry;
 
 extern const CIDEntry ff_dnxhd_cid_table[];
 
 int ff_dnxhd_get_cid_table(int cid);
+int ff_dnxhd_find_cid(AVCodecContext *avctx);
 
-#endif  // AVCODEC_DNXHDDATA_H
+#endif /* FFMPEG_DNXHDDATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/dnxhddec.c ffmpeg-free-0.svn20080206/libavcodec/dnxhddec.c
--- mplayer-1.0~rc2-12/libavcodec/dnxhddec.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dnxhddec.c	2008-03-20 19:10:57.000000000 +0100
@@ -46,7 +46,7 @@
 } DNXHDContext;
 
 #define DNXHD_VLC_BITS 9
-#define DNXHD_DC_VLC_BITS 6
+#define DNXHD_DC_VLC_BITS 7
 
 static int dnxhd_decode_init(AVCodecContext *avctx)
 {
@@ -72,7 +72,7 @@
         init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,
                  ctx->cid_table->ac_bits, 1, 1,
                  ctx->cid_table->ac_codes, 2, 2, 0);
-        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, 12,
+        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->cid_table->bit_depth+4,
                  ctx->cid_table->dc_bits, 1, 1,
                  ctx->cid_table->dc_codes, 1, 1, 0);
         init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,
@@ -84,7 +84,7 @@
     return 0;
 }
 
-static int dnxhd_decode_header(DNXHDContext *ctx, uint8_t *buf, int buf_size, int first_field)
+static int dnxhd_decode_header(DNXHDContext *ctx, const uint8_t *buf, int buf_size, int first_field)
 {
     static const uint8_t header_prefix[] = { 0x00, 0x00, 0x02, 0x80, 0x01 };
     int i;
@@ -99,7 +99,7 @@
     if (buf[5] & 2) { /* interlaced */
         ctx->cur_field = buf[5] & 1;
         ctx->picture.interlaced_frame = 1;
-        ctx->picture.top_field_first = first_field && ctx->cur_field == 1;
+        ctx->picture.top_field_first = first_field ^ ctx->cur_field;
         av_log(ctx->avctx, AV_LOG_DEBUG, "interlaced %d, cur field %d\n", buf[5] & 3, ctx->cur_field);
     }
 
@@ -108,7 +108,7 @@
 
     dprintf(ctx->avctx, "width %d, heigth %d\n", ctx->width, ctx->height);
 
-    if (buf[0x21] & 0x80) {
+    if (buf[0x21] & 0x40) {
         av_log(ctx->avctx, AV_LOG_ERROR, "10 bit per component\n");
         return -1;
     }
@@ -161,10 +161,10 @@
 
     if (n&2) {
         component = 1 + (n&1);
-        weigth_matrix = ctx->cid_table->chroma_weigth;
+        weigth_matrix = ctx->cid_table->chroma_weight;
     } else {
         component = 0;
-        weigth_matrix = ctx->cid_table->luma_weigth;
+        weigth_matrix = ctx->cid_table->luma_weight;
     }
 
     ctx->last_dc[component] += dnxhd_decode_dc(ctx);
@@ -189,22 +189,26 @@
             i += ctx->cid_table->run[index2];
         }
 
-        j = ctx->scantable.permutated[i];
-        //av_log(ctx->avctx, AV_LOG_DEBUG, "j %d\n", j);
-        //av_log(ctx->avctx, AV_LOG_DEBUG, "level %d, weigth %d\n", level, weigth_matrix[i]);
-        level = (2*level+1) * qscale * weigth_matrix[i];
-        if (weigth_matrix[i] != 32) // FIXME 10bit
-            level += 32;
-        level >>= 6;
-        level = (level^sign) - sign;
-
         if (i > 63) {
             av_log(ctx->avctx, AV_LOG_ERROR, "ac tex damaged %d, %d\n", n, i);
             return;
         }
 
+        j = ctx->scantable.permutated[i];
+        //av_log(ctx->avctx, AV_LOG_DEBUG, "j %d\n", j);
+        //av_log(ctx->avctx, AV_LOG_DEBUG, "level %d, weigth %d\n", level, weigth_matrix[i]);
+        level = (2*level+1) * qscale * weigth_matrix[i];
+        if (ctx->cid_table->bit_depth == 10) {
+            if (weigth_matrix[i] != 8)
+                level += 8;
+            level >>= 4;
+        } else {
+            if (weigth_matrix[i] != 32)
+                level += 32;
+            level >>= 6;
+        }
         //av_log(NULL, AV_LOG_DEBUG, "i %d, j %d, end level %d\n", i, j, level);
-        block[j] = level;
+        block[j] = (level^sign) - sign;
     }
 }
 
@@ -259,13 +263,13 @@
     return 0;
 }
 
-static int dnxhd_decode_macroblocks(DNXHDContext *ctx, uint8_t *buf, int buf_size)
+static int dnxhd_decode_macroblocks(DNXHDContext *ctx, const uint8_t *buf, int buf_size)
 {
     int x, y;
     for (y = 0; y < ctx->mb_height; y++) {
         ctx->last_dc[0] =
         ctx->last_dc[1] =
-        ctx->last_dc[2] = 1024; // 1024 for levels +128
+        ctx->last_dc[2] = 1<<(ctx->cid_table->bit_depth+2); // for levels +2^(bitdepth-1)
         init_get_bits(&ctx->gb, buf + ctx->mb_scan_index[y], (buf_size - ctx->mb_scan_index[y]) << 3);
         for (x = 0; x < ctx->mb_width; x++) {
             //START_TIMER;
@@ -277,7 +281,7 @@
 }
 
 static int dnxhd_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
-                              uint8_t *buf, int buf_size)
+                              const uint8_t *buf, int buf_size)
 {
     DNXHDContext *ctx = avctx->priv_data;
     AVFrame *picture = data;
Only in ffmpeg-free-0.svn20080206/libavcodec: dnxhdenc.c
diff -u mplayer-1.0~rc2-12/libavcodec/dpcm.c ffmpeg-free-0.svn20080206/libavcodec/dpcm.c
--- mplayer-1.0~rc2-12/libavcodec/dpcm.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dpcm.c	2008-03-20 19:10:57.000000000 +0100
@@ -159,7 +159,7 @@
 
 static int dpcm_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     DPCMContext *s = avctx->priv_data;
     int in, out = 0;
@@ -294,46 +294,19 @@
     return buf_size;
 }
 
-AVCodec roq_dpcm_decoder = {
-    "roq_dpcm",
-    CODEC_TYPE_AUDIO,
-    CODEC_ID_ROQ_DPCM,
-    sizeof(DPCMContext),
-    dpcm_decode_init,
-    NULL,
-    NULL,
-    dpcm_decode_frame,
+#define DPCM_DECODER(id, name)                  \
+AVCodec name ## _decoder = {                    \
+    #name,                                      \
+    CODEC_TYPE_AUDIO,                           \
+    id,                                         \
+    sizeof(DPCMContext),                        \
+    dpcm_decode_init,                           \
+    NULL,                                       \
+    NULL,                                       \
+    dpcm_decode_frame,                          \
 };
 
-AVCodec interplay_dpcm_decoder = {
-    "interplay_dpcm",
-    CODEC_TYPE_AUDIO,
-    CODEC_ID_INTERPLAY_DPCM,
-    sizeof(DPCMContext),
-    dpcm_decode_init,
-    NULL,
-    NULL,
-    dpcm_decode_frame,
-};
-
-AVCodec xan_dpcm_decoder = {
-    "xan_dpcm",
-    CODEC_TYPE_AUDIO,
-    CODEC_ID_XAN_DPCM,
-    sizeof(DPCMContext),
-    dpcm_decode_init,
-    NULL,
-    NULL,
-    dpcm_decode_frame,
-};
-
-AVCodec sol_dpcm_decoder = {
-    "sol_dpcm",
-    CODEC_TYPE_AUDIO,
-    CODEC_ID_SOL_DPCM,
-    sizeof(DPCMContext),
-    dpcm_decode_init,
-    NULL,
-    NULL,
-    dpcm_decode_frame,
-};
+DPCM_DECODER(CODEC_ID_INTERPLAY_DPCM, interplay_dpcm);
+DPCM_DECODER(CODEC_ID_ROQ_DPCM, roq_dpcm);
+DPCM_DECODER(CODEC_ID_SOL_DPCM, sol_dpcm);
+DPCM_DECODER(CODEC_ID_XAN_DPCM, xan_dpcm);
diff -u mplayer-1.0~rc2-12/libavcodec/dsicinav.c ffmpeg-free-0.svn20080206/libavcodec/dsicinav.c
--- mplayer-1.0~rc2-12/libavcodec/dsicinav.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dsicinav.c	2008-03-20 19:10:57.000000000 +0100
@@ -195,7 +195,7 @@
 
 static int cinvideo_decode_frame(AVCodecContext *avctx,
                                  void *data, int *data_size,
-                                 uint8_t *buf, int buf_size)
+                                 const uint8_t *buf, int buf_size)
 {
     CinVideoContext *cin = avctx->priv_data;
     int i, y, palette_type, palette_colors_count, bitmap_frame_type, bitmap_frame_size;
@@ -311,10 +311,10 @@
 
 static int cinaudio_decode_frame(AVCodecContext *avctx,
                                  void *data, int *data_size,
-                                 uint8_t *buf, int buf_size)
+                                 const uint8_t *buf, int buf_size)
 {
     CinAudioContext *cin = avctx->priv_data;
-    uint8_t *src = buf;
+    const uint8_t *src = buf;
     int16_t *samples = (int16_t *)data;
 
     buf_size = FFMIN(buf_size, *data_size/2);
diff -u mplayer-1.0~rc2-12/libavcodec/dsputil.c ffmpeg-free-0.svn20080206/libavcodec/dsputil.c
--- mplayer-1.0~rc2-12/libavcodec/dsputil.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dsputil.c	2008-03-20 19:10:57.000000000 +0100
@@ -214,7 +214,7 @@
     return s;
 }
 
-static void bswap_buf(uint32_t *dst, uint32_t *src, int w){
+static void bswap_buf(uint32_t *dst, const uint32_t *src, int w){
     int i;
 
     for(i=0; i+8<=w; i+=8){
@@ -1440,12 +1440,22 @@
     \
     assert(x<8 && y<8 && x>=0 && y>=0);\
 \
-    for(i=0; i<h; i++)\
-    {\
-        OP(dst[0], (A*src[0] + B*src[1] + C*src[stride+0] + D*src[stride+1]));\
-        OP(dst[1], (A*src[1] + B*src[2] + C*src[stride+1] + D*src[stride+2]));\
-        dst+= stride;\
-        src+= stride;\
+    if(D){\
+        for(i=0; i<h; i++){\
+            OP(dst[0], (A*src[0] + B*src[1] + C*src[stride+0] + D*src[stride+1]));\
+            OP(dst[1], (A*src[1] + B*src[2] + C*src[stride+1] + D*src[stride+2]));\
+            dst+= stride;\
+            src+= stride;\
+        }\
+    }else{\
+        const int E= B+C;\
+        const int step= C ? stride : 1;\
+        for(i=0; i<h; i++){\
+            OP(dst[0], (A*src[0] + E*src[step+0]));\
+            OP(dst[1], (A*src[1] + E*src[step+1]));\
+            dst+= stride;\
+            src+= stride;\
+        }\
     }\
 }\
 \
@@ -1458,14 +1468,26 @@
     \
     assert(x<8 && y<8 && x>=0 && y>=0);\
 \
-    for(i=0; i<h; i++)\
-    {\
-        OP(dst[0], (A*src[0] + B*src[1] + C*src[stride+0] + D*src[stride+1]));\
-        OP(dst[1], (A*src[1] + B*src[2] + C*src[stride+1] + D*src[stride+2]));\
-        OP(dst[2], (A*src[2] + B*src[3] + C*src[stride+2] + D*src[stride+3]));\
-        OP(dst[3], (A*src[3] + B*src[4] + C*src[stride+3] + D*src[stride+4]));\
-        dst+= stride;\
-        src+= stride;\
+    if(D){\
+        for(i=0; i<h; i++){\
+            OP(dst[0], (A*src[0] + B*src[1] + C*src[stride+0] + D*src[stride+1]));\
+            OP(dst[1], (A*src[1] + B*src[2] + C*src[stride+1] + D*src[stride+2]));\
+            OP(dst[2], (A*src[2] + B*src[3] + C*src[stride+2] + D*src[stride+3]));\
+            OP(dst[3], (A*src[3] + B*src[4] + C*src[stride+3] + D*src[stride+4]));\
+            dst+= stride;\
+            src+= stride;\
+        }\
+    }else{\
+        const int E= B+C;\
+        const int step= C ? stride : 1;\
+        for(i=0; i<h; i++){\
+            OP(dst[0], (A*src[0] + E*src[step+0]));\
+            OP(dst[1], (A*src[1] + E*src[step+1]));\
+            OP(dst[2], (A*src[2] + E*src[step+2]));\
+            OP(dst[3], (A*src[3] + E*src[step+3]));\
+            dst+= stride;\
+            src+= stride;\
+        }\
     }\
 }\
 \
@@ -1478,18 +1500,34 @@
     \
     assert(x<8 && y<8 && x>=0 && y>=0);\
 \
-    for(i=0; i<h; i++)\
-    {\
-        OP(dst[0], (A*src[0] + B*src[1] + C*src[stride+0] + D*src[stride+1]));\
-        OP(dst[1], (A*src[1] + B*src[2] + C*src[stride+1] + D*src[stride+2]));\
-        OP(dst[2], (A*src[2] + B*src[3] + C*src[stride+2] + D*src[stride+3]));\
-        OP(dst[3], (A*src[3] + B*src[4] + C*src[stride+3] + D*src[stride+4]));\
-        OP(dst[4], (A*src[4] + B*src[5] + C*src[stride+4] + D*src[stride+5]));\
-        OP(dst[5], (A*src[5] + B*src[6] + C*src[stride+5] + D*src[stride+6]));\
-        OP(dst[6], (A*src[6] + B*src[7] + C*src[stride+6] + D*src[stride+7]));\
-        OP(dst[7], (A*src[7] + B*src[8] + C*src[stride+7] + D*src[stride+8]));\
-        dst+= stride;\
-        src+= stride;\
+    if(D){\
+        for(i=0; i<h; i++){\
+            OP(dst[0], (A*src[0] + B*src[1] + C*src[stride+0] + D*src[stride+1]));\
+            OP(dst[1], (A*src[1] + B*src[2] + C*src[stride+1] + D*src[stride+2]));\
+            OP(dst[2], (A*src[2] + B*src[3] + C*src[stride+2] + D*src[stride+3]));\
+            OP(dst[3], (A*src[3] + B*src[4] + C*src[stride+3] + D*src[stride+4]));\
+            OP(dst[4], (A*src[4] + B*src[5] + C*src[stride+4] + D*src[stride+5]));\
+            OP(dst[5], (A*src[5] + B*src[6] + C*src[stride+5] + D*src[stride+6]));\
+            OP(dst[6], (A*src[6] + B*src[7] + C*src[stride+6] + D*src[stride+7]));\
+            OP(dst[7], (A*src[7] + B*src[8] + C*src[stride+7] + D*src[stride+8]));\
+            dst+= stride;\
+            src+= stride;\
+        }\
+    }else{\
+        const int E= B+C;\
+        const int step= C ? stride : 1;\
+        for(i=0; i<h; i++){\
+            OP(dst[0], (A*src[0] + E*src[step+0]));\
+            OP(dst[1], (A*src[1] + E*src[step+1]));\
+            OP(dst[2], (A*src[2] + E*src[step+2]));\
+            OP(dst[3], (A*src[3] + E*src[step+3]));\
+            OP(dst[4], (A*src[4] + E*src[step+4]));\
+            OP(dst[5], (A*src[5] + E*src[step+5]));\
+            OP(dst[6], (A*src[6] + E*src[step+6]));\
+            OP(dst[7], (A*src[7] + E*src[step+7]));\
+            dst+= stride;\
+            src+= stride;\
+        }\
     }\
 }
 
@@ -2561,10 +2599,10 @@
 }
 #endif /* CONFIG_VC1_DECODER||CONFIG_WMV3_DECODER */
 
-#if defined(CONFIG_H264_ENCODER)
+void ff_intrax8dsp_init(DSPContext* c, AVCodecContext *avctx);
+
 /* H264 specific */
 void ff_h264dspenc_init(DSPContext* c, AVCodecContext *avctx);
-#endif /* CONFIG_H264_ENCODER */
 
 static void wmv2_mspel8_v_lowpass(uint8_t *dst, uint8_t *src, int dstStride, int srcStride, int w){
     uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
@@ -3497,7 +3535,7 @@
 
     s->block_last_index[0/*FIXME*/]= s->fast_dct_quantize(s, temp, 0/*FIXME*/, s->qscale, &i);
     s->dct_unquantize_inter(s, temp, 0, s->qscale);
-    simple_idct(temp); //FIXME
+    ff_simple_idct(temp); //FIXME
 
     for(i=0; i<64; i++)
         sum+= (temp[i]-bak[i])*(temp[i]-bak[i]);
@@ -3714,16 +3752,16 @@
     return score;
 }
 
-WARPER8_16_SQ(hadamard8_diff8x8_c, hadamard8_diff16_c)
-WARPER8_16_SQ(hadamard8_intra8x8_c, hadamard8_intra16_c)
-WARPER8_16_SQ(dct_sad8x8_c, dct_sad16_c)
+WRAPPER8_16_SQ(hadamard8_diff8x8_c, hadamard8_diff16_c)
+WRAPPER8_16_SQ(hadamard8_intra8x8_c, hadamard8_intra16_c)
+WRAPPER8_16_SQ(dct_sad8x8_c, dct_sad16_c)
 #ifdef CONFIG_GPL
-WARPER8_16_SQ(dct264_sad8x8_c, dct264_sad16_c)
+WRAPPER8_16_SQ(dct264_sad8x8_c, dct264_sad16_c)
 #endif
-WARPER8_16_SQ(dct_max8x8_c, dct_max16_c)
-WARPER8_16_SQ(quant_psnr8x8_c, quant_psnr16_c)
-WARPER8_16_SQ(rd8x8_c, rd16_c)
-WARPER8_16_SQ(bit8x8_c, bit16_c)
+WRAPPER8_16_SQ(dct_max8x8_c, dct_max16_c)
+WRAPPER8_16_SQ(quant_psnr8x8_c, quant_psnr16_c)
+WRAPPER8_16_SQ(rd8x8_c, rd16_c)
+WRAPPER8_16_SQ(bit8x8_c, bit16_c)
 
 static void vector_fmul_c(float *dst, const float *src, int len){
     int i;
@@ -3747,7 +3785,7 @@
 void ff_float_to_int16_c(int16_t *dst, const float *src, int len){
     int i;
     for(i=0; i<len; i++) {
-        int_fast32_t tmp = ((int32_t*)src)[i];
+        int_fast32_t tmp = ((const int32_t*)src)[i];
         if(tmp & 0xf0000){
             tmp = (0x43c0ffff - tmp)>>31;
             // is this faster on some gcc/cpu combinations?
@@ -3758,8 +3796,90 @@
     }
 }
 
+#define W0 2048
+#define W1 2841 /* 2048*sqrt (2)*cos (1*pi/16) */
+#define W2 2676 /* 2048*sqrt (2)*cos (2*pi/16) */
+#define W3 2408 /* 2048*sqrt (2)*cos (3*pi/16) */
+#define W4 2048 /* 2048*sqrt (2)*cos (4*pi/16) */
+#define W5 1609 /* 2048*sqrt (2)*cos (5*pi/16) */
+#define W6 1108 /* 2048*sqrt (2)*cos (6*pi/16) */
+#define W7 565  /* 2048*sqrt (2)*cos (7*pi/16) */
+
+static void wmv2_idct_row(short * b)
+{
+    int s1,s2;
+    int a0,a1,a2,a3,a4,a5,a6,a7;
+    /*step 1*/
+    a1 = W1*b[1]+W7*b[7];
+    a7 = W7*b[1]-W1*b[7];
+    a5 = W5*b[5]+W3*b[3];
+    a3 = W3*b[5]-W5*b[3];
+    a2 = W2*b[2]+W6*b[6];
+    a6 = W6*b[2]-W2*b[6];
+    a0 = W0*b[0]+W0*b[4];
+    a4 = W0*b[0]-W0*b[4];
+    /*step 2*/
+    s1 = (181*(a1-a5+a7-a3)+128)>>8;//1,3,5,7,
+    s2 = (181*(a1-a5-a7+a3)+128)>>8;
+    /*step 3*/
+    b[0] = (a0+a2+a1+a5 + (1<<7))>>8;
+    b[1] = (a4+a6 +s1   + (1<<7))>>8;
+    b[2] = (a4-a6 +s2   + (1<<7))>>8;
+    b[3] = (a0-a2+a7+a3 + (1<<7))>>8;
+    b[4] = (a0-a2-a7-a3 + (1<<7))>>8;
+    b[5] = (a4-a6 -s2   + (1<<7))>>8;
+    b[6] = (a4+a6 -s1   + (1<<7))>>8;
+    b[7] = (a0+a2-a1-a5 + (1<<7))>>8;
+}
+static void wmv2_idct_col(short * b)
+{
+    int s1,s2;
+    int a0,a1,a2,a3,a4,a5,a6,a7;
+    /*step 1, with extended precision*/
+    a1 = (W1*b[8*1]+W7*b[8*7] + 4)>>3;
+    a7 = (W7*b[8*1]-W1*b[8*7] + 4)>>3;
+    a5 = (W5*b[8*5]+W3*b[8*3] + 4)>>3;
+    a3 = (W3*b[8*5]-W5*b[8*3] + 4)>>3;
+    a2 = (W2*b[8*2]+W6*b[8*6] + 4)>>3;
+    a6 = (W6*b[8*2]-W2*b[8*6] + 4)>>3;
+    a0 = (W0*b[8*0]+W0*b[8*4]    )>>3;
+    a4 = (W0*b[8*0]-W0*b[8*4]    )>>3;
+    /*step 2*/
+    s1 = (181*(a1-a5+a7-a3)+128)>>8;
+    s2 = (181*(a1-a5-a7+a3)+128)>>8;
+    /*step 3*/
+    b[8*0] = (a0+a2+a1+a5 + (1<<13))>>14;
+    b[8*1] = (a4+a6 +s1   + (1<<13))>>14;
+    b[8*2] = (a4-a6 +s2   + (1<<13))>>14;
+    b[8*3] = (a0-a2+a7+a3 + (1<<13))>>14;
+
+    b[8*4] = (a0-a2-a7-a3 + (1<<13))>>14;
+    b[8*5] = (a4-a6 -s2   + (1<<13))>>14;
+    b[8*6] = (a4+a6 -s1   + (1<<13))>>14;
+    b[8*7] = (a0+a2-a1-a5 + (1<<13))>>14;
+}
+void ff_wmv2_idct_c(short * block){
+    int i;
+
+    for(i=0;i<64;i+=8){
+        wmv2_idct_row(block+i);
+    }
+    for(i=0;i<8;i++){
+        wmv2_idct_col(block+i);
+    }
+}
 /* XXX: those functions should be suppressed ASAP when all IDCTs are
  converted */
+static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)
+{
+    ff_wmv2_idct_c(block);
+    put_pixels_clamped_c(block, dest, line_size);
+}
+static void ff_wmv2_idct_add_c(uint8_t *dest, int line_size, DCTELEM *block)
+{
+    ff_wmv2_idct_c(block);
+    add_pixels_clamped_c(block, dest, line_size);
+}
 static void ff_jref_idct_put(uint8_t *dest, int line_size, DCTELEM *block)
 {
     j_rev_dct (block);
@@ -3899,10 +4019,15 @@
             c->idct_add= ff_vp3_idct_add_c;
             c->idct    = ff_vp3_idct_c;
             c->idct_permutation_type= FF_NO_IDCT_PERM;
+        }else if(avctx->idct_algo==FF_IDCT_WMV2){
+            c->idct_put= ff_wmv2_idct_put_c;
+            c->idct_add= ff_wmv2_idct_add_c;
+            c->idct    = ff_wmv2_idct_c;
+            c->idct_permutation_type= FF_NO_IDCT_PERM;
         }else{ //accurate/default
-            c->idct_put= simple_idct_put;
-            c->idct_add= simple_idct_add;
-            c->idct    = simple_idct;
+            c->idct_put= ff_simple_idct_put;
+            c->idct_add= ff_simple_idct_add;
+            c->idct    = ff_simple_idct;
             c->idct_permutation_type= FF_NO_IDCT_PERM;
         }
     }
@@ -4056,6 +4181,9 @@
 #if defined(CONFIG_VC1_DECODER) || defined(CONFIG_WMV3_DECODER)
     ff_vc1dsp_init(c,avctx);
 #endif
+#if defined(CONFIG_WMV2_DECODER) || defined(CONFIG_VC1_DECODER) || defined(CONFIG_WMV3_DECODER)
+    ff_intrax8dsp_init(c,avctx);
+#endif
 #if defined(CONFIG_H264_ENCODER)
     ff_h264dspenc_init(c,avctx);
 #endif
diff -u mplayer-1.0~rc2-12/libavcodec/dsputil.h ffmpeg-free-0.svn20080206/libavcodec/dsputil.h
--- mplayer-1.0~rc2-12/libavcodec/dsputil.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dsputil.h	2008-02-01 14:49:15.000000000 +0100
@@ -27,8 +27,8 @@
  * absolutely necessary to call emms_c() between dsp & float/double code
  */
 
-#ifndef DSPUTIL_H
-#define DSPUTIL_H
+#ifndef FFMPEG_DSPUTIL_H
+#define FFMPEG_DSPUTIL_H
 
 #include "avcodec.h"
 
@@ -48,6 +48,7 @@
 void j_rev_dct4 (DCTELEM *data);
 void j_rev_dct2 (DCTELEM *data);
 void j_rev_dct1 (DCTELEM *data);
+void ff_wmv2_idct_c(DCTELEM *data);
 
 void ff_fdct_mmx(DCTELEM *block);
 void ff_fdct_mmx2(DCTELEM *block);
@@ -309,7 +310,7 @@
      * note, this might read from src1[-1], src2[-1]
      */
     void (*sub_hfyu_median_prediction)(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w, int *left, int *left_top);
-    void (*bswap_buf)(uint32_t *dst, uint32_t *src, int w);
+    void (*bswap_buf)(uint32_t *dst, const uint32_t *src, int w);
 
     void (*h264_v_loop_filter_luma)(uint8_t *pix, int stride, int alpha, int beta, int8_t *tc0);
     void (*h264_h_loop_filter_luma)(uint8_t *pix, int stride, int alpha, int beta, int8_t *tc0);
@@ -326,6 +327,9 @@
 
     void (*h261_loop_filter)(uint8_t *src, int stride);
 
+    void (*x8_v_loop_filter)(uint8_t *src, int stride, int qscale);
+    void (*x8_h_loop_filter)(uint8_t *src, int stride, int qscale);
+
     /* assume len is a multiple of 4, and arrays are 16-byte aligned */
     void (*vorbis_inverse_coupling)(float *mag, float *ang, int blocksize);
     /* no alignment needed */
@@ -403,15 +407,21 @@
 
     /* vc1 functions */
     void (*vc1_inv_trans_8x8)(DCTELEM *b);
-    void (*vc1_inv_trans_8x4)(DCTELEM *b, int n);
-    void (*vc1_inv_trans_4x8)(DCTELEM *b, int n);
-    void (*vc1_inv_trans_4x4)(DCTELEM *b, int n);
+    void (*vc1_inv_trans_8x4)(uint8_t *dest, int line_size, DCTELEM *block);
+    void (*vc1_inv_trans_4x8)(uint8_t *dest, int line_size, DCTELEM *block);
+    void (*vc1_inv_trans_4x4)(uint8_t *dest, int line_size, DCTELEM *block);
     void (*vc1_v_overlap)(uint8_t* src, int stride);
     void (*vc1_h_overlap)(uint8_t* src, int stride);
     /* put 8x8 block with bicubic interpolation and quarterpel precision
      * last argument is actually round value instead of height
      */
     op_pixels_func put_vc1_mspel_pixels_tab[16];
+
+    /* intrax8 functions */
+    void (*x8_spatial_compensation[12])(uint8_t *src , uint8_t *dst, int linesize);
+    void (*x8_setup_spatial_compensation)(uint8_t *src, uint8_t *dst, int linesize,
+           int * range, int * sum,  int edges);
+
 } DSPContext;
 
 void dsputil_static_init(void);
@@ -635,6 +645,14 @@
     FFTContext fft;
 } MDCTContext;
 
+/**
+ * Generate a Kaiser-Bessel Derived Window.
+ * @param   window  pointer to half window
+ * @param   alpha   determines window shape
+ * @param   n       size of half window
+ */
+void ff_kbd_window_init(float *window, float alpha, int n);
+
 int ff_mdct_init(MDCTContext *s, int nbits, int inverse);
 void ff_imdct_calc(MDCTContext *s, FFTSample *output,
                 const FFTSample *input, FFTSample *tmp);
@@ -646,13 +664,13 @@
                const FFTSample *input, FFTSample *tmp);
 void ff_mdct_end(MDCTContext *s);
 
-#define WARPER8_16(name8, name16)\
+#define WRAPPER8_16(name8, name16)\
 static int name16(void /*MpegEncContext*/ *s, uint8_t *dst, uint8_t *src, int stride, int h){\
     return name8(s, dst           , src           , stride, h)\
           +name8(s, dst+8         , src+8         , stride, h);\
 }
 
-#define WARPER8_16_SQ(name8, name16)\
+#define WRAPPER8_16_SQ(name8, name16)\
 static int name16(void /*MpegEncContext*/ *s, uint8_t *dst, uint8_t *src, int stride, int h){\
     int score=0;\
     score +=name8(s, dst           , src           , stride, 8);\
@@ -743,4 +761,4 @@
     }
 }
 
-#endif
+#endif /* FFMPEG_DSPUTIL_H */
diff -u mplayer-1.0~rc2-12/libavcodec/dvbsub.c ffmpeg-free-0.svn20080206/libavcodec/dvbsub.c
--- mplayer-1.0~rc2-12/libavcodec/dvbsub.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dvbsub.c	2008-03-20 19:10:57.000000000 +0100
@@ -390,16 +390,6 @@
     return q - outbuf;
 }
 
-static int dvbsub_init_decoder(AVCodecContext *avctx)
-{
-    return 0;
-}
-
-static int dvbsub_close_decoder(AVCodecContext *avctx)
-{
-    return 0;
-}
-
 static int dvbsub_encode(AVCodecContext *avctx,
                        unsigned char *buf, int buf_size, void *data)
 {
@@ -416,7 +406,6 @@
     CODEC_TYPE_SUBTITLE,
     CODEC_ID_DVB_SUBTITLE,
     sizeof(DVBSubtitleContext),
-    dvbsub_init_decoder,
+    NULL,
     dvbsub_encode,
-    dvbsub_close_decoder,
 };
diff -u mplayer-1.0~rc2-12/libavcodec/dvbsubdec.c ffmpeg-free-0.svn20080206/libavcodec/dvbsubdec.c
--- mplayer-1.0~rc2-12/libavcodec/dvbsubdec.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dvbsubdec.c	2008-03-20 19:10:58.000000000 +0100
@@ -102,7 +102,7 @@
     char fname[40], fname2[40];
     char command[1024];
 
-    snprintf(fname, 40, "%s.ppm", filename);
+    snprintf(fname, sizeof(fname), "%s.ppm", filename);
 
     f = fopen(fname, "w");
     if (!f) {
@@ -124,7 +124,7 @@
     fclose(f);
 
 
-    snprintf(fname2, 40, "%s-a.pgm", filename);
+    snprintf(fname2, sizeof(fname2), "%s-a.pgm", filename);
 
     f = fopen(fname2, "w");
     if (!f) {
@@ -143,10 +143,10 @@
     }
     fclose(f);
 
-    snprintf(command, 1024, "pnmtopng -alpha %s %s > %s.png 2> /dev/null", fname2, fname, filename);
+    snprintf(command, sizeof(command), "pnmtopng -alpha %s %s > %s.png 2> /dev/null", fname2, fname, filename);
     system(command);
 
-    snprintf(command, 1024, "rm %s %s", fname, fname2);
+    snprintf(command, sizeof(command), "rm %s %s", fname, fname2);
     system(command);
 }
 #endif
@@ -172,8 +172,8 @@
     int x_pos;
     int y_pos;
 
-    int fgcolour;
-    int bgcolour;
+    int fgcolor;
+    int bgcolor;
 
     struct DVBSubObjectDisplay *region_list_next;
     struct DVBSubObjectDisplay *object_list_next;
@@ -206,7 +206,7 @@
     int depth;
 
     int clut;
-    int bgcolour;
+    int bgcolor;
 
     uint8_t *pbuf;
     int buf_size;
@@ -234,7 +234,7 @@
 {
     DVBSubObject *ptr = ctx->object_list;
 
-    while (ptr != NULL && ptr->id != object_id) {
+    while (ptr && ptr->id != object_id) {
         ptr = ptr->next;
     }
 
@@ -245,7 +245,7 @@
 {
     DVBSubCLUT *ptr = ctx->clut_list;
 
-    while (ptr != NULL && ptr->id != clut_id) {
+    while (ptr && ptr->id != clut_id) {
         ptr = ptr->next;
     }
 
@@ -256,7 +256,7 @@
 {
     DVBSubRegion *ptr = ctx->region_list;
 
-    while (ptr != NULL && ptr->id != region_id) {
+    while (ptr && ptr->id != region_id) {
         ptr = ptr->next;
     }
 
@@ -268,16 +268,16 @@
     DVBSubObject *object, *obj2, **obj2_ptr;
     DVBSubObjectDisplay *display, *obj_disp, **obj_disp_ptr;
 
-    while (region->display_list != NULL) {
+    while (region->display_list) {
         display = region->display_list;
 
         object = get_object(ctx, display->object_id);
 
-        if (object != NULL) {
+        if (object) {
             obj_disp = object->display_list;
             obj_disp_ptr = &object->display_list;
 
-            while (obj_disp != NULL && obj_disp != display) {
+            while (obj_disp && obj_disp != display) {
                 obj_disp_ptr = &obj_disp->object_list_next;
                 obj_disp = obj_disp->object_list_next;
             }
@@ -285,11 +285,11 @@
             if (obj_disp) {
                 *obj_disp_ptr = obj_disp->object_list_next;
 
-                if (object->display_list == NULL) {
+                if (!object->display_list) {
                     obj2 = ctx->object_list;
                     obj2_ptr = &ctx->object_list;
 
-                    while (obj2 != NULL && obj2 != object) {
+                    while (obj2 && obj2 != object) {
                         obj2_ptr = &obj2->next;
                         obj2 = obj2->next;
                     }
@@ -313,21 +313,19 @@
     DVBSubRegion *region;
     DVBSubCLUT *clut;
 
-    while (ctx->region_list != NULL)
-    {
+    while (ctx->region_list) {
         region = ctx->region_list;
 
         ctx->region_list = region->next;
 
         delete_region_display_list(ctx, region);
-        if (region->pbuf != NULL)
+        if (region->pbuf)
             av_free(region->pbuf);
 
         av_free(region);
     }
 
-    while (ctx->clut_list != NULL)
-    {
+    while (ctx->clut_list) {
         clut = ctx->clut_list;
 
         ctx->clut_list = clut->next;
@@ -336,7 +334,7 @@
     }
 
     /* Should already be null */
-    if (ctx->object_list != NULL)
+    if (ctx->object_list)
         av_log(0, AV_LOG_ERROR, "Memory deallocation error!\n");
 }
 
@@ -420,8 +418,7 @@
 
     delete_state(ctx);
 
-    while (ctx->display_list != NULL)
-    {
+    while (ctx->display_list) {
         display = ctx->display_list;
         ctx->display_list = display->next;
 
@@ -432,7 +429,7 @@
 }
 
 static int dvbsub_read_2bit_string(uint8_t *destbuf, int dbuf_len,
-                                   uint8_t **srcbuf, int buf_size,
+                                   const uint8_t **srcbuf, int buf_size,
                                    int non_mod, uint8_t *map_table)
 {
     GetBitContext gb;
@@ -446,9 +443,9 @@
     while (get_bits_count(&gb) < (buf_size << 8) && pixels_read < dbuf_len) {
         bits = get_bits(&gb, 2);
 
-        if (bits != 0) {
+        if (bits) {
             if (non_mod != 1 || bits != 1) {
-                if (map_table != NULL)
+                if (map_table)
                     *destbuf++ = map_table[bits];
                 else
                     *destbuf++ = bits;
@@ -463,7 +460,7 @@
                 if (non_mod == 1 && bits == 1)
                     pixels_read += run_length;
                 else {
-                    if (map_table != NULL)
+                    if (map_table)
                         bits = map_table[bits];
                     while (run_length-- > 0 && pixels_read < dbuf_len) {
                         *destbuf++ = bits;
@@ -481,7 +478,7 @@
                         if (non_mod == 1 && bits == 1)
                             pixels_read += run_length;
                         else {
-                            if (map_table != NULL)
+                            if (map_table)
                                 bits = map_table[bits];
                             while (run_length-- > 0 && pixels_read < dbuf_len) {
                                 *destbuf++ = bits;
@@ -495,7 +492,7 @@
                         if (non_mod == 1 && bits == 1)
                             pixels_read += run_length;
                         else {
-                            if (map_table != NULL)
+                            if (map_table)
                                 bits = map_table[bits];
                             while (run_length-- > 0 && pixels_read < dbuf_len) {
                                 *destbuf++ = bits;
@@ -504,7 +501,7 @@
                         }
                     } else if (bits == 1) {
                         pixels_read += 2;
-                        if (map_table != NULL)
+                        if (map_table)
                             bits = map_table[0];
                         else
                             bits = 0;
@@ -517,7 +514,7 @@
                         return pixels_read;
                     }
                 } else {
-                    if (map_table != NULL)
+                    if (map_table)
                         bits = map_table[0];
                     else
                         bits = 0;
@@ -528,7 +525,7 @@
         }
     }
 
-    if (get_bits(&gb, 6) != 0)
+    if (get_bits(&gb, 6))
         av_log(0, AV_LOG_ERROR, "DVBSub error: line overflow\n");
 
     (*srcbuf) += (get_bits_count(&gb) + 7) >> 3;
@@ -537,7 +534,7 @@
 }
 
 static int dvbsub_read_4bit_string(uint8_t *destbuf, int dbuf_len,
-                                   uint8_t **srcbuf, int buf_size,
+                                   const uint8_t **srcbuf, int buf_size,
                                    int non_mod, uint8_t *map_table)
 {
     GetBitContext gb;
@@ -551,9 +548,9 @@
     while (get_bits_count(&gb) < (buf_size << 8) && pixels_read < dbuf_len) {
         bits = get_bits(&gb, 4);
 
-        if (bits != 0) {
+        if (bits) {
             if (non_mod != 1 || bits != 1) {
-                if (map_table != NULL)
+                if (map_table)
                     *destbuf++ = map_table[bits];
                 else
                     *destbuf++ = bits;
@@ -571,7 +568,7 @@
 
                 run_length += 2;
 
-                if (map_table != NULL)
+                if (map_table)
                     bits = map_table[0];
                 else
                     bits = 0;
@@ -589,7 +586,7 @@
                     if (non_mod == 1 && bits == 1)
                         pixels_read += run_length;
                     else {
-                        if (map_table != NULL)
+                        if (map_table)
                             bits = map_table[bits];
                         while (run_length-- > 0 && pixels_read < dbuf_len) {
                             *destbuf++ = bits;
@@ -605,7 +602,7 @@
                         if (non_mod == 1 && bits == 1)
                             pixels_read += run_length;
                         else {
-                            if (map_table != NULL)
+                            if (map_table)
                                 bits = map_table[bits];
                             while (run_length-- > 0 && pixels_read < dbuf_len) {
                                 *destbuf++ = bits;
@@ -619,7 +616,7 @@
                         if (non_mod == 1 && bits == 1)
                             pixels_read += run_length;
                         else {
-                            if (map_table != NULL)
+                            if (map_table)
                                 bits = map_table[bits];
                             while (run_length-- > 0 && pixels_read < dbuf_len) {
                                 *destbuf++ = bits;
@@ -628,7 +625,7 @@
                         }
                     } else if (bits == 1) {
                         pixels_read += 2;
-                        if (map_table != NULL)
+                        if (map_table)
                             bits = map_table[0];
                         else
                             bits = 0;
@@ -637,7 +634,7 @@
                             *destbuf++ = bits;
                         }
                     } else {
-                        if (map_table != NULL)
+                        if (map_table)
                             bits = map_table[0];
                         else
                             bits = 0;
@@ -649,7 +646,7 @@
         }
     }
 
-    if (get_bits(&gb, 8) != 0)
+    if (get_bits(&gb, 8))
         av_log(0, AV_LOG_ERROR, "DVBSub error: line overflow\n");
 
     (*srcbuf) += (get_bits_count(&gb) + 7) >> 3;
@@ -658,10 +655,10 @@
 }
 
 static int dvbsub_read_8bit_string(uint8_t *destbuf, int dbuf_len,
-                                    uint8_t **srcbuf, int buf_size,
+                                    const uint8_t **srcbuf, int buf_size,
                                     int non_mod, uint8_t *map_table)
 {
-    uint8_t *sbuf_end = (*srcbuf) + buf_size;
+    const uint8_t *sbuf_end = (*srcbuf) + buf_size;
     int bits;
     int run_length;
     int pixels_read = 0;
@@ -669,9 +666,9 @@
     while (*srcbuf < sbuf_end && pixels_read < dbuf_len) {
         bits = *(*srcbuf)++;
 
-        if (bits != 0) {
+        if (bits) {
             if (non_mod != 1 || bits != 1) {
-                if (map_table != NULL)
+                if (map_table)
                     *destbuf++ = map_table[bits];
                 else
                     *destbuf++ = bits;
@@ -685,7 +682,7 @@
                     return pixels_read;
                 }
 
-                if (map_table != NULL)
+                if (map_table)
                     bits = map_table[0];
                 else
                     bits = 0;
@@ -698,7 +695,7 @@
 
                 if (non_mod == 1 && bits == 1)
                     pixels_read += run_length;
-                if (map_table != NULL)
+                if (map_table)
                     bits = map_table[bits];
                 else while (run_length-- > 0 && pixels_read < dbuf_len) {
                     *destbuf++ = bits;
@@ -708,7 +705,7 @@
         }
     }
 
-    if (*(*srcbuf)++ != 0)
+    if (*(*srcbuf)++)
         av_log(0, AV_LOG_ERROR, "DVBSub error: line overflow\n");
 
     return pixels_read;
@@ -717,12 +714,12 @@
 
 
 static void dvbsub_parse_pixel_data_block(AVCodecContext *avctx, DVBSubObjectDisplay *display,
-                                          uint8_t *buf, int buf_size, int top_bottom, int non_mod)
+                                          const uint8_t *buf, int buf_size, int top_bottom, int non_mod)
 {
     DVBSubContext *ctx = (DVBSubContext*) avctx->priv_data;
 
     DVBSubRegion *region = get_region(ctx, display->region_id);
-    uint8_t *buf_end = buf + buf_size;
+    const uint8_t *buf_end = buf + buf_size;
     uint8_t *pbuf;
     int x_pos, y_pos;
     int i;
@@ -739,8 +736,7 @@
 #endif
 
 #ifdef DEBUG_PACKET_CONTENTS
-    for (i = 0; i < buf_size; i++)
-    {
+    for (i = 0; i < buf_size; i++) {
         if (i % 16 == 0)
             av_log(avctx, AV_LOG_INFO, "0x%08p: ", buf+i);
 
@@ -749,7 +745,7 @@
             av_log(avctx, AV_LOG_INFO, "\n");
     }
 
-    if (i % 16 != 0)
+    if (i % 16)
         av_log(avctx, AV_LOG_INFO, "\n");
 
 #endif
@@ -837,18 +833,18 @@
 }
 
 static void dvbsub_parse_object_segment(AVCodecContext *avctx,
-                                        uint8_t *buf, int buf_size)
+                                        const uint8_t *buf, int buf_size)
 {
     DVBSubContext *ctx = (DVBSubContext*) avctx->priv_data;
 
-    uint8_t *buf_end = buf + buf_size;
-    uint8_t *block;
+    const uint8_t *buf_end = buf + buf_size;
+    const uint8_t *block;
     int object_id;
     DVBSubObject *object;
     DVBSubObjectDisplay *display;
     int top_field_len, bottom_field_len;
 
-    int coding_method, non_modifying_colour;
+    int coding_method, non_modifying_color;
 
     object_id = AV_RB16(buf);
     buf += 2;
@@ -859,7 +855,7 @@
         return;
 
     coding_method = ((*buf) >> 2) & 3;
-    non_modifying_colour = ((*buf++) >> 1) & 1;
+    non_modifying_color = ((*buf++) >> 1) & 1;
 
     if (coding_method == 0) {
         top_field_len = AV_RB16(buf);
@@ -872,11 +868,11 @@
             return;
         }
 
-        for (display = object->display_list; display != 0; display = display->object_list_next) {
+        for (display = object->display_list; display; display = display->object_list_next) {
             block = buf;
 
             dvbsub_parse_pixel_data_block(avctx, display, block, top_field_len, 0,
-                                            non_modifying_colour);
+                                            non_modifying_color);
 
             if (bottom_field_len > 0)
                 block = buf + top_field_len;
@@ -884,7 +880,7 @@
                 bottom_field_len = top_field_len;
 
             dvbsub_parse_pixel_data_block(avctx, display, block, bottom_field_len, 1,
-                                            non_modifying_colour);
+                                            non_modifying_color);
         }
 
 /*  } else if (coding_method == 1) {*/
@@ -896,11 +892,11 @@
 }
 
 static void dvbsub_parse_clut_segment(AVCodecContext *avctx,
-                                        uint8_t *buf, int buf_size)
+                                        const uint8_t *buf, int buf_size)
 {
     DVBSubContext *ctx = (DVBSubContext*) avctx->priv_data;
 
-    uint8_t *buf_end = buf + buf_size;
+    const uint8_t *buf_end = buf + buf_size;
     int clut_id;
     DVBSubCLUT *clut;
     int entry_id, depth , full_range;
@@ -912,14 +908,13 @@
 
     av_log(avctx, AV_LOG_INFO, "DVB clut packet:\n");
 
-    for (i=0; i < buf_size; i++)
-    {
+    for (i=0; i < buf_size; i++) {
         av_log(avctx, AV_LOG_INFO, "%02x ", buf[i]);
         if (i % 16 == 15)
             av_log(avctx, AV_LOG_INFO, "\n");
     }
 
-    if (i % 16 != 0)
+    if (i % 16)
         av_log(avctx, AV_LOG_INFO, "\n");
 
 #endif
@@ -929,7 +924,7 @@
 
     clut = get_clut(ctx, clut_id);
 
-    if (clut == NULL) {
+    if (!clut) {
         clut = av_malloc(sizeof(DVBSubCLUT));
 
         memcpy(clut, &default_clut, sizeof(DVBSubCLUT));
@@ -940,8 +935,7 @@
         ctx->clut_list = clut;
     }
 
-    while (buf + 4 < buf_end)
-    {
+    while (buf + 4 < buf_end) {
         entry_id = *buf++;
 
         depth = (*buf) & 0xe0;
@@ -988,11 +982,11 @@
 
 
 static void dvbsub_parse_region_segment(AVCodecContext *avctx,
-                                        uint8_t *buf, int buf_size)
+                                        const uint8_t *buf, int buf_size)
 {
     DVBSubContext *ctx = (DVBSubContext*) avctx->priv_data;
 
-    uint8_t *buf_end = buf + buf_size;
+    const uint8_t *buf_end = buf + buf_size;
     int region_id, object_id;
     DVBSubRegion *region;
     DVBSubObject *object;
@@ -1006,8 +1000,7 @@
 
     region = get_region(ctx, region_id);
 
-    if (region == NULL)
-    {
+    if (!region) {
         region = av_mallocz(sizeof(DVBSubRegion));
 
         region->id = region_id;
@@ -1024,7 +1017,7 @@
     buf += 2;
 
     if (region->width * region->height != region->buf_size) {
-        if (region->pbuf != 0)
+        if (region->pbuf)
             av_free(region->pbuf);
 
         region->buf_size = region->width * region->height;
@@ -1035,17 +1028,21 @@
     }
 
     region->depth = 1 << (((*buf++) >> 2) & 7);
+    if(region->depth<2 || region->depth>8){
+        av_log(avctx, AV_LOG_ERROR, "region depth %d is invalid\n", region->depth);
+        region->depth= 4;
+    }
     region->clut = *buf++;
 
     if (region->depth == 8)
-        region->bgcolour = *buf++;
+        region->bgcolor = *buf++;
     else {
         buf += 1;
 
         if (region->depth == 4)
-            region->bgcolour = (((*buf++) >> 4) & 15);
+            region->bgcolor = (((*buf++) >> 4) & 15);
         else
-            region->bgcolour = (((*buf++) >> 2) & 3);
+            region->bgcolor = (((*buf++) >> 2) & 3);
     }
 
 #ifdef DEBUG
@@ -1053,9 +1050,9 @@
 #endif
 
     if (fill) {
-        memset(region->pbuf, region->bgcolour, region->buf_size);
+        memset(region->pbuf, region->bgcolor, region->buf_size);
 #ifdef DEBUG
-        av_log(avctx, AV_LOG_INFO, "Fill region (%d)\n", region->bgcolour);
+        av_log(avctx, AV_LOG_INFO, "Fill region (%d)\n", region->bgcolor);
 #endif
     }
 
@@ -1067,7 +1064,7 @@
 
         object = get_object(ctx, object_id);
 
-        if (object == NULL) {
+        if (!object) {
             object = av_mallocz(sizeof(DVBSubObject));
 
             object->id = object_id;
@@ -1088,8 +1085,8 @@
         buf += 2;
 
         if ((object->type == 1 || object->type == 2) && buf+1 < buf_end) {
-            display->fgcolour = *buf++;
-            display->bgcolour = *buf++;
+            display->fgcolor = *buf++;
+            display->bgcolor = *buf++;
         }
 
         display->region_list_next = region->display_list;
@@ -1101,13 +1098,13 @@
 }
 
 static void dvbsub_parse_page_segment(AVCodecContext *avctx,
-                                        uint8_t *buf, int buf_size)
+                                        const uint8_t *buf, int buf_size)
 {
     DVBSubContext *ctx = (DVBSubContext*) avctx->priv_data;
     DVBSubRegionDisplay *display;
     DVBSubRegionDisplay *tmp_display_list, **tmp_ptr;
 
-    uint8_t *buf_end = buf + buf_size;
+    const uint8_t *buf_end = buf + buf_size;
     int region_id;
     int page_state;
 
@@ -1121,8 +1118,7 @@
     av_log(avctx, AV_LOG_INFO, "Page time out %ds, state %d\n", ctx->time_out, page_state);
 #endif
 
-    if (page_state == 2)
-    {
+    if (page_state == 2) {
         delete_state(ctx);
     }
 
@@ -1137,12 +1133,12 @@
         display = tmp_display_list;
         tmp_ptr = &tmp_display_list;
 
-        while (display != NULL && display->region_id != region_id) {
+        while (display && display->region_id != region_id) {
             tmp_ptr = &display->next;
             display = display->next;
         }
 
-        if (display == NULL)
+        if (!display)
             display = av_mallocz(sizeof(DVBSubRegionDisplay));
 
         display->region_id = region_id;
@@ -1163,7 +1159,7 @@
 #endif
     }
 
-    while (tmp_display_list != 0) {
+    while (tmp_display_list) {
         display = tmp_display_list;
 
         tmp_display_list = display->next;
@@ -1192,7 +1188,7 @@
     width = 0;
     height = 0;
 
-    for (display = ctx->display_list; display != NULL; display = display->next) {
+    for (display = ctx->display_list; display; display = display->next) {
         region = get_region(ctx, display->region_id);
 
         if (x_pos == -1) {
@@ -1225,7 +1221,7 @@
 
         pbuf = av_malloc(width * height * 4);
 
-        for (display = ctx->display_list; display != NULL; display = display->next) {
+        for (display = ctx->display_list; display; display = display->next) {
             region = get_region(ctx, display->region_id);
 
             x_off = display->x_pos - x_pos;
@@ -1258,7 +1254,7 @@
 
         }
 
-        snprintf(filename, 32, "dvbs.%d", fileno_index);
+        snprintf(filename, sizeof(filename), "dvbs.%d", fileno_index);
 
         png_save2(filename, pbuf, width, height);
 
@@ -1269,7 +1265,7 @@
 }
 #endif
 
-static int dvbsub_display_end_segment(AVCodecContext *avctx, uint8_t *buf,
+static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,
                                         int buf_size, AVSubtitle *sub)
 {
     DVBSubContext *ctx = (DVBSubContext*) avctx->priv_data;
@@ -1293,11 +1289,11 @@
 
     i = 0;
 
-    for (display = ctx->display_list; display != NULL; display = display->next) {
+    for (display = ctx->display_list; display; display = display->next) {
         region = get_region(ctx, display->region_id);
         rect = &sub->rects[i];
 
-        if (region == NULL)
+        if (!region)
             continue;
 
         rect->x = display->x_pos;
@@ -1309,7 +1305,7 @@
 
         clut = get_clut(ctx, region->clut);
 
-        if (clut == NULL)
+        if (!clut)
             clut = &default_clut;
 
         switch (region->depth) {
@@ -1345,11 +1341,11 @@
 
 static int dvbsub_decode(AVCodecContext *avctx,
                          void *data, int *data_size,
-                         uint8_t *buf, int buf_size)
+                         const uint8_t *buf, int buf_size)
 {
     DVBSubContext *ctx = (DVBSubContext*) avctx->priv_data;
     AVSubtitle *sub = (AVSubtitle*) data;
-    uint8_t *p, *p_end;
+    const uint8_t *p, *p_end;
     int segment_type;
     int page_id;
     int segment_length;
@@ -1359,14 +1355,13 @@
 
     av_log(avctx, AV_LOG_INFO, "DVB sub packet:\n");
 
-    for (i=0; i < buf_size; i++)
-    {
+    for (i=0; i < buf_size; i++) {
         av_log(avctx, AV_LOG_INFO, "%02x ", buf[i]);
         if (i % 16 == 15)
             av_log(avctx, AV_LOG_INFO, "\n");
     }
 
-    if (i % 16 != 0)
+    if (i % 16)
         av_log(avctx, AV_LOG_INFO, "\n");
 
 #endif
@@ -1377,8 +1372,7 @@
     p = buf;
     p_end = buf + buf_size;
 
-    while (p < p_end && *p == 0x0f)
-    {
+    while (p < p_end && *p == 0x0f) {
         p += 1;
         segment_type = *p++;
         page_id = AV_RB16(p);
@@ -1415,8 +1409,7 @@
         p += segment_length;
     }
 
-    if (p != p_end)
-    {
+    if (p != p_end) {
 #ifdef DEBUG
         av_log(avctx, AV_LOG_INFO, "Junk at end of packet\n");
 #endif
diff -u mplayer-1.0~rc2-12/libavcodec/dv.c ffmpeg-free-0.svn20080206/libavcodec/dv.c
--- mplayer-1.0~rc2-12/libavcodec/dv.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dv.c	2008-03-20 19:10:57.000000000 +0100
@@ -225,7 +225,7 @@
 
     /* 248DCT setup */
     s->fdct[1] = dsp.fdct248;
-    s->idct_put[1] = simple_idct248_put;  // FIXME: need to add it to DSP
+    s->idct_put[1] = ff_simple_idct248_put;  // FIXME: need to add it to DSP
     if(avctx->lowres){
         for (i=0; i<64; i++){
             int j= ff_zigzag248_direct[i];
@@ -363,7 +363,7 @@
 
 /* mb_x and mb_y are in units of 8 pixels */
 static inline void dv_decode_video_segment(DVVideoContext *s,
-                                           uint8_t *buf_ptr1,
+                                           const uint8_t *buf_ptr1,
                                            const uint16_t *mb_pos_ptr)
 {
     int quant, dc, dct_mode, class1, j;
@@ -372,7 +372,7 @@
     int c_offset;
     uint8_t *y_ptr;
     void (*idct_put)(uint8_t *dest, int line_size, DCTELEM *block);
-    uint8_t *buf_ptr;
+    const uint8_t *buf_ptr;
     PutBitContext pb, vs_pb;
     GetBitContext gb;
     BlockInfo mb_data[5 * 6], *mb, *mb1;
@@ -1031,7 +1031,7 @@
    144000 bytes for PAL - or twice those for 50Mbps) */
 static int dvvideo_decode_frame(AVCodecContext *avctx,
                                  void *data, int *data_size,
-                                 uint8_t *buf, int buf_size)
+                                 const uint8_t *buf, int buf_size)
 {
     DVVideoContext *s = avctx->priv_data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/dvdata.h ffmpeg-free-0.svn20080206/libavcodec/dvdata.h
--- mplayer-1.0~rc2-12/libavcodec/dvdata.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dvdata.h	2008-02-01 16:08:55.000000000 +0100
@@ -24,8 +24,8 @@
  * Constants for DV codec.
  */
 
-#ifndef AVCODEC_DVDATA_H
-#define AVCODEC_DVDATA_H
+#ifndef FFMPEG_DVDATA_H
+#define FFMPEG_DVDATA_H
 
 #include "avcodec.h"
 #include "rational.h"
@@ -335,7 +335,7 @@
 
 static const uint8_t dv_quant_offset[4] = { 6, 3, 0, 1 };
 
-/* NOTE: I prefer hardcoding the positionning of dv blocks, it is
+/* NOTE: I prefer hardcoding the positioning of dv blocks, it is
    simpler :-) */
 
 static const uint16_t dv_place_420[1620] = {
@@ -2661,7 +2661,7 @@
 /* largest possible DV frame, in bytes (PAL 50Mbps) */
 #define DV_MAX_FRAME_SIZE 288000
 
-static inline const DVprofile* dv_frame_profile(uint8_t* frame)
+static inline const DVprofile* dv_frame_profile(const uint8_t* frame)
 {
     if ((frame[3] & 0x80) == 0) {      /* DSF flag */
         /* it's an NTSC format */
@@ -2729,4 +2729,4 @@
     return 3;
 }
 
-#endif // AVCODEC_DVDATA_H
+#endif /* FFMPEG_DVDATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/dvdsubdec.c ffmpeg-free-0.svn20080206/libavcodec/dvdsubdec.c
--- mplayer-1.0~rc2-12/libavcodec/dvdsubdec.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dvdsubdec.c	2008-03-20 19:10:58.000000000 +0100
@@ -42,11 +42,6 @@
     }
 }
 
-static int dvdsub_init_decoder(AVCodecContext *avctx)
-{
-    return 0;
-}
-
 static int decode_run_2bit(GetBitContext *gb, int *color)
 {
     unsigned int v, t;
@@ -443,11 +438,6 @@
     return 1;
 }
 
-static int dvdsub_close_decoder(AVCodecContext *avctx)
-{
-    return 0;
-}
-
 #ifdef DEBUG
 #undef fprintf
 static void ppm_save(const char *filename, uint8_t *bitmap, int w, int h,
@@ -479,7 +469,7 @@
 
 static int dvdsub_decode(AVCodecContext *avctx,
                          void *data, int *data_size,
-                         uint8_t *buf, int buf_size)
+                         const uint8_t *buf, int buf_size)
 {
     AVSubtitle *sub = (void *)data;
     int is_menu;
@@ -512,8 +502,8 @@
     CODEC_TYPE_SUBTITLE,
     CODEC_ID_DVD_SUBTITLE,
     0,
-    dvdsub_init_decoder,
     NULL,
-    dvdsub_close_decoder,
+    NULL,
+    NULL,
     dvdsub_decode,
 };
diff -u mplayer-1.0~rc2-12/libavcodec/dvdsubenc.c ffmpeg-free-0.svn20080206/libavcodec/dvdsubenc.c
--- mplayer-1.0~rc2-12/libavcodec/dvdsubenc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dvdsubenc.c	2008-03-20 19:10:58.000000000 +0100
@@ -204,16 +204,6 @@
     return q - outbuf;
 }
 
-static int dvdsub_init_encoder(AVCodecContext *avctx)
-{
-    return 0;
-}
-
-static int dvdsub_close_encoder(AVCodecContext *avctx)
-{
-    return 0;
-}
-
 static int dvdsub_encode(AVCodecContext *avctx,
                          unsigned char *buf, int buf_size, void *data)
 {
@@ -230,11 +220,6 @@
     CODEC_TYPE_SUBTITLE,
     CODEC_ID_DVD_SUBTITLE,
     0,
-    dvdsub_init_encoder,
+    NULL,
     dvdsub_encode,
-    dvdsub_close_encoder,
 };
-
-/* Local Variables: */
-/* c-basic-offset:4 */
-/* End: */
diff -u mplayer-1.0~rc2-12/libavcodec/dxa.c ffmpeg-free-0.svn20080206/libavcodec/dxa.c
--- mplayer-1.0~rc2-12/libavcodec/dxa.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/dxa.c	2008-03-20 19:10:58.000000000 +0100
@@ -187,7 +187,7 @@
     return 0;
 }
 
-static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size)
 {
     DxaDecContext * const c = avctx->priv_data;
     uint8_t *outptr, *srcptr, *tmpptr;
diff -u mplayer-1.0~rc2-12/libavcodec/elbg.h ffmpeg-free-0.svn20080206/libavcodec/elbg.h
--- mplayer-1.0~rc2-12/libavcodec/elbg.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/elbg.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_ELBG_H
-#define AVCODEC_ELBG_H
+#ifndef FFMPEG_ELBG_H
+#define FFMPEG_ELBG_H
 
 #include "random.h"
 
@@ -52,4 +52,4 @@
                   int numCB, int num_steps, int *closest_cb,
                   AVRandomState *rand_state);
 
-#endif // AVCODEC_ELBG_H
+#endif /* FFMPEG_ELBG_H */
diff -u mplayer-1.0~rc2-12/libavcodec/eval.c ffmpeg-free-0.svn20080206/libavcodec/eval.c
--- mplayer-1.0~rc2-12/libavcodec/eval.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/eval.c	2008-03-20 19:10:58.000000000 +0100
@@ -55,7 +55,7 @@
     double (**func2)(void *, double a, double b); // NULL terminated
     char **func2_name;          // NULL terminated
     void *opaque;
-    char **error;
+    const char **error;
 #define VARS 10
     double var[VARS];
 } Parser;
@@ -379,7 +379,7 @@
 AVEvalExpr * ff_parse(char *s, const char **const_name,
                double (**func1)(void *, double), const char **func1_name,
                double (**func2)(void *, double, double), char **func2_name,
-               char **error){
+               const char **error){
     Parser p;
     AVEvalExpr * e;
     char w[strlen(s) + 1], * wp = w;
@@ -416,7 +416,7 @@
 double ff_eval2(char *s, double *const_value, const char **const_name,
                double (**func1)(void *, double), const char **func1_name,
                double (**func2)(void *, double, double), char **func2_name,
-               void *opaque, char **error){
+               void *opaque, const char **error){
     AVEvalExpr * e = ff_parse(s, const_name, func1, func1_name, func2, func2_name, error);
     double d;
     if (!e) return NAN;
@@ -430,7 +430,7 @@
                double (**func1)(void *, double), const char **func1_name,
                double (**func2)(void *, double, double), char **func2_name,
                void *opaque){
-    char *error=NULL;
+    const char *error=NULL;
     double ret;
     ret = ff_eval2(s, const_value, const_name, func1, func1_name, func2, func2_name, opaque, &error);
     if (error)
@@ -451,7 +451,7 @@
     "E",
     0
 };
-main(){
+int main(void){
     int i;
     printf("%f == 12.7\n", ff_eval("1+(5-2)^(3-1)+1/2+sin(PI)-max(-2.2,-3.1)", const_values, const_names, NULL, NULL, NULL, NULL, NULL));
     printf("%f == 0.931322575\n", ff_eval("80G/80Gi", const_values, const_names, NULL, NULL, NULL, NULL, NULL));
@@ -461,5 +461,6 @@
             ff_eval("1+(5-2)^(3-1)+1/2+sin(PI)-max(-2.2,-3.1)", const_values, const_names, NULL, NULL, NULL, NULL, NULL);
         STOP_TIMER("ff_eval")
     }
+    return 0;
 }
 #endif
diff -u mplayer-1.0~rc2-12/libavcodec/eval.h ffmpeg-free-0.svn20080206/libavcodec/eval.h
--- mplayer-1.0~rc2-12/libavcodec/eval.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/eval.h	2008-02-04 00:25:35.000000000 +0100
@@ -25,8 +25,8 @@
  * eval header.
  */
 
-#ifndef AVCODEC_EVAL_H
-#define AVCODEC_EVAL_H
+#ifndef FFMPEG_EVAL_H
+#define FFMPEG_EVAL_H
 
 #if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
 /**
@@ -55,7 +55,7 @@
 double ff_eval2(char *s, double *const_value, const char **const_name,
                double (**func1)(void *, double), const char **func1_name,
                double (**func2)(void *, double, double), char **func2_name,
-               void *opaque, char **error);
+               void *opaque, const char **error);
 
 typedef struct ff_expr_s AVEvalExpr;
 
@@ -74,7 +74,7 @@
 AVEvalExpr * ff_parse(char *s, const char **const_name,
                double (**func1)(void *, double), const char **func1_name,
                double (**func2)(void *, double, double), char **func2_name,
-               char **error);
+               const char **error);
 /**
  * Evaluates a previously parsed expression.
  * @param const_value a zero terminated array of values for the identifers from ff_parse const_name
@@ -84,4 +84,4 @@
 double ff_parse_eval(AVEvalExpr * e, double *const_value, void *opaque);
 void ff_eval_free(AVEvalExpr * e);
 
-#endif /* AVCODEC_EVAL_H */
+#endif /* FFMPEG_EVAL_H */
diff -u mplayer-1.0~rc2-12/libavcodec/faandct.h ffmpeg-free-0.svn20080206/libavcodec/faandct.h
--- mplayer-1.0~rc2-12/libavcodec/faandct.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/faandct.h	2007-10-17 11:37:46.000000000 +0200
@@ -26,8 +26,8 @@
  * @author Michael Niedermayer <michaelni@gmx.at>
  */
 
-#ifndef AVCODEC_FAANDCT_H
-#define AVCODEC_FAANDCT_H
+#ifndef FFMPEG_FAANDCT_H
+#define FFMPEG_FAANDCT_H
 
 #include "dsputil.h"
 
@@ -36,4 +36,4 @@
 void ff_faandct(DCTELEM * data);
 void ff_faandct248(DCTELEM * data);
 
-#endif // AVCODEC_FAANDCT_H
+#endif /* FFMPEG_FAANDCT_H */
diff -u mplayer-1.0~rc2-12/libavcodec/ffv1.c ffmpeg-free-0.svn20080206/libavcodec/ffv1.c
--- mplayer-1.0~rc2-12/libavcodec/ffv1.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ffv1.c	2008-03-20 19:10:58.000000000 +0100
@@ -936,7 +936,7 @@
     return 0;
 }
 
-static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size){
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size){
     FFV1Context *f = avctx->priv_data;
     RangeCoder * const c= &f->c;
     const int width= f->width;
diff -u mplayer-1.0~rc2-12/libavcodec/flac.c ffmpeg-free-0.svn20080206/libavcodec/flac.c
--- mplayer-1.0~rc2-12/libavcodec/flac.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/flac.c	2008-03-20 19:10:58.000000000 +0100
@@ -217,7 +217,7 @@
     int sample = 0, samples;
 
     method_type = get_bits(&s->gb, 2);
-    if (method_type != 0){
+    if (method_type > 1){
         av_log(s->avctx, AV_LOG_DEBUG, "illegal residual coding method %d\n", method_type);
         return -1;
     }
@@ -234,8 +234,8 @@
     i= pred_order;
     for (partition = 0; partition < (1 << rice_order); partition++)
     {
-        tmp = get_bits(&s->gb, 4);
-        if (tmp == 15)
+        tmp = get_bits(&s->gb, method_type == 0 ? 4 : 5);
+        if (tmp == (method_type == 0 ? 15 : 31))
         {
             av_log(s->avctx, AV_LOG_DEBUG, "fixed len partition\n");
             tmp = get_bits(&s->gb, 5);
@@ -558,7 +558,8 @@
     }
 
     skip_bits(&s->gb, 8);
-    crc8= av_crc(av_crc07, 0, s->gb.buffer, get_bits_count(&s->gb)/8);
+    crc8 = av_crc(av_crc_get_table(AV_CRC_8_ATM), 0,
+                  s->gb.buffer, get_bits_count(&s->gb)/8);
     if(crc8){
         av_log(s->avctx, AV_LOG_ERROR, "header crc mismatch crc=%2X\n", crc8);
         return -1;
@@ -589,7 +590,7 @@
 
 static int flac_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     FLACContext *s = avctx->priv_data;
     int tmp = 0, i, j = 0, input_buf_size = 0;
@@ -628,9 +629,9 @@
     if (!metadata_parse(s))
     {
         tmp = show_bits(&s->gb, 16);
-        if(tmp != 0xFFF8){
+        if((tmp & 0xFFFE) != 0xFFF8){
             av_log(s->avctx, AV_LOG_ERROR, "FRAME HEADER not here\n");
-            while(get_bits_count(&s->gb)/8+2 < buf_size && show_bits(&s->gb, 16) != 0xFFF8)
+            while(get_bits_count(&s->gb)/8+2 < buf_size && (show_bits(&s->gb, 16) & 0xFFFE) != 0xFFF8)
                 skip_bits(&s->gb, 8);
             goto end; // we may not have enough bits left to decode a frame, so try next time
         }
diff -u mplayer-1.0~rc2-12/libavcodec/flacenc.c ffmpeg-free-0.svn20080206/libavcodec/flacenc.c
--- mplayer-1.0~rc2-12/libavcodec/flacenc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/flacenc.c	2008-03-20 19:10:58.000000000 +0100
@@ -474,16 +474,15 @@
     uint32_t all_bits;
 
     part = (1 << porder);
-    all_bits = 0;
+    all_bits = 4 * part;
 
     cnt = (n >> porder) - pred_order;
     for(i=0; i<part; i++) {
-        if(i == 1) cnt = (n >> porder);
         k = find_optimal_param(sums[i], cnt);
         rc->params[i] = k;
         all_bits += rice_encode_count(sums[i], cnt, k);
+        cnt = n >> porder;
     }
-    all_bits += (4 * part);
 
     rc->porder = porder;
 
@@ -1284,7 +1283,8 @@
         put_bits(&s->pb, 16, s->sr_code[1]);
     }
     flush_put_bits(&s->pb);
-    crc = av_crc(av_crc07, 0, s->pb.buf, put_bits_count(&s->pb)>>3);
+    crc = av_crc(av_crc_get_table(AV_CRC_8_ATM), 0,
+                 s->pb.buf, put_bits_count(&s->pb)>>3);
     put_bits(&s->pb, 8, crc);
 }
 
@@ -1426,7 +1426,8 @@
 {
     int crc;
     flush_put_bits(&s->pb);
-    crc = bswap_16(av_crc(av_crc8005, 0, s->pb.buf, put_bits_count(&s->pb)>>3));
+    crc = bswap_16(av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0,
+                          s->pb.buf, put_bits_count(&s->pb)>>3));
     put_bits(&s->pb, 16, crc);
     flush_put_bits(&s->pb);
 }
diff -u mplayer-1.0~rc2-12/libavcodec/flashsv.c ffmpeg-free-0.svn20080206/libavcodec/flashsv.c
--- mplayer-1.0~rc2-12/libavcodec/flashsv.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/flashsv.c	2008-03-20 19:10:58.000000000 +0100
@@ -102,7 +102,7 @@
 
 static int flashsv_decode_frame(AVCodecContext *avctx,
                                     void *data, int *data_size,
-                                    uint8_t *buf, int buf_size)
+                                    const uint8_t *buf, int buf_size)
 {
     FlashSVContext *s = avctx->priv_data;
     int h_blocks, v_blocks, h_part, v_part, i, j;
diff -u mplayer-1.0~rc2-12/libavcodec/flicvideo.c ffmpeg-free-0.svn20080206/libavcodec/flicvideo.c
--- mplayer-1.0~rc2-12/libavcodec/flicvideo.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/flicvideo.c	2008-03-20 19:10:58.000000000 +0100
@@ -127,7 +127,7 @@
 
 static int flic_decode_frame_8BPP(AVCodecContext *avctx,
                                   void *data, int *data_size,
-                                  uint8_t *buf, int buf_size)
+                                  const uint8_t *buf, int buf_size)
 {
     FlicDecodeContext *s = avctx->priv_data;
 
@@ -427,7 +427,7 @@
 
 static int flic_decode_frame_15_16BPP(AVCodecContext *avctx,
                                       void *data, int *data_size,
-                                      uint8_t *buf, int buf_size)
+                                      const uint8_t *buf, int buf_size)
 {
     /* Note, the only difference between the 15Bpp and 16Bpp */
     /* Format is the pixel format, the packets are processed the same. */
@@ -692,7 +692,7 @@
 
 static int flic_decode_frame_24BPP(AVCodecContext *avctx,
                                    void *data, int *data_size,
-                                   uint8_t *buf, int buf_size)
+                                   const uint8_t *buf, int buf_size)
 {
   av_log(avctx, AV_LOG_ERROR, "24Bpp FLC Unsupported due to lack of test files.\n");
   return -1;
@@ -700,7 +700,7 @@
 
 static int flic_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     if (avctx->pix_fmt == PIX_FMT_PAL8) {
       return flic_decode_frame_8BPP(avctx, data, data_size,
diff -u mplayer-1.0~rc2-12/libavcodec/fraps.c ffmpeg-free-0.svn20080206/libavcodec/fraps.c
--- mplayer-1.0~rc2-12/libavcodec/fraps.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/fraps.c	2008-03-20 19:10:58.000000000 +0100
@@ -33,30 +33,18 @@
 
 #include "avcodec.h"
 #include "bitstream.h"
+#include "huffman.h"
+#include "bytestream.h"
 #include "dsputil.h"
 
 #define FPS_TAG MKTAG('F', 'P', 'S', 'x')
 
-/* symbol for Huffman tree node */
-#define HNODE -1
-
-/**
- * Huffman node
- * FIXME one day this should belong to one general framework
- */
-typedef struct Node{
-    int16_t sym;
-    int16_t n0;
-    int count;
-}Node;
-
 /**
  * local variable storage
  */
 typedef struct FrapsContext{
     AVCodecContext *avctx;
     AVFrame frame;
-    Node nodes[512];
     uint8_t *tmpbuf;
     DSPContext dsp;
 } FrapsContext;
@@ -92,82 +80,22 @@
     return (a->count - b->count)*256 + a->sym - b->sym;
 }
 
-static void get_tree_codes(uint32_t *bits, int16_t *lens, uint8_t *xlat, Node *nodes, int node, uint32_t pfx, int pl, int *pos)
-{
-    int s;
-
-    s = nodes[node].sym;
-    if(s != HNODE || !nodes[node].count){
-        bits[*pos] = pfx;
-        lens[*pos] = pl;
-        xlat[*pos] = s;
-        (*pos)++;
-    }else{
-        pfx <<= 1;
-        pl++;
-        get_tree_codes(bits, lens, xlat, nodes, nodes[node].n0, pfx, pl, pos);
-        pfx |= 1;
-        get_tree_codes(bits, lens, xlat, nodes, nodes[node].n0+1, pfx, pl, pos);
-    }
-}
-
-static int build_huff_tree(VLC *vlc, Node *nodes, uint8_t *xlat)
-{
-    uint32_t bits[256];
-    int16_t lens[256];
-    int pos = 0;
-
-    get_tree_codes(bits, lens, xlat, nodes, 510, 0, 0, &pos);
-    return init_vlc(vlc, 9, pos, lens, 2, 2, bits, 4, 4, 0);
-}
-
-
 /**
  * decode Fraps v2 packed plane
  */
 static int fraps2_decode_plane(FrapsContext *s, uint8_t *dst, int stride, int w,
-                               int h, uint8_t *src, int size, int Uoff)
+                               int h, const uint8_t *src, int size, int Uoff)
 {
     int i, j;
-    int cur_node;
     GetBitContext gb;
     VLC vlc;
-    int64_t sum = 0;
-    uint8_t recode[256];
+    Node nodes[512];
 
-    for(i = 0; i < 256; i++){
-        s->nodes[i].sym = i;
-        s->nodes[i].count = AV_RL32(src);
-        s->nodes[i].n0 = -2;
-        if(s->nodes[i].count < 0) {
-            av_log(s->avctx, AV_LOG_ERROR, "Symbol count < 0\n");
-            return -1;
-        }
-        src += 4;
-        sum += s->nodes[i].count;
-    }
+    for(i = 0; i < 256; i++)
+        nodes[i].count = bytestream_get_le32(&src);
     size -= 1024;
-
-    if(sum >> 31) {
-        av_log(s->avctx, AV_LOG_ERROR, "Too high symbol frequencies. Tree construction is not possible\n");
-        return -1;
-    }
-    qsort(s->nodes, 256, sizeof(Node), huff_cmp);
-    cur_node = 256;
-    for(i = 0; i < 511; i += 2){
-        s->nodes[cur_node].sym = HNODE;
-        s->nodes[cur_node].count = s->nodes[i].count + s->nodes[i+1].count;
-        s->nodes[cur_node].n0 = i;
-        for(j = cur_node; j > 0; j--){
-            if(s->nodes[j].count >= s->nodes[j - 1].count) break;
-            FFSWAP(Node, s->nodes[j], s->nodes[j - 1]);
-        }
-        cur_node++;
-    }
-    if(build_huff_tree(&vlc, s->nodes, recode) < 0){
-        av_log(s->avctx, AV_LOG_ERROR, "Error building tree\n");
+    if (ff_huff_build_tree(s->avctx, &vlc, 256, nodes, huff_cmp, 0) < 0)
         return -1;
-    }
     /* we have built Huffman table and are ready to decode plane */
 
     /* convert bits so they may be used by standard bitreader */
@@ -176,7 +104,7 @@
     init_get_bits(&gb, s->tmpbuf, size * 8);
     for(j = 0; j < h; j++){
         for(i = 0; i < w; i++){
-            dst[i] = recode[get_vlc2(&gb, vlc.table, 9, 3)];
+            dst[i] = get_vlc2(&gb, vlc.table, 9, 3);
             /* lines are stored as deltas between previous lines
              * and we need to add 0x80 to the first lines of chroma planes
              */
@@ -200,7 +128,7 @@
  */
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     FrapsContext * const s = avctx->priv_data;
     AVFrame *frame = data;
@@ -208,7 +136,7 @@
     uint32_t header;
     unsigned int version,header_size;
     unsigned int x, y;
-    uint32_t *buf32;
+    const uint32_t *buf32;
     uint32_t *luma1,*luma2,*cb,*cr;
     uint32_t offs[4];
     int i, is_chroma, planes;
@@ -262,7 +190,7 @@
         f->key_frame = f->pict_type == FF_I_TYPE;
 
         if (f->pict_type == FF_I_TYPE) {
-            buf32=(uint32_t*)buf;
+            buf32=(const uint32_t*)buf;
             for(y=0; y<avctx->height/2; y++){
                 luma1=(uint32_t*)&f->data[0][ y*2*f->linesize[0] ];
                 luma2=(uint32_t*)&f->data[0][ (y*2+1)*f->linesize[0] ];
diff -u mplayer-1.0~rc2-12/libavcodec/g726.c ffmpeg-free-0.svn20080206/libavcodec/g726.c
--- mplayer-1.0~rc2-12/libavcodec/g726.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/g726.c	2008-03-20 19:10:58.000000000 +0100
@@ -64,14 +64,14 @@
 
 typedef struct G726Tables {
     int  bits;          /**< bits per sample */
-    int* quant;         /**< quantization table */
-    int* iquant;        /**< inverse quantization table */
-    int* W;             /**< special table #1 ;-) */
-    int* F;             /**< special table #2 */
+    const int* quant;         /**< quantization table */
+    const int* iquant;        /**< inverse quantization table */
+    const int* W;             /**< special table #1 ;-) */
+    const int* F;             /**< special table #2 */
 } G726Tables;
 
 typedef struct G726Context {
-    G726Tables* tbls;   /**< static tables needed for computation */
+    const G726Tables* tbls;   /**< static tables needed for computation */
 
     Float11 sr[2];      /**< prev. reconstructed samples */
     Float11 dq[6];      /**< prev. difference */
@@ -91,53 +91,53 @@
     int y;              /**< quantizer scaling factor for the next iteration */
 } G726Context;
 
-static int quant_tbl16[] =                  /**< 16kbit/s 2bits per sample */
+static const int quant_tbl16[] =                  /**< 16kbit/s 2bits per sample */
            { 260, INT_MAX };
-static int iquant_tbl16[] =
+static const int iquant_tbl16[] =
            { 116, 365, 365, 116 };
-static int W_tbl16[] =
+static const int W_tbl16[] =
            { -22, 439, 439, -22 };
-static int F_tbl16[] =
+static const int F_tbl16[] =
            { 0, 7, 7, 0 };
 
-static int quant_tbl24[] =                  /**< 24kbit/s 3bits per sample */
+static const int quant_tbl24[] =                  /**< 24kbit/s 3bits per sample */
            {  7, 217, 330, INT_MAX };
-static int iquant_tbl24[] =
+static const int iquant_tbl24[] =
            { INT_MIN, 135, 273, 373, 373, 273, 135, INT_MIN };
-static int W_tbl24[] =
+static const int W_tbl24[] =
            { -4,  30, 137, 582, 582, 137,  30, -4 };
-static int F_tbl24[] =
+static const int F_tbl24[] =
            { 0, 1, 2, 7, 7, 2, 1, 0 };
 
-static int quant_tbl32[] =                  /**< 32kbit/s 4bits per sample */
+static const int quant_tbl32[] =                  /**< 32kbit/s 4bits per sample */
            { -125,  79, 177, 245, 299, 348, 399, INT_MAX };
-static int iquant_tbl32[] =
+static const int iquant_tbl32[] =
            { INT_MIN,   4, 135, 213, 273, 323, 373, 425,
                  425, 373, 323, 273, 213, 135,   4, INT_MIN };
-static int W_tbl32[] =
+static const int W_tbl32[] =
            { -12,  18,  41,  64, 112, 198, 355, 1122,
             1122, 355, 198, 112,  64,  41,  18, -12};
-static int F_tbl32[] =
+static const int F_tbl32[] =
            { 0, 0, 0, 1, 1, 1, 3, 7, 7, 3, 1, 1, 1, 0, 0, 0 };
 
-static int quant_tbl40[] =                  /**< 40kbit/s 5bits per sample */
+static const int quant_tbl40[] =                  /**< 40kbit/s 5bits per sample */
            { -122, -16,  67, 138, 197, 249, 297, 338,
               377, 412, 444, 474, 501, 527, 552, INT_MAX };
-static int iquant_tbl40[] =
+static const int iquant_tbl40[] =
            { INT_MIN, -66,  28, 104, 169, 224, 274, 318,
                  358, 395, 429, 459, 488, 514, 539, 566,
                  566, 539, 514, 488, 459, 429, 395, 358,
                  318, 274, 224, 169, 104,  28, -66, INT_MIN };
-static int W_tbl40[] =
+static const int W_tbl40[] =
            {   14,  14,  24,  39,  40,  41,   58,  100,
               141, 179, 219, 280, 358, 440,  529,  696,
               696, 529, 440, 358, 280, 219,  179,  141,
               100,  58,  41,  40,  39,  24,   14,   14 };
-static int F_tbl40[] =
+static const int F_tbl40[] =
            { 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 6,
              6, 6, 5, 4, 3, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
 
-static G726Tables G726Tables_pool[] =
+static const G726Tables G726Tables_pool[] =
            {{ 2, quant_tbl16, iquant_tbl16, W_tbl16, F_tbl16 },
             { 3, quant_tbl24, iquant_tbl24, W_tbl24, F_tbl24 },
             { 4, quant_tbl32, iquant_tbl32, W_tbl32, F_tbl32 },
@@ -373,7 +373,7 @@
 
 static int g726_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     AVG726Context *c = avctx->priv_data;
     short *samples = data;
diff -u mplayer-1.0~rc2-12/libavcodec/gif.c ffmpeg-free-0.svn20080206/libavcodec/gif.c
--- mplayer-1.0~rc2-12/libavcodec/gif.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/gif.c	2008-03-20 19:10:58.000000000 +0100
@@ -136,7 +136,7 @@
 
         //printf("bitbuf = %08x\n", bit_buf);
         if (s->buf_ptr >= s->buf_end)
-            puts("bit buffer overflow !!"); // should never happen ! who got rid of the callback ???
+            abort();
 //            flush_buffer_rev(s);
         bit_cnt=bit_cnt + n - 32;
         if (bit_cnt == 0) {
diff -u mplayer-1.0~rc2-12/libavcodec/gifdec.c ffmpeg-free-0.svn20080206/libavcodec/gifdec.c
--- mplayer-1.0~rc2-12/libavcodec/gifdec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/gifdec.c	2008-03-20 19:10:58.000000000 +0100
@@ -47,8 +47,8 @@
     int gce_delay;
 
     /* LZW compatible decoder */
-    uint8_t *bytestream;
-    uint8_t *bytestream_end;
+    const uint8_t *bytestream;
+    const uint8_t *bytestream_end;
     LZWState *lzw;
 
     /* aux buffers */
@@ -285,7 +285,7 @@
     return 0;
 }
 
-static int gif_decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)
+static int gif_decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size)
 {
     GifState *s = avctx->priv_data;
     AVFrame *picture = data;
diff -u mplayer-1.0~rc2-12/libavcodec/golomb.h ffmpeg-free-0.svn20080206/libavcodec/golomb.h
--- mplayer-1.0~rc2-12/libavcodec/golomb.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/golomb.h	2007-10-17 11:37:46.000000000 +0200
@@ -27,8 +27,8 @@
  * @author Michael Niedermayer <michaelni@gmx.at> and Alex Beregszaszi
  */
 
-#ifndef AVCODEC_GOLOMB_H
-#define AVCODEC_GOLOMB_H
+#ifndef FFMPEG_GOLOMB_H
+#define FFMPEG_GOLOMB_H
 
 #include <stdint.h>
 #include "bitstream.h"
@@ -504,4 +504,4 @@
     set_ur_golomb_jpegls(pb, v, k, limit, esc_len);
 }
 
-#endif // AVCODEC_GOLOMB_H
+#endif /* FFMPEG_GOLOMB_H */
diff -u mplayer-1.0~rc2-12/libavcodec/h261data.h ffmpeg-free-0.svn20080206/libavcodec/h261data.h
--- mplayer-1.0~rc2-12/libavcodec/h261data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h261data.h	2007-10-17 11:37:46.000000000 +0200
@@ -24,8 +24,8 @@
  * H.261 tables.
  */
 
-#ifndef AVCODEC_H261DATA_H
-#define AVCODEC_H261DATA_H
+#ifndef FFMPEG_H261DATA_H
+#define FFMPEG_H261DATA_H
 
 #include <stdint.h>
 #include "h261.h"
@@ -161,4 +161,4 @@
     h261_tcoeff_level,
 };
 
-#endif // AVCODEC_H261DATA_H
+#endif /* FFMPEG_H261DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/h261dec.c ffmpeg-free-0.svn20080206/libavcodec/h261dec.c
--- mplayer-1.0~rc2-12/libavcodec/h261dec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h261dec.c	2008-03-20 19:10:58.000000000 +0100
@@ -540,7 +540,7 @@
 
 static int h261_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     H261Context *h= avctx->priv_data;
     MpegEncContext *s = &h->s;
diff -u mplayer-1.0~rc2-12/libavcodec/h261enc.c ffmpeg-free-0.svn20080206/libavcodec/h261enc.c
--- mplayer-1.0~rc2-12/libavcodec/h261enc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h261enc.c	2008-03-20 19:10:58.000000000 +0100
@@ -321,14 +321,4 @@
     }
 }
 
-AVCodec h261_encoder = {
-    "h261",
-    CODEC_TYPE_VIDEO,
-    CODEC_ID_H261,
-    sizeof(H261Context),
-    MPV_encode_init,
-    MPV_encode_picture,
-    MPV_encode_end,
-    .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, -1},
-};
 
diff -u mplayer-1.0~rc2-12/libavcodec/h261.h ffmpeg-free-0.svn20080206/libavcodec/h261.h
--- mplayer-1.0~rc2-12/libavcodec/h261.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h261.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * h261codec.
  */
 
-#ifndef AVCODEC_H261_H
-#define AVCODEC_H261_H
+#ifndef FFMPEG_H261_H
+#define FFMPEG_H261_H
 
 #include "mpegvideo.h"
 
@@ -48,4 +48,4 @@
 
 #define MB_TYPE_H261_FIL 0x800000
 
-#endif /* AVCODEC_H261_H */
+#endif /* FFMPEG_H261_H */
diff -u mplayer-1.0~rc2-12/libavcodec/h263.c ffmpeg-free-0.svn20080206/libavcodec/h263.c
--- mplayer-1.0~rc2-12/libavcodec/h263.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h263.c	2008-03-20 19:10:58.000000000 +0100
@@ -4754,26 +4754,26 @@
             i = -1;
             ff_mpeg4_pred_dc(s, n, 0, &dc_pred_dir, 0);
       }
-        if (!coded)
-            goto not_coded;
+      if (!coded)
+          goto not_coded;
 
-        if(rvlc){
-            rl = &rvlc_rl_intra;
-            rl_vlc = rvlc_rl_intra.rl_vlc[0];
-        }else{
-            rl = &rl_intra;
-            rl_vlc = rl_intra.rl_vlc[0];
-        }
-        if (s->ac_pred) {
-            if (dc_pred_dir == 0)
-                scan_table = s->intra_v_scantable.permutated; /* left */
-            else
-                scan_table = s->intra_h_scantable.permutated; /* top */
-        } else {
+      if(rvlc){
+          rl = &rvlc_rl_intra;
+          rl_vlc = rvlc_rl_intra.rl_vlc[0];
+      }else{
+          rl = &rl_intra;
+          rl_vlc = rl_intra.rl_vlc[0];
+      }
+      if (s->ac_pred) {
+          if (dc_pred_dir == 0)
+              scan_table = s->intra_v_scantable.permutated; /* left */
+          else
+              scan_table = s->intra_h_scantable.permutated; /* top */
+      } else {
             scan_table = s->intra_scantable.permutated;
-        }
-        qmul=1;
-        qadd=0;
+      }
+      qmul=1;
+      qadd=0;
     } else {
         i = -1;
         if (!coded) {
diff -u mplayer-1.0~rc2-12/libavcodec/h263data.h ffmpeg-free-0.svn20080206/libavcodec/h263data.h
--- mplayer-1.0~rc2-12/libavcodec/h263data.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h263data.h	2007-10-17 11:37:46.000000000 +0200
@@ -26,8 +26,8 @@
  * H.263 tables.
  */
 
-#ifndef AVCODEC_H263DATA_H
-#define AVCODEC_H263DATA_H
+#ifndef FFMPEG_H263DATA_H
+#define FFMPEG_H263DATA_H
 
 #include <stdint.h>
 #include "mpegvideo.h"
@@ -311,4 +311,4 @@
     0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9,10,10,10,11,11,11,12,12,12
 };
 
-#endif // AVCODEC_H263DATA_H
+#endif /* FFMPEG_H263DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/h263dec.c ffmpeg-free-0.svn20080206/libavcodec/h263dec.c
--- mplayer-1.0~rc2-12/libavcodec/h263dec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h263dec.c	2008-03-20 19:10:58.000000000 +0100
@@ -322,7 +322,7 @@
 
 int ff_h263_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     MpegEncContext *s = avctx->priv_data;
     int ret;
@@ -623,9 +623,10 @@
 
     //the second part of the wmv2 header contains the MB skip bits which are stored in current_picture->mb_type
     //which is not available before MPV_frame_start()
-    if (s->msmpeg4_version==5){
-        if(!ENABLE_WMV2_DECODER || ff_wmv2_decode_secondary_picture_header(s) < 0)
-            return -1;
+    if (ENABLE_WMV2_DECODER && s->msmpeg4_version==5){
+        ret = ff_wmv2_decode_secondary_picture_header(s);
+        if(ret<0) return ret;
+        if(ret==1) goto intrax8_decoded;
     }
 
     /* decode each macroblock */
@@ -682,6 +683,7 @@
         }
     }
 
+intrax8_decoded:
     ff_er_frame_end(s);
 
     MPV_frame_end(s);
@@ -700,7 +702,7 @@
     }
 
     /* Return the Picture timestamp as the frame number */
-    /* we substract 1 because it is added on utils.c    */
+    /* we subtract 1 because it is added on utils.c     */
     avctx->frame_number = s->picture_number - 1;
 
 #ifdef PRINT_FRAME_TIME
diff -u mplayer-1.0~rc2-12/libavcodec/h263.h ffmpeg-free-0.svn20080206/libavcodec/h263.h
--- mplayer-1.0~rc2-12/libavcodec/h263.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h263.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_H263_H
-#define AVCODEC_H263_H
+#ifndef FFMPEG_H263_H
+#define FFMPEG_H263_H
 
 #include "config.h"
 #include "msmpeg4.h"
@@ -43,4 +43,4 @@
                                  ENABLE_WMV_ENCODER)
 #define ENABLE_ANY_H263 (ENABLE_ANY_H263_DECODER || ENABLE_ANY_H263_ENCODER)
 
-#endif /* AVCODEC_H263_H */
+#endif /* FFMPEG_H263_H */
diff -u mplayer-1.0~rc2-12/libavcodec/h263_parser.c ffmpeg-free-0.svn20080206/libavcodec/h263_parser.c
--- mplayer-1.0~rc2-12/libavcodec/h263_parser.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h263_parser.c	2008-03-20 19:10:58.000000000 +0100
@@ -77,7 +77,7 @@
         return buf_size;
     }
 
-    *poutbuf = (uint8_t *)buf;
+    *poutbuf = buf;
     *poutbuf_size = buf_size;
     return next;
 }
diff -u mplayer-1.0~rc2-12/libavcodec/h263_parser.h ffmpeg-free-0.svn20080206/libavcodec/h263_parser.h
--- mplayer-1.0~rc2-12/libavcodec/h263_parser.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h263_parser.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,11 +19,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_H263_PARSER_H
-#define AVCODEC_H263_PARSER_H
+#ifndef FFMPEG_H263_PARSER_H
+#define FFMPEG_H263_PARSER_H
 
 #include "parser.h"
 
 int ff_h263_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size);
 
-#endif // AVCODEC_H263_PARSER_H
+#endif /* FFMPEG_H263_PARSER_H */
diff -u mplayer-1.0~rc2-12/libavcodec/h264.c ffmpeg-free-0.svn20080206/libavcodec/h264.c
--- mplayer-1.0~rc2-12/libavcodec/h264.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h264.c	2008-03-20 19:10:58.000000000 +0100
@@ -32,6 +32,7 @@
 #include "h264data.h"
 #include "h264_parser.h"
 #include "golomb.h"
+#include "rectangle.h"
 
 #include "cabac.h"
 
@@ -75,109 +76,23 @@
 };
 
 
-/**
- * fill a rectangle.
- * @param h height of the rectangle, should be a constant
- * @param w width of the rectangle, should be a constant
- * @param size the size of val (1 or 4), should be a constant
- */
-static av_always_inline void fill_rectangle(void *vp, int w, int h, int stride, uint32_t val, int size){
-    uint8_t *p= (uint8_t*)vp;
-    assert(size==1 || size==4);
-    assert(w<=4);
-
-    w      *= size;
-    stride *= size;
-
-    assert((((long)vp)&(FFMIN(w, STRIDE_ALIGN)-1)) == 0);
-    assert((stride&(w-1))==0);
-    if(w==2){
-        const uint16_t v= size==4 ? val : val*0x0101;
-        *(uint16_t*)(p + 0*stride)= v;
-        if(h==1) return;
-        *(uint16_t*)(p + 1*stride)= v;
-        if(h==2) return;
-        *(uint16_t*)(p + 2*stride)= v;
-        *(uint16_t*)(p + 3*stride)= v;
-    }else if(w==4){
-        const uint32_t v= size==4 ? val : val*0x01010101;
-        *(uint32_t*)(p + 0*stride)= v;
-        if(h==1) return;
-        *(uint32_t*)(p + 1*stride)= v;
-        if(h==2) return;
-        *(uint32_t*)(p + 2*stride)= v;
-        *(uint32_t*)(p + 3*stride)= v;
-    }else if(w==8){
-    //gcc can't optimize 64bit math on x86_32
-#if defined(ARCH_X86_64) || (defined(MP_WORDSIZE) && MP_WORDSIZE >= 64)
-        const uint64_t v= val*0x0100000001ULL;
-        *(uint64_t*)(p + 0*stride)= v;
-        if(h==1) return;
-        *(uint64_t*)(p + 1*stride)= v;
-        if(h==2) return;
-        *(uint64_t*)(p + 2*stride)= v;
-        *(uint64_t*)(p + 3*stride)= v;
-    }else if(w==16){
-        const uint64_t v= val*0x0100000001ULL;
-        *(uint64_t*)(p + 0+0*stride)= v;
-        *(uint64_t*)(p + 8+0*stride)= v;
-        *(uint64_t*)(p + 0+1*stride)= v;
-        *(uint64_t*)(p + 8+1*stride)= v;
-        if(h==2) return;
-        *(uint64_t*)(p + 0+2*stride)= v;
-        *(uint64_t*)(p + 8+2*stride)= v;
-        *(uint64_t*)(p + 0+3*stride)= v;
-        *(uint64_t*)(p + 8+3*stride)= v;
-#else
-        *(uint32_t*)(p + 0+0*stride)= val;
-        *(uint32_t*)(p + 4+0*stride)= val;
-        if(h==1) return;
-        *(uint32_t*)(p + 0+1*stride)= val;
-        *(uint32_t*)(p + 4+1*stride)= val;
-        if(h==2) return;
-        *(uint32_t*)(p + 0+2*stride)= val;
-        *(uint32_t*)(p + 4+2*stride)= val;
-        *(uint32_t*)(p + 0+3*stride)= val;
-        *(uint32_t*)(p + 4+3*stride)= val;
-    }else if(w==16){
-        *(uint32_t*)(p + 0+0*stride)= val;
-        *(uint32_t*)(p + 4+0*stride)= val;
-        *(uint32_t*)(p + 8+0*stride)= val;
-        *(uint32_t*)(p +12+0*stride)= val;
-        *(uint32_t*)(p + 0+1*stride)= val;
-        *(uint32_t*)(p + 4+1*stride)= val;
-        *(uint32_t*)(p + 8+1*stride)= val;
-        *(uint32_t*)(p +12+1*stride)= val;
-        if(h==2) return;
-        *(uint32_t*)(p + 0+2*stride)= val;
-        *(uint32_t*)(p + 4+2*stride)= val;
-        *(uint32_t*)(p + 8+2*stride)= val;
-        *(uint32_t*)(p +12+2*stride)= val;
-        *(uint32_t*)(p + 0+3*stride)= val;
-        *(uint32_t*)(p + 4+3*stride)= val;
-        *(uint32_t*)(p + 8+3*stride)= val;
-        *(uint32_t*)(p +12+3*stride)= val;
-#endif
-    }else
-        assert(0);
-    assert(h==4);
-}
-
 static void fill_caches(H264Context *h, int mb_type, int for_deblock){
     MpegEncContext * const s = &h->s;
     const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;
     int topleft_xy, top_xy, topright_xy, left_xy[2];
     int topleft_type, top_type, topright_type, left_type[2];
     int left_block[8];
+    int topleft_partition= -1;
     int i;
 
+    top_xy     = mb_xy  - (s->mb_stride << FIELD_PICTURE);
+
     //FIXME deblocking could skip the intra and nnz parts.
-    if(for_deblock && (h->slice_num == 1 || h->slice_table[mb_xy] == h->slice_table[mb_xy-s->mb_stride]) && !FRAME_MBAFF)
+    if(for_deblock && (h->slice_num == 1 || h->slice_table[mb_xy] == h->slice_table[top_xy]) && !FRAME_MBAFF)
         return;
 
     //wow what a mess, why didn't they simplify the interlacing&intra stuff, i can't imagine that these complex rules are worth it
 
-    top_xy     = mb_xy  - (s->mb_stride << FIELD_PICTURE);
     topleft_xy = top_xy - 1;
     topright_xy= top_xy + 1;
     left_xy[1] = left_xy[0] = mb_xy-1;
@@ -212,6 +127,10 @@
                 : (!curr_mb_frame_flag && !topleft_mb_frame_flag) // top macroblock
                 ) {
             topleft_xy -= s->mb_stride;
+        } else if(bottom && curr_mb_frame_flag && !left_mb_frame_flag) {
+            topleft_xy += s->mb_stride;
+            // take topleft mv from the middle of the mb, as opposed to all other modes which use the bottom-right partition
+            topleft_partition = 0;
         }
         if (bottom
                 ? !curr_mb_frame_flag // bottom macroblock
@@ -489,8 +408,8 @@
                 continue;
 
             if(USES_LIST(topleft_type, list)){
-                const int b_xy = h->mb2b_xy[topleft_xy] + 3 + 3*h->b_stride;
-                const int b8_xy= h->mb2b8_xy[topleft_xy] + 1 + h->b8_stride;
+                const int b_xy = h->mb2b_xy[topleft_xy] + 3 + h->b_stride + (topleft_partition & 2*h->b_stride);
+                const int b8_xy= h->mb2b8_xy[topleft_xy] + 1 + (topleft_partition & h->b8_stride);
                 *(uint32_t*)h->mv_cache[list][scan8[0] - 1 - 1*8]= *(uint32_t*)s->current_picture.motion_val[list][b_xy];
                 h->ref_cache[list][scan8[0] - 1 - 1*8]= s->current_picture.ref_index[list][b8_xy];
             }else{
@@ -787,7 +706,7 @@
 #define SET_DIAG_MV(MV_OP, REF_OP, X4, Y4)\
                 const int x4 = X4, y4 = Y4;\
                 const int mb_type = mb_types[(x4>>2)+(y4>>2)*s->mb_stride];\
-                if(!USES_LIST(mb_type,list) && !IS_8X8(mb_type))\
+                if(!USES_LIST(mb_type,list))\
                     return LIST_NOT_USED;\
                 mv = s->current_picture_ptr->motion_val[list][x4 + y4*h->b_stride];\
                 h->mv_cache[list][scan8[0]-2][0] = mv[0];\
@@ -808,7 +727,7 @@
                && !IS_INTERLACED(mb_types[h->left_mb_xy[0]])
                && i >= scan8[0]+8){
                 // leftshift will turn LIST_NOT_USED into PART_NOT_AVAILABLE, but that's ok.
-                SET_DIAG_MV(>>1, <<1, s->mb_x*4-1, (s->mb_y&~1)*4 - 1 + ((i-scan8[0])>>3)*2);
+                SET_DIAG_MV(/2, <<1, s->mb_x*4-1, (s->mb_y&~1)*4 - 1 + ((i-scan8[0])>>3)*2);
             }
         }
 #undef SET_DIAG_MV
@@ -1103,14 +1022,76 @@
         }
 
         if(ref[1] < 0){
-            *mb_type &= ~MB_TYPE_P0L1;
-            sub_mb_type &= ~MB_TYPE_P0L1;
+            if(!is_b8x8)
+                *mb_type &= ~MB_TYPE_L1;
+            sub_mb_type &= ~MB_TYPE_L1;
         }else if(ref[0] < 0){
-            *mb_type &= ~MB_TYPE_P0L0;
-            sub_mb_type &= ~MB_TYPE_P0L0;
+            if(!is_b8x8)
+                *mb_type &= ~MB_TYPE_L0;
+            sub_mb_type &= ~MB_TYPE_L0;
         }
 
-        if(IS_16X16(*mb_type)){
+        if(IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col)){
+            int pair_xy = s->mb_x + (s->mb_y&~1)*s->mb_stride;
+            int mb_types_col[2];
+            int b8_stride = h->b8_stride;
+            int b4_stride = h->b_stride;
+
+            *mb_type = (*mb_type & ~MB_TYPE_16x16) | MB_TYPE_8x8;
+
+            if(IS_INTERLACED(*mb_type)){
+                mb_types_col[0] = h->ref_list[1][0].mb_type[pair_xy];
+                mb_types_col[1] = h->ref_list[1][0].mb_type[pair_xy+s->mb_stride];
+                if(s->mb_y&1){
+                    l1ref0 -= 2*b8_stride;
+                    l1ref1 -= 2*b8_stride;
+                    l1mv0 -= 4*b4_stride;
+                    l1mv1 -= 4*b4_stride;
+                }
+                b8_stride *= 3;
+                b4_stride *= 6;
+            }else{
+                int cur_poc = s->current_picture_ptr->poc;
+                int *col_poc = h->ref_list[1]->field_poc;
+                int col_parity = FFABS(col_poc[0] - cur_poc) >= FFABS(col_poc[1] - cur_poc);
+                int dy = 2*col_parity - (s->mb_y&1);
+                mb_types_col[0] =
+                mb_types_col[1] = h->ref_list[1][0].mb_type[pair_xy + col_parity*s->mb_stride];
+                l1ref0 += dy*b8_stride;
+                l1ref1 += dy*b8_stride;
+                l1mv0 += 2*dy*b4_stride;
+                l1mv1 += 2*dy*b4_stride;
+                b8_stride = 0;
+            }
+
+            for(i8=0; i8<4; i8++){
+                int x8 = i8&1;
+                int y8 = i8>>1;
+                int xy8 = x8+y8*b8_stride;
+                int xy4 = 3*x8+y8*b4_stride;
+                int a=0, b=0;
+
+                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))
+                    continue;
+                h->sub_mb_type[i8] = sub_mb_type;
+
+                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, (uint8_t)ref[0], 1);
+                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, (uint8_t)ref[1], 1);
+                if(!IS_INTRA(mb_types_col[y8])
+                   && (   (l1ref0[xy8] == 0 && FFABS(l1mv0[xy4][0]) <= 1 && FFABS(l1mv0[xy4][1]) <= 1)
+                       || (l1ref0[xy8]  < 0 && l1ref1[xy8] == 0 && FFABS(l1mv1[xy4][0]) <= 1 && FFABS(l1mv1[xy4][1]) <= 1))){
+                    if(ref[0] > 0)
+                        a= pack16to32(mv[0][0],mv[0][1]);
+                    if(ref[1] > 0)
+                        b= pack16to32(mv[1][0],mv[1][1]);
+                }else{
+                    a= pack16to32(mv[0][0],mv[0][1]);
+                    b= pack16to32(mv[1][0],mv[1][1]);
+                }
+                fill_rectangle(&h->mv_cache[0][scan8[i8*4]], 2, 2, 8, a, 4);
+                fill_rectangle(&h->mv_cache[1][scan8[i8*4]], 2, 2, 8, b, 4);
+            }
+        }else if(IS_16X16(*mb_type)){
             int a=0, b=0;
 
             fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);
@@ -1394,7 +1375,7 @@
  * @param dst_length is the number of decoded bytes FIXME here or a decode rbsp tailing?
  * @returns decoded bytes, might be src+1 if no escapes
  */
-static uint8_t *decode_nal(H264Context *h, uint8_t *src, int *dst_length, int *consumed, int length){
+static const uint8_t *decode_nal(H264Context *h, const uint8_t *src, int *dst_length, int *consumed, int length){
     int i, si, di;
     uint8_t *dst;
     int bufidx;
@@ -1461,7 +1442,7 @@
  * identifies the exact end of the bitstream
  * @return the length of the trailing, or 0 if damaged
  */
-static int decode_rbsp_trailing(H264Context *h, uint8_t *src){
+static int decode_rbsp_trailing(H264Context *h, const uint8_t *src){
     int v= *src;
     int r;
 
@@ -1703,7 +1684,7 @@
     const int full_mx= mx>>2;
     const int full_my= my>>2;
     const int pic_width  = 16*s->mb_width;
-    const int pic_height = 16*s->mb_height >> (MB_MBAFF || FIELD_PICTURE);
+    const int pic_height = 16*s->mb_height >> MB_FIELD;
 
     if(!pic->data[0]) //FIXME this is unacceptable, some senseable error concealment must be done for missing reference frames
         return;
@@ -1727,9 +1708,9 @@
 
     if(ENABLE_GRAY && s->flags&CODEC_FLAG_GRAY) return;
 
-    if(MB_MBAFF || FIELD_PICTURE){
+    if(MB_FIELD){
         // chroma offset when predicting from a field of opposite parity
-        my += 2 * ((s->mb_y & 1) - (h->ref_cache[list][scan8[n]] & 1));
+        my += 2 * ((s->mb_y & 1) - (pic->reference - 1));
         emu |= (my>>3) < 0 || (my>>3) + 8 >= (pic_height>>1);
     }
     src_cb= pic->data[1] + (mx>>3) + (my>>3)*h->mb_uvlinesize;
@@ -1762,7 +1743,7 @@
     dest_cb +=   x_offset +   y_offset*h->mb_uvlinesize;
     dest_cr +=   x_offset +   y_offset*h->mb_uvlinesize;
     x_offset += 8*s->mb_x;
-    y_offset += 8*(s->mb_y >> (MB_MBAFF || FIELD_PICTURE));
+    y_offset += 8*(s->mb_y >> MB_FIELD);
 
     if(list0){
         Picture *ref= &h->ref_list[0][ h->ref_cache[0][ scan8[n] ] ];
@@ -1795,7 +1776,7 @@
     dest_cb +=   x_offset +   y_offset*h->mb_uvlinesize;
     dest_cr +=   x_offset +   y_offset*h->mb_uvlinesize;
     x_offset += 8*s->mb_x;
-    y_offset += 8*(s->mb_y >> (MB_MBAFF || FIELD_PICTURE));
+    y_offset += 8*(s->mb_y >> MB_FIELD);
 
     if(list0 && list1){
         /* don't optimize for luma-only case, since B-frames usually
@@ -2037,7 +2018,6 @@
         av_freep(&hx->top_borders[1]);
         av_freep(&hx->top_borders[0]);
         av_freep(&hx->s.obmc_scratchpad);
-        av_freep(&hx->s.allocated_edge_emu_buffer);
     }
 }
 
@@ -2121,12 +2101,10 @@
     CHECKED_ALLOCZ(h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(uint8_t))
     CHECKED_ALLOCZ(h->cbp_table, big_mb_num * sizeof(uint16_t))
 
-    if( h->pps.cabac ) {
-        CHECKED_ALLOCZ(h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t))
-        CHECKED_ALLOCZ(h->mvd_table[0], 32*big_mb_num * sizeof(uint16_t));
-        CHECKED_ALLOCZ(h->mvd_table[1], 32*big_mb_num * sizeof(uint16_t));
-        CHECKED_ALLOCZ(h->direct_table, 32*big_mb_num * sizeof(uint8_t));
-    }
+    CHECKED_ALLOCZ(h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t))
+    CHECKED_ALLOCZ(h->mvd_table[0], 32*big_mb_num * sizeof(uint16_t));
+    CHECKED_ALLOCZ(h->mvd_table[1], 32*big_mb_num * sizeof(uint16_t));
+    CHECKED_ALLOCZ(h->direct_table, 32*big_mb_num * sizeof(uint8_t));
 
     memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(uint8_t));
     h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;
@@ -2179,15 +2157,9 @@
  * Allocate buffers which are not shared amongst multiple threads.
  */
 static int context_init(H264Context *h){
-    MpegEncContext * const s = &h->s;
-
     CHECKED_ALLOCZ(h->top_borders[0], h->s.mb_width * (16+8+8) * sizeof(uint8_t))
     CHECKED_ALLOCZ(h->top_borders[1], h->s.mb_width * (16+8+8) * sizeof(uint8_t))
 
-    // edge emu needs blocksize + filter length - 1 (=17x17 for halfpel / 21x21 for h264)
-    CHECKED_ALLOCZ(s->allocated_edge_emu_buffer,
-                   (s->width+64)*2*21*2); //(width + edge + align)*interlaced*MBsize*tolerance
-    s->edge_emu_buffer= s->allocated_edge_emu_buffer + (s->width+64)*2*21;
     return 0;
 fail:
     return -1; // free_tables will clean up for us
@@ -2496,13 +2468,13 @@
                     continue;
                 if(IS_16X16(mb_type)){
                     int8_t *ref = &h->ref_cache[list][scan8[0]];
-                    fill_rectangle(ref, 4, 4, 8, 16+*ref^(s->mb_y&1), 1);
+                    fill_rectangle(ref, 4, 4, 8, (16+*ref)^(s->mb_y&1), 1);
                 }else{
                     for(i=0; i<16; i+=4){
                         //FIXME can refs be smaller than 8x8 when !direct_8x8_inference ?
                         int ref = h->ref_cache[list][scan8[i]];
                         if(ref >= 0)
-                            fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, 16+ref^(s->mb_y&1), 1);
+                            fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, (16+ref)^(s->mb_y&1), 1);
                     }
                 }
             }
@@ -2764,11 +2736,12 @@
     else hl_decode_mb_simple(h);
 }
 
-static void pic_as_field(Picture *pic, const int bottom){
+static void pic_as_field(Picture *pic, const int parity){
     int i;
     for (i = 0; i < 4; ++i) {
-        if (bottom)
+        if (parity == PICT_BOTTOM_FIELD)
             pic->data[i] += pic->linesize[i];
+        pic->reference = parity;
         pic->linesize[i] *= 2;
     }
 }
@@ -2779,7 +2752,7 @@
 
     if (match) {
         *dest = *src;
-        pic_as_field(dest, parity == PICT_BOTTOM_FIELD);
+        pic_as_field(dest, parity);
         dest->pic_id *= 2;
         dest->pic_id += id_add;
     }
@@ -2949,15 +2922,6 @@
                 frame_list[ list ][index++].pic_id= i;;
             }
             len[list] = index;
-
-            if(list && (smallest_poc_greater_than_current<=0 || smallest_poc_greater_than_current>=h->short_ref_count) && (1 < index)){
-                // swap the two first elements of L1 when
-                // L0 and L1 are identical
-                Picture temp= frame_list[1][0];
-                frame_list[1][0] = frame_list[1][1];
-                frame_list[1][1] = temp;
-            }
-
         }
 
         for(list=0; list<2; list++){
@@ -2969,6 +2933,14 @@
                                                  s->picture_structure,
                                                  short_len[list]);
 
+            // swap the two first elements of L1 when L0 and L1 are identical
+            if(list && len[0] > 1 && len[0] == len[1])
+                for(i=0; h->default_ref_list[0][i].data[0] == h->default_ref_list[1][i].data[0]; i++)
+                    if(i == len[0]){
+                        FFSWAP(Picture, h->default_ref_list[1][0], h->default_ref_list[1][1]);
+                        break;
+                    }
+
             if(len[list] < h->ref_count[ list ])
                 memset(&h->default_ref_list[list][len[list]], 0, sizeof(Picture)*(h->ref_count[ list ] - len[list]));
         }
@@ -3009,7 +2981,7 @@
     }
     if(h->slice_type==B_TYPE){
         for (i=0; i<h->ref_count[1]; i++) {
-            tprintf(h->s.avctx, "List1: %s fn:%d 0x%p\n", (h->default_ref_list[1][i].long_ref ? "LT" : "ST"), h->default_ref_list[1][i].pic_id, h->default_ref_list[0][i].data[0]);
+            tprintf(h->s.avctx, "List1: %s fn:%d 0x%p\n", (h->default_ref_list[1][i].long_ref ? "LT" : "ST"), h->default_ref_list[1][i].pic_id, h->default_ref_list[1][i].data[0]);
         }
     }
 #endif
@@ -3076,7 +3048,7 @@
                         const unsigned int abs_diff_pic_num= get_ue_golomb(&s->gb) + 1;
                         int frame_num;
 
-                        if(abs_diff_pic_num >= h->max_pic_num){
+                        if(abs_diff_pic_num > h->max_pic_num){
                             av_log(h->s.avctx, AV_LOG_ERROR, "abs_diff_pic_num overflow\n");
                             return -1;
                         }
@@ -3133,8 +3105,7 @@
                         }
                         h->ref_list[list][index]= *ref;
                         if (FIELD_PICTURE){
-                            int bot = pic_structure == PICT_BOTTOM_FIELD;
-                            pic_as_field(&h->ref_list[list][index], bot);
+                            pic_as_field(&h->ref_list[list][index], pic_structure);
                         }
                     }
                 }else{
@@ -3166,9 +3137,11 @@
             field[0] = *frame;
             for(j=0; j<3; j++)
                 field[0].linesize[j] <<= 1;
+            field[0].reference = PICT_TOP_FIELD;
             field[1] = field[0];
             for(j=0; j<3; j++)
                 field[1].data[j] += frame->linesize[j];
+            field[1].reference = PICT_BOTTOM_FIELD;
 
             h->luma_weight[list][16+2*i] = h->luma_weight[list][16+2*i+1] = h->luma_weight[list][i];
             h->luma_offset[list][16+2*i] = h->luma_offset[list][16+2*i+1] = h->luma_offset[list][i];
@@ -3339,6 +3312,8 @@
     idr(h);
     if(h->s.current_picture_ptr)
         h->s.current_picture_ptr->reference= 0;
+    h->s.first_field= 0;
+    ff_mpeg_flush(avctx);
 }
 
 /**
@@ -3465,42 +3440,80 @@
         av_log(h->s.avctx, AV_LOG_DEBUG, "no mmco here\n");
 
     for(i=0; i<mmco_count; i++){
+        int structure, frame_num, unref_pic;
         if(s->avctx->debug&FF_DEBUG_MMCO)
             av_log(h->s.avctx, AV_LOG_DEBUG, "mmco:%d %d %d\n", h->mmco[i].opcode, h->mmco[i].short_pic_num, h->mmco[i].long_arg);
 
         switch(mmco[i].opcode){
         case MMCO_SHORT2UNUSED:
-            pic= remove_short(h, mmco[i].short_pic_num);
-            if(pic)
-                unreference_pic(h, pic, 0);
-            else if(s->avctx->debug&FF_DEBUG_MMCO)
-                av_log(h->s.avctx, AV_LOG_DEBUG, "mmco: remove_short() failure\n");
+            if(s->avctx->debug&FF_DEBUG_MMCO)
+                av_log(h->s.avctx, AV_LOG_DEBUG, "mmco: unref short %d count %d\n", h->mmco[i].short_pic_num, h->short_ref_count);
+            frame_num = pic_num_extract(h, mmco[i].short_pic_num, &structure);
+            pic = find_short(h, frame_num, &j);
+            if (pic) {
+                if (unreference_pic(h, pic, structure ^ PICT_FRAME))
+                    remove_short_at_index(h, j);
+            } else if(s->avctx->debug&FF_DEBUG_MMCO)
+                av_log(h->s.avctx, AV_LOG_DEBUG, "mmco: unref short failure\n");
             break;
         case MMCO_SHORT2LONG:
-            pic= remove_long(h, mmco[i].long_arg);
-            if(pic) unreference_pic(h, pic, 0);
+            if (FIELD_PICTURE && mmco[i].long_arg < h->long_ref_count &&
+                    h->long_ref[mmco[i].long_arg]->frame_num ==
+                                              mmco[i].short_pic_num / 2) {
+                /* do nothing, we've already moved this field pair. */
+            } else {
+                int frame_num = mmco[i].short_pic_num >> FIELD_PICTURE;
 
-            h->long_ref[ mmco[i].long_arg ]= remove_short(h, mmco[i].short_pic_num);
-            if (h->long_ref[ mmco[i].long_arg ]){
-                h->long_ref[ mmco[i].long_arg ]->long_ref=1;
-                h->long_ref_count++;
+                pic= remove_long(h, mmco[i].long_arg);
+                if(pic) unreference_pic(h, pic, 0);
+
+                h->long_ref[ mmco[i].long_arg ]= remove_short(h, frame_num);
+                if (h->long_ref[ mmco[i].long_arg ]){
+                    h->long_ref[ mmco[i].long_arg ]->long_ref=1;
+                    h->long_ref_count++;
+                }
             }
             break;
         case MMCO_LONG2UNUSED:
-            pic= remove_long(h, mmco[i].long_arg);
-            if(pic)
-                unreference_pic(h, pic, 0);
-            else if(s->avctx->debug&FF_DEBUG_MMCO)
-                av_log(h->s.avctx, AV_LOG_DEBUG, "mmco: remove_long() failure\n");
+            j = pic_num_extract(h, mmco[i].long_arg, &structure);
+            pic = h->long_ref[j];
+            if (pic) {
+                if (unreference_pic(h, pic, structure ^ PICT_FRAME))
+                    remove_long_at_index(h, j);
+            } else if(s->avctx->debug&FF_DEBUG_MMCO)
+                av_log(h->s.avctx, AV_LOG_DEBUG, "mmco: unref long failure\n");
             break;
         case MMCO_LONG:
-            pic= remove_long(h, mmco[i].long_arg);
-            if(pic) unreference_pic(h, pic, 0);
+            unref_pic = 1;
+            if (FIELD_PICTURE && !s->first_field) {
+                if (h->long_ref[mmco[i].long_arg] == s->current_picture_ptr) {
+                    /* Just mark second field as referenced */
+                    unref_pic = 0;
+                } else if (s->current_picture_ptr->reference) {
+                    /* First field in pair is in short term list or
+                     * at a different long term index.
+                     * This is not allowed; see 7.4.3, notes 2 and 3.
+                     * Report the problem and keep the pair where it is,
+                     * and mark this field valid.
+                     */
+                    av_log(h->s.avctx, AV_LOG_ERROR,
+                        "illegal long term reference assignment for second "
+                        "field in complementary field pair (first field is "
+                        "short term or has non-matching long index)\n");
+                    unref_pic = 0;
+                }
+            }
+
+            if (unref_pic) {
+                pic= remove_long(h, mmco[i].long_arg);
+                if(pic) unreference_pic(h, pic, 0);
 
-            h->long_ref[ mmco[i].long_arg ]= s->current_picture_ptr;
-            h->long_ref[ mmco[i].long_arg ]->long_ref=1;
-            h->long_ref_count++;
+                h->long_ref[ mmco[i].long_arg ]= s->current_picture_ptr;
+                h->long_ref[ mmco[i].long_arg ]->long_ref=1;
+                h->long_ref_count++;
+            }
 
+            s->current_picture_ptr->reference |= s->picture_structure;
             current_ref_assigned=1;
             break;
         case MMCO_SET_MAX_LONG:
@@ -3525,6 +3538,34 @@
         }
     }
 
+    if (!current_ref_assigned && FIELD_PICTURE &&
+            !s->first_field && s->current_picture_ptr->reference) {
+
+        /* Second field of complementary field pair; the first field of
+         * which is already referenced. If short referenced, it
+         * should be first entry in short_ref. If not, it must exist
+         * in long_ref; trying to put it on the short list here is an
+         * error in the encoded bit stream (ref: 7.4.3, NOTE 2 and 3).
+         */
+        if (h->short_ref_count && h->short_ref[0] == s->current_picture_ptr) {
+            /* Just mark the second field valid */
+            s->current_picture_ptr->reference = PICT_FRAME;
+        } else if (s->current_picture_ptr->long_ref) {
+            av_log(h->s.avctx, AV_LOG_ERROR, "illegal short term reference "
+                                             "assignment for second field "
+                                             "in complementary field pair "
+                                             "(first field is long term)\n");
+        } else {
+            /*
+             * First field in reference, but not in any sensible place on our
+             * reference lists. This shouldn't happen unless reference
+             * handling somewhere else is wrong.
+             */
+            assert(0);
+        }
+        current_ref_assigned = 1;
+    }
+
     if(!current_ref_assigned){
         pic= remove_short(h, s->current_picture_ptr->frame_num);
         if(pic){
@@ -3538,6 +3579,32 @@
         h->short_ref[0]= s->current_picture_ptr;
         h->short_ref[0]->long_ref=0;
         h->short_ref_count++;
+        s->current_picture_ptr->reference |= s->picture_structure;
+    }
+
+    if (h->long_ref_count + h->short_ref_count > h->sps.ref_frame_count){
+
+        /* We have too many reference frames, probably due to corrupted
+         * stream. Need to discard one frame. Prevents overrun of the
+         * short_ref and long_ref buffers.
+         */
+        av_log(h->s.avctx, AV_LOG_ERROR,
+               "number of reference frames exceeds max (probably "
+               "corrupt input), discarding one\n");
+
+        if (h->long_ref_count) {
+            for (i = 0; i < 16; ++i)
+                if (h->long_ref[i])
+                    break;
+
+            assert(i < 16);
+            pic = h->long_ref[i];
+            remove_long_at_index(h, i);
+        } else {
+            pic = h->short_ref[h->short_ref_count - 1];
+            remove_short_at_index(h, h->short_ref_count - 1);
+        }
+        unreference_pic(h, pic, 0);
     }
 
     print_short_term(h);
@@ -3591,7 +3658,7 @@
         }else{
             assert(h->long_ref_count + h->short_ref_count <= h->sps.ref_frame_count);
 
-            if(h->long_ref_count + h->short_ref_count == h->sps.ref_frame_count &&
+            if(h->short_ref_count && h->long_ref_count + h->short_ref_count == h->sps.ref_frame_count &&
                     !(FIELD_PICTURE && !s->first_field && s->current_picture_ptr->reference)) {
                 h->mmco[0].opcode= MMCO_SHORT2UNUSED;
                 h->mmco[0].short_pic_num= h->short_ref[ h->short_ref_count - 1 ]->frame_num;
@@ -3697,8 +3764,10 @@
         s->current_picture_ptr->field_poc[1]= field_poc[1];
         s->current_picture_ptr->poc = field_poc[1];
     }
-    if(!FIELD_PICTURE || !s->first_field)
-        s->current_picture_ptr->poc= FFMIN(field_poc[0], field_poc[1]);
+    if(!FIELD_PICTURE || !s->first_field) {
+        Picture *cur = s->current_picture_ptr;
+        cur->poc= FFMIN(cur->field_poc[0], cur->field_poc[1]);
+    }
 
     return 0;
 }
@@ -3763,6 +3832,7 @@
     dst->s.current_picture      = src->s.current_picture;
     dst->s.linesize             = src->s.linesize;
     dst->s.uvlinesize           = src->s.uvlinesize;
+    dst->s.first_field          = src->s.first_field;
 
     dst->prev_poc_msb           = src->prev_poc_msb;
     dst->prev_poc_lsb           = src->prev_poc_lsb;
@@ -3790,20 +3860,31 @@
  */
 static int decode_slice_header(H264Context *h, H264Context *h0){
     MpegEncContext * const s = &h->s;
+    MpegEncContext * const s0 = &h0->s;
     unsigned int first_mb_in_slice;
     unsigned int pps_id;
     int num_ref_idx_active_override_flag;
     static const uint8_t slice_type_map[5]= {P_TYPE, B_TYPE, I_TYPE, SP_TYPE, SI_TYPE};
     unsigned int slice_type, tmp, i;
     int default_ref_list_done = 0;
+    int last_pic_structure;
 
     s->dropable= h->nal_ref_idc == 0;
 
+    if((s->avctx->flags2 & CODEC_FLAG2_FAST) && !h->nal_ref_idc){
+        s->me.qpel_put= s->dsp.put_2tap_qpel_pixels_tab;
+        s->me.qpel_avg= s->dsp.avg_2tap_qpel_pixels_tab;
+    }else{
+        s->me.qpel_put= s->dsp.put_h264_qpel_pixels_tab;
+        s->me.qpel_avg= s->dsp.avg_h264_qpel_pixels_tab;
+    }
+
     first_mb_in_slice= get_ue_golomb(&s->gb);
 
     if((s->flags2 & CODEC_FLAG2_CHUNKS) && first_mb_in_slice == 0){
         h0->current_slice = 0;
-        s->current_picture_ptr= NULL;
+        if (!s0->first_field)
+            s->current_picture_ptr= NULL;
     }
 
     slice_type= get_ue_golomb(&s->gb);
@@ -3825,6 +3906,11 @@
     h->slice_type= slice_type;
 
     s->pict_type= h->slice_type; // to make a few old func happy, it's wrong though
+    if (s->pict_type == B_TYPE && s0->last_picture_ptr == NULL) {
+        av_log(h->s.avctx, AV_LOG_ERROR,
+               "B picture before any references, skipping\n");
+        return -1;
+    }
 
     pps_id= get_ue_golomb(&s->gb);
     if(pps_id>=MAX_PPS_COUNT){
@@ -3872,6 +3958,7 @@
             return -1;  // we cant (re-)initialize context during parallel decoding
         if (MPV_common_init(s) < 0)
             return -1;
+        s->first_field = 0;
 
         init_scan_tables(h);
         alloc_tables(h);
@@ -3879,7 +3966,7 @@
         for(i = 1; i < s->avctx->thread_count; i++) {
             H264Context *c;
             c = h->thread_context[i] = av_malloc(sizeof(H264Context));
-            memcpy(c, h, sizeof(MpegEncContext));
+            memcpy(c, h->s.thread_context[i], sizeof(MpegEncContext));
             memset(&c->s + 1, 0, sizeof(H264Context) - sizeof(MpegEncContext));
             c->sps = h->sps;
             c->pps = h->pps;
@@ -3910,12 +3997,12 @@
 
     h->mb_mbaff = 0;
     h->mb_aff_frame = 0;
+    last_pic_structure = s0->picture_structure;
     if(h->sps.frame_mbs_only_flag){
         s->picture_structure= PICT_FRAME;
     }else{
         if(get_bits1(&s->gb)) { //field_pic_flag
             s->picture_structure= PICT_TOP_FIELD + get_bits1(&s->gb); //bottom_field_flag
-            av_log(h->s.avctx, AV_LOG_ERROR, "PAFF interlacing is not implemented\n");
         } else {
             s->picture_structure= PICT_FRAME;
             h->mb_aff_frame = h->sps.mb_aff;
@@ -3923,8 +4010,50 @@
     }
 
     if(h0->current_slice == 0){
-        if(frame_start(h) < 0)
+        /* See if we have a decoded first field looking for a pair... */
+        if (s0->first_field) {
+            assert(s0->current_picture_ptr);
+            assert(s0->current_picture_ptr->data[0]);
+            assert(s0->current_picture_ptr->reference != DELAYED_PIC_REF);
+
+            /* figure out if we have a complementary field pair */
+            if (!FIELD_PICTURE || s->picture_structure == last_pic_structure) {
+                /*
+                 * Previous field is unmatched. Don't display it, but let it
+                 * remain for reference if marked as such.
+                 */
+                s0->current_picture_ptr = NULL;
+                s0->first_field = FIELD_PICTURE;
+
+            } else {
+                if (h->nal_ref_idc &&
+                        s0->current_picture_ptr->reference &&
+                        s0->current_picture_ptr->frame_num != h->frame_num) {
+                    /*
+                     * This and previous field were reference, but had
+                     * different frame_nums. Consider this field first in
+                     * pair. Throw away previous field except for reference
+                     * purposes.
+                     */
+                    s0->first_field = 1;
+                    s0->current_picture_ptr = NULL;
+
+                } else {
+                    /* Second field in complementary pair */
+                    s0->first_field = 0;
+                }
+            }
+
+        } else {
+            /* Frame or first field in a potentially complementary pair */
+            assert(!s0->current_picture_ptr);
+            s0->first_field = FIELD_PICTURE;
+        }
+
+        if((!FIELD_PICTURE || s0->first_field) && frame_start(h) < 0) {
+            s0->first_field = 0;
             return -1;
+        }
     }
     if(h != h0)
         clone_slice(h, h0);
@@ -3983,8 +4112,6 @@
     if(h->slice_type == P_TYPE || h->slice_type == SP_TYPE || h->slice_type == B_TYPE){
         if(h->slice_type == B_TYPE){
             h->direct_spatial_mv_pred= get_bits1(&s->gb);
-            if(h->sps.mb_aff && h->direct_spatial_mv_pred)
-                av_log(h->s.avctx, AV_LOG_ERROR, "MBAFF + spatial direct mode is not implemented\n");
         }
         num_ref_idx_active_override_flag= get_bits1(&s->gb);
 
@@ -4081,7 +4208,7 @@
     if(h->deblocking_filter == 1 && h0->max_contexts > 1) {
         if(s->avctx->flags2 & CODEC_FLAG2_FAST) {
             /* Cheat slightly for speed:
-               Dont bother to deblock across slices */
+               Do not bother to deblock across slices. */
             h->deblocking_filter = 2;
         } else {
             h0->max_contexts = 1;
@@ -4121,14 +4248,6 @@
                );
     }
 
-    if((s->avctx->flags2 & CODEC_FLAG2_FAST) && !h->nal_ref_idc){
-        s->me.qpel_put= s->dsp.put_2tap_qpel_pixels_tab;
-        s->me.qpel_avg= s->dsp.avg_2tap_qpel_pixels_tab;
-    }else{
-        s->me.qpel_put= s->dsp.put_h264_qpel_pixels_tab;
-        s->me.qpel_avg= s->dsp.avg_h264_qpel_pixels_tab;
-    }
-
     return 0;
 }
 
@@ -5241,7 +5360,7 @@
     return ctx + 4 * cat;
 }
 
-static const attribute_used uint8_t last_coeff_flag_offset_8x8[63] = {
+DECLARE_ASM_CONST(1, const uint8_t, last_coeff_flag_offset_8x8[63]) = {
     0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
@@ -6252,12 +6371,13 @@
 
 static void filter_mb_fast( H264Context *h, int mb_x, int mb_y, uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr, unsigned int linesize, unsigned int uvlinesize) {
     MpegEncContext * const s = &h->s;
+    int mb_y_firstrow = s->picture_structure == PICT_BOTTOM_FIELD;
     int mb_xy, mb_type;
     int qp, qp0, qp1, qpc, qpc0, qpc1, qp_thresh;
 
     mb_xy = mb_x + mb_y*s->mb_stride;
 
-    if(mb_x==0 || mb_y==0 || !s->dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff ||
+    if(mb_x==0 || mb_y==mb_y_firstrow || !s->dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff ||
        (h->deblocking_filter == 2 && (h->slice_table[mb_xy] != h->slice_table[h->top_mb_xy] ||
                                       h->slice_table[mb_xy] != h->slice_table[mb_xy - 1]))) {
         filter_mb(h, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);
@@ -6284,17 +6404,18 @@
     if( IS_INTRA(mb_type) ) {
         int16_t bS4[4] = {4,4,4,4};
         int16_t bS3[4] = {3,3,3,3};
+        int16_t *bSH = FIELD_PICTURE ? bS3 : bS4;
         if( IS_8x8DCT(mb_type) ) {
             filter_mb_edgev( h, &img_y[4*0], linesize, bS4, qp0 );
             filter_mb_edgev( h, &img_y[4*2], linesize, bS3, qp );
-            filter_mb_edgeh( h, &img_y[4*0*linesize], linesize, bS4, qp1 );
+            filter_mb_edgeh( h, &img_y[4*0*linesize], linesize, bSH, qp1 );
             filter_mb_edgeh( h, &img_y[4*2*linesize], linesize, bS3, qp );
         } else {
             filter_mb_edgev( h, &img_y[4*0], linesize, bS4, qp0 );
             filter_mb_edgev( h, &img_y[4*1], linesize, bS3, qp );
             filter_mb_edgev( h, &img_y[4*2], linesize, bS3, qp );
             filter_mb_edgev( h, &img_y[4*3], linesize, bS3, qp );
-            filter_mb_edgeh( h, &img_y[4*0*linesize], linesize, bS4, qp1 );
+            filter_mb_edgeh( h, &img_y[4*0*linesize], linesize, bSH, qp1 );
             filter_mb_edgeh( h, &img_y[4*1*linesize], linesize, bS3, qp );
             filter_mb_edgeh( h, &img_y[4*2*linesize], linesize, bS3, qp );
             filter_mb_edgeh( h, &img_y[4*3*linesize], linesize, bS3, qp );
@@ -6303,9 +6424,9 @@
         filter_mb_edgecv( h, &img_cb[2*2], uvlinesize, bS3, qpc );
         filter_mb_edgecv( h, &img_cr[2*0], uvlinesize, bS4, qpc0 );
         filter_mb_edgecv( h, &img_cr[2*2], uvlinesize, bS3, qpc );
-        filter_mb_edgech( h, &img_cb[2*0*uvlinesize], uvlinesize, bS4, qpc1 );
+        filter_mb_edgech( h, &img_cb[2*0*uvlinesize], uvlinesize, bSH, qpc1 );
         filter_mb_edgech( h, &img_cb[2*2*uvlinesize], uvlinesize, bS3, qpc );
-        filter_mb_edgech( h, &img_cr[2*0*uvlinesize], uvlinesize, bS4, qpc1 );
+        filter_mb_edgech( h, &img_cr[2*0*uvlinesize], uvlinesize, bSH, qpc1 );
         filter_mb_edgech( h, &img_cr[2*2*uvlinesize], uvlinesize, bS3, qpc );
         return;
     } else {
@@ -6329,7 +6450,7 @@
         if( IS_INTRA(s->current_picture.mb_type[mb_xy-1]) )
             bSv[0][0] = 0x0004000400040004ULL;
         if( IS_INTRA(s->current_picture.mb_type[h->top_mb_xy]) )
-            bSv[1][0] = 0x0004000400040004ULL;
+            bSv[1][0] = FIELD_PICTURE ? 0x0003000300030003ULL : 0x0004000400040004ULL;
 
 #define FILTER(hv,dir,edge)\
         if(bSv[dir][edge]) {\
@@ -7082,8 +7203,9 @@
     }
 
     tmp= get_ue_golomb(&s->gb);
-    if(tmp > MAX_PICTURE_COUNT-2){
+    if(tmp > MAX_PICTURE_COUNT-2 || tmp >= 32){
         av_log(h->s.avctx, AV_LOG_ERROR, "too many reference frames\n");
+        return -1;
     }
     sps->ref_frame_count= tmp;
     sps->gaps_in_frame_num_allowed_flag= get_bits1(&s->gb);
@@ -7295,13 +7417,15 @@
         hx = h->thread_context[context_count - 1];
         s->mb_x = hx->s.mb_x;
         s->mb_y = hx->s.mb_y;
+        s->dropable = hx->s.dropable;
+        s->picture_structure = hx->s.picture_structure;
         for(i = 1; i < context_count; i++)
             h->s.error_count += h->thread_context[i]->s.error_count;
     }
 }
 
 
-static int decode_nal_units(H264Context *h, uint8_t *buf, int buf_size){
+static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){
     MpegEncContext * const s = &h->s;
     AVCodecContext * const avctx= s->avctx;
     int buf_index=0;
@@ -7317,14 +7441,15 @@
 #endif
     if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){
         h->current_slice = 0;
-        s->current_picture_ptr= NULL;
+        if (!s->first_field)
+            s->current_picture_ptr= NULL;
     }
 
     for(;;){
         int consumed;
         int dst_length;
         int bit_length;
-        uint8_t *ptr;
+        const uint8_t *ptr;
         int i, nalsize = 0;
         int err;
 
@@ -7502,7 +7627,7 @@
 
 static int decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     H264Context *h = avctx->priv_data;
     MpegEncContext *s = &h->s;
@@ -7614,86 +7739,109 @@
 
         h->prev_frame_num_offset= h->frame_num_offset;
         h->prev_frame_num= h->frame_num;
-        if(s->current_picture_ptr->reference & s->picture_structure){
+        if(!s->dropable) {
             h->prev_poc_msb= h->poc_msb;
             h->prev_poc_lsb= h->poc_lsb;
             execute_ref_pic_marking(h, h->mmco, h->mmco_index);
         }
 
-        ff_er_frame_end(s);
+        /*
+         * FIXME: Error handling code does not seem to support interlaced
+         * when slices span multiple rows
+         * The ff_er_add_slice calls don't work right for bottom
+         * fields; they cause massive erroneous error concealing
+         * Error marking covers both fields (top and bottom).
+         * This causes a mismatched s->error_count
+         * and a bad error table. Further, the error count goes to
+         * INT_MAX when called for bottom field, because mb_y is
+         * past end by one (callers fault) and resync_mb_y != 0
+         * causes problems for the first MB line, too.
+         */
+        if (!FIELD_PICTURE)
+            ff_er_frame_end(s);
 
         MPV_frame_end(s);
 
-    //FIXME do something with unavailable reference frames
-
-#if 0 //decode order
-        *data_size = sizeof(AVFrame);
-#else
-        /* Sort B-frames into display order */
-
-        if(h->sps.bitstream_restriction_flag
-           && s->avctx->has_b_frames < h->sps.num_reorder_frames){
-            s->avctx->has_b_frames = h->sps.num_reorder_frames;
-            s->low_delay = 0;
-        }
-
-        pics = 0;
-        while(h->delayed_pic[pics]) pics++;
+        if (s->first_field) {
+            /* Wait for second field. */
+            *data_size = 0;
 
-        assert(pics+1 < sizeof(h->delayed_pic) / sizeof(h->delayed_pic[0]));
+        } else {
+            cur->interlaced_frame = FIELD_OR_MBAFF_PICTURE;
+            /* Derive top_field_first from field pocs. */
+            cur->top_field_first = cur->field_poc[0] < cur->field_poc[1];
 
-        h->delayed_pic[pics++] = cur;
-        if(cur->reference == 0)
-            cur->reference = DELAYED_PIC_REF;
+        //FIXME do something with unavailable reference frames
 
-        cross_idr = 0;
-        for(i=0; h->delayed_pic[i]; i++)
-            if(h->delayed_pic[i]->key_frame || h->delayed_pic[i]->poc==0)
-                cross_idr = 1;
+#if 0 //decode order
+            *data_size = sizeof(AVFrame);
+#else
+            /* Sort B-frames into display order */
 
-        out = h->delayed_pic[0];
-        out_idx = 0;
-        for(i=1; h->delayed_pic[i] && !h->delayed_pic[i]->key_frame; i++)
-            if(h->delayed_pic[i]->poc < out->poc){
-                out = h->delayed_pic[i];
-                out_idx = i;
+            if(h->sps.bitstream_restriction_flag
+               && s->avctx->has_b_frames < h->sps.num_reorder_frames){
+                s->avctx->has_b_frames = h->sps.num_reorder_frames;
+                s->low_delay = 0;
+            }
+
+            pics = 0;
+            while(h->delayed_pic[pics]) pics++;
+
+            assert(pics+1 < sizeof(h->delayed_pic) / sizeof(h->delayed_pic[0]));
+
+            h->delayed_pic[pics++] = cur;
+            if(cur->reference == 0)
+                cur->reference = DELAYED_PIC_REF;
+
+            cross_idr = 0;
+            for(i=0; h->delayed_pic[i]; i++)
+                if(h->delayed_pic[i]->key_frame || h->delayed_pic[i]->poc==0)
+                    cross_idr = 1;
+
+            out = h->delayed_pic[0];
+            out_idx = 0;
+            for(i=1; h->delayed_pic[i] && !h->delayed_pic[i]->key_frame; i++)
+                if(h->delayed_pic[i]->poc < out->poc){
+                    out = h->delayed_pic[i];
+                    out_idx = i;
+                }
+
+            out_of_order = !cross_idr && prev && out->poc < prev->poc;
+            if(h->sps.bitstream_restriction_flag && s->avctx->has_b_frames >= h->sps.num_reorder_frames)
+                { }
+            else if(prev && pics <= s->avctx->has_b_frames)
+                out = prev;
+            else if((out_of_order && pics-1 == s->avctx->has_b_frames && pics < 15)
+               || (s->low_delay &&
+                ((!cross_idr && prev && out->poc > prev->poc + 2)
+                 || cur->pict_type == B_TYPE)))
+            {
+                s->low_delay = 0;
+                s->avctx->has_b_frames++;
+                out = prev;
+            }
+            else if(out_of_order)
+                out = prev;
+
+            if(out_of_order || pics > s->avctx->has_b_frames){
+                for(i=out_idx; h->delayed_pic[i]; i++)
+                    h->delayed_pic[i] = h->delayed_pic[i+1];
             }
 
-        out_of_order = !cross_idr && prev && out->poc < prev->poc;
-        if(h->sps.bitstream_restriction_flag && s->avctx->has_b_frames >= h->sps.num_reorder_frames)
-            { }
-        else if(prev && pics <= s->avctx->has_b_frames)
-            out = prev;
-        else if((out_of_order && pics-1 == s->avctx->has_b_frames && pics < 15)
-           || (s->low_delay &&
-            ((!cross_idr && prev && out->poc > prev->poc + 2)
-             || cur->pict_type == B_TYPE)))
-        {
-            s->low_delay = 0;
-            s->avctx->has_b_frames++;
-            out = prev;
-        }
-        else if(out_of_order)
-            out = prev;
-
-        if(out_of_order || pics > s->avctx->has_b_frames){
-            for(i=out_idx; h->delayed_pic[i]; i++)
-                h->delayed_pic[i] = h->delayed_pic[i+1];
-        }
-
-        if(prev == out)
-            *data_size = 0;
-        else
-            *data_size = sizeof(AVFrame);
-        if(prev && prev != out && prev->reference == DELAYED_PIC_REF)
-            prev->reference = 0;
-        h->delayed_output_pic = out;
+            if(prev == out)
+                *data_size = 0;
+            else
+                *data_size = sizeof(AVFrame);
+            if(prev && prev != out && prev->reference == DELAYED_PIC_REF)
+                prev->reference = 0;
+            h->delayed_output_pic = out;
 #endif
 
-        if(out)
-            *pict= *(AVFrame*)out;
-        else
-            av_log(avctx, AV_LOG_DEBUG, "no picture\n");
+            if(out)
+                *pict= *(AVFrame*)out;
+            else
+                av_log(avctx, AV_LOG_DEBUG, "no picture\n");
+        }
     }
 
     assert(pict->data[0] || !*data_size);
@@ -7702,7 +7850,7 @@
 #if 0 //?
 
     /* Return the Picture timestamp as the frame number */
-    /* we substract 1 because it is added on utils.c    */
+    /* we subtract 1 because it is added on utils.c     */
     avctx->frame_number = s->picture_number - 1;
 #endif
     return get_consumed_bytes(s, buf_index, buf_size);
@@ -7727,11 +7875,12 @@
 }
 #endif
 
-#if 0 //selftest
+#ifdef TEST
+#undef printf
 #undef random
 #define COUNT 8000
 #define SIZE (COUNT*40)
-int main(){
+int main(void){
     int i;
     uint8_t temp[SIZE];
     PutBitContext pb;
@@ -7791,6 +7940,7 @@
         STOP_TIMER("get_se_golomb");
     }
 
+#if 0
     printf("testing 4x4 (I)DCT\n");
 
     DCTELEM block[16];
@@ -7830,14 +7980,12 @@
         }
     }
     printf("error=%f max_error=%d\n", ((float)error)/COUNT/16, (int)max_error );
-#if 0
     printf("testing quantizer\n");
     for(qp=0; qp<52; qp++){
         for(i=0; i<16; i++)
             src1_block[i]= src2_block[i]= random()%255;
 
     }
-#endif
     printf("Testing NAL layer\n");
 
     uint8_t bitstream[COUNT];
@@ -7893,13 +8041,14 @@
             return -1;
         }
     }
+#endif
 
     printf("Testing RBSP\n");
 
 
     return 0;
 }
-#endif
+#endif /* TEST */
 
 
 static int decode_end(AVCodecContext *avctx)
diff -u mplayer-1.0~rc2-12/libavcodec/h264data.h ffmpeg-free-0.svn20080206/libavcodec/h264data.h
--- mplayer-1.0~rc2-12/libavcodec/h264data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h264data.h	2007-10-17 11:37:46.000000000 +0200
@@ -26,8 +26,8 @@
  * @author Michael Niedermayer <michaelni@gmx.at>
  */
 
-#ifndef AVCODEC_H264DATA_H
-#define AVCODEC_H264DATA_H
+#ifndef FFMPEG_H264DATA_H
+#define FFMPEG_H264DATA_H
 
 #include <stdint.h>
 #include "mpegvideo.h"
@@ -1305,4 +1305,4 @@
     }
 };
 
-#endif // AVCODEC_H264DATA_H
+#endif /* FFMPEG_H264DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/h264.h ffmpeg-free-0.svn20080206/libavcodec/h264.h
--- mplayer-1.0~rc2-12/libavcodec/h264.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h264.h	2008-02-03 08:05:11.000000000 +0100
@@ -25,8 +25,8 @@
  * @author Michael Niedermayer <michaelni@gmx.at>
  */
 
-#ifndef H264_H
-#define H264_H
+#ifndef FFMPEG_H264_H
+#define FFMPEG_H264_H
 
 #include "dsputil.h"
 #include "cabac.h"
@@ -59,7 +59,7 @@
 #define MB_MBAFF h->mb_mbaff
 #define MB_FIELD h->mb_field_decoding_flag
 #define FRAME_MBAFF h->mb_aff_frame
-#define FIELD_PICTURE 0
+#define FIELD_PICTURE (s->picture_structure != PICT_FRAME)
 #else
 #define MB_MBAFF 0
 #define MB_FIELD 0
@@ -348,7 +348,7 @@
     GetBitContext *intra_gb_ptr;
     GetBitContext *inter_gb_ptr;
 
-    DECLARE_ALIGNED_8(DCTELEM, mb[16*24]);
+    DECLARE_ALIGNED_16(DCTELEM, mb[16*24]);
     DCTELEM mb_padding[256];        ///< as mb is addressed by scantable[i] and scantable is uint8_t we can either check that i is not to large or ensure that there is some unused stuff after mb
 
     /**
@@ -416,4 +416,4 @@
 
 }H264Context;
 
-#endif /* H264_H */
+#endif /* FFMPEG_H264_H */
diff -u mplayer-1.0~rc2-12/libavcodec/h264_mp4toannexb_bsf.c ffmpeg-free-0.svn20080206/libavcodec/h264_mp4toannexb_bsf.c
--- mplayer-1.0~rc2-12/libavcodec/h264_mp4toannexb_bsf.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h264_mp4toannexb_bsf.c	2008-03-20 19:10:58.000000000 +0100
@@ -41,8 +41,8 @@
     if (!offset)
         AV_WB32(*poutbuf+sps_pps_size, 1);
     else {
-        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;
-        (*poutbuf+offset)[2] = 1;
+        (*poutbuf+offset+sps_pps_size)[0] = (*poutbuf+offset+sps_pps_size)[1] = 0;
+        (*poutbuf+offset+sps_pps_size)[2] = 1;
     }
 }
 
diff -u mplayer-1.0~rc2-12/libavcodec/h264_parser.h ffmpeg-free-0.svn20080206/libavcodec/h264_parser.h
--- mplayer-1.0~rc2-12/libavcodec/h264_parser.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h264_parser.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * @author Michael Niedermayer <michaelni@gmx.at>
  */
 
-#ifndef H264_PARSER_H
-#define H264_PARSER_H
+#ifndef FFMPEG_H264_PARSER_H
+#define FFMPEG_H264_PARSER_H
 
 #include "h264.h"
 
@@ -36,4 +36,4 @@
  */
 int ff_h264_find_frame_end(H264Context *h, const uint8_t *buf, int buf_size);
 
-#endif /* H264_PARSER_H */
+#endif /* FFMPEG_H264_PARSER_H */
diff -u mplayer-1.0~rc2-12/libavcodec/h264pred.c ffmpeg-free-0.svn20080206/libavcodec/h264pred.c
--- mplayer-1.0~rc2-12/libavcodec/h264pred.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h264pred.c	2008-03-20 19:10:58.000000000 +0100
@@ -288,10 +288,10 @@
     src[3+3*stride]=(t4 + 2*t5 + t6 + 2)>>2;
 }
 
-static void pred4x4_vertical_left_rv40_c(uint8_t *src, uint8_t *topright, int stride){
+static void pred4x4_vertical_left_rv40(uint8_t *src, uint8_t *topright, int stride,
+                                      const int l0, const int l1, const int l2, const int l3, const int l4){
     LOAD_TOP_EDGE
     LOAD_TOP_RIGHT_EDGE
-    LOAD_LEFT_EDGE
 
     src[0+0*stride]=(2*t0 + 2*t1 + l1 + 2*l2 + l3 + 4)>>3;
     src[1+0*stride]=
@@ -301,7 +301,7 @@
     src[3+0*stride]=
     src[2+2*stride]=(t3 + t4+ 1)>>1;
     src[3+2*stride]=(t4 + t5+ 1)>>1;
-    src[0+1*stride]=(t0 + 2*t1 + t2 + l2 + 2*l3 + l3 + 4)>>3;
+    src[0+1*stride]=(t0 + 2*t1 + t2 + l2 + 2*l3 + l4 + 4)>>3;
     src[1+1*stride]=
     src[0+3*stride]=(t1 + 2*t2 + t3 + 2)>>2;
     src[2+1*stride]=
@@ -311,6 +311,19 @@
     src[3+3*stride]=(t4 + 2*t5 + t6 + 2)>>2;
 }
 
+static void pred4x4_vertical_left_rv40_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+    LOAD_DOWN_LEFT_EDGE
+
+    pred4x4_vertical_left_rv40(src, topright, stride, l0, l1, l2, l3, l4);
+}
+
+static void pred4x4_vertical_left_rv40_nodown_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+
+    pred4x4_vertical_left_rv40(src, topright, stride, l0, l1, l2, l3, l3);
+}
+
 static void pred4x4_horizontal_up_c(uint8_t *src, uint8_t *topright, int stride){
     LOAD_LEFT_EDGE
 
@@ -1010,6 +1023,7 @@
         h->pred4x4[DC_128_PRED         ]= pred4x4_128_dc_c;
         h->pred4x4[DIAG_DOWN_LEFT_PRED_RV40_NODOWN]= pred4x4_down_left_rv40_nodown_c;
         h->pred4x4[HOR_UP_PRED_RV40_NODOWN]= pred4x4_horizontal_up_rv40_nodown_c;
+        h->pred4x4[VERT_LEFT_PRED_RV40_NODOWN]= pred4x4_vertical_left_rv40_nodown_c;
     }
 
     h->pred8x8l[VERT_PRED           ]= pred8x8l_vertical_c;
diff -u mplayer-1.0~rc2-12/libavcodec/h264pred.h ffmpeg-free-0.svn20080206/libavcodec/h264pred.h
--- mplayer-1.0~rc2-12/libavcodec/h264pred.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/h264pred.h	2007-12-17 19:43:34.000000000 +0100
@@ -25,8 +25,8 @@
  * @author Michael Niedermayer <michaelni@gmx.at>
  */
 
-#ifndef H264PRED_H
-#define H264PRED_H
+#ifndef FFMPEG_H264PRED_H
+#define FFMPEG_H264PRED_H
 
 #include "common.h"
 
@@ -50,6 +50,7 @@
 
 #define DIAG_DOWN_LEFT_PRED_RV40_NODOWN   12
 #define HOR_UP_PRED_RV40_NODOWN           13
+#define VERT_LEFT_PRED_RV40_NODOWN        14
 
 #define DC_PRED8x8            0
 #define HOR_PRED8x8           1
@@ -65,7 +66,7 @@
  * Context for storing H.264 prediction functions
  */
 typedef struct H264PredContext{
-    void (*pred4x4  [9+3+2])(uint8_t *src, uint8_t *topright, int stride);//FIXME move to dsp?
+    void (*pred4x4  [9+3+3])(uint8_t *src, uint8_t *topright, int stride);//FIXME move to dsp?
     void (*pred8x8l [9+3])(uint8_t *src, int topleft, int topright, int stride);
     void (*pred8x8  [4+3])(uint8_t *src, int stride);
     void (*pred16x16[4+3])(uint8_t *src, int stride);
@@ -73,4 +74,4 @@
 
 void ff_h264_pred_init(H264PredContext *h, int codec_id);
 
-#endif /* H264PRED_H */
+#endif /* FFMPEG_H264PRED_H */
Only in ffmpeg-free-0.svn20080206/libavcodec: huffman.c
Only in ffmpeg-free-0.svn20080206/libavcodec: huffman.h
diff -u mplayer-1.0~rc2-12/libavcodec/huffyuv.c ffmpeg-free-0.svn20080206/libavcodec/huffyuv.c
--- mplayer-1.0~rc2-12/libavcodec/huffyuv.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/huffyuv.c	2008-03-20 19:10:58.000000000 +0100
@@ -959,7 +959,7 @@
     s->last_slice_end= y + h;
 }
 
-static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size){
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size){
     HYuvContext *s = avctx->priv_data;
     const int width= s->width;
     const int width2= s->width>>1;
@@ -972,7 +972,7 @@
 
     s->bitstream_buffer= av_fast_realloc(s->bitstream_buffer, &s->bitstream_buffer_size, buf_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
-    s->dsp.bswap_buf((uint32_t*)s->bitstream_buffer, (uint32_t*)buf, buf_size/4);
+    s->dsp.bswap_buf((uint32_t*)s->bitstream_buffer, (const uint32_t*)buf, buf_size/4);
 
     if(p->data[0])
         avctx->release_buffer(avctx, p);
Common subdirectories: mplayer-1.0~rc2-12/libavcodec/i386 and ffmpeg-free-0.svn20080206/libavcodec/i386
diff -u mplayer-1.0~rc2-12/libavcodec/idcinvideo.c ffmpeg-free-0.svn20080206/libavcodec/idcinvideo.c
--- mplayer-1.0~rc2-12/libavcodec/idcinvideo.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/idcinvideo.c	2008-03-20 19:10:58.000000000 +0100
@@ -69,7 +69,7 @@
     DSPContext dsp;
     AVFrame frame;
 
-    unsigned char *buf;
+    const unsigned char *buf;
     int size;
 
     hnode_t huff_nodes[256][HUF_TOKENS*2];
@@ -212,7 +212,7 @@
 
 static int idcin_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
-                              uint8_t *buf, int buf_size)
+                              const uint8_t *buf, int buf_size)
 {
     IdcinContext *s = avctx->priv_data;
     AVPaletteControl *palette_control = avctx->palctrl;
diff -u mplayer-1.0~rc2-12/libavcodec/imc.c ffmpeg-free-0.svn20080206/libavcodec/imc.c
--- mplayer-1.0~rc2-12/libavcodec/imc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/imc.c	2008-03-20 19:10:58.000000000 +0100
@@ -41,6 +41,7 @@
 
 #include "imcdata.h"
 
+#define IMC_BLOCK_SIZE 64
 #define IMC_FRAME_ID 0x21
 #define BANDS 32
 #define COEFFS 256
@@ -625,7 +626,7 @@
 
 static int imc_decode_frame(AVCodecContext * avctx,
                             void *data, int *data_size,
-                            uint8_t * buf, int buf_size)
+                            const uint8_t * buf, int buf_size)
 {
 
     IMCContext *q = avctx->priv_data;
@@ -635,13 +636,16 @@
     int flag;
     int bits, summer;
     int counter, bitscount;
-    uint16_t *buf16 = (uint16_t *) buf;
+    uint16_t buf16[IMC_BLOCK_SIZE / 2];
 
-    /* FIXME: input should not be modified */
-    for(i = 0; i < FFMIN(buf_size, avctx->block_align) / 2; i++)
-        buf16[i] = bswap_16(buf16[i]);
+    if (buf_size < IMC_BLOCK_SIZE) {
+        av_log(avctx, AV_LOG_ERROR, "imc frame too small!\n");
+        return -1;
+    }
+    for(i = 0; i < IMC_BLOCK_SIZE / 2; i++)
+        buf16[i] = bswap_16(((const uint16_t*)buf)[i]);
 
-    init_get_bits(&q->gb, buf, 512);
+    init_get_bits(&q->gb, (const uint8_t*)buf16, IMC_BLOCK_SIZE * 8);
 
     /* Check the frame header */
     imc_hdr = get_bits(&q->gb, 9);
@@ -788,7 +792,7 @@
 
     *data_size = COEFFS * sizeof(int16_t);
 
-    return avctx->block_align;
+    return IMC_BLOCK_SIZE;
 }
 
 
diff -u mplayer-1.0~rc2-12/libavcodec/imcdata.h ffmpeg-free-0.svn20080206/libavcodec/imcdata.h
--- mplayer-1.0~rc2-12/libavcodec/imcdata.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/imcdata.h	2007-10-17 11:37:46.000000000 +0200
@@ -21,8 +21,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_IMCDATA_H
-#define AVCODEC_IMCDATA_H
+#ifndef FFMPEG_IMCDATA_H
+#define FFMPEG_IMCDATA_H
 
 #include <stdint.h>
 
@@ -166,4 +166,4 @@
     }
 };
 
-#endif // AVCODEC_IMCDATA_H
+#endif /* FFMPEG_IMCDATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/imgconvert.c ffmpeg-free-0.svn20080206/libavcodec/imgconvert.c
--- mplayer-1.0~rc2-12/libavcodec/imgconvert.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/imgconvert.c	2008-06-18 12:09:30.000000000 +0200
@@ -1901,9 +1901,9 @@
 {
     int x, y, src_wrap, dst_wrap;
     uint16_t *s, *d;
-    s = src->data[0];
+    s = (uint16_t*)src->data[0];
     src_wrap = (src->linesize[0] - width * 2)/2;
-    d = dst->data[0];
+    d = (uint16_t*)dst->data[0];
     dst_wrap = (dst->linesize[0] - width * 2)/2;
     for(y=0; y<height; y++){
         for(x=0; x<width; x++){
@@ -1935,7 +1935,7 @@
 
    - PIX_FMT_422 must convert to and from PIX_FMT_422P.
 
-   The other conversion functions are just optimisations for common cases.
+   The other conversion functions are just optimizations for common cases.
 */
 static const ConvertEntry convert_table[PIX_FMT_NB][PIX_FMT_NB] = {
     [PIX_FMT_YUV420P] = {
@@ -2324,7 +2324,7 @@
 }
 #endif
 
-#ifndef CONFIG_SWSCALER
+#if 1
 /* XXX: always use linesize. Return -1 if not supported */
 int img_convert(AVPicture *dst, int dst_pix_fmt,
                 const AVPicture *src, int src_pix_fmt,
@@ -2555,6 +2555,8 @@
         else
             int_pix_fmt = PIX_FMT_RGB24;
     }
+    if (src_pix_fmt == int_pix_fmt)
+        return -1;
     if (avpicture_alloc(tmp, int_pix_fmt, dst_width, dst_height) < 0)
         return -1;
     ret = -1;
@@ -2824,7 +2826,8 @@
     if (pix_fmt != PIX_FMT_YUV420P &&
         pix_fmt != PIX_FMT_YUV422P &&
         pix_fmt != PIX_FMT_YUV444P &&
-        pix_fmt != PIX_FMT_YUV411P)
+        pix_fmt != PIX_FMT_YUV411P &&
+        pix_fmt != PIX_FMT_GRAY8)
         return -1;
     if ((width & 3) != 0 || (height & 3) != 0)
         return -1;
@@ -2845,6 +2848,9 @@
             default:
                 break;
             }
+            if (pix_fmt == PIX_FMT_GRAY8) {
+                break;
+            }
         }
         if (src == dst) {
             deinterlace_bottom_field_inplace(dst->data[i], dst->linesize[i],
diff -u mplayer-1.0~rc2-12/libavcodec/imgconvert_template.h ffmpeg-free-0.svn20080206/libavcodec/imgconvert_template.h
--- mplayer-1.0~rc2-12/libavcodec/imgconvert_template.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/imgconvert_template.h	2007-12-01 23:21:04.000000000 +0100
@@ -19,6 +19,10 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+/* This header intentionally has no multiple inclusion guards. It is meant to
+ * be included multiple times and generates different code depending on the
+ * value of certain #defines. */
+
 #ifndef RGB_OUT
 #define RGB_OUT(d, r, g, b) RGBA_OUT(d, r, g, b, 0xff)
 #endif
@@ -410,7 +414,7 @@
     }
 }
 
-// RGB24 has optimised routines
+// RGB24 has optimized routines
 #if !defined(FMT_RGB32) && !defined(FMT_RGB24)
 /* alpha support */
 
diff -u mplayer-1.0~rc2-12/libavcodec/imgresample.c ffmpeg-free-0.svn20080206/libavcodec/imgresample.c
--- mplayer-1.0~rc2-12/libavcodec/imgresample.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/imgresample.c	2008-06-18 12:09:30.000000000 +0200
@@ -285,7 +285,7 @@
 }
 #endif /* HAVE_MMX */
 
-/* slow version to handle limit cases. Does not need optimisation */
+/* slow version to handle limit cases. Does not need optimization */
 static void h_resample_slow(uint8_t *dst, int dst_width,
                             const uint8_t *src, int src_width,
                             int src_start, int src_incr, int16_t *filters)
@@ -391,7 +391,7 @@
             h_resample(new_line, owidth,
                        src_line, iwidth, - FCENTER * POS_FRAC, s->h_incr,
                        &s->h_filters[0][0]);
-            /* handle ring buffer wraping */
+            /* handle ring buffer wrapping */
             if (ring_y >= LINE_BUF_HEIGHT) {
                 memcpy(s->line_buf + (ring_y - LINE_BUF_HEIGHT) * owidth,
                        new_line, owidth);
@@ -512,6 +512,12 @@
     av_free(s);
 }
 
+/*
+ * the following symbols are provided by libswscale. Disable them in
+ * libavcodec so that applications can actually link against both
+ * avcodec and libswscale.
+ */
+#if 0
 struct SwsContext *sws_getContext(int srcW, int srcH, int srcFormat,
                                   int dstW, int dstH, int dstFormat,
                                   int flags, SwsFilter *srcFilter,
@@ -688,7 +694,7 @@
     av_free(buf2);
     return res;
 }
-
+#endif
 
 #ifdef TEST
 #include <stdio.h>
diff -u mplayer-1.0~rc2-12/libavcodec/indeo2.c ffmpeg-free-0.svn20080206/libavcodec/indeo2.c
--- mplayer-1.0~rc2-12/libavcodec/indeo2.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/indeo2.c	2008-03-20 19:10:58.000000000 +0100
@@ -136,7 +136,7 @@
 
 static int ir2_decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     Ir2Context * const s = avctx->priv_data;
     AVFrame *picture = data;
diff -u mplayer-1.0~rc2-12/libavcodec/indeo2data.h ffmpeg-free-0.svn20080206/libavcodec/indeo2data.h
--- mplayer-1.0~rc2-12/libavcodec/indeo2data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/indeo2data.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_INDEO2DATA_H
-#define AVCODEC_INDEO2DATA_H
+#ifndef FFMPEG_INDEO2DATA_H
+#define FFMPEG_INDEO2DATA_H
 
 #include <stdint.h>
 
@@ -138,4 +138,4 @@
  0x3F, 0x94, 0xD9, 0xD9, 0x27, 0x27, 0x80, 0x80
 };
 
-#endif // AVCODEC_INDEO2DATA_H
+#endif /* FFMPEG_INDEO2DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/indeo3.c ffmpeg-free-0.svn20080206/libavcodec/indeo3.c
--- mplayer-1.0~rc2-12/libavcodec/indeo3.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/indeo3.c	2008-03-20 19:10:58.000000000 +0100
@@ -27,6 +27,7 @@
 #include "avcodec.h"
 #include "dsputil.h"
 #include "mpegvideo.h"
+#include "bytestream.h"
 
 #include "indeo3data.h"
 
@@ -54,13 +55,13 @@
     unsigned short *corrector_type;
 } Indeo3DecodeContext;
 
-static int corrector_type_0[24] = {
+static const int corrector_type_0[24] = {
   195, 159, 133, 115, 101,  93,  87,  77,
   195, 159, 133, 115, 101,  93,  87,  77,
   128,  79,  79,  79,  79,  79,  79,  79
 };
 
-static int corrector_type_2[8] = { 9, 7, 6, 8, 5, 4, 3, 2 };
+static const int corrector_type_2[8] = { 9, 7, 6, 8, 5, 4, 3, 2 };
 
 static void build_modpred(Indeo3DecodeContext *s)
 {
@@ -92,9 +93,9 @@
 }
 
 static void iv_Decode_Chunk(Indeo3DecodeContext *s, unsigned char *cur,
-  unsigned char *ref, int width, int height, unsigned char *buf1,
-  long fflags2, unsigned char *hdr,
-  unsigned char *buf2, int min_width_160);
+  unsigned char *ref, int width, int height, const unsigned char *buf1,
+  long fflags2, const unsigned char *hdr,
+  const unsigned char *buf2, int min_width_160);
 
 /* ---------------------------------------------------------------------- */
 static void iv_alloc_frames(Indeo3DecodeContext *s)
@@ -176,38 +177,32 @@
 
 /* ---------------------------------------------------------------------- */
 static unsigned long iv_decode_frame(Indeo3DecodeContext *s,
-                                     unsigned char *buf, int buf_size)
+                                     const unsigned char *buf, int buf_size)
 {
   unsigned int hdr_width, hdr_height,
     chroma_width, chroma_height;
   unsigned long fflags1, fflags2, fflags3, offs1, offs2, offs3, offs;
-  unsigned char *hdr_pos, *buf_pos;
+  const unsigned char *hdr_pos, *buf_pos;
 
   buf_pos = buf;
   buf_pos += 18;
 
-  fflags1 = le2me_16(*(uint16_t *)buf_pos);
-  buf_pos += 2;
-  fflags3 = le2me_32(*(uint32_t *)buf_pos);
-  buf_pos += 4;
+  fflags1 = bytestream_get_le16(&buf_pos);
+  fflags3 = bytestream_get_le32(&buf_pos);
   fflags2 = *buf_pos++;
   buf_pos += 3;
-  hdr_height = le2me_16(*(uint16_t *)buf_pos);
-  buf_pos += 2;
-  hdr_width = le2me_16(*(uint16_t *)buf_pos);
+  hdr_height = bytestream_get_le16(&buf_pos);
+  hdr_width  = bytestream_get_le16(&buf_pos);
 
   if(avcodec_check_dimensions(NULL, hdr_width, hdr_height))
       return -1;
 
-  buf_pos += 2;
   chroma_height = ((hdr_height >> 2) + 3) & 0x7ffc;
   chroma_width = ((hdr_width >> 2) + 3) & 0x7ffc;
-  offs1 = le2me_32(*(uint32_t *)buf_pos);
-  buf_pos += 4;
-  offs2 = le2me_32(*(uint32_t *)buf_pos);
+  offs1 = bytestream_get_le32(&buf_pos);
+  offs2 = bytestream_get_le32(&buf_pos);
+  offs3 = bytestream_get_le32(&buf_pos);
   buf_pos += 4;
-  offs3 = le2me_32(*(uint32_t *)buf_pos);
-  buf_pos += 8;
   hdr_pos = buf_pos;
   if(fflags3 == 0x80) return 4;
 
@@ -220,8 +215,7 @@
   }
 
   buf_pos = buf + 16 + offs1;
-  offs = le2me_32(*(uint32_t *)buf_pos);
-  buf_pos += 4;
+  offs = bytestream_get_le32(&buf_pos);
 
   iv_Decode_Chunk(s, s->cur_frame->Ybuf, s->ref_frame->Ybuf, hdr_width,
     hdr_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos,
@@ -231,16 +225,14 @@
   {
 
   buf_pos = buf + 16 + offs2;
-  offs = le2me_32(*(uint32_t *)buf_pos);
-  buf_pos += 4;
+  offs = bytestream_get_le32(&buf_pos);
 
   iv_Decode_Chunk(s, s->cur_frame->Vbuf, s->ref_frame->Vbuf, chroma_width,
     chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos,
     FFMIN(chroma_width, 40));
 
   buf_pos = buf + 16 + offs3;
-  offs = le2me_32(*(uint32_t *)buf_pos);
-  buf_pos += 4;
+  offs = bytestream_get_le32(&buf_pos);
 
   iv_Decode_Chunk(s, s->cur_frame->Ubuf, s->ref_frame->Ubuf, chroma_width,
     chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos,
@@ -307,13 +299,13 @@
 
 static void iv_Decode_Chunk(Indeo3DecodeContext *s,
   unsigned char *cur, unsigned char *ref, int width, int height,
-  unsigned char *buf1, long fflags2, unsigned char *hdr,
-  unsigned char *buf2, int min_width_160)
+  const unsigned char *buf1, long fflags2, const unsigned char *hdr,
+  const unsigned char *buf2, int min_width_160)
 {
   unsigned char bit_buf;
   unsigned long bit_pos, lv, lv1, lv2;
   long *width_tbl, width_tbl_arr[10];
-  signed char *ref_vectors;
+  const signed char *ref_vectors;
   unsigned char *cur_frm_pos, *ref_frm_pos, *cp, *cp2;
   uint32_t *cur_lp, *ref_lp;
   const uint32_t *correction_lp[2], *correctionloworder_lp[2], *correctionhighorder_lp[2];
@@ -378,7 +370,7 @@
     } else if(cmd == 3) {
       if(strip->usl7 == 0) {
         strip->usl7 = 1;
-        ref_vectors = (signed char*)buf2 + (*buf1 * 2);
+        ref_vectors = (const signed char*)buf2 + (*buf1 * 2);
         buf1++;
         continue;
       }
@@ -1074,7 +1066,7 @@
 
 static int indeo3_decode_frame(AVCodecContext *avctx,
                                void *data, int *data_size,
-                               unsigned char *buf, int buf_size)
+                               const unsigned char *buf, int buf_size)
 {
     Indeo3DecodeContext *s=avctx->priv_data;
     unsigned char *src, *dest;
diff -u mplayer-1.0~rc2-12/libavcodec/indeo3data.h ffmpeg-free-0.svn20080206/libavcodec/indeo3data.h
--- mplayer-1.0~rc2-12/libavcodec/indeo3data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/indeo3data.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_INDEO3DATA_H
-#define AVCODEC_INDEO3DATA_H
+#ifndef FFMPEG_INDEO3DATA_H
+#define FFMPEG_INDEO3DATA_H
 
 #include <stdint.h>
 
@@ -2339,4 +2339,4 @@
         0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
 };
 
-#endif // AVCODEC_INDEO3DATA_H
+#endif /* FFMPEG_INDEO3DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/interplayvideo.c ffmpeg-free-0.svn20080206/libavcodec/interplayvideo.c
--- mplayer-1.0~rc2-12/libavcodec/interplayvideo.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/interplayvideo.c	2008-03-20 19:10:58.000000000 +0100
@@ -60,14 +60,14 @@
     AVFrame second_last_frame;
     AVFrame last_frame;
     AVFrame current_frame;
-    unsigned char *decoding_map;
+    const unsigned char *decoding_map;
     int decoding_map_size;
 
-    unsigned char *buf;
+    const unsigned char *buf;
     int size;
 
-    unsigned char *stream_ptr;
-    unsigned char *stream_end;
+    const unsigned char *stream_ptr;
+    const unsigned char *stream_end;
     unsigned char *pixel_ptr;
     int line_inc;
     int stride;
@@ -879,7 +879,7 @@
 
 static int ipvideo_decode_frame(AVCodecContext *avctx,
                                 void *data, int *data_size,
-                                uint8_t *buf, int buf_size)
+                                const uint8_t *buf, int buf_size)
 {
     IpvideoContext *s = avctx->priv_data;
     AVPaletteControl *palette_control = avctx->palctrl;
Only in ffmpeg-free-0.svn20080206/libavcodec: intrax8.c
Only in ffmpeg-free-0.svn20080206/libavcodec: intrax8dsp.c
Only in ffmpeg-free-0.svn20080206/libavcodec: intrax8.h
Only in ffmpeg-free-0.svn20080206/libavcodec: intrax8huf.h
diff -u mplayer-1.0~rc2-12/libavcodec/jpeglsdec.h ffmpeg-free-0.svn20080206/libavcodec/jpeglsdec.h
--- mplayer-1.0~rc2-12/libavcodec/jpeglsdec.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/jpeglsdec.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * JPEG-LS decoder.
  */
 
-#ifndef JPEGLSDEC_H
-#define JPEGLSDEC_H
+#ifndef FFMPEG_JPEGLSDEC_H
+#define FFMPEG_JPEGLSDEC_H
 
 #include "mjpeg.h"
 #include "mjpegdec.h"
@@ -38,4 +38,4 @@
 
 int ff_jpegls_decode_picture(MJpegDecodeContext *s, int near, int point_transform, int ilv);
 
-#endif /* JPEGLSDEC_H */
+#endif /* FFMPEG_JPEGLSDEC_H */
diff -u mplayer-1.0~rc2-12/libavcodec/jpegls.h ffmpeg-free-0.svn20080206/libavcodec/jpegls.h
--- mplayer-1.0~rc2-12/libavcodec/jpegls.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/jpegls.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * JPEG-LS common code.
  */
 
-#ifndef JPEGLS_H
-#define JPEGLS_H
+#ifndef FFMPEG_JPEGLS_H
+#define FFMPEG_JPEGLS_H
 
 #include "avcodec.h"
 
@@ -108,4 +108,4 @@
 #define R(a, i   ) (bits == 8 ?  ((uint8_t*)(a))[i]    :  ((uint16_t*)(a))[i]  )
 #define W(a, i, v) (bits == 8 ? (((uint8_t*)(a))[i]=v) : (((uint16_t*)(a))[i]=v))
 
-#endif /* JPEGLS_H */
+#endif /* FFMPEG_JPEGLS_H */
diff -u mplayer-1.0~rc2-12/libavcodec/kmvc.c ffmpeg-free-0.svn20080206/libavcodec/kmvc.c
--- mplayer-1.0~rc2-12/libavcodec/kmvc.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/kmvc.c	2008-03-20 19:10:58.000000000 +0100
@@ -67,7 +67,7 @@
     } \
 }
 
-static void kmvc_decode_intra_8x8(KmvcContext * ctx, uint8_t * src, int w, int h)
+static void kmvc_decode_intra_8x8(KmvcContext * ctx, const uint8_t * src, int w, int h)
 {
     BitBuf bb;
     int res, val;
@@ -142,7 +142,7 @@
         }
 }
 
-static void kmvc_decode_inter_8x8(KmvcContext * ctx, uint8_t * src, int w, int h)
+static void kmvc_decode_inter_8x8(KmvcContext * ctx, const uint8_t * src, int w, int h)
 {
     BitBuf bb;
     int res, val;
@@ -224,7 +224,7 @@
         }
 }
 
-static int decode_frame(AVCodecContext * avctx, void *data, int *data_size, uint8_t * buf,
+static int decode_frame(AVCodecContext * avctx, void *data, int *data_size, const uint8_t * buf,
                         int buf_size)
 {
     KmvcContext *const ctx = avctx->priv_data;
diff -u mplayer-1.0~rc2-12/libavcodec/lcldec.c ffmpeg-free-0.svn20080206/libavcodec/lcldec.c
--- mplayer-1.0~rc2-12/libavcodec/lcldec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/lcldec.c	2008-03-20 19:10:58.000000000 +0100
@@ -161,7 +161,7 @@
  * Decode a frame
  *
  */
-static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size)
 {
     LclDecContext * const c = avctx->priv_data;
     unsigned char *encoded = (unsigned char *)buf;
diff -u mplayer-1.0~rc2-12/libavcodec/lcl.h ffmpeg-free-0.svn20080206/libavcodec/lcl.h
--- mplayer-1.0~rc2-12/libavcodec/lcl.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/lcl.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_LCL_H
-#define AVCODEC_LCL_H
+#ifndef FFMPEG_LCL_H
+#define FFMPEG_LCL_H
 
 #define BMPTYPE_YUV 1
 #define BMPTYPE_RGB 2
@@ -46,4 +46,4 @@
 #define CODEC_MSZH 1
 #define CODEC_ZLIB 3
 
-#endif /* AVCODEC_LCL_H */
+#endif /* FFMPEG_LCL_H */
diff -u mplayer-1.0~rc2-12/libavcodec/liba52.c ffmpeg-free-0.svn20080206/libavcodec/liba52.c
--- mplayer-1.0~rc2-12/libavcodec/liba52.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/liba52.c	2008-03-20 19:10:58.000000000 +0100
@@ -117,6 +117,13 @@
     s->inbuf_ptr = s->inbuf;
     s->frame_size = 0;
 
+    /* allow downmixing to stereo or mono */
+    if (avctx->channels > 0 && avctx->request_channels > 0 &&
+            avctx->request_channels < avctx->channels &&
+            avctx->request_channels <= 2) {
+        avctx->channels = avctx->request_channels;
+    }
+
     return 0;
 }
 
@@ -179,11 +186,11 @@
                     s->channels = ac3_channels[s->flags & 7];
                     if (s->flags & A52_LFE)
                         s->channels++;
-                    if (avctx->channels == 0)
-                        /* No specific number of channel requested */
-                        avctx->channels = s->channels;
-                    else if (s->channels < avctx->channels) {
-                        av_log(avctx, AV_LOG_ERROR, "ac3dec: AC3 Source channels are less than specified: output to %d channels.. (frmsize: %d)\n", s->channels, len);
+                    if (avctx->request_channels > 0 &&
+                            avctx->request_channels <= 2 &&
+                            avctx->request_channels < s->channels) {
+                        avctx->channels = avctx->request_channels;
+                    } else {
                         avctx->channels = s->channels;
                     }
                     avctx->bit_rate = bit_rate;
diff -u mplayer-1.0~rc2-12/libavcodec/libamr.c ffmpeg-free-0.svn20080206/libavcodec/libamr.c
--- mplayer-1.0~rc2-12/libavcodec/libamr.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/libamr.c	2008-03-20 19:10:58.000000000 +0100
@@ -523,7 +523,7 @@
 #ifdef CONFIG_LIBAMR_WB
 
 #ifdef _TYPEDEF_H
-//To avoid duplicate typedefs from typdef in amr-nb
+//To avoid duplicate typedefs from typedef in amr-nb
 #define typedef_h
 #endif
 
diff -u mplayer-1.0~rc2-12/libavcodec/libfaad.c ffmpeg-free-0.svn20080206/libavcodec/libfaad.c
--- mplayer-1.0~rc2-12/libavcodec/libfaad.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/libfaad.c	2008-03-20 19:10:58.000000000 +0100
@@ -42,7 +42,7 @@
 
 #ifdef CONFIG_LIBFAADBIN
 #include <dlfcn.h>
-static const char* libfaadname = "libfaad.so.0";
+static const char* libfaadname = "libfaad.so";
 #else
 #define dlopen(a)
 #define dlclose(a)
@@ -58,36 +58,36 @@
     faacDecHandle FAADAPI (*faacDecOpen)(void);
     faacDecConfigurationPtr FAADAPI (*faacDecGetCurrentConfiguration)(faacDecHandle hDecoder);
 #ifndef FAAD2_VERSION
-        int FAADAPI (*faacDecSetConfiguration)(faacDecHandle hDecoder,
+    int FAADAPI (*faacDecSetConfiguration)(faacDecHandle hDecoder,
                                            faacDecConfigurationPtr config);
-        int FAADAPI (*faacDecInit)(faacDecHandle hDecoder,
-                                unsigned char *buffer,
-                                unsigned long *samplerate,
-                                unsigned long *channels);
-        int FAADAPI (*faacDecInit2)(faacDecHandle hDecoder, unsigned char *pBuffer,
+    int FAADAPI (*faacDecInit)(faacDecHandle hDecoder,
+                               unsigned char *buffer,
+                               unsigned long *samplerate,
+                               unsigned long *channels);
+    int FAADAPI (*faacDecInit2)(faacDecHandle hDecoder, unsigned char *pBuffer,
                                 unsigned long SizeOfDecoderSpecificInfo,
                                 unsigned long *samplerate, unsigned long *channels);
-        int FAADAPI (*faacDecDecode)(faacDecHandle hDecoder,
-                                unsigned char *buffer,
-                                unsigned long *bytesconsumed,
-                                short *sample_buffer,
-                                unsigned long *samples);
+    int FAADAPI (*faacDecDecode)(faacDecHandle hDecoder,
+                                 unsigned char *buffer,
+                                 unsigned long *bytesconsumed,
+                                 short *sample_buffer,
+                                 unsigned long *samples);
 #else
-        unsigned char FAADAPI (*faacDecSetConfiguration)(faacDecHandle hDecoder,
+    unsigned char FAADAPI (*faacDecSetConfiguration)(faacDecHandle hDecoder,
                                                      faacDecConfigurationPtr config);
-        long FAADAPI (*faacDecInit)(faacDecHandle hDecoder,
-                                   unsigned char *buffer,
-                                 unsigned long buffer_size,
-                                 unsigned long *samplerate,
-                                 unsigned char *channels);
-        char FAADAPI (*faacDecInit2)(faacDecHandle hDecoder, unsigned char *pBuffer,
+    long FAADAPI (*faacDecInit)(faacDecHandle hDecoder,
+                                unsigned char *buffer,
+                                unsigned long buffer_size,
+                                unsigned long *samplerate,
+                                unsigned char *channels);
+    char FAADAPI (*faacDecInit2)(faacDecHandle hDecoder, unsigned char *pBuffer,
                                  unsigned long SizeOfDecoderSpecificInfo,
                                  unsigned long *samplerate, unsigned char *channels);
-        void *FAADAPI (*faacDecDecode)(faacDecHandle hDecoder,
-                                         faacDecFrameInfo *hInfo,
-                                         unsigned char *buffer,
-                                                                 unsigned long buffer_size);
-        char* FAADAPI (*faacDecGetErrorMessage)(unsigned char errcode);
+    void *FAADAPI (*faacDecDecode)(faacDecHandle hDecoder,
+                                   faacDecFrameInfo *hInfo,
+                                   unsigned char *buffer,
+                                   unsigned long buffer_size);
+    char* FAADAPI (*faacDecGetErrorMessage)(unsigned char errcode);
 #endif
 
     void FAADAPI (*faacDecClose)(faacDecHandle hDecoder);
@@ -101,6 +101,21 @@
     24000, 22050, 16000, 12000, 11025, 8000
 };
 
+static void channel_setup(AVCodecContext *avctx)
+{
+#ifdef FAAD2_VERSION
+    FAACContext *s = avctx->priv_data;
+    if (avctx->request_channels > 0 && avctx->request_channels == 2 &&
+        avctx->request_channels < avctx->channels) {
+        faacDecConfigurationPtr faac_cfg;
+        avctx->channels = 2;
+        faac_cfg = s->faacDecGetCurrentConfiguration(s->faac_handle);
+        faac_cfg->downMatrix = 1;
+        s->faacDecSetConfiguration(s->faac_handle, faac_cfg);
+    }
+#endif
+}
+
 static int faac_init_mp4(AVCodecContext *avctx)
 {
     FAACContext *s = avctx->priv_data;
@@ -123,6 +138,7 @@
         } else {
             avctx->sample_rate = samplerate;
             avctx->channels = channels;
+            channel_setup(avctx);
             s->init = 1;
         }
     }
@@ -170,6 +186,7 @@
         }
         avctx->sample_rate = srate;
         avctx->channels = channels;
+        channel_setup(avctx);
         s->init = 1;
     }
 
@@ -177,7 +194,7 @@
 
     if (frame_info.error > 0) {
         av_log(avctx, AV_LOG_ERROR, "faac: frame decoding failed: %s\n",
-                s->faacDecGetErrorMessage(frame_info.error));
+               s->faacDecGetErrorMessage(frame_info.error));
         return -1;
     }
 
@@ -214,54 +231,39 @@
     if (!s->handle)
     {
         av_log(avctx, AV_LOG_ERROR, "FAAD library: %s could not be opened! \n%s\n",
-                libfaadname, dlerror());
+               libfaadname, dlerror());
         return -1;
     }
-#define dfaac(a, b) \
-    do { static const char* n = "faacDec" #a; \
-    if ((s->faacDec ## a = b dlsym( s->handle, n )) == NULL) { err = n; break; } } while(0)
-    for(;;) {
+
+#define dfaac(a) do {                                                   \
+        const char* n = AV_STRINGIFY(faacDec ## a);                     \
+        if (!err && !(s->faacDec ## a = dlsym(s->handle, n))) {         \
+            err = n;                                                    \
+        }                                                               \
+    } while(0)
 #else  /* !CONFIG_LIBFAADBIN */
-#define dfaac(a, b)     s->faacDec ## a = faacDec ## a
+#define dfaac(a)     s->faacDec ## a = faacDec ## a
 #endif /* CONFIG_LIBFAADBIN */
 
-        // resolve all needed function calls
-        dfaac(Open, (faacDecHandle FAADAPI (*)(void)));
-        dfaac(Close, (void FAADAPI (*)(faacDecHandle hDecoder)));
-        dfaac(GetCurrentConfiguration, (faacDecConfigurationPtr
-                                        FAADAPI (*)(faacDecHandle)));
-#ifndef FAAD2_VERSION
-        dfaac(SetConfiguration, (int FAADAPI (*)(faacDecHandle,
-                                                           faacDecConfigurationPtr)));
-
-        dfaac(Init, (int FAADAPI (*)(faacDecHandle, unsigned char*,
-                                     unsigned long*, unsigned long*)));
-    dfaac(Init2, (int FAADAPI (*)(faacDecHandle, unsigned char*,
-                                       unsigned long, unsigned long*,
-                                       unsigned long*)));
-        dfaac(Decode, (int FAADAPI (*)(faacDecHandle, unsigned char*,
-                             unsigned long*, short*, unsigned long*)));
-#else
-        dfaac(SetConfiguration, (unsigned char FAADAPI (*)(faacDecHandle,
-                                                           faacDecConfigurationPtr)));
-        dfaac(Init, (long FAADAPI (*)(faacDecHandle, unsigned char*,
-                                     unsigned long, unsigned long*, unsigned char*)));
-        dfaac(Init2, (char FAADAPI (*)(faacDecHandle, unsigned char*,
-                                       unsigned long, unsigned long*,
-                                       unsigned char*)));
-        dfaac(Decode, (void *FAADAPI (*)(faacDecHandle, faacDecFrameInfo*,
-                             unsigned char*, unsigned long)));
-        dfaac(GetErrorMessage, (char* FAADAPI (*)(unsigned char)));
+    // resolve all needed function calls
+    dfaac(Open);
+    dfaac(Close);
+    dfaac(GetCurrentConfiguration);
+    dfaac(SetConfiguration);
+    dfaac(Init);
+    dfaac(Init2);
+    dfaac(Decode);
+#ifdef FAAD2_VERSION
+    dfaac(GetErrorMessage);
 #endif
-#undef dfacc
+
+#undef dfaac
 
 #ifdef CONFIG_LIBFAADBIN
-        break;
-    }
     if (err) {
         dlclose(s->handle);
         av_log(avctx, AV_LOG_ERROR, "FAAD library: cannot resolve %s in %s!\n",
-                err, libfaadname);
+               err, libfaadname);
         return -1;
     }
 #endif
@@ -308,6 +310,9 @@
 
     faac_init_mp4(avctx);
 
+    if(!s->init && avctx->channels > 0)
+        channel_setup(avctx);
+
     return 0;
 }
 
diff -u mplayer-1.0~rc2-12/libavcodec/libvorbis.c ffmpeg-free-0.svn20080206/libavcodec/libvorbis.c
--- mplayer-1.0~rc2-12/libavcodec/libvorbis.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/libvorbis.c	2008-03-20 19:10:58.000000000 +0100
@@ -218,160 +218,3 @@
     oggvorbis_encode_close,
     .capabilities= CODEC_CAP_DELAY,
 } ;
-
-static int oggvorbis_decode_init(AVCodecContext *avccontext) {
-    OggVorbisContext *context = avccontext->priv_data ;
-    uint8_t *p= avccontext->extradata;
-    int i, hsizes[3];
-    unsigned char *headers[3], *extradata = avccontext->extradata;
-
-    vorbis_info_init(&context->vi) ;
-    vorbis_comment_init(&context->vc) ;
-
-    if(! avccontext->extradata_size || ! p) {
-        av_log(avccontext, AV_LOG_ERROR, "vorbis extradata absent\n");
-        return -1;
-    }
-
-    if(p[0] == 0 && p[1] == 30) {
-        for(i = 0; i < 3; i++){
-            hsizes[i] = bytestream_get_be16(&p);
-            headers[i] = p;
-            p += hsizes[i];
-        }
-    } else if(*p == 2) {
-        unsigned int offset = 1;
-        p++;
-        for(i=0; i<2; i++) {
-            hsizes[i] = 0;
-            while((*p == 0xFF) && (offset < avccontext->extradata_size)) {
-                hsizes[i] += 0xFF;
-                offset++;
-                p++;
-            }
-            if(offset >= avccontext->extradata_size - 1) {
-                av_log(avccontext, AV_LOG_ERROR,
-                       "vorbis header sizes damaged\n");
-                return -1;
-            }
-            hsizes[i] += *p;
-            offset++;
-            p++;
-        }
-        hsizes[2] = avccontext->extradata_size - hsizes[0]-hsizes[1]-offset;
-#if 0
-        av_log(avccontext, AV_LOG_DEBUG,
-               "vorbis header sizes: %d, %d, %d, / extradata_len is %d \n",
-               hsizes[0], hsizes[1], hsizes[2], avccontext->extradata_size);
-#endif
-        headers[0] = extradata + offset;
-        headers[1] = extradata + offset + hsizes[0];
-        headers[2] = extradata + offset + hsizes[0] + hsizes[1];
-    } else {
-        av_log(avccontext, AV_LOG_ERROR,
-               "vorbis initial header len is wrong: %d\n", *p);
-        return -1;
-    }
-
-    for(i=0; i<3; i++){
-        context->op.b_o_s= i==0;
-        context->op.bytes = hsizes[i];
-        context->op.packet = headers[i];
-        if(vorbis_synthesis_headerin(&context->vi, &context->vc, &context->op)<0){
-            av_log(avccontext, AV_LOG_ERROR, "%d. vorbis header damaged\n", i+1);
-            return -1;
-        }
-    }
-
-    avccontext->channels = context->vi.channels;
-    avccontext->sample_rate = context->vi.rate;
-    avccontext->time_base= (AVRational){1, avccontext->sample_rate};
-
-    vorbis_synthesis_init(&context->vd, &context->vi);
-    vorbis_block_init(&context->vd, &context->vb);
-
-    return 0 ;
-}
-
-
-static inline int conv(int samples, float **pcm, char *buf, int channels) {
-    int i, j;
-    ogg_int16_t *ptr, *data = (ogg_int16_t*)buf ;
-    float *mono ;
-
-    for(i = 0 ; i < channels ; i++){
-        ptr = &data[i];
-        mono = pcm[i] ;
-
-        for(j = 0 ; j < samples ; j++) {
-            *ptr = av_clip_int16(mono[j] * 32767.f);
-            ptr += channels;
-        }
-    }
-
-    return 0 ;
-}
-
-
-static int oggvorbis_decode_frame(AVCodecContext *avccontext,
-                        void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
-{
-    OggVorbisContext *context = avccontext->priv_data ;
-    float **pcm ;
-    ogg_packet *op= &context->op;
-    int samples, total_samples, total_bytes;
-
-    if(!buf_size){
-    //FIXME flush
-        return 0;
-    }
-
-    op->packet = buf;
-    op->bytes  = buf_size;
-
-//    av_log(avccontext, AV_LOG_DEBUG, "%d %d %d %"PRId64" %"PRId64" %d %d\n", op->bytes, op->b_o_s, op->e_o_s, op->granulepos, op->packetno, buf_size, context->vi.rate);
-
-/*    for(i=0; i<op->bytes; i++)
-      av_log(avccontext, AV_LOG_DEBUG, "%02X ", op->packet[i]);
-    av_log(avccontext, AV_LOG_DEBUG, "\n");*/
-
-    if(vorbis_synthesis(&context->vb, op) == 0)
-        vorbis_synthesis_blockin(&context->vd, &context->vb) ;
-
-    total_samples = 0 ;
-    total_bytes = 0 ;
-
-    while((samples = vorbis_synthesis_pcmout(&context->vd, &pcm)) > 0) {
-        conv(samples, pcm, (char*)data + total_bytes, context->vi.channels) ;
-        total_bytes += samples * 2 * context->vi.channels ;
-        total_samples += samples ;
-        vorbis_synthesis_read(&context->vd, samples) ;
-    }
-
-    *data_size = total_bytes ;
-    return buf_size ;
-}
-
-
-static int oggvorbis_decode_close(AVCodecContext *avccontext) {
-    OggVorbisContext *context = avccontext->priv_data ;
-
-    vorbis_info_clear(&context->vi) ;
-    vorbis_comment_clear(&context->vc) ;
-
-    return 0 ;
-}
-
-
-AVCodec libvorbis_decoder = {
-    "libvorbis",
-    CODEC_TYPE_AUDIO,
-    CODEC_ID_VORBIS,
-    sizeof(OggVorbisContext),
-    oggvorbis_decode_init,
-    NULL,
-    oggvorbis_decode_close,
-    oggvorbis_decode_frame,
-    .capabilities= CODEC_CAP_DELAY,
-} ;
diff -u mplayer-1.0~rc2-12/libavcodec/libxvid_internal.h ffmpeg-free-0.svn20080206/libavcodec/libxvid_internal.h
--- mplayer-1.0~rc2-12/libavcodec/libxvid_internal.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/libxvid_internal.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef XVID_INTERNAL_H
-#define XVID_INTERNAL_H
+#ifndef FFMPEG_LIBXVID_INTERNAL_H
+#define FFMPEG_LIBXVID_INTERNAL_H
 
 /**
  * @file libxvid_internal.h
@@ -29,4 +29,4 @@
 
 int av_tempfile(char *prefix, char **filename);
 
-#endif /* XVID_INTERNAL_H */
+#endif /* FFMPEG_LIBXVID_INTERNAL_H */
diff -u mplayer-1.0~rc2-12/libavcodec/loco.c ffmpeg-free-0.svn20080206/libavcodec/loco.c
--- mplayer-1.0~rc2-12/libavcodec/loco.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/loco.c	2008-03-20 19:10:58.000000000 +0100
@@ -116,7 +116,7 @@
 }
 
 static int loco_decode_plane(LOCOContext *l, uint8_t *data, int width, int height,
-                             int stride, uint8_t *buf, int buf_size, int step)
+                             int stride, const uint8_t *buf, int buf_size, int step)
 {
     RICEContext rc;
     int val;
@@ -157,7 +157,7 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     LOCOContext * const l = avctx->priv_data;
     AVFrame * const p= (AVFrame*)&l->pic;
diff -u mplayer-1.0~rc2-12/libavcodec/lzw.c ffmpeg-free-0.svn20080206/libavcodec/lzw.c
--- mplayer-1.0~rc2-12/libavcodec/lzw.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/lzw.c	2008-03-20 19:10:58.000000000 +0100
@@ -42,7 +42,7 @@
 };
 
 struct LZWState {
-    uint8_t *pbuf, *ebuf;
+    const uint8_t *pbuf, *ebuf;
     int bbits;
     unsigned int bbuf;
 
@@ -91,7 +91,7 @@
     return c & s->curmask;
 }
 
-uint8_t* ff_lzw_cur_ptr(LZWState *p)
+const uint8_t* ff_lzw_cur_ptr(LZWState *p)
 {
     return ((struct LZWState*)p)->pbuf;
 }
@@ -127,7 +127,7 @@
  * @param buf_size input data size
  * @param mode decoder working mode - either GIF or TIFF
  */
-int ff_lzw_decode_init(LZWState *p, int csize, uint8_t *buf, int buf_size, int mode)
+int ff_lzw_decode_init(LZWState *p, int csize, const uint8_t *buf, int buf_size, int mode)
 {
     struct LZWState *s = (struct LZWState *)p;
 
diff -u mplayer-1.0~rc2-12/libavcodec/lzw.h ffmpeg-free-0.svn20080206/libavcodec/lzw.h
--- mplayer-1.0~rc2-12/libavcodec/lzw.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/lzw.h	2008-02-01 04:26:31.000000000 +0100
@@ -27,8 +27,8 @@
  * Modified for use in TIFF by Konstantin Shishkov
  */
 
-#ifndef LZW_H
-#define LZW_H
+#ifndef FFMPEG_LZW_H
+#define FFMPEG_LZW_H
 
 #include "bitstream.h"
 
@@ -43,9 +43,9 @@
 /* first two functions de/allocate memory for LZWState */
 void ff_lzw_decode_open(LZWState **p);
 void ff_lzw_decode_close(LZWState **p);
-int ff_lzw_decode_init(LZWState *s, int csize, uint8_t *buf, int buf_size, int mode);
+int ff_lzw_decode_init(LZWState *s, int csize, const uint8_t *buf, int buf_size, int mode);
 int ff_lzw_decode(LZWState *s, uint8_t *buf, int len);
-uint8_t* ff_lzw_cur_ptr(LZWState *lzw);
+const uint8_t* ff_lzw_cur_ptr(LZWState *lzw);
 void ff_lzw_decode_tail(LZWState *lzw);
 
 /** LZW encode state */
@@ -56,4 +56,4 @@
 int ff_lzw_encode(struct LZWEncodeState * s, const uint8_t * inbuf, int insize);
 int ff_lzw_encode_flush(struct LZWEncodeState * s);
 
-#endif
+#endif /* FFMPEG_LZW_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mace.c ffmpeg-free-0.svn20080206/libavcodec/mace.c
--- mplayer-1.0~rc2-12/libavcodec/mace.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mace.c	2008-03-20 19:10:58.000000000 +0100
@@ -263,7 +263,7 @@
 
 /* /// "Exp1to3()" */
 static void Exp1to3(MACEContext *ctx,
-             uint8_t *inBuffer,
+             const uint8_t *inBuffer,
              void *outBuffer,
              uint32_t cnt,
              uint32_t numChannels,
@@ -347,7 +347,7 @@
 
 /* /// "Exp1to6()" */
 static void Exp1to6(MACEContext *ctx,
-             uint8_t *inBuffer,
+             const uint8_t *inBuffer,
              void *outBuffer,
              uint32_t cnt,
              uint32_t numChannels,
@@ -401,7 +401,7 @@
 
 static int mace_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     short *samples;
     MACEContext *c = avctx->priv_data;
@@ -409,18 +409,14 @@
     samples = (short *)data;
     switch (avctx->codec->id) {
     case CODEC_ID_MACE3:
-#ifdef DEBUG
-puts("mace_decode_frame[3]()");
-#endif
+        dprintf(avctx, "mace_decode_frame[3]()");
         Exp1to3(c, buf, samples, buf_size / 2 / avctx->channels, avctx->channels, 1);
         if (avctx->channels == 2)
             Exp1to3(c, buf, samples+1, buf_size / 2 / 2, 2, 2);
         *data_size = 2 * 3 * buf_size;
         break;
     case CODEC_ID_MACE6:
-#ifdef DEBUG
-puts("mace_decode_frame[6]()");
-#endif
+        dprintf(avctx, "mace_decode_frame[6]()");
         Exp1to6(c, buf, samples, buf_size / avctx->channels, avctx->channels, 1);
         if (avctx->channels == 2)
             Exp1to6(c, buf, samples+1, buf_size / 2, 2, 2);
diff -u mplayer-1.0~rc2-12/libavcodec/Makefile ffmpeg-free-0.svn20080206/libavcodec/Makefile
--- mplayer-1.0~rc2-12/libavcodec/Makefile	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/Makefile	2008-06-18 12:09:30.000000000 +0200
@@ -18,7 +18,8 @@
        jrevdct.o \
        jfdctfst.o \
        jfdctint.o\
-       mpeg12.o mpeg12data.o \
+       mpeg12.o \
+       mpeg12data.o \
        mpegvideo.o \
        opt.o \
        parser.o \
@@ -56,8 +57,9 @@
 OBJS-$(CONFIG_CYUV_DECODER)            += cyuv.o
 OBJS-$(CONFIG_DCA_DECODER)             += dca.o
 OBJS-$(CONFIG_DNXHD_DECODER)           += dnxhddec.o dnxhddata.o
-OBJS-$(CONFIG_DSICINVIDEO_DECODER)     += dsicinav.o
+OBJS-$(CONFIG_DNXHD_ENCODER)           += dnxhdenc.o dnxhddata.o mpegvideo_enc.o motion_est.o ratecontrol.o
 OBJS-$(CONFIG_DSICINAUDIO_DECODER)     += dsicinav.o
+OBJS-$(CONFIG_DSICINVIDEO_DECODER)     += dsicinav.o
 OBJS-$(CONFIG_DVBSUB_DECODER)          += dvbsubdec.o
 OBJS-$(CONFIG_DVBSUB_ENCODER)          += dvbsub.o
 OBJS-$(CONFIG_DVDSUB_DECODER)          += dvdsubdec.o
@@ -78,7 +80,7 @@
 OBJS-$(CONFIG_FLV_DECODER)             += h263dec.o h263.o
 OBJS-$(CONFIG_FLV_ENCODER)             += mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
 OBJS-$(CONFIG_FOURXM_DECODER)          += 4xm.o
-OBJS-$(CONFIG_FRAPS_DECODER)           += fraps.o
+OBJS-$(CONFIG_FRAPS_DECODER)           += fraps.o huffman.o
 OBJS-$(CONFIG_GIF_DECODER)             += gifdec.o lzw.o
 OBJS-$(CONFIG_GIF_ENCODER)             += gif.o
 OBJS-$(CONFIG_H261_DECODER)            += h261dec.o h261.o
@@ -95,8 +97,8 @@
 OBJS-$(CONFIG_IMC_DECODER)             += imc.o mdct.o fft.o
 OBJS-$(CONFIG_INDEO2_DECODER)          += indeo2.o
 OBJS-$(CONFIG_INDEO3_DECODER)          += indeo3.o
-OBJS-$(CONFIG_INTERPLAY_VIDEO_DECODER) += interplayvideo.o
 OBJS-$(CONFIG_INTERPLAY_DPCM_DECODER)  += dpcm.o
+OBJS-$(CONFIG_INTERPLAY_VIDEO_DECODER) += interplayvideo.o
 OBJS-$(CONFIG_JPEGLS_DECODER)          += jpeglsdec.o jpegls.o mjpegdec.o mjpeg.o golomb.o
 OBJS-$(CONFIG_JPEGLS_ENCODER)          += jpeglsenc.o jpegls.o golomb.o
 OBJS-$(CONFIG_KMVC_DECODER)            += kmvc.o
@@ -113,7 +115,8 @@
 OBJS-$(CONFIG_MP3_DECODER)             += mpegaudiodec.o mpegaudiodecheader.o mpegaudio.o mpegaudiodata.o
 OBJS-$(CONFIG_MP3ADU_DECODER)          += mpegaudiodec.o mpegaudiodecheader.o mpegaudio.o mpegaudiodata.o
 OBJS-$(CONFIG_MP3ON4_DECODER)          += mpegaudiodec.o mpegaudiodecheader.o mpegaudio.o mpegaudiodata.o
-OBJS-$(CONFIG_MPC7_DECODER)            += mpc.o mpegaudiodec.o mpegaudiodecheader.o mpegaudio.o mpegaudiodata.o
+OBJS-$(CONFIG_MPC7_DECODER)            += mpc7.o mpc.o mpegaudiodec.o mpegaudiodecheader.o mpegaudio.o mpegaudiodata.o
+OBJS-$(CONFIG_MPC8_DECODER)            += mpc8.o mpc.o mpegaudiodec.o mpegaudiodecheader.o mpegaudio.o mpegaudiodata.o
 OBJS-$(CONFIG_MPEG1VIDEO_ENCODER)      += mpeg12enc.o mpeg12data.o mpegvideo_enc.o motion_est.o ratecontrol.o
 OBJS-$(CONFIG_MPEG2VIDEO_ENCODER)      += mpeg12enc.o mpeg12data.o mpegvideo_enc.o motion_est.o ratecontrol.o
 OBJS-$(CONFIG_MPEG4_DECODER)           += h263dec.o h263.o
@@ -127,9 +130,11 @@
 OBJS-$(CONFIG_MSRLE_DECODER)           += msrle.o
 OBJS-$(CONFIG_MSVIDEO1_DECODER)        += msvideo1.o
 OBJS-$(CONFIG_MSZH_DECODER)            += lcldec.o
+OBJS-$(CONFIG_NELLYMOSER_DECODER)      += nellymoserdec.o mdct.o fft.o
 OBJS-$(CONFIG_NUV_DECODER)             += nuv.o rtjpeg.o
 OBJS-$(CONFIG_PAM_ENCODER)             += pnmenc.o pnm.o
 OBJS-$(CONFIG_PBM_ENCODER)             += pnmenc.o pnm.o
+OBJS-$(CONFIG_PCX_DECODER)             += pcx.o
 OBJS-$(CONFIG_PGM_ENCODER)             += pnmenc.o pnm.o
 OBJS-$(CONFIG_PGMYUV_ENCODER)          += pnmenc.o pnm.o
 OBJS-$(CONFIG_PNG_DECODER)             += png.o pngdec.o
@@ -167,6 +172,7 @@
 OBJS-$(CONFIG_SONIC_ENCODER)           += sonic.o golomb.o
 OBJS-$(CONFIG_SONIC_LS_ENCODER)        += sonic.o golomb.o
 OBJS-$(CONFIG_SP5X_DECODER)            += sp5xdec.o mjpegdec.o mjpeg.o
+OBJS-$(CONFIG_SUNRAST_DECODER)         += sunrast.o
 OBJS-$(CONFIG_SVQ1_DECODER)            += svq1dec.o svq1.o h263.o
 OBJS-$(CONFIG_SVQ1_ENCODER)            += svq1enc.o svq1.o motion_est.o h263.o
 OBJS-$(CONFIG_SVQ3_DECODER)            += h264.o h264idct.o h264pred.o cabac.o golomb.o
@@ -184,7 +190,8 @@
 OBJS-$(CONFIG_TTA_DECODER)             += tta.o
 OBJS-$(CONFIG_TXD_DECODER)             += txd.o s3tc.o
 OBJS-$(CONFIG_ULTI_DECODER)            += ulti.o
-OBJS-$(CONFIG_VC1_DECODER)             += vc1.o vc1data.o vc1dsp.o msmpeg4data.o
+OBJS-$(CONFIG_VB_DECODER)              += vb.o
+OBJS-$(CONFIG_VC1_DECODER)             += vc1.o vc1data.o vc1dsp.o msmpeg4data.o intrax8.o intrax8dsp.o
 OBJS-$(CONFIG_VCR1_DECODER)            += vcr1.o
 OBJS-$(CONFIG_VCR1_ENCODER)            += vcr1.o
 OBJS-$(CONFIG_VMDAUDIO_DECODER)        += vmdav.o
@@ -194,18 +201,19 @@
 OBJS-$(CONFIG_VORBIS_ENCODER)          += vorbis_enc.o vorbis.o vorbis_data.o mdct.o fft.o
 OBJS-$(CONFIG_VP3_DECODER)             += vp3.o vp3dsp.o
 OBJS-$(CONFIG_VP5_DECODER)             += vp5.o vp56.o vp56data.o vp3dsp.o
-OBJS-$(CONFIG_VP6_DECODER)             += vp6.o vp56.o vp56data.o vp3dsp.o
-OBJS-$(CONFIG_VP6F_DECODER)            += vp6.o vp56.o vp56data.o vp3dsp.o
+OBJS-$(CONFIG_VP6_DECODER)             += vp6.o vp56.o vp56data.o vp3dsp.o huffman.o
+OBJS-$(CONFIG_VP6A_DECODER)            += vp6.o vp56.o vp56data.o vp3dsp.o huffman.o
+OBJS-$(CONFIG_VP6F_DECODER)            += vp6.o vp56.o vp56data.o vp3dsp.o huffman.o
 OBJS-$(CONFIG_VQA_DECODER)             += vqavideo.o
 OBJS-$(CONFIG_WAVPACK_DECODER)         += wavpack.o
 OBJS-$(CONFIG_WMAV1_DECODER)           += wmadec.o wma.o mdct.o fft.o
-OBJS-$(CONFIG_WMAV2_DECODER)           += wmadec.o wma.o mdct.o fft.o
 OBJS-$(CONFIG_WMAV1_ENCODER)           += wmaenc.o wma.o mdct.o fft.o
+OBJS-$(CONFIG_WMAV2_DECODER)           += wmadec.o wma.o mdct.o fft.o
 OBJS-$(CONFIG_WMAV2_ENCODER)           += wmaenc.o wma.o mdct.o fft.o
 OBJS-$(CONFIG_WMV1_DECODER)            += h263dec.o h263.o
 OBJS-$(CONFIG_WMV1_ENCODER)            += mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
-OBJS-$(CONFIG_WMV2_DECODER)            += msmpeg4.o msmpeg4data.o h263dec.o h263.o
-OBJS-$(CONFIG_WMV2_ENCODER)            += msmpeg4.o msmpeg4data.o mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
+OBJS-$(CONFIG_WMV2_DECODER)            += wmv2dec.o wmv2.o msmpeg4.o msmpeg4data.o h263dec.o h263.o intrax8.o intrax8dsp.o
+OBJS-$(CONFIG_WMV2_ENCODER)            += wmv2enc.o wmv2.o msmpeg4.o msmpeg4data.o mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
 OBJS-$(CONFIG_WMV3_DECODER)            += vc1.o vc1data.o vc1dsp.o
 OBJS-$(CONFIG_WNV1_DECODER)            += wnv1.o
 OBJS-$(CONFIG_WS_SND1_DECODER)         += ws-snd1.o
@@ -219,26 +227,27 @@
 OBJS-$(CONFIG_ZMBV_DECODER)            += zmbv.o
 OBJS-$(CONFIG_ZMBV_ENCODER)            += zmbvenc.o
 
-OBJS-$(CONFIG_PCM_S32LE_DECODER)       += pcm.o
-OBJS-$(CONFIG_PCM_S32LE_ENCODER)       += pcm.o
 OBJS-$(CONFIG_PCM_S32BE_DECODER)       += pcm.o
 OBJS-$(CONFIG_PCM_S32BE_ENCODER)       += pcm.o
-OBJS-$(CONFIG_PCM_U32LE_DECODER)       += pcm.o
-OBJS-$(CONFIG_PCM_U32LE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S32LE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S32LE_ENCODER)       += pcm.o
 OBJS-$(CONFIG_PCM_U32BE_DECODER)       += pcm.o
 OBJS-$(CONFIG_PCM_U32BE_ENCODER)       += pcm.o
-OBJS-$(CONFIG_PCM_S24LE_DECODER)       += pcm.o
-OBJS-$(CONFIG_PCM_S24LE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U32LE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U32LE_ENCODER)       += pcm.o
 OBJS-$(CONFIG_PCM_S24BE_DECODER)       += pcm.o
 OBJS-$(CONFIG_PCM_S24BE_ENCODER)       += pcm.o
-OBJS-$(CONFIG_PCM_U24LE_DECODER)       += pcm.o
-OBJS-$(CONFIG_PCM_U24LE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S24LE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S24LE_ENCODER)       += pcm.o
 OBJS-$(CONFIG_PCM_U24BE_DECODER)       += pcm.o
 OBJS-$(CONFIG_PCM_U24BE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U24LE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U24LE_ENCODER)       += pcm.o
 OBJS-$(CONFIG_PCM_S24DAUD_DECODER)     += pcm.o
 OBJS-$(CONFIG_PCM_S24DAUD_ENCODER)     += pcm.o
 OBJS-$(CONFIG_PCM_S16LE_DECODER)       += pcm.o
 OBJS-$(CONFIG_PCM_S16LE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S16LE_PLANAR_DECODER)+= pcm.o
 OBJS-$(CONFIG_PCM_S16BE_DECODER)       += pcm.o
 OBJS-$(CONFIG_PCM_S16BE_ENCODER)       += pcm.o
 OBJS-$(CONFIG_PCM_U16LE_DECODER)       += pcm.o
@@ -253,49 +262,50 @@
 OBJS-$(CONFIG_PCM_ALAW_ENCODER)        += pcm.o
 OBJS-$(CONFIG_PCM_MULAW_DECODER)       += pcm.o
 OBJS-$(CONFIG_PCM_MULAW_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_ZORK_DECODER)        += pcm.o
+OBJS-$(CONFIG_PCM_ZORK_ENCODER)        += pcm.o
 
 OBJS-$(CONFIG_ADPCM_4XM_DECODER)       += adpcm.o
-OBJS-$(CONFIG_ADPCM_4XM_ENCODER)       += adpcm.o
-OBJS-$(CONFIG_ADPCM_ADX_DECODER)       += adx.o
-OBJS-$(CONFIG_ADPCM_ADX_ENCODER)       += adx.o
+OBJS-$(CONFIG_ADPCM_ADX_DECODER)       += adxdec.o
+OBJS-$(CONFIG_ADPCM_ADX_ENCODER)       += adxenc.o
 OBJS-$(CONFIG_ADPCM_CT_DECODER)        += adpcm.o
-OBJS-$(CONFIG_ADPCM_CT_ENCODER)        += adpcm.o
 OBJS-$(CONFIG_ADPCM_EA_DECODER)        += adpcm.o
-OBJS-$(CONFIG_ADPCM_EA_ENCODER)        += adpcm.o
+OBJS-$(CONFIG_ADPCM_EA_R1_DECODER)     += adpcm.o
+OBJS-$(CONFIG_ADPCM_EA_R2_DECODER)     += adpcm.o
+OBJS-$(CONFIG_ADPCM_EA_R3_DECODER)     += adpcm.o
+OBJS-$(CONFIG_ADPCM_EA_XAS_DECODER)    += adpcm.o
 OBJS-$(CONFIG_ADPCM_G726_DECODER)      += g726.o
 OBJS-$(CONFIG_ADPCM_G726_ENCODER)      += g726.o
 OBJS-$(CONFIG_ADPCM_IMA_AMV_DECODER)   += adpcm.o
 OBJS-$(CONFIG_ADPCM_IMA_DK3_DECODER)   += adpcm.o
-OBJS-$(CONFIG_ADPCM_IMA_DK3_ENCODER)   += adpcm.o
 OBJS-$(CONFIG_ADPCM_IMA_DK4_DECODER)   += adpcm.o
-OBJS-$(CONFIG_ADPCM_IMA_DK4_ENCODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_EA_EACS_DECODER) += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_EA_SEAD_DECODER) += adpcm.o
 OBJS-$(CONFIG_ADPCM_IMA_QT_DECODER)    += adpcm.o
-OBJS-$(CONFIG_ADPCM_IMA_QT_ENCODER)    += adpcm.o
 OBJS-$(CONFIG_ADPCM_IMA_SMJPEG_DECODER) += adpcm.o
-OBJS-$(CONFIG_ADPCM_IMA_SMJPEG_ENCODER) += adpcm.o
 OBJS-$(CONFIG_ADPCM_IMA_WAV_DECODER)   += adpcm.o
 OBJS-$(CONFIG_ADPCM_IMA_WAV_ENCODER)   += adpcm.o
 OBJS-$(CONFIG_ADPCM_IMA_WS_DECODER)    += adpcm.o
-OBJS-$(CONFIG_ADPCM_IMA_WS_ENCODER)    += adpcm.o
 OBJS-$(CONFIG_ADPCM_MS_DECODER)        += adpcm.o
 OBJS-$(CONFIG_ADPCM_MS_ENCODER)        += adpcm.o
 OBJS-$(CONFIG_ADPCM_SBPRO_2_DECODER)   += adpcm.o
-OBJS-$(CONFIG_ADPCM_SBPRO_2_ENCODER)   += adpcm.o
 OBJS-$(CONFIG_ADPCM_SBPRO_3_DECODER)   += adpcm.o
-OBJS-$(CONFIG_ADPCM_SBPRO_3_ENCODER)   += adpcm.o
 OBJS-$(CONFIG_ADPCM_SBPRO_4_DECODER)   += adpcm.o
-OBJS-$(CONFIG_ADPCM_SBPRO_4_ENCODER)   += adpcm.o
 OBJS-$(CONFIG_ADPCM_SWF_DECODER)       += adpcm.o
 OBJS-$(CONFIG_ADPCM_SWF_ENCODER)       += adpcm.o
 OBJS-$(CONFIG_ADPCM_THP_DECODER)       += adpcm.o
 OBJS-$(CONFIG_ADPCM_XA_DECODER)        += adpcm.o
-OBJS-$(CONFIG_ADPCM_XA_ENCODER)        += adpcm.o
 OBJS-$(CONFIG_ADPCM_YAMAHA_DECODER)    += adpcm.o
 OBJS-$(CONFIG_ADPCM_YAMAHA_ENCODER)    += adpcm.o
 
+# libavformat dependencies
+OBJS-$(CONFIG_MATROSKA_MUXER)          += xiph.o
+OBJS-$(CONFIG_OGG_MUXER)               += xiph.o
+
 # external codec libraries
 OBJS-$(CONFIG_LIBA52)                  += liba52.o
-OBJS-$(CONFIG_LIBAMR)                  += libamr.o
+OBJS-$(CONFIG_LIBAMR_NB)               += libamr.o
+OBJS-$(CONFIG_LIBAMR_WB)               += libamr.o
 OBJS-$(CONFIG_LIBFAAC)                 += libfaac.o
 OBJS-$(CONFIG_LIBFAAD)                 += libfaad.o
 OBJS-$(CONFIG_LIBGSM)                  += libgsm.o
@@ -316,6 +326,7 @@
 OBJS-$(CONFIG_H263_PARSER)             += h263_parser.o
 OBJS-$(CONFIG_H264_PARSER)             += h264_parser.o
 OBJS-$(CONFIG_MJPEG_PARSER)            += mjpeg_parser.o
+OBJS-$(CONFIG_MLP_PARSER)              += mlp_parser.o
 OBJS-$(CONFIG_MPEG4VIDEO_PARSER)       += mpeg4video_parser.o h263.o
 OBJS-$(CONFIG_MPEGAUDIO_PARSER)        += mpegaudio_parser.o mpegaudiodecheader.o mpegaudiodata.o
 OBJS-$(CONFIG_MPEGVIDEO_PARSER)        += mpegvideo_parser.o
@@ -326,10 +337,12 @@
 OBJS-$(CONFIG_H264_MP4TOANNEXB_BSF)    += h264_mp4toannexb_bsf.o
 OBJS-$(CONFIG_IMX_DUMP_HEADER_BSF)     += imx_dump_header_bsf.o
 OBJS-$(CONFIG_MJPEGA_DUMP_HEADER_BSF)  += mjpega_dump_header_bsf.o
+OBJS-$(CONFIG_MOV2TEXTSUB_BSF)         += movsub_bsf.o
 OBJS-$(CONFIG_MP3_HEADER_COMPRESS_BSF) += mp3_header_compress_bsf.o
 OBJS-$(CONFIG_MP3_HEADER_DECOMPRESS_BSF) += mp3_header_decompress_bsf.o mpegaudiodata.o
 OBJS-$(CONFIG_NOISE_BSF)               += noise_bsf.o
 OBJS-$(CONFIG_REMOVE_EXTRADATA_BSF)    += remove_extradata_bsf.o
+OBJS-$(CONFIG_TEXT2MOVSUB_BSF)         += movsub_bsf.o
 
 OBJS-$(HAVE_BEOSTHREADS)               += beosthread.o
 OBJS-$(HAVE_OS2THREADS)                += os2thread.o
@@ -338,9 +351,7 @@
 
 OBJS-$(HAVE_XVMC_ACCEL)                += xvmcvideo.o
 
-ifneq ($(CONFIG_SWSCALER),yes)
 OBJS += imgresample.o
-endif
 
 # processor-specific code
 ifeq ($(HAVE_MMX),yes)
@@ -358,11 +369,15 @@
 OBJS-$(CONFIG_GPL)                     += i386/idct_mmx.o
 
 OBJS-$(CONFIG_CAVS_DECODER)            += i386/cavsdsp_mmx.o
+OBJS-$(CONFIG_FLAC_ENCODER)            += i386/flacdsp_mmx.o
 OBJS-$(CONFIG_SNOW_DECODER)            += i386/snowdsp_mmx.o
+OBJS-$(CONFIG_VC1_DECODER)             += i386/vc1dsp_mmx.o
 OBJS-$(CONFIG_VP3_DECODER)             += i386/vp3dsp_mmx.o i386/vp3dsp_sse2.o
 OBJS-$(CONFIG_VP5_DECODER)             += i386/vp3dsp_mmx.o i386/vp3dsp_sse2.o
 OBJS-$(CONFIG_VP6_DECODER)             += i386/vp3dsp_mmx.o i386/vp3dsp_sse2.o
+OBJS-$(CONFIG_VP6A_DECODER)            += i386/vp3dsp_mmx.o i386/vp3dsp_sse2.o
 OBJS-$(CONFIG_VP6F_DECODER)            += i386/vp3dsp_mmx.o i386/vp3dsp_sse2.o
+OBJS-$(CONFIG_WMV3_DECODER)            += i386/vc1dsp_mmx.o
 endif
 
 ASM_OBJS-$(ARCH_ARMV4L)                += armv4l/jrevdct_arm.o     \
@@ -439,6 +454,11 @@
 LIBVERSION=$(LAVCVERSION)
 LIBMAJOR=$(LAVCMAJOR)
 
+TESTS = $(addsuffix -test$(EXESUF), cabac dct eval fft h264 imgresample rangecoder snow)
+ifeq ($(ARCH_X86),yes)
+TESTS += cpuid-test$(EXESUF) motion-test$(EXESUF)
+endif
+
 include ../common.mak
 
 clean::
@@ -452,27 +472,10 @@
 	   ps2/*.o ps2/*~ \
 	   sh4/*.o sh4/*~ \
 	   sparc/*.o sparc/*~ \
-	   apiexample $(TESTS)
-
-TESTS= imgresample-test fft-test dct-test
-ifeq ($(ARCH_X86),yes)
-TESTS+= cpuid-test motion-test
-endif
-
-tests: apiexample $(TESTS)
-
-apiexample: apiexample.o $(LIB)
-
-cpuid-test: i386/cputest.c
-	$(CC) $(CFLAGS) -DTEST -o $@ $<
-
-dct-test: dct-test.o fdctref.o $(LIB)
-
-fft-test: fft-test.o $(LIB)
-
-imgresample-test: imgresample.c $(LIB)
-	$(CC) $(CFLAGS) -DTEST -o $@ $^ $(EXTRALIBS)
-
-motion-test: motion-test.o $(LIB)
+	   apiexample$(EXESUF)
 
-.PHONY: tests
+cpuid-test$(EXESUF): i386/cputest.c
+apiexample$(EXESUF): apiexample.o $(LIBNAME)
+dct-test$(EXESUF): dct-test.o fdctref.o $(LIBNAME)
+fft-test$(EXESUF): fft-test.o $(LIBNAME)
+motion-test$(EXESUF): motion-test.o $(LIBNAME)
diff -u mplayer-1.0~rc2-12/libavcodec/mathops.h ffmpeg-free-0.svn20080206/libavcodec/mathops.h
--- mplayer-1.0~rc2-12/libavcodec/mathops.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mathops.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-#ifndef MATHOPS_H
-#define MATHOPS_H
+#ifndef FFMPEG_MATHOPS_H
+#define FFMPEG_MATHOPS_H
 
 #include "common.h"
 
@@ -71,5 +71,5 @@
 #   define MUL16(ra, rb) ((ra) * (rb))
 #endif
 
-#endif //MATHOPS_H
+#endif /* FFMPEG_MATHOPS_H */
 
diff -u mplayer-1.0~rc2-12/libavcodec/mdct.c ffmpeg-free-0.svn20080206/libavcodec/mdct.c
--- mplayer-1.0~rc2-12/libavcodec/mdct.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mdct.c	2008-03-20 19:10:58.000000000 +0100
@@ -25,6 +25,29 @@
  * MDCT/IMDCT transforms.
  */
 
+// Generate a Kaiser-Bessel Derived Window.
+#define BESSEL_I0_ITER 50 // default: 50 iterations of Bessel I0 approximation
+void ff_kbd_window_init(float *window, float alpha, int n)
+{
+   int i, j;
+   double sum = 0.0, bessel, tmp;
+   double local_window[n];
+   double alpha2 = (alpha * M_PI / n) * (alpha * M_PI / n);
+
+   for (i = 0; i < n; i++) {
+       tmp = i * (n - i) * alpha2;
+       bessel = 1.0;
+       for (j = BESSEL_I0_ITER; j > 0; j--)
+           bessel = bessel * tmp / (j * j) + 1;
+       sum += bessel;
+       local_window[i] = sum;
+   }
+
+   sum++;
+   for (i = 0; i < n; i++)
+       window[i] = sqrt(local_window[i] / sum);
+}
+
 /**
  * init MDCT or IMDCT computation.
  */
diff -u mplayer-1.0~rc2-12/libavcodec/mdec.c ffmpeg-free-0.svn20080206/libavcodec/mdec.c
--- mplayer-1.0~rc2-12/libavcodec/mdec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mdec.c	2008-03-20 19:10:58.000000000 +0100
@@ -158,7 +158,7 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     MDECContext * const a = avctx->priv_data;
     AVFrame *picture = data;
@@ -175,9 +175,6 @@
     }
     p->pict_type= I_TYPE;
     p->key_frame= 1;
-    a->last_dc[0]=
-    a->last_dc[1]=
-    a->last_dc[2]= 0;
 
     a->bitstream_buffer= av_fast_realloc(a->bitstream_buffer, &a->bitstream_buffer_size, buf_size + FF_INPUT_BUFFER_PADDING_SIZE);
     for(i=0; i<buf_size; i+=2){
@@ -192,6 +189,10 @@
     a->qscale=  get_bits(&a->gb, 16);
     a->version= get_bits(&a->gb, 16);
 
+    a->last_dc[0]=
+    a->last_dc[1]=
+    a->last_dc[2]= 128;
+
 //    printf("qscale:%d (0x%X), version:%d (0x%X)\n", a->qscale, a->qscale, a->version, a->version);
 
     for(a->mb_x=0; a->mb_x<a->mb_width; a->mb_x++){
diff -u mplayer-1.0~rc2-12/libavcodec/mjpegbdec.c ffmpeg-free-0.svn20080206/libavcodec/mjpegbdec.c
--- mplayer-1.0~rc2-12/libavcodec/mjpegbdec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mjpegbdec.c	2008-03-20 19:10:58.000000000 +0100
@@ -31,10 +31,10 @@
 
 static int mjpegb_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
-                              uint8_t *buf, int buf_size)
+                              const uint8_t *buf, int buf_size)
 {
     MJpegDecodeContext *s = avctx->priv_data;
-    uint8_t *buf_end, *buf_ptr;
+    const uint8_t *buf_end, *buf_ptr;
     AVFrame *picture = data;
     GetBitContext hgb; /* for the header */
     uint32_t dqt_offs, dht_offs, sof_offs, sos_offs, second_field_offs;
@@ -109,7 +109,7 @@
     if (s->interlaced) {
         s->bottom_field ^= 1;
         /* if not bottom field, do not output image yet */
-        if (s->bottom_field && second_field_offs)
+        if (s->bottom_field != s->interlace_polarity && second_field_offs)
         {
             buf_ptr = buf + second_field_offs;
             second_field_offs = 0;
diff -u mplayer-1.0~rc2-12/libavcodec/mjpegdec.c ffmpeg-free-0.svn20080206/libavcodec/mjpegdec.c
--- mplayer-1.0~rc2-12/libavcodec/mjpegdec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mjpegdec.c	2008-03-20 19:10:58.000000000 +0100
@@ -671,7 +671,8 @@
         linesize[c]=s->linesize[c];
         if(s->avctx->codec->id==CODEC_ID_AMV) {
             //picture should be flipped upside-down for this codec
-            data[c] += (linesize[c] * (s->v_scount[i] * 8 * s->mb_height - 1));
+            assert(!(s->avctx->flags & CODEC_FLAG_EMU_EDGE));
+            data[c] += (linesize[c] * (s->v_scount[i] * (8 * s->mb_height -((s->height/s->v_max)&7)) - 1 ));
             linesize[c] *= -1;
         }
     }
@@ -1072,9 +1073,9 @@
 
 /* return the 8 bit start code value and update the search
    state. Return -1 if no start code found */
-static int find_marker(uint8_t **pbuf_ptr, uint8_t *buf_end)
+static int find_marker(const uint8_t **pbuf_ptr, const uint8_t *buf_end)
 {
-    uint8_t *buf_ptr;
+    const uint8_t *buf_ptr;
     unsigned int v, v2;
     int val;
 #ifdef DEBUG
@@ -1104,10 +1105,10 @@
 
 int ff_mjpeg_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
-                              uint8_t *buf, int buf_size)
+                              const uint8_t *buf, int buf_size)
 {
     MJpegDecodeContext *s = avctx->priv_data;
-    uint8_t *buf_end, *buf_ptr;
+    const uint8_t *buf_end, *buf_ptr;
     int start_code;
     AVFrame *picture = data;
 
@@ -1135,7 +1136,7 @@
                 /* unescape buffer of SOS, use special treatment for JPEG-LS */
                 if (start_code == SOS && !s->ls)
                 {
-                    uint8_t *src = buf_ptr;
+                    const uint8_t *src = buf_ptr;
                     uint8_t *dst = s->buffer;
 
                     while (src<buf_end)
@@ -1162,7 +1163,7 @@
                            (buf_end - buf_ptr) - (dst - s->buffer));
                 }
                 else if(start_code == SOS && s->ls){
-                    uint8_t *src = buf_ptr;
+                    const uint8_t *src = buf_ptr;
                     uint8_t *dst = s->buffer;
                     int bit_count = 0;
                     int t = 0, b = 0;
diff -u mplayer-1.0~rc2-12/libavcodec/mjpegdec.h ffmpeg-free-0.svn20080206/libavcodec/mjpegdec.h
--- mplayer-1.0~rc2-12/libavcodec/mjpegdec.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mjpegdec.h	2008-02-01 04:40:46.000000000 +0100
@@ -26,8 +26,8 @@
  * MJPEG decoder.
  */
 
-#ifndef MJPEGDEC_H
-#define MJPEGDEC_H
+#ifndef FFMPEG_MJPEGDEC_H
+#define FFMPEG_MJPEGDEC_H
 
 #include "avcodec.h"
 #include "bitstream.h"
@@ -103,10 +103,10 @@
 int ff_mjpeg_decode_end(AVCodecContext *avctx);
 int ff_mjpeg_decode_frame(AVCodecContext *avctx,
                           void *data, int *data_size,
-                          uint8_t *buf, int buf_size);
+                          const uint8_t *buf, int buf_size);
 int ff_mjpeg_decode_dqt(MJpegDecodeContext *s);
 int ff_mjpeg_decode_dht(MJpegDecodeContext *s);
 int ff_mjpeg_decode_sof(MJpegDecodeContext *s);
 int ff_mjpeg_decode_sos(MJpegDecodeContext *s);
 
-#endif /* MJPEGDEC_H */
+#endif /* FFMPEG_MJPEGDEC_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mjpegenc.h ffmpeg-free-0.svn20080206/libavcodec/mjpegenc.h
--- mplayer-1.0~rc2-12/libavcodec/mjpegenc.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mjpegenc.h	2007-10-17 11:37:46.000000000 +0200
@@ -30,8 +30,8 @@
  * MJPEG encoder.
  */
 
-#ifndef MJPEGENC_H
-#define MJPEGENC_H
+#ifndef FFMPEG_MJPEGENC_H
+#define FFMPEG_MJPEGENC_H
 
 #include "dsputil.h"
 #include "mpegvideo.h"
@@ -57,4 +57,4 @@
                         uint8_t *huff_size, uint16_t *huff_code);
 void ff_mjpeg_encode_mb(MpegEncContext *s, DCTELEM block[6][64]);
 
-#endif /* MJPEGENC_H */
+#endif /* FFMPEG_MJPEGENC_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mjpeg.h ffmpeg-free-0.svn20080206/libavcodec/mjpeg.h
--- mplayer-1.0~rc2-12/libavcodec/mjpeg.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mjpeg.h	2007-10-17 11:37:46.000000000 +0200
@@ -30,8 +30,8 @@
  * MJPEG encoder and decoder.
  */
 
-#ifndef MJPEG_H
-#define MJPEG_H
+#ifndef FFMPEG_MJPEG_H
+#define FFMPEG_MJPEG_H
 
 #include "avcodec.h"
 #include "bitstream.h"
@@ -153,4 +153,4 @@
                                   const uint8_t *bits_table,
                                   const uint8_t *val_table);
 
-#endif /* MJPEG_H */
+#endif /* FFMPEG_MJPEG_H */
Common subdirectories: mplayer-1.0~rc2-12/libavcodec/mlib and ffmpeg-free-0.svn20080206/libavcodec/mlib
Only in ffmpeg-free-0.svn20080206/libavcodec: mlp_parser.c
Only in ffmpeg-free-0.svn20080206/libavcodec: mlp_parser.h
diff -u mplayer-1.0~rc2-12/libavcodec/mmvideo.c ffmpeg-free-0.svn20080206/libavcodec/mmvideo.c
--- mplayer-1.0~rc2-12/libavcodec/mmvideo.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mmvideo.c	2008-03-20 19:10:58.000000000 +0100
@@ -150,7 +150,7 @@
 
 static int mm_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     MmContext *s = avctx->priv_data;
     AVPaletteControl *palette_control = avctx->palctrl;
diff -u mplayer-1.0~rc2-12/libavcodec/motion-test.c ffmpeg-free-0.svn20080206/libavcodec/motion-test.c
--- mplayer-1.0~rc2-12/libavcodec/motion-test.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/motion-test.c	2008-03-20 19:10:58.000000000 +0100
@@ -112,7 +112,7 @@
         }
     }
     emms_c();
-    dummy = d1; /* avoid optimisation */
+    dummy = d1; /* avoid optimization */
     ti = gettime() - ti;
 
     printf("  %0.0f kop/s\n",
Only in ffmpeg-free-0.svn20080206/libavcodec: movsub_bsf.c
Only in ffmpeg-free-0.svn20080206/libavcodec: mpc7.c
Only in ffmpeg-free-0.svn20080206/libavcodec: mpc7data.h
Only in ffmpeg-free-0.svn20080206/libavcodec: mpc8.c
Only in ffmpeg-free-0.svn20080206/libavcodec: mpc8data.h
Only in ffmpeg-free-0.svn20080206/libavcodec: mpc8huff.h
diff -u mplayer-1.0~rc2-12/libavcodec/mpc.c ffmpeg-free-0.svn20080206/libavcodec/mpc.c
--- mplayer-1.0~rc2-12/libavcodec/mpc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpc.c	2008-03-20 19:10:58.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Musepack decoder
+ * Musepack decoder core
  * Copyright (c) 2006 Konstantin Shishkov
  *
  * This file is part of FFmpeg.
@@ -20,7 +20,7 @@
  */
 
 /**
- * @file mpc.c Musepack decoder
+ * @file mpc.c Musepack decoder core
  * MPEG Audio Layer 1/2 -like codec with frames of 1152 samples
  * divided into 32 subbands.
  */
@@ -35,108 +35,18 @@
 #endif
 #include "mpegaudio.h"
 
+#include "mpc.h"
 #include "mpcdata.h"
 
-#define BANDS            32
-#define SAMPLES_PER_BAND 36
-#define MPC_FRAME_SIZE   (BANDS * SAMPLES_PER_BAND)
-
-static VLC scfi_vlc, dscf_vlc, hdr_vlc, quant_vlc[MPC7_QUANT_VLC_TABLES][2];
-
 static DECLARE_ALIGNED_16(MPA_INT, mpa_window[512]);
 
-typedef struct {
-    DSPContext dsp;
-    int IS, MSS, gapless;
-    int lastframelen, bands;
-    int oldDSCF[2][BANDS];
-    AVRandomState rnd;
-    int frames_to_skip;
-    /* for synthesis */
-    DECLARE_ALIGNED_16(MPA_INT, synth_buf[MPA_MAX_CHANNELS][512*2]);
-    int synth_buf_offset[MPA_MAX_CHANNELS];
-    DECLARE_ALIGNED_16(int32_t, sb_samples[MPA_MAX_CHANNELS][36][SBLIMIT]);
-} MPCContext;
-
-/** Subband structure - hold all variables for each subband */
-typedef struct {
-    int msf; ///< mid-stereo flag
-    int res[2];
-    int scfi[2];
-    int scf_idx[2][3];
-    int Q[2];
-}Band;
-
-static int mpc7_decode_init(AVCodecContext * avctx)
+void ff_mpc_init()
 {
-    int i, j;
-    MPCContext *c = avctx->priv_data;
-    GetBitContext gb;
-    uint8_t buf[16];
-    static int vlc_inited = 0;
-
-    if(avctx->extradata_size < 16){
-        av_log(avctx, AV_LOG_ERROR, "Too small extradata size (%i)!\n", avctx->extradata_size);
-        return -1;
-    }
-    memset(c->oldDSCF, 0, sizeof(c->oldDSCF));
-    av_init_random(0xDEADBEEF, &c->rnd);
-    dsputil_init(&c->dsp, avctx);
-    c->dsp.bswap_buf(buf, avctx->extradata, 4);
     ff_mpa_synth_init(mpa_window);
-    init_get_bits(&gb, buf, 128);
-
-    c->IS = get_bits1(&gb);
-    c->MSS = get_bits1(&gb);
-    c->bands = get_bits(&gb, 6);
-    if(c->bands >= BANDS){
-        av_log(avctx, AV_LOG_ERROR, "Too many bands: %i\n", c->bands);
-        return -1;
-    }
-    skip_bits(&gb, 88);
-    c->gapless = get_bits1(&gb);
-    c->lastframelen = get_bits(&gb, 11);
-    av_log(avctx, AV_LOG_DEBUG, "IS: %d, MSS: %d, TG: %d, LFL: %d, bands: %d\n",
-            c->IS, c->MSS, c->gapless, c->lastframelen, c->bands);
-    c->frames_to_skip = 0;
-
-    if(vlc_inited) return 0;
-    av_log(avctx, AV_LOG_DEBUG, "Initing VLC\n");
-    if(init_vlc(&scfi_vlc, MPC7_SCFI_BITS, MPC7_SCFI_SIZE,
-                &mpc7_scfi[1], 2, 1,
-                &mpc7_scfi[0], 2, 1, INIT_VLC_USE_STATIC)){
-        av_log(avctx, AV_LOG_ERROR, "Cannot init SCFI VLC\n");
-        return -1;
-    }
-    if(init_vlc(&dscf_vlc, MPC7_DSCF_BITS, MPC7_DSCF_SIZE,
-                &mpc7_dscf[1], 2, 1,
-                &mpc7_dscf[0], 2, 1, INIT_VLC_USE_STATIC)){
-        av_log(avctx, AV_LOG_ERROR, "Cannot init DSCF VLC\n");
-        return -1;
-    }
-    if(init_vlc(&hdr_vlc, MPC7_HDR_BITS, MPC7_HDR_SIZE,
-                &mpc7_hdr[1], 2, 1,
-                &mpc7_hdr[0], 2, 1, INIT_VLC_USE_STATIC)){
-        av_log(avctx, AV_LOG_ERROR, "Cannot init HDR VLC\n");
-        return -1;
-    }
-    for(i = 0; i < MPC7_QUANT_VLC_TABLES; i++){
-        for(j = 0; j < 2; j++){
-            if(init_vlc(&quant_vlc[i][j], 9, mpc7_quant_vlc_sizes[i],
-                        &mpc7_quant_vlc[i][j][1], 4, 2,
-                        &mpc7_quant_vlc[i][j][0], 4, 2, INIT_VLC_USE_STATIC)){
-                av_log(avctx, AV_LOG_ERROR, "Cannot init QUANT VLC %i,%i\n",i,j);
-                return -1;
-            }
-        }
-    }
-    vlc_inited = 1;
-    return 0;
 }
 
 /**
  * Process decoded Musepack data and produce PCM
- * @todo make it available for MPC8 and MPC6
  */
 static void mpc_synth(MPCContext *c, int16_t *out)
 {
@@ -158,147 +68,29 @@
         *out++=samples[i];
 }
 
-/**
- * Fill samples for given subband
- */
-static inline void idx_to_quant(MPCContext *c, GetBitContext *gb, int idx, int *dst)
+void ff_mpc_dequantize_and_synth(MPCContext * c, int maxband, void *data)
 {
-    int i, i1, t;
-    switch(idx){
-    case -1:
-        for(i = 0; i < SAMPLES_PER_BAND; i++){
-            *dst++ = (av_random(&c->rnd) & 0x3FC) - 510;
-        }
-        break;
-    case 1:
-        i1 = get_bits1(gb);
-        for(i = 0; i < SAMPLES_PER_BAND/3; i++){
-            t = get_vlc2(gb, quant_vlc[0][i1].table, 9, 2);
-            *dst++ = mpc_idx30[t];
-            *dst++ = mpc_idx31[t];
-            *dst++ = mpc_idx32[t];
-        }
-        break;
-    case 2:
-        i1 = get_bits1(gb);
-        for(i = 0; i < SAMPLES_PER_BAND/2; i++){
-            t = get_vlc2(gb, quant_vlc[1][i1].table, 9, 2);
-            *dst++ = mpc_idx50[t];
-            *dst++ = mpc_idx51[t];
-        }
-        break;
-    case  3: case  4: case  5: case  6: case  7:
-        i1 = get_bits1(gb);
-        for(i = 0; i < SAMPLES_PER_BAND; i++)
-            *dst++ = get_vlc2(gb, quant_vlc[idx-1][i1].table, 9, 2) - mpc7_quant_vlc_off[idx-1];
-        break;
-    case  8: case  9: case 10: case 11: case 12:
-    case 13: case 14: case 15: case 16: case 17:
-        t = (1 << (idx - 2)) - 1;
-        for(i = 0; i < SAMPLES_PER_BAND; i++)
-            *dst++ = get_bits(gb, idx - 1) - t;
-        break;
-    default: // case 0 and -2..-17
-        return;
-    }
-}
-
-static int mpc7_decode_frame(AVCodecContext * avctx,
-                            void *data, int *data_size,
-                            uint8_t * buf, int buf_size)
-{
-    MPCContext *c = avctx->priv_data;
-    GetBitContext gb;
-    uint8_t *bits;
-    int i, j, ch, t;
-    int mb = -1;
-    Band bands[BANDS];
-    int Q[2][MPC_FRAME_SIZE];
+    int i, j, ch;
+    Band *bands = c->bands;
     int off;
     float mul;
-    int bits_used, bits_avail;
-
-    memset(bands, 0, sizeof(bands));
-    if(buf_size <= 4){
-        av_log(avctx, AV_LOG_ERROR, "Too small buffer passed (%i bytes)\n", buf_size);
-    }
 
-    bits = av_malloc(((buf_size - 1) & ~3) + FF_INPUT_BUFFER_PADDING_SIZE);
-    c->dsp.bswap_buf(bits, buf + 4, (buf_size - 4) >> 2);
-    init_get_bits(&gb, bits, (buf_size - 4)* 8);
-    skip_bits(&gb, buf[0]);
-
-    /* read subband indexes */
-    for(i = 0; i <= c->bands; i++){
-        for(ch = 0; ch < 2; ch++){
-            if(i) t = get_vlc2(&gb, hdr_vlc.table, MPC7_HDR_BITS, 1) - 5;
-            if(!i || (t == 4)) bands[i].res[ch] = get_bits(&gb, 4);
-            else bands[i].res[ch] = bands[i-1].res[ch] + t;
-        }
-
-        if(bands[i].res[0] || bands[i].res[1]){
-            mb = i;
-            if(c->MSS) bands[i].msf = get_bits1(&gb);
-        }
-    }
-    /* get scale indexes coding method */
-    for(i = 0; i <= mb; i++)
-        for(ch = 0; ch < 2; ch++)
-            if(bands[i].res[ch]) bands[i].scfi[ch] = get_vlc2(&gb, scfi_vlc.table, MPC7_SCFI_BITS, 1);
-    /* get scale indexes */
-    for(i = 0; i <= mb; i++){
-        for(ch = 0; ch < 2; ch++){
-            if(bands[i].res[ch]){
-                bands[i].scf_idx[ch][2] = c->oldDSCF[ch][i];
-                t = get_vlc2(&gb, dscf_vlc.table, MPC7_DSCF_BITS, 1) - 7;
-                bands[i].scf_idx[ch][0] = (t == 8) ? get_bits(&gb, 6) : (bands[i].scf_idx[ch][2] + t);
-                switch(bands[i].scfi[ch]){
-                case 0:
-                    t = get_vlc2(&gb, dscf_vlc.table, MPC7_DSCF_BITS, 1) - 7;
-                    bands[i].scf_idx[ch][1] = (t == 8) ? get_bits(&gb, 6) : (bands[i].scf_idx[ch][0] + t);
-                    t = get_vlc2(&gb, dscf_vlc.table, MPC7_DSCF_BITS, 1) - 7;
-                    bands[i].scf_idx[ch][2] = (t == 8) ? get_bits(&gb, 6) : (bands[i].scf_idx[ch][1] + t);
-                    break;
-                case 1:
-                    t = get_vlc2(&gb, dscf_vlc.table, MPC7_DSCF_BITS, 1) - 7;
-                    bands[i].scf_idx[ch][1] = (t == 8) ? get_bits(&gb, 6) : (bands[i].scf_idx[ch][0] + t);
-                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1];
-                    break;
-                case 2:
-                    bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];
-                    t = get_vlc2(&gb, dscf_vlc.table, MPC7_DSCF_BITS, 1) - 7;
-                    bands[i].scf_idx[ch][2] = (t == 8) ? get_bits(&gb, 6) : (bands[i].scf_idx[ch][1] + t);
-                    break;
-                case 3:
-                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];
-                    break;
-                }
-                c->oldDSCF[ch][i] = bands[i].scf_idx[ch][2];
-            }
-        }
-    }
-    /* get quantizers */
-    memset(Q, 0, sizeof(Q));
-    off = 0;
-    for(i = 0; i < BANDS; i++, off += SAMPLES_PER_BAND)
-        for(ch = 0; ch < 2; ch++)
-            idx_to_quant(c, &gb, bands[i].res[ch], Q[ch] + off);
     /* dequantize */
     memset(c->sb_samples, 0, sizeof(c->sb_samples));
     off = 0;
-    for(i = 0; i <= mb; i++, off += SAMPLES_PER_BAND){
+    for(i = 0; i <= maxband; i++, off += SAMPLES_PER_BAND){
         for(ch = 0; ch < 2; ch++){
             if(bands[i].res[ch]){
                 j = 0;
-                mul = mpc_CC[bands[i].res[ch]] * mpc7_SCF[bands[i].scf_idx[ch][0]];
+                mul = mpc_CC[bands[i].res[ch]] * mpc_SCF[bands[i].scf_idx[ch][0]];
                 for(; j < 12; j++)
-                    c->sb_samples[ch][j][i] = mul * Q[ch][j + off];
-                mul = mpc_CC[bands[i].res[ch]] * mpc7_SCF[bands[i].scf_idx[ch][1]];
+                    c->sb_samples[ch][j][i] = mul * c->Q[ch][j + off];
+                mul = mpc_CC[bands[i].res[ch]] * mpc_SCF[bands[i].scf_idx[ch][1]];
                 for(; j < 24; j++)
-                    c->sb_samples[ch][j][i] = mul * Q[ch][j + off];
-                mul = mpc_CC[bands[i].res[ch]] * mpc7_SCF[bands[i].scf_idx[ch][2]];
+                    c->sb_samples[ch][j][i] = mul * c->Q[ch][j + off];
+                mul = mpc_CC[bands[i].res[ch]] * mpc_SCF[bands[i].scf_idx[ch][2]];
                 for(; j < 36; j++)
-                    c->sb_samples[ch][j][i] = mul * Q[ch][j + off];
+                    c->sb_samples[ch][j][i] = mul * c->Q[ch][j + off];
             }
         }
         if(bands[i].msf){
@@ -313,41 +105,4 @@
     }
 
     mpc_synth(c, data);
-
-    av_free(bits);
-
-    bits_used = get_bits_count(&gb);
-    bits_avail = (buf_size - 4) * 8;
-    if(!buf[1] && ((bits_avail < bits_used) || (bits_used + 32 <= bits_avail))){
-        av_log(NULL,0, "Error decoding frame: used %i of %i bits\n", bits_used, bits_avail);
-        return -1;
-    }
-    if(c->frames_to_skip){
-        c->frames_to_skip--;
-        *data_size = 0;
-        return buf_size;
-    }
-    *data_size = (buf[1] ? c->lastframelen : MPC_FRAME_SIZE) * 4;
-
-    return buf_size;
 }
-
-static void mpc7_decode_flush(AVCodecContext *avctx)
-{
-    MPCContext *c = avctx->priv_data;
-
-    memset(c->oldDSCF, 0, sizeof(c->oldDSCF));
-    c->frames_to_skip = 32;
-}
-
-AVCodec mpc7_decoder = {
-    "mpc sv7",
-    CODEC_TYPE_AUDIO,
-    CODEC_ID_MUSEPACK7,
-    sizeof(MPCContext),
-    mpc7_decode_init,
-    NULL,
-    NULL,
-    mpc7_decode_frame,
-    .flush = mpc7_decode_flush,
-};
diff -u mplayer-1.0~rc2-12/libavcodec/mpcdata.h ffmpeg-free-0.svn20080206/libavcodec/mpcdata.h
--- mplayer-1.0~rc2-12/libavcodec/mpcdata.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpcdata.h	2007-11-02 07:40:42.000000000 +0100
@@ -19,162 +19,18 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_MPCDATA_H
-#define AVCODEC_MPCDATA_H
+#ifndef FFMPEG_MPCDATA_H
+#define FFMPEG_MPCDATA_H
 
 #include <stdint.h>
 
-static const int8_t mpc_idx30[] = { -1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1};
-static const int8_t mpc_idx31[] = { -1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1, 0, 0, 0, 1, 1, 1};
-static const int8_t mpc_idx32[] = { -1,-1,-1,-1,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-static const int8_t mpc_idx50[] = { -2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2};
-static const int8_t mpc_idx51[] = { -2,-2,-2,-2,-2,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2};
-
 static const float mpc_CC[18] = {
     65536.0000, 21845.3333, 13107.2000, 9362.2857, 7281.7778, 4369.0667, 2114.0645,
     1040.2539, 516.0315, 257.0039, 128.2505, 64.0626, 32.0156, 16.0039, 8.0010,
     4.0002, 2.0001, 1.0000
 };
 
-#define MPC7_SCFI_SIZE  4
-#define MPC7_SCFI_BITS  3
-static const uint8_t mpc7_scfi[MPC7_SCFI_SIZE * 2] = {
-    0x2, 3, 0x1, 1, 0x3, 3, 0x0, 2
-};
-
-#define MPC7_DSCF_SIZE 16
-#define MPC7_DSCF_BITS  6
-static const uint8_t mpc7_dscf[MPC7_DSCF_SIZE * 2] = {
-    0x20, 6, 0x04, 5, 0x11, 5, 0x1E, 5, 0x0D, 4, 0x00, 3, 0x03, 3, 0x09, 4,
-    0x05, 3, 0x02, 3, 0x0E, 4, 0x03, 4, 0x1F, 5, 0x05, 5, 0x21, 6, 0x0C, 4
-};
-
-#define MPC7_HDR_SIZE  10
-#define MPC7_HDR_BITS   9
-static const uint8_t mpc7_hdr[MPC7_HDR_SIZE * 2] = {
-    0x5C, 8, 0x2F, 7, 0x0A, 5, 0x04, 4, 0x00, 2,
-    0x01, 1, 0x03, 3, 0x16, 6, 0xBB, 9, 0xBA, 9
-};
-
-#define MPC7_QUANT_VLC_TABLES 7
-static const uint8_t mpc7_quant_vlc_sizes[MPC7_QUANT_VLC_TABLES * 2] = {
-    27, 25, 7, 9, 15, 31, 63
-};
-
-static const uint8_t mpc7_quant_vlc_off[MPC7_QUANT_VLC_TABLES] = {
-    0, 0, 3, 4, 7, 15, 31
-};
-
-static const uint16_t mpc7_quant_vlc[MPC7_QUANT_VLC_TABLES][2][64 * 2] = {
-{
-    {
-        0x0036,  6, 0x0009,  5, 0x0020,  6, 0x0005,  5, 0x000A,  4, 0x0007,  5,
-        0x0034,  6, 0x0000,  5, 0x0023,  6, 0x000A,  5, 0x0006,  4, 0x0004,  5,
-        0x000B,  4, 0x0007,  3, 0x000C,  4, 0x0003,  5, 0x0007,  4, 0x000B,  5,
-        0x0022,  6, 0x0001,  5, 0x0035,  6, 0x0006,  5, 0x0009,  4, 0x0002,  5,
-        0x0021,  6, 0x0008,  5, 0x0037,  6
-    },
-    {
-        0x0067,  8, 0x003E,  7, 0x00E1,  9, 0x0037,  7, 0x0003,  4, 0x0034,  7,
-        0x0065,  8, 0x003C,  7, 0x00E3,  9, 0x0018,  6, 0x0000,  4, 0x003D,  7,
-        0x0004,  4, 0x0001,  1, 0x0005,  4, 0x003F,  7, 0x0001,  4, 0x003B,  7,
-        0x00E2,  9, 0x0039,  7, 0x0064,  8, 0x0035,  7, 0x0002,  4, 0x0036,  7,
-        0x00E0,  9, 0x003A,  7, 0x0066,  8
-    }
-},
-{
-    {
-        0x0059,  7, 0x002F,  6, 0x000F,  5, 0x0000,  5, 0x005B,  7, 0x0004,  5,
-        0x0006,  4, 0x000D,  4, 0x0004,  4, 0x0005,  5, 0x0014,  5, 0x000C,  4,
-        0x0004,  3, 0x000F,  4, 0x000E,  5, 0x0003,  5, 0x0003,  4, 0x000E,  4,
-        0x0005,  4, 0x0001,  5, 0x005A,  7, 0x0002,  5, 0x0015,  5, 0x002E,  6,
-        0x0058,  7
-    },
-    {
-        0x0399, 10, 0x0071,  7, 0x0033,  6, 0x00E7,  8, 0x039A, 10, 0x0068,  7,
-        0x001E,  5, 0x0000,  3, 0x001D,  5, 0x0069,  7, 0x0032,  6, 0x0001,  3,
-        0x0002,  2, 0x0003,  3, 0x0031,  6, 0x006B,  7, 0x001B,  5, 0x0002,  3,
-        0x001F,  5, 0x0070,  7, 0x0398, 10, 0x006A,  7, 0x0030,  6, 0x0072,  7,
-        0x039B, 10
-    }
-},
-{
-    {
-        0x000C,  4, 0x0004,  3, 0x0000,  2, 0x0001,  2, 0x0007,  3, 0x0005,  3, 0x000D,  4
-    },
-    {
-        0x0004,  5, 0x0003,  4, 0x0002,  2, 0x0003,  2, 0x0001,  2, 0x0000,  3, 0x0005,  5
-    }
-},
-{
-    {
-        0x0005,  4, 0x0000,  3, 0x0004,  3, 0x0006,  3, 0x0007,  3, 0x0005,  3, 0x0003,  3, 0x0001,  3, 0x0004,  4
-    },
-    {
-        0x0009,  5, 0x000C,  4, 0x0003,  3, 0x0000,  2, 0x0002,  2, 0x0007,  3, 0x000D,  4, 0x0005,  4, 0x0008,  5
-    }
-},
-{
-    {
-        0x0039,  6, 0x0017,  5, 0x0008,  4, 0x000A,  4, 0x000D,  4, 0x0000,  3,
-        0x0002,  3, 0x0003,  3, 0x0001,  3, 0x000F,  4, 0x000C,  4, 0x0009,  4,
-        0x001D,  5, 0x0016,  5, 0x0038,  6,
-    },
-    {
-        0x00E5,  8, 0x0038,  6, 0x0007,  5, 0x0002,  4, 0x0000,  3, 0x0003,  3,
-        0x0005,  3, 0x0006,  3, 0x0004,  3, 0x0002,  3, 0x000F,  4, 0x001D,  5,
-        0x0006,  5, 0x0073,  7, 0x00E4,  8,
-    },
-},
-{
-    {
-        0x0041,  7, 0x0006,  6, 0x002C,  6, 0x002D,  6, 0x003B,  6, 0x000D,  5,
-        0x0011,  5, 0x0013,  5, 0x0017,  5, 0x0015,  5, 0x001A,  5, 0x001E,  5,
-        0x0000,  4, 0x0002,  4, 0x0005,  4, 0x0007,  4, 0x0003,  4, 0x0004,  4,
-        0x001F,  5, 0x001C,  5, 0x0019,  5, 0x001B,  5, 0x0018,  5, 0x0014,  5,
-        0x0012,  5, 0x000C,  5, 0x0002,  5, 0x003A,  6, 0x0021,  6, 0x0007,  6,
-        0x0040,  7
-    },
-    {
-        0x1948, 13, 0x194A, 13, 0x0328, 10, 0x0195,  9, 0x00CB,  8, 0x0066,  7,
-        0x0031,  6, 0x0009,  5, 0x000F,  5, 0x001F,  5, 0x0002,  4, 0x0006,  4,
-        0x0008,  4, 0x000B,  4, 0x000D,  4, 0x0000,  3, 0x000E,  4, 0x000A,  4,
-        0x0009,  4, 0x0005,  4, 0x0003,  4, 0x001E,  5, 0x000E,  5, 0x0008,  5,
-        0x0030,  6, 0x0067,  7, 0x00C9,  8, 0x00C8,  8, 0x0653, 11, 0x1949, 13,
-        0x194B, 13
-    }
-},
-{
-    {
-        0x0067,  8, 0x0099,  8, 0x00B5,  8, 0x00E9,  8, 0x0040,  7, 0x0041,  7,
-        0x004D,  7, 0x0051,  7, 0x005B,  7, 0x0071,  7, 0x0070,  7, 0x0018,  6,
-        0x001D,  6, 0x0023,  6, 0x0025,  6, 0x0029,  6, 0x002C,  6, 0x002E,  6,
-        0x0033,  6, 0x0031,  6, 0x0036,  6, 0x0037,  6, 0x0039,  6, 0x003C,  6,
-        0x0000,  5, 0x0002,  5, 0x000A,  5, 0x0005,  5, 0x0009,  5, 0x0006,  5,
-        0x000D,  5, 0x0007,  5, 0x000B,  5, 0x000F,  5, 0x0008,  5, 0x0004,  5,
-        0x0003,  5, 0x0001,  5, 0x003F,  6, 0x003E,  6, 0x003D,  6, 0x0035,  6,
-        0x003B,  6, 0x0034,  6, 0x0030,  6, 0x002F,  6, 0x002B,  6, 0x002A,  6,
-        0x0027,  6, 0x0024,  6, 0x0021,  6, 0x001C,  6, 0x0075,  7, 0x0065,  7,
-        0x0064,  7, 0x0050,  7, 0x0045,  7, 0x0044,  7, 0x0032,  7, 0x00E8,  8,
-        0x00B4,  8, 0x0098,  8, 0x0066,  8
-    },
-    {
-        0x37A4, 14, 0x37AD, 14, 0x37A6, 14, 0x37AE, 14, 0x0DEA, 12, 0x02F0, 10,
-        0x02F1, 10, 0x00A0,  9, 0x00A2,  9, 0x01BC,  9, 0x007A,  8, 0x00DF,  8,
-        0x003C,  7, 0x0049,  7, 0x006E,  7, 0x000E,  6, 0x0018,  6, 0x0019,  6,
-        0x0022,  6, 0x0025,  6, 0x0036,  6, 0x0003,  5, 0x0009,  5, 0x000B,  5,
-        0x0010,  5, 0x0013,  5, 0x0015,  5, 0x0018,  5, 0x001A,  5, 0x001D,  5,
-        0x001F,  5, 0x0002,  4, 0x0000,  4, 0x001E,  5, 0x001C,  5, 0x0019,  5,
-        0x0016,  5, 0x0014,  5, 0x000E,  5, 0x000D,  5, 0x0008,  5, 0x0006,  5,
-        0x0002,  5, 0x002E,  6, 0x0023,  6, 0x001F,  6, 0x0015,  6, 0x000F,  6,
-        0x005F,  7, 0x0048,  7, 0x0029,  7, 0x00BD,  8, 0x007B,  8, 0x0179,  9,
-        0x00A1,  9, 0x037B, 10, 0x0147, 10, 0x0146, 10, 0x0DE8, 12, 0x37AF, 14,
-        0x37A7, 14, 0x37AC, 14, 0x37A5, 14
-    }
-}
-};
-
-static const float mpc7_SCF[128] = {
+static const float mpc_SCF[128] = {
     307.330047607421875000, 255.999984741210937500, 213.243041992187500000, 177.627334594726562500,
     147.960128784179687500, 123.247924804687500000, 102.663139343261718750, 85.516410827636718750,
     71.233520507812500000, 59.336143493652343750, 49.425861358642578125, 41.170787811279296875,
@@ -209,4 +65,4 @@
     0.000000044293003043, 0.000000036895215771, 0.000000030733001921, 0.000000025599996789
 };
 
-#endif // AVCODEC_MPCDATA_H
+#endif /* FFMPEG_MPCDATA_H */
Only in ffmpeg-free-0.svn20080206/libavcodec: mpc.h
diff -u mplayer-1.0~rc2-12/libavcodec/mpeg12.c ffmpeg-free-0.svn20080206/libavcodec/mpeg12.c
--- mplayer-1.0~rc2-12/libavcodec/mpeg12.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpeg12.c	2008-03-20 19:10:58.000000000 +0100
@@ -2220,7 +2220,7 @@
 /* handle buffering and image synchronisation */
 static int mpeg_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     Mpeg1Context *s = avctx->priv_data;
     const uint8_t *buf_end;
@@ -2239,7 +2239,7 @@
 
             *data_size = sizeof(AVFrame);
         }
-        return 0;
+        return buf_size;
     }
 
     if(s2->flags&CODEC_FLAG_TRUNCATED){
@@ -2329,8 +2329,10 @@
                 if(s2->last_picture_ptr==NULL){
                 /* Skip B-frames if we do not have reference frames. */
                     if(s2->pict_type==B_TYPE) break;
+                }
+                if(s2->next_picture_ptr==NULL){
                 /* Skip P-frames if we do not have reference frame no valid header. */
-//                    if(s2->pict_type==P_TYPE && s2->first_field && !s2->first_slice) break;
+                    if(s2->pict_type==P_TYPE && (s2->first_field || s2->picture_structure==PICT_FRAME)) break;
                 }
                 /* Skip B-frames if we are in a hurry. */
                 if(avctx->hurry_up && s2->pict_type==B_TYPE) break;
diff -u mplayer-1.0~rc2-12/libavcodec/mpeg12data.h ffmpeg-free-0.svn20080206/libavcodec/mpeg12data.h
--- mplayer-1.0~rc2-12/libavcodec/mpeg12data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpeg12data.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * MPEG1/2 tables.
  */
 
-#ifndef AVCODEC_MPEG12DATA_H
-#define AVCODEC_MPEG12DATA_H
+#ifndef FFMPEG_MPEG12DATA_H
+#define FFMPEG_MPEG12DATA_H
 
 #include <stdint.h>
 #include "mpegvideo.h"
@@ -47,4 +47,4 @@
 extern const float ff_mpeg1_aspect[16];
 extern const AVRational ff_mpeg2_aspect[16];
 
-#endif // AVCODEC_MPEG12DATA_H
+#endif /* FFMPEG_MPEG12DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mpeg12decdata.h ffmpeg-free-0.svn20080206/libavcodec/mpeg12decdata.h
--- mplayer-1.0~rc2-12/libavcodec/mpeg12decdata.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpeg12decdata.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * MPEG1/2 decoder tables.
  */
 
-#ifndef AVCODEC_MPEG12DECDATA_H
-#define AVCODEC_MPEG12DECDATA_H
+#ifndef FFMPEG_MPEG12DECDATA_H
+#define FFMPEG_MPEG12DECDATA_H
 
 #include <stdint.h>
 #include "mpegvideo.h"
@@ -121,4 +121,4 @@
     mpeg2_dc_scale_table3,
 };
 
-#endif // AVCODEC_MPEG12DECDATA_H
+#endif /* FFMPEG_MPEG12DECDATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mpeg12enc.c ffmpeg-free-0.svn20080206/libavcodec/mpeg12enc.c
--- mplayer-1.0~rc2-12/libavcodec/mpeg12enc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpeg12enc.c	2008-03-20 19:10:58.000000000 +0100
@@ -940,15 +940,3 @@
     .capabilities= CODEC_CAP_DELAY,
 };
 
-AVCodec mpeg2video_encoder = {
-    "mpeg2video",
-    CODEC_TYPE_VIDEO,
-    CODEC_ID_MPEG2VIDEO,
-    sizeof(MpegEncContext),
-    encode_init,
-    MPV_encode_picture,
-    MPV_encode_end,
-    .supported_framerates= ff_frame_rate_tab+1,
-    .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, PIX_FMT_YUV422P, -1},
-    .capabilities= CODEC_CAP_DELAY,
-};
diff -u mplayer-1.0~rc2-12/libavcodec/mpeg12.h ffmpeg-free-0.svn20080206/libavcodec/mpeg12.h
--- mplayer-1.0~rc2-12/libavcodec/mpeg12.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpeg12.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_MPEG12_H
-#define AVCODEC_MPEG12_H
+#ifndef FFMPEG_MPEG12_H
+#define FFMPEG_MPEG12_H
 
 #include "mpegvideo.h"
 
@@ -28,4 +28,4 @@
 
 void ff_mpeg12_common_init(MpegEncContext *s);
 
-#endif /* AVCODEC_MPEG12_H */
+#endif /* FFMPEG_MPEG12_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mpeg4data.h ffmpeg-free-0.svn20080206/libavcodec/mpeg4data.h
--- mplayer-1.0~rc2-12/libavcodec/mpeg4data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpeg4data.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * mpeg4 tables.
  */
 
-#ifndef AVCODEC_MPEG4DATA_H
-#define AVCODEC_MPEG4DATA_H
+#ifndef FFMPEG_MPEG4DATA_H
+#define FFMPEG_MPEG4DATA_H
 
 #include <stdint.h>
 #include "mpegvideo.h"
@@ -429,4 +429,4 @@
     99, 13, 15, 17, 19, 21, 23, 0
 };
 
-#endif // AVCODEC_MPEG4DATA_H
+#endif /* FFMPEG_MPEG4DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mpeg4video_parser.h ffmpeg-free-0.svn20080206/libavcodec/mpeg4video_parser.h
--- mplayer-1.0~rc2-12/libavcodec/mpeg4video_parser.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpeg4video_parser.h	2007-10-17 11:37:46.000000000 +0200
@@ -20,8 +20,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef MPEG4VIDEO_PARSER_H
-#define MPEG4VIDEO_PARSER_H
+#ifndef FFMPEG_MPEG4VIDEO_PARSER_H
+#define FFMPEG_MPEG4VIDEO_PARSER_H
 
 #include "parser.h"
 
@@ -31,4 +31,4 @@
  */
 int ff_mpeg4_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size);
 
-#endif /* MPEG4VIDEO_PARSER_H */
+#endif /* FFMPEG_MPEG4VIDEO_PARSER_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mpegaudiodata.h ffmpeg-free-0.svn20080206/libavcodec/mpegaudiodata.h
--- mplayer-1.0~rc2-12/libavcodec/mpegaudiodata.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpegaudiodata.h	2007-11-08 11:53:32.000000000 +0100
@@ -24,11 +24,14 @@
  * mpeg audio layer common tables.
  */
 
-#ifndef MPEGAUDIODATA_H
-#define MPEGAUDIODATA_H
+#ifndef FFMPEG_MPEGAUDIODATA_H
+#define FFMPEG_MPEGAUDIODATA_H
 
 #include "common.h"
 
+#define MODE_EXT_MS_STEREO 2
+#define MODE_EXT_I_STEREO  1
+
 extern const uint16_t ff_mpa_bitrate_tab[2][3][15];
 extern const uint16_t ff_mpa_freq_tab[3];
 extern const int32_t ff_mpa_enwindow[257];
@@ -37,4 +40,4 @@
 extern const int ff_mpa_quant_bits[17];
 extern const unsigned char *ff_mpa_alloc_tables[5];
 
-#endif /* MPEGAUDIODATA_H */
+#endif /* FFMPEG_MPEGAUDIODATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mpegaudiodec.c ffmpeg-free-0.svn20080206/libavcodec/mpegaudiodec.c
--- mplayer-1.0~rc2-12/libavcodec/mpegaudiodec.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpegaudiodec.c	2008-03-20 19:10:58.000000000 +0100
@@ -85,9 +85,6 @@
     int32_t sb_hybrid[SBLIMIT * 18]; /* 576 samples */
 } GranuleDef;
 
-#define MODE_EXT_MS_STEREO 2
-#define MODE_EXT_I_STEREO  1
-
 #include "mpegaudiodata.h"
 #include "mpegaudiodectab.h"
 
@@ -129,6 +126,68 @@
 
 static DECLARE_ALIGNED_16(MPA_INT, window[512]);
 
+/**
+ * Convert region offsets to region sizes and truncate
+ * size to big_values.
+ */
+void ff_region_offset2size(GranuleDef *g){
+    int i, k, j=0;
+    g->region_size[2] = (576 / 2);
+    for(i=0;i<3;i++) {
+        k = FFMIN(g->region_size[i], g->big_values);
+        g->region_size[i] = k - j;
+        j = k;
+    }
+}
+
+void ff_init_short_region(MPADecodeContext *s, GranuleDef *g){
+    if (g->block_type == 2)
+        g->region_size[0] = (36 / 2);
+    else {
+        if (s->sample_rate_index <= 2)
+            g->region_size[0] = (36 / 2);
+        else if (s->sample_rate_index != 8)
+            g->region_size[0] = (54 / 2);
+        else
+            g->region_size[0] = (108 / 2);
+    }
+    g->region_size[1] = (576 / 2);
+}
+
+void ff_init_long_region(MPADecodeContext *s, GranuleDef *g, int ra1, int ra2){
+    int l;
+    g->region_size[0] =
+        band_index_long[s->sample_rate_index][ra1 + 1] >> 1;
+    /* should not overflow */
+    l = FFMIN(ra1 + ra2 + 2, 22);
+    g->region_size[1] =
+        band_index_long[s->sample_rate_index][l] >> 1;
+}
+
+void ff_compute_band_indexes(MPADecodeContext *s, GranuleDef *g){
+    if (g->block_type == 2) {
+        if (g->switch_point) {
+            /* if switched mode, we handle the 36 first samples as
+                long blocks.  For 8000Hz, we handle the 48 first
+                exponents as long blocks (XXX: check this!) */
+            if (s->sample_rate_index <= 2)
+                g->long_end = 8;
+            else if (s->sample_rate_index != 8)
+                g->long_end = 6;
+            else
+                g->long_end = 4; /* 8000 Hz */
+
+            g->short_start = 2 + (s->sample_rate_index != 8);
+        } else {
+            g->long_end = 0;
+            g->short_start = 0;
+        }
+    } else {
+        g->short_start = 13;
+        g->long_end = 22;
+    }
+}
+
 /* layer 1 unscaling */
 /* n = number of bits of the mantissa minus 1 */
 static inline int l1_unscale(int n, int mant, int scale_factor)
@@ -2011,20 +2070,9 @@
                     g->table_select[i] = get_bits(&s->gb, 5);
                 for(i=0;i<3;i++)
                     g->subblock_gain[i] = get_bits(&s->gb, 3);
-                /* compute huffman coded region sizes */
-                if (g->block_type == 2)
-                    g->region_size[0] = (36 / 2);
-                else {
-                    if (s->sample_rate_index <= 2)
-                        g->region_size[0] = (36 / 2);
-                    else if (s->sample_rate_index != 8)
-                        g->region_size[0] = (54 / 2);
-                    else
-                        g->region_size[0] = (108 / 2);
-                }
-                g->region_size[1] = (576 / 2);
+                ff_init_short_region(s, g);
             } else {
-                int region_address1, region_address2, l;
+                int region_address1, region_address2;
                 g->block_type = 0;
                 g->switch_point = 0;
                 for(i=0;i<3;i++)
@@ -2034,47 +2082,10 @@
                 region_address2 = get_bits(&s->gb, 3);
                 dprintf(s->avctx, "region1=%d region2=%d\n",
                         region_address1, region_address2);
-                g->region_size[0] =
-                    band_index_long[s->sample_rate_index][region_address1 + 1] >> 1;
-                l = region_address1 + region_address2 + 2;
-                /* should not overflow */
-                if (l > 22)
-                    l = 22;
-                g->region_size[1] =
-                    band_index_long[s->sample_rate_index][l] >> 1;
-            }
-            /* convert region offsets to region sizes and truncate
-               size to big_values */
-            g->region_size[2] = (576 / 2);
-            j = 0;
-            for(i=0;i<3;i++) {
-                k = FFMIN(g->region_size[i], g->big_values);
-                g->region_size[i] = k - j;
-                j = k;
-            }
-
-            /* compute band indexes */
-            if (g->block_type == 2) {
-                if (g->switch_point) {
-                    /* if switched mode, we handle the 36 first samples as
-                       long blocks.  For 8000Hz, we handle the 48 first
-                       exponents as long blocks (XXX: check this!) */
-                    if (s->sample_rate_index <= 2)
-                        g->long_end = 8;
-                    else if (s->sample_rate_index != 8)
-                        g->long_end = 6;
-                    else
-                        g->long_end = 4; /* 8000 Hz */
-
-                    g->short_start = 2 + (s->sample_rate_index != 8);
-                } else {
-                    g->long_end = 0;
-                    g->short_start = 0;
-                }
-            } else {
-                g->short_start = 13;
-                g->long_end = 22;
+                ff_init_long_region(s, g, region_address1, region_address2);
             }
+            ff_region_offset2size(g);
+            ff_compute_band_indexes(s, g);
 
             g->preflag = 0;
             if (!s->lsf)
@@ -2356,7 +2367,7 @@
 
 static int decode_frame(AVCodecContext * avctx,
                         void *data, int *data_size,
-                        uint8_t * buf, int buf_size)
+                        const uint8_t * buf, int buf_size)
 {
     MPADecodeContext *s = avctx->priv_data;
     uint32_t header;
@@ -2420,13 +2431,14 @@
 
 static void flush(AVCodecContext *avctx){
     MPADecodeContext *s = avctx->priv_data;
+    memset(s->synth_buf, 0, sizeof(s->synth_buf));
     s->last_buf_size= 0;
 }
 
 #ifdef CONFIG_MP3ADU_DECODER
 static int decode_frame_adu(AVCodecContext * avctx,
                         void *data, int *data_size,
-                        uint8_t * buf, int buf_size)
+                        const uint8_t * buf, int buf_size)
 {
     MPADecodeContext *s = avctx->priv_data;
     uint32_t header;
@@ -2552,7 +2564,7 @@
 
 static int decode_frame_mp3on4(AVCodecContext * avctx,
                         void *data, int *data_size,
-                        uint8_t * buf, int buf_size)
+                        const uint8_t * buf, int buf_size)
 {
     MP3On4DecodeContext *s = avctx->priv_data;
     MPADecodeContext *m;
@@ -2562,7 +2574,7 @@
     OUT_INT decoded_buf[MPA_FRAME_SIZE * MPA_MAX_CHANNELS];
     OUT_INT *outptr, *bp;
     int fsize;
-    unsigned char *start2 = buf, *start;
+    const unsigned char *start2 = buf, *start;
     int fr, i, j, n;
     int off = avctx->channels;
     int *coff = chan_offset[s->chan_cfg];
@@ -2645,6 +2657,7 @@
     NULL,
     decode_frame,
     CODEC_CAP_PARSE_ONLY,
+    .flush= flush,
 };
 #endif
 #ifdef CONFIG_MP3_DECODER
diff -u mplayer-1.0~rc2-12/libavcodec/mpegaudiodecheader.h ffmpeg-free-0.svn20080206/libavcodec/mpegaudiodecheader.h
--- mplayer-1.0~rc2-12/libavcodec/mpegaudiodecheader.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpegaudiodecheader.h	2007-10-17 11:37:46.000000000 +0200
@@ -24,8 +24,8 @@
  * MPEG Audio header decoder.
  */
 
-#ifndef MPEGAUDIODECHEADER_H
-#define MPEGAUDIODECHEADER_H
+#ifndef FFMPEG_MPEGAUDIODECHEADER_H
+#define FFMPEG_MPEGAUDIODECHEADER_H
 
 #include "common.h"
 #include "mpegaudio.h"
@@ -36,4 +36,4 @@
    that the frame size must be computed externally */
 int ff_mpegaudio_decode_header(MPADecodeContext *s, uint32_t header);
 
-#endif /* MPEGAUDIODECHEADER_H */
+#endif /* FFMPEG_MPEGAUDIODECHEADER_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mpegaudiodectab.h ffmpeg-free-0.svn20080206/libavcodec/mpegaudiodectab.h
--- mplayer-1.0~rc2-12/libavcodec/mpegaudiodectab.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpegaudiodectab.h	2007-10-17 11:37:46.000000000 +0200
@@ -24,8 +24,8 @@
  * mpeg audio layer decoder tables.
  */
 
-#ifndef AVCODEC_MPEGAUDIODECTAB_H
-#define AVCODEC_MPEGAUDIODECTAB_H
+#ifndef FFMPEG_MPEGAUDIODECTAB_H
+#define FFMPEG_MPEGAUDIODECTAB_H
 
 #include <stdint.h>
 #include "mpegaudio.h"
@@ -603,4 +603,4 @@
     -0.6, -0.535, -0.33, -0.185, -0.095, -0.041, -0.0142, -0.0037,
 };
 
-#endif // AVCODEC_MPEGAUDIODECTAB_H
+#endif /* FFMPEG_MPEGAUDIODECTAB_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mpegaudio.h ffmpeg-free-0.svn20080206/libavcodec/mpegaudio.h
--- mplayer-1.0~rc2-12/libavcodec/mpegaudio.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpegaudio.h	2007-10-17 11:37:46.000000000 +0200
@@ -23,8 +23,8 @@
  * mpeg audio declarations for both encoder and decoder.
  */
 
-#ifndef MPEGAUDIO_H
-#define MPEGAUDIO_H
+#ifndef FFMPEG_MPEGAUDIO_H
+#define FFMPEG_MPEGAUDIO_H
 
 #include "avcodec.h"
 #include "bitstream.h"
@@ -152,4 +152,4 @@
     return 0;
 }
 
-#endif /* MPEGAUDIO_H */
+#endif /* FFMPEG_MPEGAUDIO_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mpegaudiotab.h ffmpeg-free-0.svn20080206/libavcodec/mpegaudiotab.h
--- mplayer-1.0~rc2-12/libavcodec/mpegaudiotab.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpegaudiotab.h	2007-10-17 11:37:46.000000000 +0200
@@ -27,8 +27,8 @@
  * Most of them come from the mpeg audio specification.
  */
 
-#ifndef AVCODEC_MPEGAUDIOTAB_H
-#define AVCODEC_MPEGAUDIOTAB_H
+#ifndef FFMPEG_MPEGAUDIOTAB_H
+#define FFMPEG_MPEGAUDIOTAB_H
 
 #include <stdint.h>
 #include "mpegaudio.h"
@@ -115,4 +115,4 @@
 
 static const unsigned char nb_scale_factors[4] = { 3, 2, 1, 2 };
 
-#endif // AVCODEC_MPEGAUDIOTAB_H
+#endif /* FFMPEG_MPEGAUDIOTAB_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mpegvideo.c ffmpeg-free-0.svn20080206/libavcodec/mpegvideo.c
--- mplayer-1.0~rc2-12/libavcodec/mpegvideo.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpegvideo.c	2008-03-20 19:10:58.000000000 +0100
@@ -130,7 +130,7 @@
 }
 
 /* init common dct for both encoder and decoder */
-static int DCT_common_init(MpegEncContext *s)
+int ff_dct_common_init(MpegEncContext *s)
 {
     s->dct_unquantize_h263_intra = dct_unquantize_h263_intra_c;
     s->dct_unquantize_h263_inter = dct_unquantize_h263_inter_c;
@@ -229,8 +229,8 @@
 
         CHECKED_ALLOCZ(pic->mbskip_table , mb_array_size * sizeof(uint8_t)+2) //the +2 is for the slice end check
         CHECKED_ALLOCZ(pic->qscale_table , mb_array_size * sizeof(uint8_t))
-        CHECKED_ALLOCZ(pic->mb_type_base , big_mb_num    * sizeof(uint32_t))
-        pic->mb_type= pic->mb_type_base + s->mb_stride+1;
+        CHECKED_ALLOCZ(pic->mb_type_base , (big_mb_num + s->mb_stride) * sizeof(uint32_t))
+        pic->mb_type= pic->mb_type_base + 2*s->mb_stride+1;
         if(s->out_format == FMT_H264){
             for(i=0; i<2; i++){
                 CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b4_array_size+4)  * sizeof(int16_t))
@@ -431,7 +431,7 @@
         return -1;
 
     dsputil_init(&s->dsp, s->avctx);
-    DCT_common_init(s);
+    ff_dct_common_init(s);
 
     s->flags= s->avctx->flags;
     s->flags2= s->avctx->flags2;
@@ -587,9 +587,7 @@
     s->context_initialized = 1;
 
     s->thread_context[0]= s;
-    /* h264 does thread context setup itself, but it needs context[0]
-     * to be fully initialized for the error resilience code */
-    threads = s->codec_id == CODEC_ID_H264 ? 1 : s->avctx->thread_count;
+    threads = s->avctx->thread_count;
 
     for(i=1; i<threads; i++){
         s->thread_context[i]= av_malloc(sizeof(MpegEncContext));
@@ -842,7 +840,19 @@
         }
     }
 
-    assert(0);
+    av_log(s->avctx, AV_LOG_FATAL, "Internal error, picture buffer overflow\n");
+    /* We could return -1, but the codec would crash trying to draw into a
+     * non-existing frame anyway. This is safer than waiting for a random crash.
+     * Also the return of this is never useful, an encoder must only allocate
+     * as much as allowed in the specification. This has no relationship to how
+     * much libavcodec could allocate (and MAX_PICTURE_COUNT is always large
+     * enough for such valid streams).
+     * Plus, a decoder has to check stream validity and remove frames if too
+     * many reference frames are around. Waiting for "OOM" is not correct at
+     * all. Similarly, missing reference frames have to be replaced by
+     * interpolated/MC frames, anything else is a bug in the codec ...
+     */
+    abort();
     return -1;
 }
 
@@ -954,7 +964,7 @@
 
     assert(s->pict_type == I_TYPE || (s->last_picture_ptr && s->last_picture_ptr->data[0]));
 
-    if(s->picture_structure!=PICT_FRAME){
+    if(s->picture_structure!=PICT_FRAME && s->out_format != FMT_H264){
         int i;
         for(i=0; i<4; i++){
             if(s->picture_structure == PICT_BOTTOM_FIELD){
diff -u mplayer-1.0~rc2-12/libavcodec/mpegvideo_common.h ffmpeg-free-0.svn20080206/libavcodec/mpegvideo_common.h
--- mplayer-1.0~rc2-12/libavcodec/mpegvideo_common.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpegvideo_common.h	2007-10-17 11:37:46.000000000 +0200
@@ -27,8 +27,8 @@
  * The simplest mpeg encoder (well, it was the simplest!).
  */
 
-#ifndef MPEGVIDEO_COMMON_H
-#define MPEGVIDEO_COMMON_H
+#ifndef FFMPEG_MPEGVIDEO_COMMON_H
+#define FFMPEG_MPEGVIDEO_COMMON_H
 
 #include "avcodec.h"
 #include "dsputil.h"
@@ -833,4 +833,4 @@
     }
 }
 
-#endif /* MPEGVIDEO_COMMON_H */
+#endif /* FFMPEG_MPEGVIDEO_COMMON_H */
diff -u mplayer-1.0~rc2-12/libavcodec/mpegvideo_enc.c ffmpeg-free-0.svn20080206/libavcodec/mpegvideo_enc.c
--- mplayer-1.0~rc2-12/libavcodec/mpegvideo_enc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpegvideo_enc.c	2008-03-20 19:10:58.000000000 +0100
@@ -64,9 +64,7 @@
 static uint8_t default_mv_penalty[MAX_FCODE+1][MAX_MV*2+1];
 static uint8_t default_fcode_tab[MAX_MV*2+1];
 
-enum PixelFormat ff_yuv420p_list[2]= {PIX_FMT_YUV420P, -1};
-
-static void convert_matrix(DSPContext *dsp, int (*qmat)[64], uint16_t (*qmat16)[2][64],
+void ff_convert_matrix(DSPContext *dsp, int (*qmat)[64], uint16_t (*qmat16)[2][64],
                            const uint16_t *quant_matrix, int bias, int qmin, int qmax, int intra)
 {
     int qscale;
@@ -716,9 +714,9 @@
     /* precompute matrix */
     /* for mjpeg, we do include qscale in the matrix */
     if (s->out_format != FMT_MJPEG) {
-        convert_matrix(&s->dsp, s->q_intra_matrix, s->q_intra_matrix16,
+        ff_convert_matrix(&s->dsp, s->q_intra_matrix, s->q_intra_matrix16,
                        s->intra_matrix, s->intra_quant_bias, avctx->qmin, 31, 1);
-        convert_matrix(&s->dsp, s->q_inter_matrix, s->q_inter_matrix16,
+        ff_convert_matrix(&s->dsp, s->q_inter_matrix, s->q_inter_matrix16,
                        s->inter_matrix, s->inter_quant_bias, avctx->qmin, 31, 0);
     }
 
@@ -1422,7 +1420,7 @@
         av_log(s->avctx, AV_LOG_INFO, "warning, clipping %d dct coefficients to %d..%d\n", overflow, minlevel, maxlevel);
 }
 
-static void get_vissual_weight(int16_t *weight, uint8_t *ptr, int stride){
+static void get_visual_weight(int16_t *weight, uint8_t *ptr, int stride){
     int x, y;
 //FIXME optimize
     for(y=0; y<8; y++){
@@ -1626,15 +1624,15 @@
     }
 
     if(s->avctx->quantizer_noise_shaping){
-        if(!skip_dct[0]) get_vissual_weight(weight[0], ptr_y                 , wrap_y);
-        if(!skip_dct[1]) get_vissual_weight(weight[1], ptr_y              + 8, wrap_y);
-        if(!skip_dct[2]) get_vissual_weight(weight[2], ptr_y + dct_offset    , wrap_y);
-        if(!skip_dct[3]) get_vissual_weight(weight[3], ptr_y + dct_offset + 8, wrap_y);
-        if(!skip_dct[4]) get_vissual_weight(weight[4], ptr_cb                , wrap_c);
-        if(!skip_dct[5]) get_vissual_weight(weight[5], ptr_cr                , wrap_c);
+        if(!skip_dct[0]) get_visual_weight(weight[0], ptr_y                 , wrap_y);
+        if(!skip_dct[1]) get_visual_weight(weight[1], ptr_y              + 8, wrap_y);
+        if(!skip_dct[2]) get_visual_weight(weight[2], ptr_y + dct_offset    , wrap_y);
+        if(!skip_dct[3]) get_visual_weight(weight[3], ptr_y + dct_offset + 8, wrap_y);
+        if(!skip_dct[4]) get_visual_weight(weight[4], ptr_cb                , wrap_c);
+        if(!skip_dct[5]) get_visual_weight(weight[5], ptr_cr                , wrap_c);
         if(!s->chroma_y_shift){ /* 422 */
-            if(!skip_dct[6]) get_vissual_weight(weight[6], ptr_cb + (dct_offset>>1), wrap_c);
-            if(!skip_dct[7]) get_vissual_weight(weight[7], ptr_cr + (dct_offset>>1), wrap_c);
+            if(!skip_dct[6]) get_visual_weight(weight[6], ptr_cb + (dct_offset>>1), wrap_c);
+            if(!skip_dct[7]) get_visual_weight(weight[7], ptr_cr + (dct_offset>>1), wrap_c);
         }
         memcpy(orig[0], s->block[0], sizeof(DCTELEM)*64*mb_block_count);
     }
@@ -1769,6 +1767,8 @@
     d->mb_skipped= 0;
     d->qscale= s->qscale;
     d->dquant= s->dquant;
+
+    d->esc3_level_length= s->esc3_level_length;
 }
 
 static inline void copy_context_after_encode(MpegEncContext *d, MpegEncContext *s, int type){
@@ -1806,6 +1806,8 @@
         d->block_last_index[i]= s->block_last_index[i];
     d->interlaced_dct= s->interlaced_dct;
     d->qscale= s->qscale;
+
+    d->esc3_level_length= s->esc3_level_length;
 }
 
 static inline void encode_mb_hq(MpegEncContext *s, MpegEncContext *backup, MpegEncContext *best, int type,
@@ -2861,7 +2863,7 @@
 
             s->intra_matrix[j] = av_clip_uint8((ff_mpeg1_default_intra_matrix[i] * s->qscale) >> 3);
         }
-        convert_matrix(&s->dsp, s->q_intra_matrix, s->q_intra_matrix16,
+        ff_convert_matrix(&s->dsp, s->q_intra_matrix, s->q_intra_matrix16,
                        s->intra_matrix, s->intra_quant_bias, 8, 8, 1);
         s->qscale= 8;
     }
@@ -3714,27 +3716,7 @@
     return last_non_zero;
 }
 
-AVCodec h263_encoder = {
-    "h263",
-    CODEC_TYPE_VIDEO,
-    CODEC_ID_H263,
-    sizeof(MpegEncContext),
-    MPV_encode_init,
-    MPV_encode_picture,
-    MPV_encode_end,
-    .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, -1},
-};
 
-AVCodec h263p_encoder = {
-    "h263p",
-    CODEC_TYPE_VIDEO,
-    CODEC_ID_H263P,
-    sizeof(MpegEncContext),
-    MPV_encode_init,
-    MPV_encode_picture,
-    MPV_encode_end,
-    .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, -1},
-};
 
 AVCodec flv_encoder = {
     "flv",
@@ -3769,50 +3751,9 @@
     .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, -1},
 };
 
-AVCodec mpeg4_encoder = {
-    "mpeg4",
-    CODEC_TYPE_VIDEO,
-    CODEC_ID_MPEG4,
-    sizeof(MpegEncContext),
-    MPV_encode_init,
-    MPV_encode_picture,
-    MPV_encode_end,
-    .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, -1},
-    .capabilities= CODEC_CAP_DELAY,
-};
 
-AVCodec msmpeg4v1_encoder = {
-    "msmpeg4v1",
-    CODEC_TYPE_VIDEO,
-    CODEC_ID_MSMPEG4V1,
-    sizeof(MpegEncContext),
-    MPV_encode_init,
-    MPV_encode_picture,
-    MPV_encode_end,
-    .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, -1},
-};
 
-AVCodec msmpeg4v2_encoder = {
-    "msmpeg4v2",
-    CODEC_TYPE_VIDEO,
-    CODEC_ID_MSMPEG4V2,
-    sizeof(MpegEncContext),
-    MPV_encode_init,
-    MPV_encode_picture,
-    MPV_encode_end,
-    .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, -1},
-};
 
-AVCodec msmpeg4v3_encoder = {
-    "msmpeg4",
-    CODEC_TYPE_VIDEO,
-    CODEC_ID_MSMPEG4V3,
-    sizeof(MpegEncContext),
-    MPV_encode_init,
-    MPV_encode_picture,
-    MPV_encode_end,
-    .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, -1},
-};
 
 AVCodec wmv1_encoder = {
     "wmv1",
diff -u mplayer-1.0~rc2-12/libavcodec/mpegvideo.h ffmpeg-free-0.svn20080206/libavcodec/mpegvideo.h
--- mplayer-1.0~rc2-12/libavcodec/mpegvideo.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/mpegvideo.h	2008-02-03 18:54:30.000000000 +0100
@@ -25,8 +25,8 @@
  * mpegvideo header.
  */
 
-#ifndef AVCODEC_MPEGVIDEO_H
-#define AVCODEC_MPEGVIDEO_H
+#ifndef FFMPEG_MPEGVIDEO_H
+#define FFMPEG_MPEGVIDEO_H
 
 #include "dsputil.h"
 #include "bitstream.h"
@@ -94,7 +94,7 @@
     uint8_t permutated[64];
     uint8_t raster_end[64];
 #ifdef ARCH_POWERPC
-                /** Used by dct_quantise_alitvec to find last-non-zero */
+                /** Used by dct_quantize_altivec to find last-non-zero */
     DECLARE_ALIGNED_8(uint8_t, inverse[64]);
 #endif
 } ScanTable;
@@ -111,7 +111,7 @@
     uint8_t *interpolated[3];
     int16_t (*motion_val_base[2])[2];
     uint32_t *mb_type_base;
-#define MB_TYPE_INTRA MB_TYPE_INTRA4x4 //default mb_type if theres just one type
+#define MB_TYPE_INTRA MB_TYPE_INTRA4x4 //default mb_type if there is just one type
 #define IS_INTRA4x4(a)   ((a)&MB_TYPE_INTRA4x4)
 #define IS_INTRA16x16(a) ((a)&MB_TYPE_INTRA16x16)
 #define IS_PCM(a)        ((a)&MB_TYPE_INTRA_PCM)
@@ -723,8 +723,9 @@
 void ff_er_frame_end(MpegEncContext *s);
 void ff_er_add_slice(MpegEncContext *s, int startx, int starty, int endx, int endy, int status);
 
-
-extern enum PixelFormat ff_yuv420p_list[2];
+int ff_dct_common_init(MpegEncContext *s);
+void ff_convert_matrix(DSPContext *dsp, int (*qmat)[64], uint16_t (*qmat16)[2][64],
+                       const uint16_t *quant_matrix, int bias, int qmin, int qmax, int intra);
 
 void ff_init_block_index(MpegEncContext *s);
 
@@ -770,10 +771,10 @@
                      int16_t (*mv_table)[2], int f_code, int type, int truncate);
 void ff_init_me(MpegEncContext *s);
 int ff_pre_estimate_p_frame_motion(MpegEncContext * s, int mb_x, int mb_y);
-inline int ff_epzs_motion_search(MpegEncContext * s, int *mx_ptr, int *my_ptr,
+int ff_epzs_motion_search(MpegEncContext * s, int *mx_ptr, int *my_ptr,
                              int P[10][2], int src_index, int ref_index, int16_t (*last_mv)[2],
                              int ref_mv_scale, int size, int h);
-inline int ff_get_mb_score(MpegEncContext * s, int mx, int my, int src_index,
+int ff_get_mb_score(MpegEncContext * s, int mx, int my, int src_index,
                                int ref_index, int size, int h, int add_rate);
 
 /* mpeg12.c */
@@ -816,7 +817,7 @@
 int ff_h263_decode_init(AVCodecContext *avctx);
 int ff_h263_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size);
+                             const uint8_t *buf, int buf_size);
 int ff_h263_decode_end(AVCodecContext *avctx);
 void h263_encode_mb(MpegEncContext *s,
                     DCTELEM block[6][64],
@@ -895,5 +896,5 @@
                        DCTELEM block[6][64],
                        int motion_x, int motion_y);
 
-#endif /* AVCODEC_MPEGVIDEO_H */
+#endif /* FFMPEG_MPEGVIDEO_H */
 
diff -u mplayer-1.0~rc2-12/libavcodec/msmpeg4.c ffmpeg-free-0.svn20080206/libavcodec/msmpeg4.c
--- mplayer-1.0~rc2-12/libavcodec/msmpeg4.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/msmpeg4.c	2008-03-20 19:10:58.000000000 +0100
@@ -30,6 +30,7 @@
 #include "avcodec.h"
 #include "dsputil.h"
 #include "mpegvideo.h"
+#include "msmpeg4.h"
 
 /*
  * You can also call this codec : MPEG4 with a twist !
@@ -42,7 +43,6 @@
 
 #define DC_VLC_BITS 9
 #define CBPY_VLC_BITS 6
-#define INTER_INTRA_VLC_BITS 3
 #define V1_INTRA_CBPC_VLC_BITS 6
 #define V1_INTER_CBPC_VLC_BITS 6
 #define V2_INTRA_CBPC_VLC_BITS 3
@@ -50,8 +50,6 @@
 #define MV_VLC_BITS 9
 #define V2_MV_VLC_BITS 9
 #define TEX_VLC_BITS 9
-#define MB_NON_INTRA_VLC_BITS 9
-#define MB_INTRA_VLC_BITS 9
 
 #define II_BITRATE 128*1024
 #define MBAC_BITRATE 50*1024
@@ -61,12 +59,7 @@
 static uint32_t v2_dc_lum_table[512][2];
 static uint32_t v2_dc_chroma_table[512][2];
 
-void ff_msmpeg4_encode_block(MpegEncContext * s, DCTELEM * block, int n);
-static inline int msmpeg4_decode_block(MpegEncContext * s, DCTELEM * block,
-                                       int n, int coded, const uint8_t *scantable);
 static int msmpeg4_decode_dc(MpegEncContext * s, int n, int *dir_ptr);
-static int msmpeg4_decode_motion(MpegEncContext * s,
-                                 int *mx_ptr, int *my_ptr);
 static void init_h263_dc_for_msmpeg4(void);
 static inline void msmpeg4_memsetw(short *tab, int val, int n);
 #ifdef CONFIG_ENCODERS
@@ -75,10 +68,9 @@
 #endif //CONFIG_ENCODERS
 static int msmpeg4v12_decode_mb(MpegEncContext *s, DCTELEM block[6][64]);
 static int msmpeg4v34_decode_mb(MpegEncContext *s, DCTELEM block[6][64]);
-static int wmv2_decode_mb(MpegEncContext *s, DCTELEM block[6][64]);
 
 /* vc1 externs */
-extern uint8_t wmv3_dc_scale_table[32];
+extern const uint8_t wmv3_dc_scale_table[32];
 
 #ifdef DEBUG
 int intra_count = 0;
@@ -161,7 +153,7 @@
     }
 }
 
-void ff_code012(PutBitContext *pb, int n)
+void ff_msmpeg4_code012(PutBitContext *pb, int n)
 {
     if (n == 0) {
         put_bits(pb, 1, 0);
@@ -347,8 +339,8 @@
 
         if(s->msmpeg4_version>2){
             if(!s->per_mb_rl_table){
-                ff_code012(&s->pb, s->rl_chroma_table_index);
-                ff_code012(&s->pb, s->rl_table_index);
+                ff_msmpeg4_code012(&s->pb, s->rl_chroma_table_index);
+                ff_msmpeg4_code012(&s->pb, s->rl_table_index);
             }
 
             put_bits(&s->pb, 1, s->dc_table_index);
@@ -361,7 +353,7 @@
 
         if(s->msmpeg4_version>2){
             if(!s->per_mb_rl_table)
-                ff_code012(&s->pb, s->rl_table_index);
+                ff_msmpeg4_code012(&s->pb, s->rl_table_index);
 
             put_bits(&s->pb, 1, s->dc_table_index);
 
@@ -393,7 +385,7 @@
 #endif //CONFIG_ENCODERS
 
 /* predict coded block */
-static inline int coded_block_pred(MpegEncContext * s, int n, uint8_t **coded_block_ptr)
+int ff_msmpeg4_coded_block_pred(MpegEncContext * s, int n, uint8_t **coded_block_ptr)
 {
     int xy, wrap, pred, a, b, c;
 
@@ -421,7 +413,7 @@
 
 #ifdef CONFIG_ENCODERS
 
-static void msmpeg4_encode_motion(MpegEncContext * s,
+void ff_msmpeg4_encode_motion(MpegEncContext * s,
                                   int mx, int my)
 {
     int code;
@@ -459,7 +451,7 @@
     }
 }
 
-static inline void handle_slices(MpegEncContext *s){
+void ff_msmpeg4_handle_slices(MpegEncContext *s){
     if (s->mb_x == 0) {
         if (s->slice_height && (s->mb_y % s->slice_height) == 0) {
             if(s->msmpeg4_version < 4){
@@ -480,7 +472,7 @@
     int pred_x, pred_y;
     uint8_t *coded_block;
 
-    handle_slices(s);
+    ff_msmpeg4_handle_slices(s);
 
     if (!s->mb_intra) {
         /* compute cbp */
@@ -526,7 +518,7 @@
 
             /* motion vector */
             h263_pred_motion(s, 0, 0, &pred_x, &pred_y);
-            msmpeg4_encode_motion(s, motion_x - pred_x,
+            ff_msmpeg4_encode_motion(s, motion_x - pred_x,
                                   motion_y - pred_y);
         }
 
@@ -546,7 +538,7 @@
             cbp |= val << (5 - i);
             if (i < 4) {
                 /* predict value for close blocks only for luma */
-                pred = coded_block_pred(s, i, &coded_block);
+                pred = ff_msmpeg4_coded_block_pred(s, i, &coded_block);
                 *coded_block = val;
                 val = val ^ pred;
             }
@@ -990,7 +982,7 @@
 /****************************************/
 /* decoding stuff */
 
-static VLC mb_non_intra_vlc[4];
+VLC ff_mb_non_intra_vlc[4];
 static VLC v2_dc_lum_vlc;
 static VLC v2_dc_chroma_vlc;
 static VLC cbpy_vlc;
@@ -999,7 +991,7 @@
 static VLC v2_mv_vlc;
 static VLC v1_intra_cbpc_vlc;
 static VLC v1_inter_cbpc_vlc;
-static VLC inter_intra_vlc;
+VLC ff_inter_intra_vlc;
 
 /* This table is practically identical to the one from h263
  * except that it is inverted. */
@@ -1114,7 +1106,7 @@
                  &mvtab[0][0], 2, 1, 1);
 
         for(i=0; i<4; i++){
-            init_vlc(&mb_non_intra_vlc[i], MB_NON_INTRA_VLC_BITS, 128,
+            init_vlc(&ff_mb_non_intra_vlc[i], MB_NON_INTRA_VLC_BITS, 128,
                      &wmv2_inter_table[i][0][1], 8, 4,
                      &wmv2_inter_table[i][0][0], 8, 4, 1); //FIXME name?
         }
@@ -1130,7 +1122,7 @@
                  inter_MCBPC_bits, 1, 1,
                  inter_MCBPC_code, 1, 1, 1);
 
-        init_vlc(&inter_intra_vlc, INTER_INTRA_VLC_BITS, 4,
+        init_vlc(&ff_inter_intra_vlc, INTER_INTRA_VLC_BITS, 4,
                  &table_inter_intra[0][1], 2, 1,
                  &table_inter_intra[0][0], 2, 1, 1);
     }
@@ -1145,7 +1137,8 @@
         s->decode_mb= msmpeg4v34_decode_mb;
         break;
     case 5:
-        s->decode_mb= wmv2_decode_mb;
+        if (ENABLE_WMV2_DECODER)
+            s->decode_mb= ff_wmv2_decode_mb;
     case 6:
         //FIXME + TODO VC1 decode mb
         break;
@@ -1508,7 +1501,7 @@
 
     s->dsp.clear_blocks(s->block[0]);
     for (i = 0; i < 6; i++) {
-        if (msmpeg4_decode_block(s, block[i], i, (cbp >> (5 - i)) & 1, NULL) < 0)
+        if (ff_msmpeg4_decode_block(s, block[i], i, (cbp >> (5 - i)) & 1, NULL) < 0)
         {
              av_log(s->avctx, AV_LOG_ERROR, "\nerror while decoding block: %d x %d (%d)\n", s->mb_x, s->mb_y, i);
              return -1;
@@ -1541,7 +1534,7 @@
             }
         }
 
-        code = get_vlc2(&s->gb, mb_non_intra_vlc[DEFAULT_INTER_INDEX].table, MB_NON_INTRA_VLC_BITS, 3);
+        code = get_vlc2(&s->gb, ff_mb_non_intra_vlc[DEFAULT_INTER_INDEX].table, MB_NON_INTRA_VLC_BITS, 3);
         if (code < 0)
             return -1;
         //s->mb_intra = (code & 0x40) ? 0 : 1;
@@ -1558,7 +1551,7 @@
         for(i=0;i<6;i++) {
             int val = ((code >> (5 - i)) & 1);
             if (i < 4) {
-                int pred = coded_block_pred(s, i, &coded_val);
+                int pred = ff_msmpeg4_coded_block_pred(s, i, &coded_val);
                 val = val ^ pred;
                 *coded_val = val;
             }
@@ -1574,7 +1567,7 @@
             s->rl_chroma_table_index = s->rl_table_index;
         }
         h263_pred_motion(s, 0, 0, &mx, &my);
-        if (msmpeg4_decode_motion(s, &mx, &my) < 0)
+        if (ff_msmpeg4_decode_motion(s, &mx, &my) < 0)
             return -1;
         s->mv_dir = MV_DIR_FORWARD;
         s->mv_type = MV_TYPE_16X16;
@@ -1586,7 +1579,7 @@
         s->ac_pred = get_bits1(&s->gb);
         *mb_type_ptr = MB_TYPE_INTRA;
         if(s->inter_intra_pred){
-            s->h263_aic_dir= get_vlc2(&s->gb, inter_intra_vlc.table, INTER_INTRA_VLC_BITS, 1);
+            s->h263_aic_dir= get_vlc2(&s->gb, ff_inter_intra_vlc.table, INTER_INTRA_VLC_BITS, 1);
 //            printf("%d%d %d %d/", s->ac_pred, s->h263_aic_dir, s->mb_x, s->mb_y);
         }
         if(s->per_mb_rl_table && cbp){
@@ -1597,7 +1590,7 @@
 
     s->dsp.clear_blocks(s->block[0]);
     for (i = 0; i < 6; i++) {
-        if (msmpeg4_decode_block(s, block[i], i, (cbp >> (5 - i)) & 1, NULL) < 0)
+        if (ff_msmpeg4_decode_block(s, block[i], i, (cbp >> (5 - i)) & 1, NULL) < 0)
         {
             av_log(s->avctx, AV_LOG_ERROR, "\nerror while decoding block: %d x %d (%d)\n", s->mb_x, s->mb_y, i);
             return -1;
@@ -1607,7 +1600,7 @@
     return 0;
 }
 //#define ERROR_DETAILS
-static inline int msmpeg4_decode_block(MpegEncContext * s, DCTELEM * block,
+int ff_msmpeg4_decode_block(MpegEncContext * s, DCTELEM * block,
                               int n, int coded, const uint8_t *scan_table)
 {
     int level, i, last, run, run_diff;
@@ -1911,7 +1904,7 @@
     return level;
 }
 
-static int msmpeg4_decode_motion(MpegEncContext * s,
+int ff_msmpeg4_decode_motion(MpegEncContext * s,
                                  int *mx_ptr, int *my_ptr)
 {
     MVTable *mv;
@@ -1949,9 +1942,3 @@
     *my_ptr = my;
     return 0;
 }
-
-/* cleanest way to support it
- * there is too much shared between versions so that we cant have 1 file per version & 1 common
- * as allmost everything would be in the common file
- */
-#include "wmv2.c"
diff -u mplayer-1.0~rc2-12/libavcodec/msmpeg4data.c ffmpeg-free-0.svn20080206/libavcodec/msmpeg4data.c
--- mplayer-1.0~rc2-12/libavcodec/msmpeg4data.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/msmpeg4data.c	2008-03-20 19:10:58.000000000 +0100
@@ -1828,53 +1828,47 @@
     0, 8, 8, 8, 8, 9, 9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22
 };
 
-
-static const uint8_t wmv1_scantable00[64]= {
-0x00, 0x08, 0x01, 0x02, 0x09, 0x10, 0x18, 0x11,
-0x0A, 0x03, 0x04, 0x0B, 0x12, 0x19, 0x20, 0x28,
-0x30, 0x38, 0x29, 0x21, 0x1A, 0x13, 0x0C, 0x05,
-0x06, 0x0D, 0x14, 0x1B, 0x22, 0x31, 0x39, 0x3A,
-0x32, 0x2A, 0x23, 0x1C, 0x15, 0x0E, 0x07, 0x0F,
-0x16, 0x1D, 0x24, 0x2B, 0x33, 0x3B, 0x3C, 0x34,
-0x2C, 0x25, 0x1E, 0x17, 0x1F, 0x26, 0x2D, 0x35,
-0x3D, 0x3E, 0x36, 0x2E, 0x27, 0x2F, 0x37, 0x3F,
-};
-static const uint8_t wmv1_scantable01[64]= {
-0x00, 0x08, 0x01, 0x02, 0x09, 0x10, 0x18, 0x11,
-0x0A, 0x03, 0x04, 0x0B, 0x12, 0x19, 0x20, 0x28,
-0x21, 0x30, 0x1A, 0x13, 0x0C, 0x05, 0x06, 0x0D,
-0x14, 0x1B, 0x22, 0x29, 0x38, 0x31, 0x39, 0x2A,
-0x23, 0x1C, 0x15, 0x0E, 0x07, 0x0F, 0x16, 0x1D,
-0x24, 0x2B, 0x32, 0x3A, 0x33, 0x3B, 0x2C, 0x25,
-0x1E, 0x17, 0x1F, 0x26, 0x2D, 0x34, 0x3C, 0x35,
-0x3D, 0x2E, 0x27, 0x2F, 0x36, 0x3E, 0x37, 0x3F,
-};
-static const uint8_t wmv1_scantable02[64]= {
-0x00, 0x01, 0x08, 0x02, 0x03, 0x09, 0x10, 0x18,
-0x11, 0x0A, 0x04, 0x05, 0x0B, 0x12, 0x19, 0x20,
-0x28, 0x30, 0x21, 0x1A, 0x13, 0x0C, 0x06, 0x07,
-0x0D, 0x14, 0x1B, 0x22, 0x29, 0x38, 0x31, 0x39,
-0x2A, 0x23, 0x1C, 0x15, 0x0E, 0x0F, 0x16, 0x1D,
-0x24, 0x2B, 0x32, 0x3A, 0x33, 0x2C, 0x25, 0x1E,
-0x17, 0x1F, 0x26, 0x2D, 0x34, 0x3B, 0x3C, 0x35,
-0x2E, 0x27, 0x2F, 0x36, 0x3D, 0x3E, 0x37, 0x3F,
-};
-static const uint8_t wmv1_scantable03[64]= {
-0x00, 0x08, 0x10, 0x01, 0x18, 0x20, 0x28, 0x09,
-0x02, 0x03, 0x0A, 0x11, 0x19, 0x30, 0x38, 0x29,
-0x21, 0x1A, 0x12, 0x0B, 0x04, 0x05, 0x0C, 0x13,
-0x1B, 0x22, 0x31, 0x39, 0x32, 0x2A, 0x23, 0x1C,
-0x14, 0x0D, 0x06, 0x07, 0x0E, 0x15, 0x1D, 0x24,
-0x2B, 0x33, 0x3A, 0x3B, 0x34, 0x2C, 0x25, 0x1E,
-0x16, 0x0F, 0x17, 0x1F, 0x26, 0x2D, 0x3C, 0x35,
-0x2E, 0x27, 0x2F, 0x36, 0x3D, 0x3E, 0x37, 0x3F,
-};
-
-const uint8_t *wmv1_scantable[WMV1_SCANTABLE_COUNT+1]={
-    wmv1_scantable00,
-    wmv1_scantable01,
-    wmv1_scantable02,
-    wmv1_scantable03,
+const uint8_t wmv1_scantable[WMV1_SCANTABLE_COUNT][64]={
+  {
+    0x00, 0x08, 0x01, 0x02, 0x09, 0x10, 0x18, 0x11,
+    0x0A, 0x03, 0x04, 0x0B, 0x12, 0x19, 0x20, 0x28,
+    0x30, 0x38, 0x29, 0x21, 0x1A, 0x13, 0x0C, 0x05,
+    0x06, 0x0D, 0x14, 0x1B, 0x22, 0x31, 0x39, 0x3A,
+    0x32, 0x2A, 0x23, 0x1C, 0x15, 0x0E, 0x07, 0x0F,
+    0x16, 0x1D, 0x24, 0x2B, 0x33, 0x3B, 0x3C, 0x34,
+    0x2C, 0x25, 0x1E, 0x17, 0x1F, 0x26, 0x2D, 0x35,
+    0x3D, 0x3E, 0x36, 0x2E, 0x27, 0x2F, 0x37, 0x3F,
+  },
+  {
+    0x00, 0x08, 0x01, 0x02, 0x09, 0x10, 0x18, 0x11,
+    0x0A, 0x03, 0x04, 0x0B, 0x12, 0x19, 0x20, 0x28,
+    0x21, 0x30, 0x1A, 0x13, 0x0C, 0x05, 0x06, 0x0D,
+    0x14, 0x1B, 0x22, 0x29, 0x38, 0x31, 0x39, 0x2A,
+    0x23, 0x1C, 0x15, 0x0E, 0x07, 0x0F, 0x16, 0x1D,
+    0x24, 0x2B, 0x32, 0x3A, 0x33, 0x3B, 0x2C, 0x25,
+    0x1E, 0x17, 0x1F, 0x26, 0x2D, 0x34, 0x3C, 0x35,
+    0x3D, 0x2E, 0x27, 0x2F, 0x36, 0x3E, 0x37, 0x3F,
+  },
+  {
+    0x00, 0x01, 0x08, 0x02, 0x03, 0x09, 0x10, 0x18,
+    0x11, 0x0A, 0x04, 0x05, 0x0B, 0x12, 0x19, 0x20,
+    0x28, 0x30, 0x21, 0x1A, 0x13, 0x0C, 0x06, 0x07,
+    0x0D, 0x14, 0x1B, 0x22, 0x29, 0x38, 0x31, 0x39,
+    0x2A, 0x23, 0x1C, 0x15, 0x0E, 0x0F, 0x16, 0x1D,
+    0x24, 0x2B, 0x32, 0x3A, 0x33, 0x2C, 0x25, 0x1E,
+    0x17, 0x1F, 0x26, 0x2D, 0x34, 0x3B, 0x3C, 0x35,
+    0x2E, 0x27, 0x2F, 0x36, 0x3D, 0x3E, 0x37, 0x3F,
+  },
+  {
+    0x00, 0x08, 0x10, 0x01, 0x18, 0x20, 0x28, 0x09,
+    0x02, 0x03, 0x0A, 0x11, 0x19, 0x30, 0x38, 0x29,
+    0x21, 0x1A, 0x12, 0x0B, 0x04, 0x05, 0x0C, 0x13,
+    0x1B, 0x22, 0x31, 0x39, 0x32, 0x2A, 0x23, 0x1C,
+    0x14, 0x0D, 0x06, 0x07, 0x0E, 0x15, 0x1D, 0x24,
+    0x2B, 0x33, 0x3A, 0x3B, 0x34, 0x2C, 0x25, 0x1E,
+    0x16, 0x0F, 0x17, 0x1F, 0x26, 0x2D, 0x3C, 0x35,
+    0x2E, 0x27, 0x2F, 0x36, 0x3D, 0x3E, 0x37, 0x3F,
+  }
 };
 
 const uint8_t table_inter_intra[4][2]={
diff -u mplayer-1.0~rc2-12/libavcodec/msmpeg4data.h ffmpeg-free-0.svn20080206/libavcodec/msmpeg4data.h
--- mplayer-1.0~rc2-12/libavcodec/msmpeg4data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/msmpeg4data.h	2008-01-07 13:47:14.000000000 +0100
@@ -27,8 +27,8 @@
  * MSMPEG4 data tables.
  */
 
-#ifndef MSMPEG4DATA_H
-#define MSMPEG4DATA_H
+#ifndef FFMPEG_MSMPEG4DATA_H
+#define FFMPEG_MSMPEG4DATA_H
 
 #include "common.h"
 #include "bitstream.h"
@@ -67,7 +67,7 @@
 
 #define WMV1_SCANTABLE_COUNT 4
 
-extern const uint8_t *wmv1_scantable[WMV1_SCANTABLE_COUNT+1];
+extern const uint8_t wmv1_scantable[WMV1_SCANTABLE_COUNT][64];
 
 #define NB_RL_TABLES  6
 
@@ -97,4 +97,4 @@
 extern const uint8_t wmv2_scantableA[64];
 extern const uint8_t wmv2_scantableB[64];
 
-#endif /* MSMPEG4DATA_H */
+#endif /* FFMPEG_MSMPEG4DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/msmpeg4.h ffmpeg-free-0.svn20080206/libavcodec/msmpeg4.h
--- mplayer-1.0~rc2-12/libavcodec/msmpeg4.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/msmpeg4.h	2007-11-08 00:41:39.000000000 +0100
@@ -23,10 +23,31 @@
  * @file msmpeg4.h
  */
 
-#ifndef MSMPEG4_H
-#define MSMPEG4_H
+#ifndef FFMPEG_MSMPEG4_H
+#define FFMPEG_MSMPEG4_H
 
 #include "config.h"
+#include "avcodec.h"
+#include "dsputil.h"
+#include "mpegvideo.h"
+
+#define INTER_INTRA_VLC_BITS 3
+#define MB_NON_INTRA_VLC_BITS 9
+#define MB_INTRA_VLC_BITS 9
+
+extern VLC ff_mb_non_intra_vlc[4];
+extern VLC ff_inter_intra_vlc;
+
+void ff_msmpeg4_code012(PutBitContext *pb, int n);
+void ff_msmpeg4_encode_block(MpegEncContext * s, DCTELEM * block, int n);
+void ff_msmpeg4_handle_slices(MpegEncContext *s);
+void ff_msmpeg4_encode_motion(MpegEncContext * s, int mx, int my);
+int ff_msmpeg4_coded_block_pred(MpegEncContext * s, int n,
+                                uint8_t **coded_block_ptr);
+int ff_msmpeg4_decode_motion(MpegEncContext * s, int *mx_ptr, int *my_ptr);
+int ff_msmpeg4_decode_block(MpegEncContext * s, DCTELEM * block,
+                            int n, int coded, const uint8_t *scan_table);
+int ff_wmv2_decode_mb(MpegEncContext *s, DCTELEM block[6][64]);
 
 #define ENABLE_MSMPEG4_DECODER (ENABLE_MSMPEG4V1_DECODER || \
                                 ENABLE_MSMPEG4V2_DECODER || \
@@ -41,4 +62,4 @@
 #define ENABLE_WMV_DECODER (ENABLE_WMV1_DECODER || ENABLE_WMV2_DECODER)
 #define ENABLE_WMV_ENCODER (ENABLE_WMV1_ENCODER || ENABLE_WMV2_ENCODER)
 
-#endif /* MSMPEG4_H */
+#endif /* FFMPEG_MSMPEG4_H */
diff -u mplayer-1.0~rc2-12/libavcodec/msrle.c ffmpeg-free-0.svn20080206/libavcodec/msrle.c
--- mplayer-1.0~rc2-12/libavcodec/msrle.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/msrle.c	2008-03-20 19:10:58.000000000 +0100
@@ -43,7 +43,7 @@
     AVCodecContext *avctx;
     AVFrame frame;
 
-    unsigned char *buf;
+    const unsigned char *buf;
     int size;
 
 } MsrleContext;
@@ -250,7 +250,7 @@
 
 static int msrle_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
-                              uint8_t *buf, int buf_size)
+                              const uint8_t *buf, int buf_size)
 {
     MsrleContext *s = avctx->priv_data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/msvideo1.c ffmpeg-free-0.svn20080206/libavcodec/msvideo1.c
--- mplayer-1.0~rc2-12/libavcodec/msvideo1.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/msvideo1.c	2008-03-20 19:10:59.000000000 +0100
@@ -52,7 +52,7 @@
     DSPContext dsp;
     AVFrame frame;
 
-    unsigned char *buf;
+    const unsigned char *buf;
     int size;
 
     int mode_8bit;  /* if it's not 8-bit, it's 16-bit */
@@ -297,7 +297,7 @@
 
 static int msvideo1_decode_frame(AVCodecContext *avctx,
                                 void *data, int *data_size,
-                                uint8_t *buf, int buf_size)
+                                const uint8_t *buf, int buf_size)
 {
     Msvideo1Context *s = avctx->priv_data;
 
Only in ffmpeg-free-0.svn20080206/libavcodec: nellymoserdec.c
diff -u mplayer-1.0~rc2-12/libavcodec/noise_bsf.c ffmpeg-free-0.svn20080206/libavcodec/noise_bsf.c
--- mplayer-1.0~rc2-12/libavcodec/noise_bsf.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/noise_bsf.c	2008-03-20 19:10:59.000000000 +0100
@@ -24,8 +24,8 @@
 static int noise(AVBitStreamFilterContext *bsfc, AVCodecContext *avctx, const char *args,
                      uint8_t **poutbuf, int *poutbuf_size,
                      const uint8_t *buf, int buf_size, int keyframe){
-    int amount= args ? atoi(args) : 10000;
     unsigned int *state= bsfc->priv_data;
+    int amount= args ? atoi(args) : (*state % 10001+1);
     int i;
 
     *poutbuf= av_malloc(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);
diff -u mplayer-1.0~rc2-12/libavcodec/nuv.c ffmpeg-free-0.svn20080206/libavcodec/nuv.c
--- mplayer-1.0~rc2-12/libavcodec/nuv.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/nuv.c	2008-03-20 19:10:59.000000000 +0100
@@ -69,7 +69,7 @@
  * \param width width of the video frame
  * \param height height of the video frame
  */
-static void copy_frame(AVFrame *f, uint8_t *src,
+static void copy_frame(AVFrame *f, const uint8_t *src,
                        int width, int height) {
     AVPicture pic;
     avpicture_fill(&pic, src, PIX_FMT_YUV420P, width, height);
@@ -80,7 +80,7 @@
  * \brief extract quantization tables from codec data into our context
  */
 static int get_quant(AVCodecContext *avctx, NuvContext *c,
-                     uint8_t *buf, int size) {
+                     const uint8_t *buf, int size) {
     int i;
     if (size < 2 * 64 * 4) {
         av_log(avctx, AV_LOG_ERROR, "insufficient rtjpeg quant data\n");
@@ -129,7 +129,7 @@
 }
 
 static int decode_frame(AVCodecContext *avctx, void *data, int *data_size,
-                        uint8_t *buf, int buf_size) {
+                        const uint8_t *buf, int buf_size) {
     NuvContext *c = avctx->priv_data;
     AVFrame *picture = data;
     int orig_size = buf_size;
diff -u mplayer-1.0~rc2-12/libavcodec/opt.c ffmpeg-free-0.svn20080206/libavcodec/opt.c
--- mplayer-1.0~rc2-12/libavcodec/opt.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/opt.c	2008-03-20 19:10:59.000000000 +0100
@@ -69,6 +69,7 @@
     case FF_OPT_TYPE_RATIONAL:
         if((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};
         else                *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);
+        break;
     default:
         return NULL;
     }
@@ -107,6 +108,13 @@
     0
 };
 
+static int hexchar2int(char c) {
+    if (c >= '0' && c <= '9') return c - '0';
+    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
+    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
+    return -1;
+}
+
 const AVOption *av_set_string(void *obj, const char *name, const char *val){
     const AVOption *o= av_find_opt(obj, name, NULL, 0, 0);
     if(o && o->offset==0 && o->type == FF_OPT_TYPE_CONST && o->unit){
@@ -114,6 +122,29 @@
     }
     if(!o || !val || o->offset<=0)
         return NULL;
+    if(o->type == FF_OPT_TYPE_BINARY){
+        uint8_t **dst = (uint8_t **)(((uint8_t*)obj) + o->offset);
+        int *lendst = (int *)(dst + 1);
+        uint8_t *bin, *ptr;
+        int len = strlen(val);
+        av_freep(dst);
+        *lendst = 0;
+        if (len & 1) return NULL;
+        len /= 2;
+        ptr = bin = av_malloc(len);
+        while (*val) {
+            int a = hexchar2int(*val++);
+            int b = hexchar2int(*val++);
+            if (a < 0 || b < 0) {
+                av_free(bin);
+                return NULL;
+            }
+            *ptr++ = (a << 4) | b;
+        }
+        *dst = bin;
+        *lendst = len;
+        return o;
+    }
     if(o->type != FF_OPT_TYPE_STRING){
         for(;;){
             int i;
@@ -159,7 +190,7 @@
         return NULL;
     }
 
-    memcpy(((uint8_t*)obj) + o->offset, val, sizeof(val));
+    memcpy(((uint8_t*)obj) + o->offset, &val, sizeof(val));
     return o;
 }
 
@@ -183,6 +214,8 @@
 const char *av_get_string(void *obj, const char *name, const AVOption **o_out, char *buf, int buf_len){
     const AVOption *o= av_find_opt(obj, name, NULL, 0, 0);
     void *dst;
+    uint8_t *bin;
+    int len, i;
     if(!o || o->offset<=0)
         return NULL;
     if(o->type != FF_OPT_TYPE_STRING && (!buf || !buf_len))
@@ -191,9 +224,6 @@
     dst= ((uint8_t*)obj) + o->offset;
     if(o_out) *o_out= o;
 
-    if(o->type == FF_OPT_TYPE_STRING)
-        return dst;
-
     switch(o->type){
     case FF_OPT_TYPE_FLAGS:     snprintf(buf, buf_len, "0x%08X",*(int    *)dst);break;
     case FF_OPT_TYPE_INT:       snprintf(buf, buf_len, "%d" , *(int    *)dst);break;
@@ -201,6 +231,13 @@
     case FF_OPT_TYPE_FLOAT:     snprintf(buf, buf_len, "%f" , *(float  *)dst);break;
     case FF_OPT_TYPE_DOUBLE:    snprintf(buf, buf_len, "%f" , *(double *)dst);break;
     case FF_OPT_TYPE_RATIONAL:  snprintf(buf, buf_len, "%d/%d", ((AVRational*)dst)->num, ((AVRational*)dst)->den);break;
+    case FF_OPT_TYPE_STRING:    return *(void**)dst;
+    case FF_OPT_TYPE_BINARY:
+        len = *(int*)(((uint8_t *)dst) + sizeof(uint8_t *));
+        if(len >= (buf_len + 1)/2) return NULL;
+        bin = *(uint8_t**)dst;
+        for(i = 0; i < len; i++) snprintf(buf + i*2, 3, "%02X", bin[i]);
+        break;
     default: return NULL;
     }
     return buf;
@@ -307,6 +344,9 @@
             case FF_OPT_TYPE_RATIONAL:
                 av_log( av_log_obj, AV_LOG_INFO, "%-7s ", "<rational>" );
                 break;
+            case FF_OPT_TYPE_BINARY:
+                av_log( av_log_obj, AV_LOG_INFO, "%-7s ", "<binary>" );
+                break;
             case FF_OPT_TYPE_CONST:
             default:
                 av_log( av_log_obj, AV_LOG_INFO, "%-7s ", "" );
@@ -374,6 +414,7 @@
             }
             break;
             case FF_OPT_TYPE_STRING:
+            case FF_OPT_TYPE_BINARY:
                 /* Cannot set default for string as default_val is of type * double */
             break;
             default:
diff -u mplayer-1.0~rc2-12/libavcodec/opt.h ffmpeg-free-0.svn20080206/libavcodec/opt.h
--- mplayer-1.0~rc2-12/libavcodec/opt.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/opt.h	2007-12-17 18:41:24.000000000 +0100
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVOPT_H
-#define AVOPT_H
+#ifndef FFMPEG_OPT_H
+#define FFMPEG_OPT_H
 
 /**
  * @file opt.h
@@ -37,6 +37,7 @@
     FF_OPT_TYPE_FLOAT,
     FF_OPT_TYPE_STRING,
     FF_OPT_TYPE_RATIONAL,
+    FF_OPT_TYPE_BINARY,  ///< offset must point to a pointer immediately followed by an int for the length
     FF_OPT_TYPE_CONST=128,
 };
 
@@ -84,4 +85,4 @@
 void av_opt_set_defaults(void *s);
 void av_opt_set_defaults2(void *s, int mask, int flags);
 
-#endif
+#endif /* FFMPEG_OPT_H */
diff -u mplayer-1.0~rc2-12/libavcodec/parser.c ffmpeg-free-0.svn20080206/libavcodec/parser.c
--- mplayer-1.0~rc2-12/libavcodec/parser.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/parser.c	2008-03-20 19:10:59.000000000 +0100
@@ -24,6 +24,11 @@
 
 AVCodecParser *av_first_parser = NULL;
 
+AVCodecParser* av_parser_next(AVCodecParser *p){
+    if(p) return p->next;
+    else  return av_first_parser;
+}
+
 void av_register_codec_parser(AVCodecParser *parser)
 {
     parser->next = av_first_parser;
diff -u mplayer-1.0~rc2-12/libavcodec/parser.h ffmpeg-free-0.svn20080206/libavcodec/parser.h
--- mplayer-1.0~rc2-12/libavcodec/parser.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/parser.h	2007-10-17 11:21:52.000000000 +0200
@@ -59,4 +59,4 @@
 void ff_parse_close(AVCodecParserContext *s);
 void ff_parse1_close(AVCodecParserContext *s);
 
-#endif /* !FFMPEG_PARSER_H */
+#endif /* FFMPEG_PARSER_H */
diff -u mplayer-1.0~rc2-12/libavcodec/pcm.c ffmpeg-free-0.svn20080206/libavcodec/pcm.c
--- mplayer-1.0~rc2-12/libavcodec/pcm.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/pcm.c	2008-03-20 19:10:59.000000000 +0100
@@ -28,6 +28,8 @@
 #include "bitstream.h" // for ff_reverse
 #include "bytestream.h"
 
+#define MAX_CHANNELS 64
+
 /* from g711.c by SUN microsystems (unrestricted use) */
 
 #define         SIGN_BIT        (0x80)      /* Sign bit for a A-law byte. */
@@ -353,7 +355,7 @@
  * \param src_len number of bytes in src
  */
 static inline void decode_to16(int bps, int le, int us,
-                               uint8_t **src, short **samples, int src_len)
+                               const uint8_t **src, short **samples, int src_len)
 {
     int usum = us ? -0x8000 : 0;
     register int n = src_len / bps;
@@ -371,12 +373,12 @@
 
 static int pcm_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     PCMDecode *s = avctx->priv_data;
-    int n;
+    int c, n;
     short *samples;
-    uint8_t *src;
+    const uint8_t *src, *src2[MAX_CHANNELS];
 
     samples = data;
     src = buf;
@@ -386,10 +388,18 @@
         av_log(avctx, AV_LOG_ERROR, "invalid PCM packet\n");
         return -1;
     }
+    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){
+        av_log(avctx, AV_LOG_ERROR, "PCM channels out of bounds\n");
+        return -1;
+    }
 
     buf_size= FFMIN(buf_size, *data_size/2);
     *data_size=0;
 
+    n = buf_size/avctx->channels;
+    for(c=0;c<avctx->channels;c++)
+        src2[c] = &src[c*n];
+
     switch(avctx->codec->id) {
     case CODEC_ID_PCM_S32LE:
         decode_to16(4, 1, 0, &src, &samples, buf_size);
@@ -430,6 +440,12 @@
             *samples++ = bytestream_get_le16(&src);
         }
         break;
+    case CODEC_ID_PCM_S16LE_PLANAR:
+        for(n>>=1;n>0;n--)
+            for(c=0;c<avctx->channels;c++)
+                *samples++ = bytestream_get_le16(&src2[c]);
+        src = src2[avctx->channels-1];
+        break;
     case CODEC_ID_PCM_S16BE:
         n = buf_size >> 1;
         for(;n>0;n--) {
@@ -483,7 +499,8 @@
     return src - buf;
 }
 
-#define PCM_CODEC(id, name)                     \
+#ifdef CONFIG_ENCODERS
+#define PCM_ENCODER(id,name)                    \
 AVCodec name ## _encoder = {                    \
     #name,                                      \
     CODEC_TYPE_AUDIO,                           \
@@ -493,7 +510,13 @@
     pcm_encode_frame,                           \
     pcm_encode_close,                           \
     NULL,                                       \
-};                                              \
+};
+#else
+#define PCM_ENCODER(id,name)
+#endif
+
+#ifdef CONFIG_DECODERS
+#define PCM_DECODER(id,name)                    \
 AVCodec name ## _decoder = {                    \
     #name,                                      \
     CODEC_TYPE_AUDIO,                           \
@@ -503,25 +526,30 @@
     NULL,                                       \
     NULL,                                       \
     pcm_decode_frame,                           \
-}
+};
+#else
+#define PCM_DECODER(id,name)
+#endif
 
-PCM_CODEC(CODEC_ID_PCM_S32LE, pcm_s32le);
-PCM_CODEC(CODEC_ID_PCM_S32BE, pcm_s32be);
-PCM_CODEC(CODEC_ID_PCM_U32LE, pcm_u32le);
-PCM_CODEC(CODEC_ID_PCM_U32BE, pcm_u32be);
-PCM_CODEC(CODEC_ID_PCM_S24LE, pcm_s24le);
-PCM_CODEC(CODEC_ID_PCM_S24BE, pcm_s24be);
-PCM_CODEC(CODEC_ID_PCM_U24LE, pcm_u24le);
-PCM_CODEC(CODEC_ID_PCM_U24BE, pcm_u24be);
-PCM_CODEC(CODEC_ID_PCM_S24DAUD, pcm_s24daud);
-PCM_CODEC(CODEC_ID_PCM_S16LE, pcm_s16le);
-PCM_CODEC(CODEC_ID_PCM_S16BE, pcm_s16be);
-PCM_CODEC(CODEC_ID_PCM_U16LE, pcm_u16le);
-PCM_CODEC(CODEC_ID_PCM_U16BE, pcm_u16be);
-PCM_CODEC(CODEC_ID_PCM_S8, pcm_s8);
-PCM_CODEC(CODEC_ID_PCM_U8, pcm_u8);
-PCM_CODEC(CODEC_ID_PCM_ALAW, pcm_alaw);
-PCM_CODEC(CODEC_ID_PCM_MULAW, pcm_mulaw);
-PCM_CODEC(CODEC_ID_PCM_ZORK, pcm_zork);
+#define PCM_CODEC(id, name)                     \
+PCM_ENCODER(id,name) PCM_DECODER(id,name)
 
-#undef PCM_CODEC
+PCM_CODEC  (CODEC_ID_PCM_S32LE, pcm_s32le);
+PCM_CODEC  (CODEC_ID_PCM_S32BE, pcm_s32be);
+PCM_CODEC  (CODEC_ID_PCM_U32LE, pcm_u32le);
+PCM_CODEC  (CODEC_ID_PCM_U32BE, pcm_u32be);
+PCM_CODEC  (CODEC_ID_PCM_S24LE, pcm_s24le);
+PCM_CODEC  (CODEC_ID_PCM_S24BE, pcm_s24be);
+PCM_CODEC  (CODEC_ID_PCM_U24LE, pcm_u24le);
+PCM_CODEC  (CODEC_ID_PCM_U24BE, pcm_u24be);
+PCM_CODEC  (CODEC_ID_PCM_S24DAUD, pcm_s24daud);
+PCM_CODEC  (CODEC_ID_PCM_S16LE, pcm_s16le);
+PCM_DECODER(CODEC_ID_PCM_S16LE_PLANAR, pcm_s16le_planar);
+PCM_CODEC  (CODEC_ID_PCM_S16BE, pcm_s16be);
+PCM_CODEC  (CODEC_ID_PCM_U16LE, pcm_u16le);
+PCM_CODEC  (CODEC_ID_PCM_U16BE, pcm_u16be);
+PCM_CODEC  (CODEC_ID_PCM_S8, pcm_s8);
+PCM_CODEC  (CODEC_ID_PCM_U8, pcm_u8);
+PCM_CODEC  (CODEC_ID_PCM_ALAW, pcm_alaw);
+PCM_CODEC  (CODEC_ID_PCM_MULAW, pcm_mulaw);
+PCM_CODEC  (CODEC_ID_PCM_ZORK, pcm_zork);
Only in ffmpeg-free-0.svn20080206/libavcodec: pcx.c
diff -u mplayer-1.0~rc2-12/libavcodec/pngdec.c ffmpeg-free-0.svn20080206/libavcodec/pngdec.c
--- mplayer-1.0~rc2-12/libavcodec/pngdec.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/pngdec.c	2008-03-20 19:10:59.000000000 +0100
@@ -31,9 +31,9 @@
 //#define DEBUG
 
 typedef struct PNGDecContext {
-    uint8_t *bytestream;
-    uint8_t *bytestream_start;
-    uint8_t *bytestream_end;
+    const uint8_t *bytestream;
+    const uint8_t *bytestream_start;
+    const uint8_t *bytestream_end;
     AVFrame picture;
 
     int state;
@@ -312,7 +312,7 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     PNGDecContext * const s = avctx->priv_data;
     AVFrame *picture = data;
diff -u mplayer-1.0~rc2-12/libavcodec/pngenc.c ffmpeg-free-0.svn20080206/libavcodec/pngenc.c
--- mplayer-1.0~rc2-12/libavcodec/pngenc.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/pngenc.c	2008-03-20 19:10:59.000000000 +0100
@@ -144,6 +144,7 @@
     AVFrame * const p= (AVFrame*)&s->picture;
     int bit_depth, color_type, y, len, row_size, ret, is_progressive;
     int bits_per_pixel, pass_row_size;
+    int compression_level;
     uint8_t *ptr;
     uint8_t *crow_buf = NULL;
     uint8_t *tmp_buf = NULL;
@@ -187,7 +188,10 @@
     s->zstream.zalloc = ff_png_zalloc;
     s->zstream.zfree = ff_png_zfree;
     s->zstream.opaque = NULL;
-    ret = deflateInit2(&s->zstream, Z_DEFAULT_COMPRESSION,
+    compression_level = avctx->compression_level == FF_COMPRESSION_DEFAULT ?
+                            Z_DEFAULT_COMPRESSION :
+                            av_clip(avctx->compression_level, 0, 9);
+    ret = deflateInit2(&s->zstream, compression_level,
                        Z_DEFLATED, 15, 8, Z_DEFAULT_STRATEGY);
     if (ret != Z_OK)
         return -1;
diff -u mplayer-1.0~rc2-12/libavcodec/png.h ffmpeg-free-0.svn20080206/libavcodec/png.h
--- mplayer-1.0~rc2-12/libavcodec/png.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/png.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_PNG_H
-#define AVCODEC_PNG_H
+#ifndef FFMPEG_PNG_H
+#define FFMPEG_PNG_H
 
 #include <stdint.h>
 
@@ -71,4 +71,4 @@
 /* compute the row size of an interleaved pass */
 extern int ff_png_pass_row_size(int pass, int bits_per_pixel, int width);
 
-#endif
+#endif /* FFMPEG_PNG_H */
diff -u mplayer-1.0~rc2-12/libavcodec/pnmenc.c ffmpeg-free-0.svn20080206/libavcodec/pnmenc.c
--- mplayer-1.0~rc2-12/libavcodec/pnmenc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/pnmenc.c	2008-03-20 19:10:59.000000000 +0100
@@ -34,7 +34,7 @@
 
 static int pnm_decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     PNMContext * const s = avctx->priv_data;
     AVFrame *picture = data;
diff -u mplayer-1.0~rc2-12/libavcodec/pnm.h ffmpeg-free-0.svn20080206/libavcodec/pnm.h
--- mplayer-1.0~rc2-12/libavcodec/pnm.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/pnm.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef PNM_H
-#define PNM_H
+#ifndef FFMPEG_PNM_H
+#define FFMPEG_PNM_H
 
 #include "avcodec.h"
 
@@ -34,4 +34,4 @@
 
 int ff_pnm_decode_header(AVCodecContext *avctx, PNMContext * const s);
 
-#endif /* PNM_H */
+#endif /* FFMPEG_PNM_H */
Common subdirectories: mplayer-1.0~rc2-12/libavcodec/ppc and ffmpeg-free-0.svn20080206/libavcodec/ppc
Common subdirectories: mplayer-1.0~rc2-12/libavcodec/ps2 and ffmpeg-free-0.svn20080206/libavcodec/ps2
diff -u mplayer-1.0~rc2-12/libavcodec/ptx.c ffmpeg-free-0.svn20080206/libavcodec/ptx.c
--- mplayer-1.0~rc2-12/libavcodec/ptx.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ptx.c	2008-03-20 19:10:59.000000000 +0100
@@ -28,18 +28,17 @@
 static int ptx_init(AVCodecContext *avctx) {
     PTXContext *s = avctx->priv_data;
 
-    avcodec_get_frame_defaults((AVFrame*)&s->picture);
-    avctx->coded_frame= (AVFrame*)&s->picture;
-    s->picture.data[0] = NULL;
+    avcodec_get_frame_defaults(&s->picture);
+    avctx->coded_frame= &s->picture;
 
     return 0;
 }
 
 static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
-                            uint8_t *buf, int buf_size) {
+                            const uint8_t *buf, int buf_size) {
     PTXContext * const s = avctx->priv_data;
     AVFrame *picture = data;
-    AVFrame * const p = (AVFrame *)&s->picture;
+    AVFrame * const p = &s->picture;
     unsigned int offset, w, h, y, stride, bytes_per_pixel;
     uint8_t *ptr;
 
@@ -89,7 +88,7 @@
         buf += w*bytes_per_pixel;
     }
 
-    *picture = *(AVFrame *)&s->picture;
+    *picture = s->picture;
     *data_size = sizeof(AVPicture);
 
     return offset + w*h*bytes_per_pixel;
diff -u mplayer-1.0~rc2-12/libavcodec/qdm2.c ffmpeg-free-0.svn20080206/libavcodec/qdm2.c
--- mplayer-1.0~rc2-12/libavcodec/qdm2.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/qdm2.c	2008-03-20 19:10:59.000000000 +0100
@@ -97,16 +97,16 @@
 /**
  * A node in the subpacket list
  */
-typedef struct _QDM2SubPNode {
+typedef struct QDM2SubPNode {
     QDM2SubPacket *packet;      ///< packet
-    struct _QDM2SubPNode *next; ///< pointer to next packet in the list, NULL if leaf node
+    struct QDM2SubPNode *next; ///< pointer to next packet in the list, NULL if leaf node
 } QDM2SubPNode;
 
 typedef struct {
     float level;
     float *samples_im;
     float *samples_re;
-    float *table;
+    const float *table;
     int   phase;
     int   phase_shift;
     int   duration;
@@ -176,7 +176,7 @@
     QDM2FFT fft;
 
     /// I/O data
-    uint8_t *compressed_data;
+    const uint8_t *compressed_data;
     int compressed_size;
     float output_buffer[1024];
 
@@ -404,7 +404,7 @@
  *
  * @return          0 if checksum is OK
  */
-static uint16_t qdm2_packet_checksum (uint8_t *data, int length, int value) {
+static uint16_t qdm2_packet_checksum (const uint8_t *data, int length, int value) {
     int i;
 
     for (i=0; i < length; i++)
@@ -1598,7 +1598,7 @@
                     tone.level = (q->fft_coefs[j].exp < 0) ? 0.0 : fft_tone_level_table[q->superblocktype_2_3 ? 0 : 1][q->fft_coefs[j].exp & 63];
                     tone.samples_im = &q->fft.samples_im[ch][offset];
                     tone.samples_re = &q->fft.samples_re[ch][offset];
-                    tone.table = (float*)fft_tone_sample_table[i][q->fft_coefs[j].offset - (offset << four_i)];
+                    tone.table = fft_tone_sample_table[i][q->fft_coefs[j].offset - (offset << four_i)];
                     tone.phase = 64 * q->fft_coefs[j].phase - (offset << 8) - 128;
                     tone.phase_shift = (2 * q->fft_coefs[j].offset + 1) << (7 - four_i);
                     tone.duration = i;
@@ -1943,7 +1943,7 @@
 }
 
 
-static void qdm2_decode (QDM2Context *q, uint8_t *in, int16_t *out)
+static void qdm2_decode (QDM2Context *q, const uint8_t *in, int16_t *out)
 {
     int ch, i;
     const int frame_size = (q->frame_size * q->channels);
@@ -2005,7 +2005,7 @@
 
 static int qdm2_decode_frame(AVCodecContext *avctx,
             void *data, int *data_size,
-            uint8_t *buf, int buf_size)
+            const uint8_t *buf, int buf_size)
 {
     QDM2Context *s = avctx->priv_data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/qdm2data.h ffmpeg-free-0.svn20080206/libavcodec/qdm2data.h
--- mplayer-1.0~rc2-12/libavcodec/qdm2data.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/qdm2data.h	2007-10-17 11:37:46.000000000 +0200
@@ -27,8 +27,8 @@
  * Various QDM2 tables.
  */
 
-#ifndef QDM2DATA_H
-#define QDM2DATA_H
+#ifndef FFMPEG_QDM2DATA_H
+#define FFMPEG_QDM2DATA_H
 
 #include <stdint.h>
 
@@ -528,4 +528,4 @@
     0.138071194291115f,0.333333343267441f,0.60947573184967f,1.0f,0.0f,
 };
 
-#endif /* QDM2DATA_H */
+#endif /* FFMPEG_QDM2DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/qdrw.c ffmpeg-free-0.svn20080206/libavcodec/qdrw.c
--- mplayer-1.0~rc2-12/libavcodec/qdrw.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/qdrw.c	2008-03-20 19:10:59.000000000 +0100
@@ -34,7 +34,7 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     QdrawContext * const a = avctx->priv_data;
     AVFrame * const p= (AVFrame*)&a->pic;
@@ -90,7 +90,7 @@
     buf += 18; /* skip unneeded data */
     for (i = 0; i < avctx->height; i++) {
         int size, left, code, pix;
-        uint8_t *next;
+        const uint8_t *next;
         uint8_t *out;
         int tsize = 0;
 
diff -u mplayer-1.0~rc2-12/libavcodec/qpeg.c ffmpeg-free-0.svn20080206/libavcodec/qpeg.c
--- mplayer-1.0~rc2-12/libavcodec/qpeg.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/qpeg.c	2008-03-20 19:10:59.000000000 +0100
@@ -33,7 +33,7 @@
     uint8_t *refdata;
 } QpegContext;
 
-static void qpeg_decode_intra(uint8_t *src, uint8_t *dst, int size,
+static void qpeg_decode_intra(const uint8_t *src, uint8_t *dst, int size,
                             int stride, int width, int height)
 {
     int i;
@@ -115,9 +115,9 @@
  { 0x00, 0x20, 0x18, 0x08, 0x18, 0x10, 0x20, 0x10, 0x08, 0x10, 0x20, 0x20, 0x08, 0x10, 0x18, 0x04};
 
 /* Decodes delta frames */
-static void qpeg_decode_inter(uint8_t *src, uint8_t *dst, int size,
+static void qpeg_decode_inter(const uint8_t *src, uint8_t *dst, int size,
                             int stride, int width, int height,
-                            int delta, uint8_t *ctable, uint8_t *refdata)
+                            int delta, const uint8_t *ctable, uint8_t *refdata)
 {
     int i, j;
     int code;
@@ -249,7 +249,7 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     QpegContext * const a = avctx->priv_data;
     AVFrame * const p= (AVFrame*)&a->pic;
diff -u mplayer-1.0~rc2-12/libavcodec/qtrle.c ffmpeg-free-0.svn20080206/libavcodec/qtrle.c
--- mplayer-1.0~rc2-12/libavcodec/qtrle.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/qtrle.c	2008-03-20 19:10:59.000000000 +0100
@@ -45,7 +45,7 @@
     DSPContext dsp;
     AVFrame frame;
 
-    unsigned char *buf;
+    const unsigned char *buf;
     int size;
 
 } QtrleContext;
@@ -530,7 +530,7 @@
 
 static int qtrle_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
-                              uint8_t *buf, int buf_size)
+                              const uint8_t *buf, int buf_size)
 {
     QtrleContext *s = avctx->priv_data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/qtrleenc.c ffmpeg-free-0.svn20080206/libavcodec/qtrleenc.c
--- mplayer-1.0~rc2-12/libavcodec/qtrleenc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/qtrleenc.c	2008-03-20 19:10:59.000000000 +0100
@@ -254,7 +254,7 @@
 
     bytestream_put_be32(&buf, 0);                         // CHUNK SIZE, patched later
 
-    if (start_line == 0 && end_line == s->avctx->height || start_line == s->avctx->height)
+    if ((start_line == 0 && end_line == s->avctx->height) || start_line == s->avctx->height)
         bytestream_put_be16(&buf, 0);                     // header
     else {
         bytestream_put_be16(&buf, 8);                     // header
diff -u mplayer-1.0~rc2-12/libavcodec/ra144.c ffmpeg-free-0.svn20080206/libavcodec/ra144.c
--- mplayer-1.0~rc2-12/libavcodec/ra144.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ra144.c	2008-03-20 19:10:59.000000000 +0100
@@ -251,7 +251,7 @@
 }
 
 /* Decode 20-byte input */
-static void unpack_input(unsigned char *input, unsigned int *output)
+static void unpack_input(const unsigned char *input, unsigned int *output)
 {
   unsigned int outbuffer[28];
   unsigned short inbuffer[10];
@@ -427,7 +427,7 @@
 /* Uncompress one block (20 bytes -> 160*2 bytes) */
 static int ra144_decode_frame(AVCodecContext * avctx,
             void *vdata, int *data_size,
-            uint8_t * buf, int buf_size)
+            const uint8_t * buf, int buf_size)
 {
   unsigned int a,b,c;
   signed short *shptr;
diff -u mplayer-1.0~rc2-12/libavcodec/ra144.h ffmpeg-free-0.svn20080206/libavcodec/ra144.h
--- mplayer-1.0~rc2-12/libavcodec/ra144.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ra144.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef RA144TABLES_H
-#define RA144TABLES_H
+#ifndef FFMPEG_RA144_H
+#define FFMPEG_RA144_H
 
 /* 14.4 data tables */
 static const unsigned short sqrt_table[4096]={
@@ -2425,4 +2425,4 @@
 decodetable6,decodetable7,decodetable8,decodetable9,decodetable10,
 decodetable11};
 
-#endif /* RA144TABLES_H */
+#endif /* FFMPEG_RA144_H */
diff -u mplayer-1.0~rc2-12/libavcodec/ra288.c ffmpeg-free-0.svn20080206/libavcodec/ra288.c
--- mplayer-1.0~rc2-12/libavcodec/ra288.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ra288.c	2008-03-20 19:10:59.000000000 +0100
@@ -49,7 +49,7 @@
 
 
 /* initial decode */
-static void unpack(unsigned short *tgt, unsigned char *src, unsigned int len)
+static void unpack(unsigned short *tgt, const unsigned char *src, unsigned int len)
 {
   int x,y,z;
   int n,temp;
@@ -208,7 +208,7 @@
   }
 }
 
-static void * decode_block(AVCodecContext * avctx, unsigned char *in, signed short int *out,unsigned len)
+static void * decode_block(AVCodecContext * avctx, const unsigned char *in, signed short int *out,unsigned len)
 {
   int x,y;
   Real288_internal *glob=avctx->priv_data;
@@ -228,7 +228,7 @@
 /* Decode a block (celp) */
 static int ra288_decode_frame(AVCodecContext * avctx,
             void *data, int *data_size,
-            uint8_t * buf, int buf_size)
+            const uint8_t * buf, int buf_size)
 {
     void *datao;
 
diff -u mplayer-1.0~rc2-12/libavcodec/ra288.h ffmpeg-free-0.svn20080206/libavcodec/ra288.h
--- mplayer-1.0~rc2-12/libavcodec/ra288.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ra288.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef RA288TABLES_H
-#define RA288TABLES_H
+#ifndef FFMPEG_RA288_H
+#define FFMPEG_RA288_H
 
 static const float amptable[8]={ 0.515625, 0.90234375, 1.57910156, 2.76342773,
                          -0.515625,-0.90234375,-1.57910156,-2.76342773 };
@@ -202,4 +202,4 @@
         0.553955078,        0.50201416,        0.454956055,        0.41229248,        0.373657227
 };
 
-#endif /* RA288TABLES_H */
+#endif /* FFMPEG_RA288_H */
diff -u mplayer-1.0~rc2-12/libavcodec/rangecoder.c ffmpeg-free-0.svn20080206/libavcodec/rangecoder.c
--- mplayer-1.0~rc2-12/libavcodec/rangecoder.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/rangecoder.c	2008-03-20 19:10:59.000000000 +0100
@@ -109,9 +109,10 @@
     return c->bytestream - c->bytestream_start;
 }
 
-#if 0 //selftest
+#ifdef TEST
 #define SIZE 10240
-int main(){
+#undef random
+int main(void){
     RangeCoder c;
     uint8_t b[9*SIZE];
     uint8_t r[9*SIZE];
@@ -133,7 +134,7 @@
 STOP_TIMER("put_rac")
     }
 
-    ff_put_rac_terminate(&c);
+    ff_rac_terminate(&c);
 
     ff_init_range_decoder(&c, b, SIZE);
 
@@ -148,4 +149,4 @@
 
     return 0;
 }
-#endif
+#endif /* TEST */
diff -u mplayer-1.0~rc2-12/libavcodec/rangecoder.h ffmpeg-free-0.svn20080206/libavcodec/rangecoder.h
--- mplayer-1.0~rc2-12/libavcodec/rangecoder.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/rangecoder.h	2007-10-17 11:37:46.000000000 +0200
@@ -24,8 +24,8 @@
  * Range coder.
  */
 
-#ifndef AVCODEC_RANGECODER_H
-#define AVCODEC_RANGECODER_H
+#ifndef FFMPEG_RANGECODER_H
+#define FFMPEG_RANGECODER_H
 
 #include <stdint.h>
 #include <assert.h>
@@ -138,4 +138,4 @@
 #endif
 }
 
-#endif // AVCODEC_RANGECODER_H
+#endif /* FFMPEG_RANGECODER_H */
diff -u mplayer-1.0~rc2-12/libavcodec/ratecontrol.c ffmpeg-free-0.svn20080206/libavcodec/ratecontrol.c
--- mplayer-1.0~rc2-12/libavcodec/ratecontrol.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ratecontrol.c	2008-03-20 19:10:59.000000000 +0100
@@ -138,7 +138,7 @@
         i+= s->max_b_frames;
         if(i<=0 || i>=INT_MAX / sizeof(RateControlEntry))
             return -1;
-        rcc->entry = (RateControlEntry*)av_mallocz(i*sizeof(RateControlEntry));
+        rcc->entry = av_mallocz(i*sizeof(RateControlEntry));
         rcc->num_entries= i;
 
         /* init all to skipped p frames (with b frames we might have a not encoded frame at the end FIXME) */
diff -u mplayer-1.0~rc2-12/libavcodec/ratecontrol.h ffmpeg-free-0.svn20080206/libavcodec/ratecontrol.h
--- mplayer-1.0~rc2-12/libavcodec/ratecontrol.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ratecontrol.h	2007-10-17 11:37:46.000000000 +0200
@@ -20,8 +20,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_RATECONTROL_H
-#define AVCODEC_RATECONTROL_H
+#ifndef FFMPEG_RATECONTROL_H
+#define FFMPEG_RATECONTROL_H
 
 /**
  * @file ratecontrol.h
@@ -101,5 +101,5 @@
 void ff_xvid_rate_control_uninit(struct MpegEncContext *s);
 float ff_xvid_rate_estimate_qscale(struct MpegEncContext *s, int dry_run);
 
-#endif /* AVCODEC_RATECONTROL_H */
+#endif /* FFMPEG_RATECONTROL_H */
 
diff -u mplayer-1.0~rc2-12/libavcodec/rawdec.c ffmpeg-free-0.svn20080206/libavcodec/rawdec.c
--- mplayer-1.0~rc2-12/libavcodec/rawdec.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/rawdec.c	2008-03-20 19:10:59.000000000 +0100
@@ -96,7 +96,7 @@
 
 static int raw_decode(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     RawVideoContext *context = avctx->priv_data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/raw.h ffmpeg-free-0.svn20080206/libavcodec/raw.h
--- mplayer-1.0~rc2-12/libavcodec/raw.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/raw.h	2007-10-17 11:37:46.000000000 +0200
@@ -24,8 +24,8 @@
  * Raw Video Codec
  */
 
-#ifndef AVCODEC_RAW_H
-#define AVCODEC_RAW_H
+#ifndef FFMPEG_RAW_H
+#define FFMPEG_RAW_H
 
 #include "avcodec.h"
 
@@ -36,4 +36,4 @@
 
 extern const PixelFormatTag ff_raw_pixelFormatTags[];
 
-#endif /* AVCODEC_RAW_H */
+#endif /* FFMPEG_RAW_H */
Only in ffmpeg-free-0.svn20080206/libavcodec: rectangle.h
diff -u mplayer-1.0~rc2-12/libavcodec/resample.c ffmpeg-free-0.svn20080206/libavcodec/resample.c
--- mplayer-1.0~rc2-12/libavcodec/resample.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/resample.c	2008-03-20 19:10:59.000000000 +0100
@@ -133,14 +133,14 @@
 
     if ( input_channels > 2)
       {
-        av_log(NULL, AV_LOG_ERROR, "Resampling with input channels greater than 2 unsupported.");
+        av_log(NULL, AV_LOG_ERROR, "Resampling with input channels greater than 2 unsupported.\n");
         return NULL;
       }
 
     s = av_mallocz(sizeof(ReSampleContext));
     if (!s)
       {
-        av_log(NULL, AV_LOG_ERROR, "Can't allocate memory for resample context.");
+        av_log(NULL, AV_LOG_ERROR, "Can't allocate memory for resample context.\n");
         return NULL;
       }
 
@@ -185,15 +185,15 @@
 
     /* XXX: move those malloc to resample init code */
     for(i=0; i<s->filter_channels; i++){
-        bufin[i]= (short*) av_malloc( (nb_samples + s->temp_len) * sizeof(short) );
+        bufin[i]= av_malloc( (nb_samples + s->temp_len) * sizeof(short) );
         memcpy(bufin[i], s->temp[i], s->temp_len * sizeof(short));
         buftmp2[i] = bufin[i] + s->temp_len;
     }
 
     /* make some zoom to avoid round pb */
-    lenout= (int)(4*nb_samples * s->ratio) + 16;
-    bufout[0]= (short*) av_malloc( lenout * sizeof(short) );
-    bufout[1]= (short*) av_malloc( lenout * sizeof(short) );
+    lenout= 4*nb_samples * s->ratio + 16;
+    bufout[0]= av_malloc( lenout * sizeof(short) );
+    bufout[1]= av_malloc( lenout * sizeof(short) );
 
     if (s->input_channels == 2 &&
         s->output_channels == 1) {
diff -u mplayer-1.0~rc2-12/libavcodec/rle.h ffmpeg-free-0.svn20080206/libavcodec/rle.h
--- mplayer-1.0~rc2-12/libavcodec/rle.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/rle.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef RLE_H
-#define RLE_H
+#ifndef FFMPEG_RLE_H
+#define FFMPEG_RLE_H
 
 #include <stdint.h>
 
@@ -36,4 +36,4 @@
 int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *inbuf, int bpp, int w,
                   int add_rep, int xor_rep, int add_raw, int xor_raw);
 
-#endif /* RLE_H */
+#endif /* FFMPEG_RLE_H */
diff -u mplayer-1.0~rc2-12/libavcodec/rl.h ffmpeg-free-0.svn20080206/libavcodec/rl.h
--- mplayer-1.0~rc2-12/libavcodec/rl.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/rl.h	2007-10-17 11:37:46.000000000 +0200
@@ -24,8 +24,8 @@
  * rl header.
  */
 
-#ifndef AVCODEC_RL_H
-#define AVCODEC_RL_H
+#ifndef FFMPEG_RL_H
+#define FFMPEG_RL_H
 
 #include <stdint.h>
 #include "bitstream.h"
@@ -64,4 +64,4 @@
     return index + level - 1;
 }
 
-#endif
+#endif /* FFMPEG_RL_H */
diff -u mplayer-1.0~rc2-12/libavcodec/roqvideodec.c ffmpeg-free-0.svn20080206/libavcodec/roqvideodec.c
--- mplayer-1.0~rc2-12/libavcodec/roqvideodec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/roqvideodec.c	2008-03-20 19:10:59.000000000 +0100
@@ -43,8 +43,8 @@
     int vqid, bpos, xpos, ypos, xp, yp, x, y, mx, my;
     int frame_stats[2][4] = {{0},{0}};
     roq_qcell *qcell;
-    unsigned char *buf = ri->buf;
-    unsigned char *buf_end = ri->buf + ri->size;
+    const unsigned char *buf = ri->buf;
+    const unsigned char *buf_end = ri->buf + ri->size;
 
     while (buf < buf_end) {
         chunk_id = bytestream_get_le16(&buf);
@@ -171,7 +171,7 @@
 
 static int roq_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     RoqContext *s = avctx->priv_data;
     int copy= !s->current_frame->data[0];
diff -u mplayer-1.0~rc2-12/libavcodec/roqvideo.h ffmpeg-free-0.svn20080206/libavcodec/roqvideo.h
--- mplayer-1.0~rc2-12/libavcodec/roqvideo.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/roqvideo.h	2008-02-02 22:55:56.000000000 +0100
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_ROQVIDEO_H
-#define AVCODEC_ROQVIDEO_H
+#ifndef FFMPEG_ROQVIDEO_H
+#define FFMPEG_ROQVIDEO_H
 
 #include "avcodec.h"
 #include "dsputil.h"
@@ -51,7 +51,7 @@
     roq_cell cb2x2[256];
     roq_qcell cb4x4[256];
 
-    unsigned char *buf;
+    const unsigned char *buf;
     int size;
     int width, height;
 
@@ -89,4 +89,4 @@
 
 void ff_apply_motion_8x8(RoqContext *ri, int x, int y, int deltax, int deltay);
 
-#endif // AVCODEC_ROQVIDEO_H
+#endif /* FFMPEG_ROQVIDEO_H */
diff -u mplayer-1.0~rc2-12/libavcodec/rpza.c ffmpeg-free-0.svn20080206/libavcodec/rpza.c
--- mplayer-1.0~rc2-12/libavcodec/rpza.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/rpza.c	2008-03-20 19:10:59.000000000 +0100
@@ -48,7 +48,7 @@
     DSPContext dsp;
     AVFrame frame;
 
-    unsigned char *buf;
+    const unsigned char *buf;
     int size;
 
 } RpzaContext;
@@ -243,7 +243,7 @@
 
 static int rpza_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     RpzaContext *s = avctx->priv_data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/rtjpeg.c ffmpeg-free-0.svn20080206/libavcodec/rtjpeg.c
--- mplayer-1.0~rc2-12/libavcodec/rtjpeg.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/rtjpeg.c	2008-03-20 19:10:59.000000000 +0100
@@ -43,8 +43,8 @@
  * aligned this could be done faster in a different way, e.g. as it is done
  * in MPlayer libmpcodecs/native/RTjpegN.c
  */
-static inline int get_block(GetBitContext *gb, DCTELEM *block, uint8_t *scan,
-                            uint32_t *quant) {
+static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,
+                            const uint32_t *quant) {
     int coeff, i, n;
     int8_t ac;
     uint8_t dc = get_bits(gb, 8);
@@ -97,7 +97,7 @@
  * \return number of bytes consumed from the input buffer
  */
 int rtjpeg_decode_frame_yuv420(RTJpegContext *c, AVFrame *f,
-                               uint8_t *buf, int buf_size) {
+                               const uint8_t *buf, int buf_size) {
     DECLARE_ALIGNED_16(DCTELEM, block[64]);
     GetBitContext gb;
     int w = c->w / 16, h = c->h / 16;
@@ -147,7 +147,7 @@
  */
 void rtjpeg_decode_init(RTJpegContext *c, DSPContext *dsp,
                         int width, int height,
-                        uint32_t *lquant, uint32_t *cquant) {
+                        const uint32_t *lquant, const uint32_t *cquant) {
     int i;
     c->dsp = dsp;
     for (i = 0; i < 64; i++) {
diff -u mplayer-1.0~rc2-12/libavcodec/rtjpeg.h ffmpeg-free-0.svn20080206/libavcodec/rtjpeg.h
--- mplayer-1.0~rc2-12/libavcodec/rtjpeg.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/rtjpeg.h	2008-02-01 17:20:27.000000000 +0100
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef RTJPEG_H
-#define RTJPEG_H
+#ifndef FFMPEG_RTJPEG_H
+#define FFMPEG_RTJPEG_H
 
 #include <stdint.h>
 #include <dsputil.h>
@@ -35,8 +35,8 @@
 
 void rtjpeg_decode_init(RTJpegContext *c, DSPContext *dsp,
                         int width, int height,
-                        uint32_t *lquant, uint32_t *cquant);
+                        const uint32_t *lquant, const uint32_t *cquant);
 
 int rtjpeg_decode_frame_yuv420(RTJpegContext *c, AVFrame *f,
-                               uint8_t *buf, int buf_size);
-#endif
+                               const uint8_t *buf, int buf_size);
+#endif /* FFMPEG_RTJPEG_H */
diff -u mplayer-1.0~rc2-12/libavcodec/rv10.c ffmpeg-free-0.svn20080206/libavcodec/rv10.c
--- mplayer-1.0~rc2-12/libavcodec/rv10.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/rv10.c	2008-03-20 19:10:59.000000000 +0100
@@ -597,7 +597,7 @@
 }
 
 static int rv10_decode_packet(AVCodecContext *avctx,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     MpegEncContext *s = avctx->priv_data;
     int mb_count, mb_pos, left, start_mb_x;
@@ -711,13 +711,21 @@
     return buf_size;
 }
 
+static int get_slice_offset(AVCodecContext *avctx, const uint8_t *buf, int n)
+{
+    if(avctx->slice_count) return avctx->slice_offset[n];
+    else                   return AV_RL32(buf + n*8);
+}
+
 static int rv10_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     MpegEncContext *s = avctx->priv_data;
     int i;
     AVFrame *pict = data;
+    int slice_count;
+    const uint8_t *slices_hdr = NULL;
 
 #ifdef DEBUG
     av_log(avctx, AV_LOG_DEBUG, "*****frame %d size=%d\n", avctx->frame_number, buf_size);
@@ -728,20 +736,23 @@
         return 0;
     }
 
-    if(avctx->slice_count){
-        for(i=0; i<avctx->slice_count; i++){
-            int offset= avctx->slice_offset[i];
-            int size;
-
-            if(i+1 == avctx->slice_count)
-                size= buf_size - offset;
-            else
-                size= avctx->slice_offset[i+1] - offset;
+    if(!avctx->slice_count){
+        slice_count = (*buf++) + 1;
+        slices_hdr = buf + 4;
+        buf += 8 * slice_count;
+    }else
+        slice_count = avctx->slice_count;
+
+    for(i=0; i<slice_count; i++){
+        int offset= get_slice_offset(avctx, slices_hdr, i);
+        int size;
+
+        if(i+1 == slice_count)
+            size= buf_size - offset;
+        else
+            size= get_slice_offset(avctx, slices_hdr, i+1) - offset;
 
-            rv10_decode_packet(avctx, buf+offset, size);
-        }
-    }else{
-        rv10_decode_packet(avctx, buf, buf_size);
+        rv10_decode_packet(avctx, buf+offset, size);
     }
 
     if(s->current_picture_ptr != NULL && s->mb_y>=s->mb_height){
Only in ffmpeg-free-0.svn20080206/libavcodec: rv30.c
Only in ffmpeg-free-0.svn20080206/libavcodec: rv30data.h
Only in ffmpeg-free-0.svn20080206/libavcodec: rv30dsp.c
Only in ffmpeg-free-0.svn20080206/libavcodec: rv34.c
Only in ffmpeg-free-0.svn20080206/libavcodec: rv34data.h
Only in ffmpeg-free-0.svn20080206/libavcodec: rv34.h
Only in ffmpeg-free-0.svn20080206/libavcodec: rv34vlc.h
Only in ffmpeg-free-0.svn20080206/libavcodec: rv40.c
Only in ffmpeg-free-0.svn20080206/libavcodec: rv40data.h
Only in ffmpeg-free-0.svn20080206/libavcodec: rv40vlc2.h
diff -u mplayer-1.0~rc2-12/libavcodec/s3tc.c ffmpeg-free-0.svn20080206/libavcodec/s3tc.c
--- mplayer-1.0~rc2-12/libavcodec/s3tc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/s3tc.c	2008-03-20 19:10:59.000000000 +0100
@@ -31,8 +31,8 @@
     unsigned int rb0, rb1, rb2, rb3, g0, g1, g2, g3;
     uint32_t colors[4], pixels;
 
-    c0 = le2me_16(*(uint16_t *)(s));
-    c1 = le2me_16(*(uint16_t *)(s+2));
+    c0 = AV_RL16(s);
+    c1 = AV_RL16(s+2);
 
     rb0  = (c0<<3 | c0<<8) & 0xf800f8;
     rb1  = (c1<<3 | c1<<8) & 0xf800f8;
@@ -60,7 +60,7 @@
 
     colors[2] = rb2 + g2 + a;
 
-    pixels = le2me_32(*(uint32_t *)(s+4));
+    pixels = AV_RL32(s+4);
     for (y=0; y<4; y++) {
         for (x=0; x<4; x++) {
             a        = (alpha & 0x0f) << 28;
diff -u mplayer-1.0~rc2-12/libavcodec/s3tc.h ffmpeg-free-0.svn20080206/libavcodec/s3tc.h
--- mplayer-1.0~rc2-12/libavcodec/s3tc.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/s3tc.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef FF_S3TC_H
-#define FF_S3TC_H
+#ifndef FFMPEG_S3TC_H
+#define FFMPEG_S3TC_H
 
 #include <stdint.h>
 
@@ -50,4 +50,4 @@
                     const unsigned int w, const unsigned int h,
                     const unsigned int stride);
 
-#endif
+#endif /* FFMPEG_S3TC_H */
diff -u mplayer-1.0~rc2-12/libavcodec/sgidec.c ffmpeg-free-0.svn20080206/libavcodec/sgidec.c
--- mplayer-1.0~rc2-12/libavcodec/sgidec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/sgidec.c	2008-03-20 19:10:59.000000000 +0100
@@ -40,7 +40,7 @@
  * @param pixelstride pixel stride of input buffer
  * @return size of output in bytes, -1 if buffer overflows
  */
-static int expand_rle_row(uint8_t *in_buf, uint8_t* in_end,
+static int expand_rle_row(const uint8_t *in_buf, const uint8_t* in_end,
             unsigned char *out_buf, uint8_t* out_end, int pixelstride)
 {
     unsigned char pixel, count;
@@ -80,12 +80,12 @@
  * @param s the current image state
  * @return 0 if no error, else return error number.
  */
-static int read_rle_sgi(unsigned char* out_buf, uint8_t *in_buf,
-                        uint8_t *in_end, SgiState* s)
+static int read_rle_sgi(unsigned char* out_buf, const uint8_t *in_buf,
+                        const uint8_t *in_end, SgiState* s)
 {
     uint8_t *dest_row;
     unsigned int len = s->height * s->depth * 4;
-    uint8_t *start_table = in_buf;
+    const uint8_t *start_table = in_buf;
     unsigned int y, z;
     unsigned int start_offset;
 
@@ -121,10 +121,10 @@
  * @return 0 if read success, otherwise return -1.
  */
 static int read_uncompressed_sgi(unsigned char* out_buf, uint8_t* out_end,
-                uint8_t *in_buf, uint8_t *in_end, SgiState* s)
+                const uint8_t *in_buf, const uint8_t *in_end, SgiState* s)
 {
     int x, y, z;
-    uint8_t *ptr;
+    const uint8_t *ptr;
     unsigned int offset = s->height * s->width;
 
     /* Test buffer size. */
@@ -147,12 +147,12 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *in_buf, int buf_size)
+                        const uint8_t *in_buf, int buf_size)
 {
     SgiState *s = avctx->priv_data;
     AVFrame *picture = data;
     AVFrame *p = &s->picture;
-    uint8_t *in_end = in_buf + buf_size;
+    const uint8_t *in_end = in_buf + buf_size;
     unsigned int dimension, bytes_per_channel, rle;
     int ret = 0;
     uint8_t *out_buf, *out_end;
diff -u mplayer-1.0~rc2-12/libavcodec/sgi.h ffmpeg-free-0.svn20080206/libavcodec/sgi.h
--- mplayer-1.0~rc2-12/libavcodec/sgi.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/sgi.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef SGI_H
-#define SGI_H
+#ifndef FFMPEG_SGI_H
+#define FFMPEG_SGI_H
 
 /**
  * SGI image file signature
@@ -33,5 +33,4 @@
 #define SGI_RGB 3
 #define SGI_RGBA 4
 
-#endif
-
+#endif /* FFMPEG_SGI_H */
Common subdirectories: mplayer-1.0~rc2-12/libavcodec/sh4 and ffmpeg-free-0.svn20080206/libavcodec/sh4
diff -u mplayer-1.0~rc2-12/libavcodec/shorten.c ffmpeg-free-0.svn20080206/libavcodec/shorten.c
--- mplayer-1.0~rc2-12/libavcodec/shorten.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/shorten.c	2008-03-20 19:10:59.000000000 +0100
@@ -268,7 +268,7 @@
 
 static int shorten_decode_frame(AVCodecContext *avctx,
         void *data, int *data_size,
-        uint8_t *buf, int buf_size)
+        const uint8_t *buf, int buf_size)
 {
     ShortenContext *s = avctx->priv_data;
     int i, input_buf_size = 0;
@@ -345,7 +345,7 @@
             s->lpcqoffset = V2LPCQOFFSET;
 
         if (get_ur_golomb_shorten(&s->gb, FNSIZE) != FN_VERBATIM) {
-            av_log(s->avctx, AV_LOG_ERROR, "missing verbatim section at begining of stream\n");
+            av_log(s->avctx, AV_LOG_ERROR, "missing verbatim section at beginning of stream\n");
             return -1;
         }
 
diff -u mplayer-1.0~rc2-12/libavcodec/simple_idct.c ffmpeg-free-0.svn20080206/libavcodec/simple_idct.c
--- mplayer-1.0~rc2-12/libavcodec/simple_idct.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/simple_idct.c	2008-03-20 19:10:59.000000000 +0100
@@ -387,7 +387,7 @@
         col[56] = ((a0 - b0) >> COL_SHIFT);
 }
 
-void simple_idct_put(uint8_t *dest, int line_size, DCTELEM *block)
+void ff_simple_idct_put(uint8_t *dest, int line_size, DCTELEM *block)
 {
     int i;
     for(i=0; i<8; i++)
@@ -397,7 +397,7 @@
         idctSparseColPut(dest + i, line_size, block + i);
 }
 
-void simple_idct_add(uint8_t *dest, int line_size, DCTELEM *block)
+void ff_simple_idct_add(uint8_t *dest, int line_size, DCTELEM *block)
 {
     int i;
     for(i=0; i<8; i++)
@@ -407,7 +407,7 @@
         idctSparseColAdd(dest + i, line_size, block + i);
 }
 
-void simple_idct(DCTELEM *block)
+void ff_simple_idct(DCTELEM *block)
 {
     int i;
     for(i=0; i<8; i++)
@@ -428,7 +428,7 @@
    and the butterfly must be multiplied by 0.5 * sqrt(2.0) */
 #define C_SHIFT (4+1+12)
 
-static inline void idct4col(uint8_t *dest, int line_size, const DCTELEM *col)
+static inline void idct4col_put(uint8_t *dest, int line_size, const DCTELEM *col)
 {
     int c0, c1, c2, c3, a0, a1, a2, a3;
     const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
@@ -465,7 +465,7 @@
 /* XXX: I think a 1.0/sqrt(2) normalization should be needed to
    compensate the extra butterfly stage - I don't have the full DV
    specification */
-void simple_idct248_put(uint8_t *dest, int line_size, DCTELEM *block)
+void ff_simple_idct248_put(uint8_t *dest, int line_size, DCTELEM *block)
 {
     int i;
     DCTELEM *ptr;
@@ -491,8 +491,8 @@
 
     /* IDCT4 and store */
     for(i=0;i<8;i++) {
-        idct4col(dest + i, 2 * line_size, block + i);
-        idct4col(dest + line_size + i, 2 * line_size, block + 8 + i);
+        idct4col_put(dest + i, 2 * line_size, block + i);
+        idct4col_put(dest + line_size + i, 2 * line_size, block + 8 + i);
     }
 }
 
@@ -555,7 +555,7 @@
     row[3]= (c0 - c1) >> R_SHIFT;
 }
 
-void simple_idct84_add(uint8_t *dest, int line_size, DCTELEM *block)
+void ff_simple_idct84_add(uint8_t *dest, int line_size, DCTELEM *block)
 {
     int i;
 
@@ -570,7 +570,7 @@
     }
 }
 
-void simple_idct48_add(uint8_t *dest, int line_size, DCTELEM *block)
+void ff_simple_idct48_add(uint8_t *dest, int line_size, DCTELEM *block)
 {
     int i;
 
@@ -585,3 +585,17 @@
     }
 }
 
+void ff_simple_idct44_add(uint8_t *dest, int line_size, DCTELEM *block)
+{
+    int i;
+
+    /* IDCT4 on each line */
+    for(i=0; i<4; i++) {
+        idct4row(block + i*8);
+    }
+
+    /* IDCT4 and store */
+    for(i=0; i<4; i++){
+        idct4col_add(dest + i, line_size, block + i);
+    }
+}
diff -u mplayer-1.0~rc2-12/libavcodec/simple_idct.h ffmpeg-free-0.svn20080206/libavcodec/simple_idct.h
--- mplayer-1.0~rc2-12/libavcodec/simple_idct.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/simple_idct.h	2007-12-09 06:54:59.000000000 +0100
@@ -25,22 +25,23 @@
  * simple idct header.
  */
 
-#ifndef AVCODEC_SIMPLE_IDCT_H
-#define AVCODEC_SIMPLE_IDCT_H
+#ifndef FFMPEG_SIMPLE_IDCT_H
+#define FFMPEG_SIMPLE_IDCT_H
 
 #include <stdint.h>
 #include "dsputil.h"
 
-void simple_idct_put(uint8_t *dest, int line_size, DCTELEM *block);
-void simple_idct_add(uint8_t *dest, int line_size, DCTELEM *block);
+void ff_simple_idct_put(uint8_t *dest, int line_size, DCTELEM *block);
+void ff_simple_idct_add(uint8_t *dest, int line_size, DCTELEM *block);
 void ff_simple_idct_mmx(int16_t *block);
 void ff_simple_idct_add_mmx(uint8_t *dest, int line_size, int16_t *block);
 void ff_simple_idct_put_mmx(uint8_t *dest, int line_size, int16_t *block);
-void simple_idct(DCTELEM *block);
+void ff_simple_idct(DCTELEM *block);
 
-void simple_idct248_put(uint8_t *dest, int line_size, DCTELEM *block);
+void ff_simple_idct248_put(uint8_t *dest, int line_size, DCTELEM *block);
 
-void simple_idct84_add(uint8_t *dest, int line_size, DCTELEM *block);
-void simple_idct48_add(uint8_t *dest, int line_size, DCTELEM *block);
+void ff_simple_idct84_add(uint8_t *dest, int line_size, DCTELEM *block);
+void ff_simple_idct48_add(uint8_t *dest, int line_size, DCTELEM *block);
+void ff_simple_idct44_add(uint8_t *dest, int line_size, DCTELEM *block);
 
-#endif // AVCODEC_SIMPLE_IDCT_H
+#endif /* FFMPEG_SIMPLE_IDCT_H */
diff -u mplayer-1.0~rc2-12/libavcodec/smacker.c ffmpeg-free-0.svn20080206/libavcodec/smacker.c
--- mplayer-1.0~rc2-12/libavcodec/smacker.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/smacker.c	2008-03-20 19:10:59.000000000 +0100
@@ -35,6 +35,7 @@
 
 #define ALT_BITSTREAM_READER_LE
 #include "bitstream.h"
+#include "bytestream.h"
 
 #define SMKTREE_BITS 9
 #define SMK_NODE 0x80000000
@@ -344,7 +345,7 @@
     return v;
 }
 
-static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size)
 {
     SmackVContext * const smk = avctx->priv_data;
     uint8_t *out;
@@ -354,7 +355,7 @@
     int i;
     int stride;
 
-    if(buf_size == 769)
+    if(buf_size <= 769)
         return 0;
     if(smk->pic.data[0])
             avctx->release_buffer(avctx, &smk->pic);
@@ -367,7 +368,6 @@
     }
 
     /* make the palette available on the way out */
-    out = buf + 1;
     pal = (uint32_t*)smk->pic.data[1];
     smk->pic.palette_has_changed = buf[0] & 1;
     smk->pic.key_frame = !!(buf[0] & 2);
@@ -376,19 +376,16 @@
     else
         smk->pic.pict_type = FF_P_TYPE;
 
-    for(i = 0; i < 256; i++) {
-        int r, g, b;
-        r = *out++;
-        g = *out++;
-        b = *out++;
-        *pal++ = (r << 16) | (g << 8) | b;
-    }
+    buf++;
+    for(i = 0; i < 256; i++)
+        *pal++ = bytestream_get_be24(&buf);
+    buf_size -= 769;
 
     last_reset(smk->mmap_tbl, smk->mmap_last);
     last_reset(smk->mclr_tbl, smk->mclr_last);
     last_reset(smk->full_tbl, smk->full_last);
     last_reset(smk->type_tbl, smk->type_last);
-    init_get_bits(&gb, buf + 769, (buf_size - 769) * 8);
+    init_get_bits(&gb, buf, buf_size * 8);
 
     blk = 0;
     bw = avctx->width >> 2;
@@ -567,7 +564,7 @@
 /**
  * Decode Smacker audio data
  */
-static int smka_decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)
+static int smka_decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size)
 {
     GetBitContext gb;
     HuffContext h[4];
diff -u mplayer-1.0~rc2-12/libavcodec/smc.c ffmpeg-free-0.svn20080206/libavcodec/smc.c
--- mplayer-1.0~rc2-12/libavcodec/smc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/smc.c	2008-03-20 19:10:59.000000000 +0100
@@ -48,7 +48,7 @@
     DSPContext dsp;
     AVFrame frame;
 
-    unsigned char *buf;
+    const unsigned char *buf;
     int size;
 
     /* SMC color tables */
@@ -443,7 +443,7 @@
 
 static int smc_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     SmcContext *s = avctx->priv_data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/snow.c ffmpeg-free-0.svn20080206/libavcodec/snow.c
--- mplayer-1.0~rc2-12/libavcodec/snow.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/snow.c	2008-03-20 19:10:59.000000000 +0100
@@ -339,7 +339,7 @@
   0,  0,  0,  0,  0,  4,  4,  4,  4,  4,  4,  0,  0,  0,  0,  0,
 //error:0.000022
 };
-#endif
+#endif /* 0 */
 
 //linear *64
 static const uint8_t obmc8[64]={
@@ -657,7 +657,7 @@
             if(is_signed)
                 put_rac(c, state+11 + FFMIN(e,10), v < 0); //11..21
         }
-#endif
+#endif /* 1 */
     }else{
         put_rac(c, state+0, 1);
     }
@@ -1078,7 +1078,7 @@
 #else
     inv_lift(temp   , b   , b+w2, 1, 1, 1, width,  1, 2, 2, 0, 1);
     inv_lift(temp+w2, b+w2, temp, 1, 1, 1, width, -1, 0, 1, 1, 1);
-#endif
+#endif /* 0 */
     for(x=0; x<width2; x++){
         b[2*x    ]= temp[x   ];
         b[2*x + 1]= temp[x+w2];
@@ -1160,7 +1160,7 @@
     cs->y += 2;
 }
 
-static void spatial_compose53i(IDWTELEM *buffer, int width, int height, int stride){
+static void av_unused spatial_compose53i(IDWTELEM *buffer, int width, int height, int stride){
     dwt_compose_t cs;
     spatial_compose53i_init(&cs, buffer, height, stride);
     while(cs.y <= height)
@@ -1310,7 +1310,7 @@
     cs->y += 2;
 }
 
-static void spatial_compose97i(IDWTELEM *buffer, int width, int height, int stride){
+static void av_unused spatial_compose97i(IDWTELEM *buffer, int width, int height, int stride){
     dwt_compose_t cs;
     spatial_compose97i_init(&cs, buffer, height, stride);
     while(cs.y <= height)
@@ -2193,7 +2193,7 @@
     uint8_t tmp2t[3][stride*(32+HTAPS_MAX)];
     int16_t *tmpI= tmpIt;
     uint8_t *tmp2= tmp2t[0];
-    uint8_t *hpel[11];
+    const uint8_t *hpel[11];
 START_TIMER
     assert(dx<16 && dy<16);
     r= brane[dx + 16*dy]&15;
@@ -2302,10 +2302,10 @@
     hpel[10]= hpel[8] + 1;
 
     if(b==15){
-        uint8_t *src1= hpel[dx/8 + dy/8*4  ];
-        uint8_t *src2= hpel[dx/8 + dy/8*4+1];
-        uint8_t *src3= hpel[dx/8 + dy/8*4+4];
-        uint8_t *src4= hpel[dx/8 + dy/8*4+5];
+        const uint8_t *src1= hpel[dx/8 + dy/8*4  ];
+        const uint8_t *src2= hpel[dx/8 + dy/8*4+1];
+        const uint8_t *src3= hpel[dx/8 + dy/8*4+4];
+        const uint8_t *src4= hpel[dx/8 + dy/8*4+5];
         dx&=7;
         dy&=7;
         for(y=0; y < b_h; y++){
@@ -2320,8 +2320,8 @@
             dst +=stride;
         }
     }else{
-        uint8_t *src1= hpel[l];
-        uint8_t *src2= hpel[r];
+        const uint8_t *src1= hpel[l];
+        const uint8_t *src2= hpel[r];
         int a= weight[((dx&7) + (8*(dy&7)))];
         int b= 8-a;
         for(y=0; y < b_h; y++){
@@ -2410,7 +2410,7 @@
 //        assert(b_w == b_h || 2*b_w == b_h || b_w == 2*b_h);
 //        assert(!(b_w&(b_w-1)));
         assert(b_w>1 && b_h>1);
-        assert(tab_index>=0 && tab_index<4 || b_w==32);
+        assert((tab_index>=0 && tab_index<4) || b_w==32);
         if((dx&3) || (dy&3) || !(b_w == b_h || 2*b_w == b_h || b_w == 2*b_h) || (b_w&(b_w-1)) || !s->plane[plane_index].fast_mc )
             mc_block(&s->plane[plane_index], dst, src, tmp, stride, b_w, b_h, dx, dy);
         else if(b_w==32){
@@ -2621,7 +2621,7 @@
             }
         }
     }
-#endif
+#endif /* 0 */
 }
 
 static av_always_inline void predict_slice_buffered(SnowContext *s, slice_buffer * sb, IDWTELEM * old_buffer, int plane_index, int add, int mb_y){
@@ -3583,10 +3583,6 @@
                 put_symbol(&s->c, s->header_state, p->htaps/2-1, 0);
                 for(i= p->htaps/2; i; i--)
                     put_symbol(&s->c, s->header_state, FFABS(p->hcoeff[i]), 0);
-
-                p->last_diag_mc= p->diag_mc;
-                p->last_htaps= p->htaps;
-                memcpy(p->last_hcoeff, p->hcoeff, sizeof(p->hcoeff));
             }
         }
         if(s->last_spatial_decomposition_count != s->spatial_decomposition_count){
@@ -3603,6 +3599,20 @@
     put_symbol(&s->c, s->header_state, s->qbias           - s->last_qbias   , 1);
     put_symbol(&s->c, s->header_state, s->block_max_depth - s->last_block_max_depth, 1);
 
+}
+
+static void update_last_header_values(SnowContext *s){
+    int plane_index;
+
+    if(!s->keyframe){
+        for(plane_index=0; plane_index<2; plane_index++){
+            Plane *p= &s->plane[plane_index];
+            p->last_diag_mc= p->diag_mc;
+            p->last_htaps  = p->htaps;
+            memcpy(p->last_hcoeff, p->hcoeff, sizeof(p->hcoeff));
+        }
+    }
+
     s->last_spatial_decomposition_type= s->spatial_decomposition_type;
     s->last_qlog                      = s->qlog;
     s->last_qbias                     = s->qbias;
@@ -3665,7 +3675,7 @@
     if(!s->keyframe){
         if(get_rac(&s->c, s->header_state)){
             for(plane_index=0; plane_index<2; plane_index++){
-                int htaps, i, sum=0, absum=0;
+                int htaps, i, sum=0;
                 Plane *p= &s->plane[plane_index];
                 p->diag_mc= get_rac(&s->c, s->header_state);
                 htaps= get_symbol(&s->c, s->header_state, 0)*2 + 2;
@@ -3895,7 +3905,7 @@
     return delta_qlog;
 }
 
-static void calculate_vissual_weight(SnowContext *s, Plane *p){
+static void calculate_visual_weight(SnowContext *s, Plane *p){
     int width = p->width;
     int height= p->height;
     int level, orientation, x, y;
@@ -4037,7 +4047,7 @@
     memcpy(s->spatial_idwt_buffer, best_dequant, height * stride * sizeof(IDWTELEM)); //FIXME work with that directly insteda of copy at the end
 }
 
-#endif
+#endif /* QUANTIZE2==1 */
 
 static int encode_init(AVCodecContext *avctx)
 {
@@ -4115,7 +4125,7 @@
         s->colorspace= 1;
         break;*/
     default:
-        av_log(avctx, AV_LOG_ERROR, "format not supported\n");
+        av_log(avctx, AV_LOG_ERROR, "pixel format not supported\n");
         return -1;
     }
 //    avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift, &s->chroma_v_shift);
@@ -4139,6 +4149,8 @@
     return 0;
 }
 
+#define USE_HALFPEL_PLANE 0
+
 static void halfpel_interpol(SnowContext *s, uint8_t *halfpel[4][4], AVFrame *frame){
     int p,x,y;
 
@@ -4197,10 +4209,8 @@
     tmp= s->last_picture[s->max_ref_frames-1];
     memmove(s->last_picture+1, s->last_picture, (s->max_ref_frames-1)*sizeof(AVFrame));
     memmove(s->halfpel_plane+1, s->halfpel_plane, (s->max_ref_frames-1)*sizeof(void*)*4*4);
-#ifdef USE_HALFPEL_PLANE
-    if(s->current_picture.data[0])
+    if(USE_HALFPEL_PLANE && s->current_picture.data[0])
         halfpel_interpol(s, s->halfpel_plane[0], &s->current_picture);
-#endif
     s->last_picture[0]= s->current_picture;
     s->current_picture= tmp;
 
@@ -4338,7 +4348,7 @@
 
     if(s->last_spatial_decomposition_count != s->spatial_decomposition_count){
         for(plane_index=0; plane_index<3; plane_index++){
-            calculate_vissual_weight(s, &s->plane[plane_index]);
+            calculate_visual_weight(s, &s->plane[plane_index]);
         }
     }
 
@@ -4473,6 +4483,8 @@
         }
     }
 
+    update_last_header_values(s);
+
     if(s->last_picture[s->max_ref_frames-1].data[0]){
         avctx->release_buffer(avctx, &s->last_picture[s->max_ref_frames-1]);
         for(i=0; i<9; i++)
@@ -4548,8 +4560,6 @@
 
 static int decode_init(AVCodecContext *avctx)
 {
-    SnowContext *s = avctx->priv_data;
-
     avctx->pix_fmt= PIX_FMT_YUV420P;
 
     common_init(avctx);
@@ -4557,7 +4567,7 @@
     return 0;
 }
 
-static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size){
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size){
     SnowContext *s = avctx->priv_data;
     RangeCoder * const c= &s->c;
     int bytes_read;
@@ -4765,13 +4775,13 @@
 #endif
 
 
-#if 0
+#ifdef TEST
 #undef malloc
 #undef free
 #undef printf
 #undef random
 
-int main(){
+int main(void){
     int width=256;
     int height=256;
     int buffer[2][width*height];
@@ -4873,9 +4883,8 @@
     printf("};\n");
     {
             int level=2;
-            int orientation=3;
             int w= width  >> (s.spatial_decomposition_count-level);
-            int h= height >> (s.spatial_decomposition_count-level);
+            //int h= height >> (s.spatial_decomposition_count-level);
             int stride= width  << (s.spatial_decomposition_count-level);
             DWTELEM *buf= buffer[0];
             int64_t error=0;
@@ -4914,5 +4923,4 @@
 }
     return 0;
 }
-#endif
-
+#endif /* TEST */
diff -u mplayer-1.0~rc2-12/libavcodec/snow.h ffmpeg-free-0.svn20080206/libavcodec/snow.h
--- mplayer-1.0~rc2-12/libavcodec/snow.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/snow.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef SNOW_H
-#define SNOW_H
+#ifndef FFMPEG_SNOW_H
+#define FFMPEG_SNOW_H
 
 #include "dsputil.h"
 
@@ -171,4 +171,4 @@
         }
 }
 
-#endif
+#endif /* FFMPEG_SNOW_H */
diff -u mplayer-1.0~rc2-12/libavcodec/sonic.c ffmpeg-free-0.svn20080206/libavcodec/sonic.c
--- mplayer-1.0~rc2-12/libavcodec/sonic.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/sonic.c	2008-03-20 19:10:59.000000000 +0100
@@ -851,7 +851,7 @@
 
 static int sonic_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     SonicContext *s = avctx->priv_data;
     GetBitContext gb;
diff -u mplayer-1.0~rc2-12/libavcodec/sp5xdec.c ffmpeg-free-0.svn20080206/libavcodec/sp5xdec.c
--- mplayer-1.0~rc2-12/libavcodec/sp5xdec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/sp5xdec.c	2008-03-20 19:10:59.000000000 +0100
@@ -32,13 +32,14 @@
 
 static int sp5x_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
-                              uint8_t *buf, int buf_size)
+                              const uint8_t *buf, int buf_size)
 {
 #if 0
     MJpegDecodeContext *s = avctx->priv_data;
 #endif
     const int qscale = 5;
-    uint8_t *buf_ptr, *buf_end, *recoded;
+    const uint8_t *buf_ptr, *buf_end;
+    uint8_t *recoded;
     int i = 0, j = 0;
 
     if (!avctx->width || !avctx->height)
@@ -87,6 +88,7 @@
     recoded[j++] = 0xFF;
     recoded[j++] = 0xD9;
 
+    avctx->flags &= ~CODEC_FLAG_EMU_EDGE;
     i = ff_mjpeg_decode_frame(avctx, data, data_size, recoded, j);
 
     av_free(recoded);
@@ -207,6 +209,5 @@
     ff_mjpeg_decode_init,
     NULL,
     ff_mjpeg_decode_end,
-    sp5x_decode_frame,
-    CODEC_CAP_DR1
+    sp5x_decode_frame
 };
diff -u mplayer-1.0~rc2-12/libavcodec/sp5x.h ffmpeg-free-0.svn20080206/libavcodec/sp5x.h
--- mplayer-1.0~rc2-12/libavcodec/sp5x.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/sp5x.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef SP5X_H
-#define SP5X_H
+#ifndef FFMPEG_SP5X_H
+#define FFMPEG_SP5X_H
 
 #include <stdint.h>
 
@@ -331,4 +331,4 @@
 };
 #endif
 
-#endif /* SP5X_H */
+#endif /* FFMPEG_SP5X_H */
Common subdirectories: mplayer-1.0~rc2-12/libavcodec/sparc and ffmpeg-free-0.svn20080206/libavcodec/sparc
Only in ffmpeg-free-0.svn20080206/libavcodec: sunrast.c
diff -u mplayer-1.0~rc2-12/libavcodec/svq1.c ffmpeg-free-0.svn20080206/libavcodec/svq1.c
--- mplayer-1.0~rc2-12/libavcodec/svq1.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/svq1.c	2008-03-20 19:10:59.000000000 +0100
@@ -37,7 +37,7 @@
 #include "svq1_vlc.h"
 
 /* standard video sizes */
-svq1_frame_size_t ff_svq1_frame_size_table[8] = {
+const svq1_frame_size_t ff_svq1_frame_size_table[8] = {
   { 160, 120 }, { 128,  96 }, { 176, 144 }, { 352, 288 },
   { 704, 576 }, { 240, 180 }, { 320, 240 }, {  -1,  -1 }
 };
diff -u mplayer-1.0~rc2-12/libavcodec/svq1_cb.h ffmpeg-free-0.svn20080206/libavcodec/svq1_cb.h
--- mplayer-1.0~rc2-12/libavcodec/svq1_cb.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/svq1_cb.h	2007-10-17 11:37:46.000000000 +0200
@@ -28,8 +28,8 @@
  * svq1 code books.
  */
 
-#ifndef AVCODEC_SVQ1_CB_H
-#define AVCODEC_SVQ1_CB_H
+#ifndef FFMPEG_SVQ1_CB_H
+#define FFMPEG_SVQ1_CB_H
 
 #include <stdint.h>
 #include <stdlib.h>
@@ -1520,4 +1520,4 @@
     NULL, NULL,
 };
 
-#endif // AVCODEC_SVQ1_CB_H
+#endif /* FFMPEG_SVQ1_CB_H */
diff -u mplayer-1.0~rc2-12/libavcodec/svq1dec.c ffmpeg-free-0.svn20080206/libavcodec/svq1dec.c
--- mplayer-1.0~rc2-12/libavcodec/svq1dec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/svq1dec.c	2008-03-20 19:10:59.000000000 +0100
@@ -540,7 +540,7 @@
   return result;
 }
 
-static uint16_t svq1_packet_checksum (uint8_t *data, int length, int value) {
+static uint16_t svq1_packet_checksum (const uint8_t *data, const int length, int value) {
   int i;
 
   for (i=0; i < length; i++) {
@@ -581,7 +581,7 @@
     if (s->f_code == 0x50 || s->f_code == 0x60) {
       int csum = get_bits (bitbuf, 16);
 
-      csum = svq1_packet_checksum ((uint8_t *)bitbuf->buffer, bitbuf->size_in_bits>>3, csum);
+      csum = svq1_packet_checksum (bitbuf->buffer, bitbuf->size_in_bits>>3, csum);
 
 //      av_log(s->avctx, AV_LOG_INFO, "%s checksum (%02x) for packet data\n",
 //              (csum == 0) ? "correct" : "incorrect", csum);
@@ -641,7 +641,7 @@
 
 static int svq1_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
   MpegEncContext *s=avctx->priv_data;
   uint8_t        *current, *previous;
diff -u mplayer-1.0~rc2-12/libavcodec/svq1enc_cb.h ffmpeg-free-0.svn20080206/libavcodec/svq1enc_cb.h
--- mplayer-1.0~rc2-12/libavcodec/svq1enc_cb.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/svq1enc_cb.h	2007-10-17 11:37:46.000000000 +0200
@@ -24,8 +24,8 @@
  * svq1 code books.
  */
 
-#ifndef AVCODEC_SVQ1ENC_CB_H
-#define AVCODEC_SVQ1ENC_CB_H
+#ifndef FFMPEG_SVQ1ENC_CB_H
+#define FFMPEG_SVQ1ENC_CB_H
 
 #include <stdint.h>
 
@@ -93,4 +93,4 @@
  }
 };
 
-#endif /* AVCODEC_SVQ1ENC_CB_H */
+#endif /* FFMPEG_SVQ1ENC_CB_H */
diff -u mplayer-1.0~rc2-12/libavcodec/svq1.h ffmpeg-free-0.svn20080206/libavcodec/svq1.h
--- mplayer-1.0~rc2-12/libavcodec/svq1.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/svq1.h	2008-01-07 13:48:42.000000000 +0100
@@ -32,8 +32,8 @@
  *   http://www.pcisys.net/~melanson/codecs/
  */
 
-#ifndef AVCODEC_SVQ1_H
-#define AVCODEC_SVQ1_H
+#ifndef FFMPEG_SVQ1_H
+#define FFMPEG_SVQ1_H
 
 #include <stdint.h>
 
@@ -56,6 +56,6 @@
 extern const uint16_t ff_svq1_intra_mean_vlc[256][2];
 extern const uint16_t ff_svq1_inter_mean_vlc[512][2];
 
-extern svq1_frame_size_t ff_svq1_frame_size_table[8];
+extern const svq1_frame_size_t ff_svq1_frame_size_table[8];
 
-#endif /* AVCODEC_SVQ1_H */
+#endif /* FFMPEG_SVQ1_H */
diff -u mplayer-1.0~rc2-12/libavcodec/svq1_vlc.h ffmpeg-free-0.svn20080206/libavcodec/svq1_vlc.h
--- mplayer-1.0~rc2-12/libavcodec/svq1_vlc.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/svq1_vlc.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef SVQ1_VLC_H
-#define SVQ1_VLC_H
+#ifndef FFMPEG_SVQ1_VLC_H
+#define FFMPEG_SVQ1_VLC_H
 
 #include <stdint.h>
 
@@ -280,4 +280,4 @@
     { 0x3, 22 },  { 0x2, 22 },  { 0x1, 22 },  { 0x0, 22 }
 };
 
-#endif
+#endif /* FFMPEG_SVQ1_VLC_H */
diff -u mplayer-1.0~rc2-12/libavcodec/svq3.c ffmpeg-free-0.svn20080206/libavcodec/svq3.c
--- mplayer-1.0~rc2-12/libavcodec/svq3.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/svq3.c	2008-03-20 19:10:59.000000000 +0100
@@ -760,7 +760,7 @@
 
 static int svq3_decode_frame (AVCodecContext *avctx,
                               void *data, int *data_size,
-                              uint8_t *buf, int buf_size) {
+                              const uint8_t *buf, int buf_size) {
   MpegEncContext *const s = avctx->priv_data;
   H264Context *const h = avctx->priv_data;
   int m, mb_type;
diff -u mplayer-1.0~rc2-12/libavcodec/targa.c ffmpeg-free-0.svn20080206/libavcodec/targa.c
--- mplayer-1.0~rc2-12/libavcodec/targa.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/targa.c	2008-03-20 19:10:59.000000000 +0100
@@ -37,7 +37,7 @@
     int compression_type;
 } TargaContext;
 
-static void targa_decode_rle(AVCodecContext *avctx, TargaContext *s, uint8_t *src, uint8_t *dst, int w, int h, int stride, int bpp)
+static void targa_decode_rle(AVCodecContext *avctx, TargaContext *s, const uint8_t *src, uint8_t *dst, int w, int h, int stride, int bpp)
 {
     int i, x, y;
     int depth = (bpp + 1) >> 3;
@@ -89,7 +89,7 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     TargaContext * const s = avctx->priv_data;
     AVFrame *picture = data;
diff -u mplayer-1.0~rc2-12/libavcodec/tiertexseqv.c ffmpeg-free-0.svn20080206/libavcodec/tiertexseqv.c
--- mplayer-1.0~rc2-12/libavcodec/tiertexseqv.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/tiertexseqv.c	2008-03-20 19:10:59.000000000 +0100
@@ -37,7 +37,7 @@
 } SeqVideoContext;
 
 
-static unsigned char *seq_unpack_rle_block(unsigned char *src, unsigned char *dst, int dst_size)
+static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)
 {
     int i, len, sz;
     GetBitContext gb;
@@ -67,9 +67,9 @@
     return src;
 }
 
-static unsigned char *seq_decode_op1(SeqVideoContext *seq, unsigned char *src, unsigned char *dst)
+static const unsigned char *seq_decode_op1(SeqVideoContext *seq, const unsigned char *src, unsigned char *dst)
 {
-    unsigned char *color_table;
+    const unsigned char *color_table;
     int b, i, len, bits;
     GetBitContext gb;
 
@@ -107,7 +107,7 @@
     return src;
 }
 
-static unsigned char *seq_decode_op2(SeqVideoContext *seq, unsigned char *src, unsigned char *dst)
+static const unsigned char *seq_decode_op2(SeqVideoContext *seq, const unsigned char *src, unsigned char *dst)
 {
     int i;
 
@@ -120,7 +120,7 @@
     return src;
 }
 
-static unsigned char *seq_decode_op3(SeqVideoContext *seq, unsigned char *src, unsigned char *dst)
+static const unsigned char *seq_decode_op3(SeqVideoContext *seq, const unsigned char *src, unsigned char *dst)
 {
     int pos, offset;
 
@@ -133,7 +133,7 @@
     return src;
 }
 
-static void seqvideo_decode(SeqVideoContext *seq, unsigned char *data, int data_size)
+static void seqvideo_decode(SeqVideoContext *seq, const unsigned char *data, int data_size)
 {
     GetBitContext gb;
     int flags, i, j, x, y, op;
@@ -187,7 +187,7 @@
 
 static int seqvideo_decode_frame(AVCodecContext *avctx,
                                  void *data, int *data_size,
-                                 uint8_t *buf, int buf_size)
+                                 const uint8_t *buf, int buf_size)
 {
 
     SeqVideoContext *seq = avctx->priv_data;
diff -u mplayer-1.0~rc2-12/libavcodec/tiff.c ffmpeg-free-0.svn20080206/libavcodec/tiff.c
--- mplayer-1.0~rc2-12/libavcodec/tiff.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/tiff.c	2008-03-20 19:10:59.000000000 +0100
@@ -44,25 +44,25 @@
 
     int strips, rps;
     int sot;
-    uint8_t* stripdata;
-    uint8_t* stripsizes;
+    const uint8_t* stripdata;
+    const uint8_t* stripsizes;
     int stripsize, stripoff;
     LZWState *lzw;
 } TiffContext;
 
-static int tget_short(uint8_t **p, int le){
+static int tget_short(const uint8_t **p, int le){
     int v = le ? AV_RL16(*p) : AV_RB16(*p);
     *p += 2;
     return v;
 }
 
-static int tget_long(uint8_t **p, int le){
+static int tget_long(const uint8_t **p, int le){
     int v = le ? AV_RL32(*p) : AV_RB32(*p);
     *p += 4;
     return v;
 }
 
-static int tget(uint8_t **p, int type, int le){
+static int tget(const uint8_t **p, int type, int le){
     switch(type){
     case TIFF_BYTE : return *(*p)++;
     case TIFF_SHORT: return tget_short(p, le);
@@ -71,9 +71,9 @@
     }
 }
 
-static int tiff_unpack_strip(TiffContext *s, uint8_t* dst, int stride, uint8_t *src, int size, int lines){
+static int tiff_unpack_strip(TiffContext *s, uint8_t* dst, int stride, const uint8_t *src, int size, int lines){
     int c, line, pixels, code;
-    uint8_t *ssrc = src;
+    const uint8_t *ssrc = src;
     int width = s->width * (s->bpp / 8);
 #ifdef CONFIG_ZLIB
     uint8_t *zbuf; unsigned long outlen;
@@ -150,13 +150,14 @@
 }
 
 
-static int tiff_decode_tag(TiffContext *s, uint8_t *start, uint8_t *buf, uint8_t *end_buf, AVFrame *pic)
+static int tiff_decode_tag(TiffContext *s, const uint8_t *start, const uint8_t *buf, const uint8_t *end_buf, AVFrame *pic)
 {
     int tag, type, count, off, value = 0;
-    uint8_t *src, *dst;
+    const uint8_t *src;
+    uint8_t *dst;
     int i, j, ssize, soff, stride;
     uint32_t *pal;
-    uint8_t *rp, *gp, *bp;
+    const uint8_t *rp, *gp, *bp;
 
     tag = tget_short(&buf, s->le);
     type = tget_short(&buf, s->le);
@@ -346,14 +347,14 @@
             return -1;
         }
         if(value == 2){
-            src = pic->data[0];
+            dst = pic->data[0];
             stride = pic->linesize[0];
             soff = s->bpp >> 3;
             ssize = s->width * soff;
             for(i = 0; i < s->height; i++) {
                 for(j = soff; j < ssize; j++)
-                    src[j] += src[j - soff];
-                src += stride;
+                    dst[j] += dst[j - soff];
+                dst += stride;
             }
         }
         break;
@@ -403,12 +404,12 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     TiffContext * const s = avctx->priv_data;
     AVFrame *picture = data;
     AVFrame * const p= (AVFrame*)&s->picture;
-    uint8_t *orig_buf = buf, *end_buf = buf + buf_size;
+    const uint8_t *orig_buf = buf, *end_buf = buf + buf_size;
     int id, le, off;
     int i, entries;
 
@@ -422,6 +423,7 @@
     }
     s->le = le;
     s->invert = 0;
+    s->compr = TIFF_RAW;
     // As TIFF 6.0 specification puts it "An arbitrary but carefully chosen number
     // that further identifies the file as a TIFF file"
     if(tget_short(&buf, le) != 42){
diff -u mplayer-1.0~rc2-12/libavcodec/tiffenc.c ffmpeg-free-0.svn20080206/libavcodec/tiffenc.c
--- mplayer-1.0~rc2-12/libavcodec/tiffenc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/tiffenc.c	2008-03-20 19:10:59.000000000 +0100
@@ -133,7 +133,7 @@
                        enum TiffTags tag, enum TiffTypes type, int val){
     uint16_t w = val;
     uint32_t dw= val;
-    add_entry(s, tag, type, 1, type == TIFF_SHORT ? &w : &dw);
+    add_entry(s, tag, type, 1, type == TIFF_SHORT ? (void *)&w : (void *)&dw);
 }
 
 /**
diff -u mplayer-1.0~rc2-12/libavcodec/tiff.h ffmpeg-free-0.svn20080206/libavcodec/tiff.h
--- mplayer-1.0~rc2-12/libavcodec/tiff.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/tiff.h	2007-10-17 11:37:46.000000000 +0200
@@ -24,8 +24,8 @@
  * @file tiff.h
  * @author Konstantin Shishkov
  */
-#ifndef TIFF_H
-#define TIFF_H
+#ifndef FFMPEG_TIFF_H
+#define FFMPEG_TIFF_H
 
 #include <stdint.h>
 
@@ -83,4 +83,4 @@
     0, 1, 100, 2, 4, 8
 };
 
-#endif                          /* TIFF_H */
+#endif /* FFMPEG_TIFF_H */
diff -u mplayer-1.0~rc2-12/libavcodec/truemotion1.c ffmpeg-free-0.svn20080206/libavcodec/truemotion1.c
--- mplayer-1.0~rc2-12/libavcodec/truemotion1.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/truemotion1.c	2008-03-20 19:10:59.000000000 +0100
@@ -43,12 +43,12 @@
     AVCodecContext *avctx;
     AVFrame frame;
 
-    uint8_t *buf;
+    const uint8_t *buf;
     int size;
 
-    uint8_t *mb_change_bits;
+    const uint8_t *mb_change_bits;
     int mb_change_bits_row_size;
-    uint8_t *index_stream;
+    const uint8_t *index_stream;
     int index_stream_size;
 
     int flags;
@@ -603,7 +603,7 @@
     int keyframe = s->flags & FLAG_KEYFRAME;
 
     /* these variables are for managing the stream of macroblock change bits */
-    unsigned char *mb_change_bits = s->mb_change_bits;
+    const unsigned char *mb_change_bits = s->mb_change_bits;
     unsigned char mb_change_byte;
     unsigned char mb_change_byte_mask;
     int mb_change_index;
@@ -729,7 +729,7 @@
     int keyframe = s->flags & FLAG_KEYFRAME;
 
     /* these variables are for managing the stream of macroblock change bits */
-    unsigned char *mb_change_bits = s->mb_change_bits;
+    const unsigned char *mb_change_bits = s->mb_change_bits;
     unsigned char mb_change_byte;
     unsigned char mb_change_byte_mask;
     int mb_change_index;
@@ -846,7 +846,7 @@
 
 static int truemotion1_decode_frame(AVCodecContext *avctx,
                                     void *data, int *data_size,
-                                    uint8_t *buf, int buf_size)
+                                    const uint8_t *buf, int buf_size)
 {
     TrueMotion1Context *s = avctx->priv_data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/truemotion1data.h ffmpeg-free-0.svn20080206/libavcodec/truemotion1data.h
--- mplayer-1.0~rc2-12/libavcodec/truemotion1data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/truemotion1data.h	2007-10-17 11:37:46.000000000 +0200
@@ -22,8 +22,8 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-#ifndef TRUEMOTION1DATA_H
-#define TRUEMOTION1DATA_H
+#ifndef FFMPEG_TRUEMOTION1DATA_H
+#define FFMPEG_TRUEMOTION1DATA_H
 
 #include <stdint.h>
 #include <stdlib.h>
@@ -829,4 +829,5 @@
 };
 
 static const uint8_t *tables[] = { pc_tbl2, pc_tbl3, pc_tbl4 };
-#endif
+
+#endif /* FFMPEG_TRUEMOTION1DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/truemotion2.c ffmpeg-free-0.svn20080206/libavcodec/truemotion2.c
--- mplayer-1.0~rc2-12/libavcodec/truemotion2.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/truemotion2.c	2008-03-20 19:10:59.000000000 +0100
@@ -198,10 +198,10 @@
     return code->recode[val];
 }
 
-static inline int tm2_read_header(TM2Context *ctx, uint8_t *buf)
+static inline int tm2_read_header(TM2Context *ctx, const uint8_t *buf)
 {
     uint32_t magic;
-    uint8_t *obuf;
+    const uint8_t *obuf;
     int length;
 
     obuf = buf;
@@ -260,7 +260,7 @@
     return 0;
 }
 
-static int tm2_read_stream(TM2Context *ctx, uint8_t *buf, int stream_id) {
+static int tm2_read_stream(TM2Context *ctx, const uint8_t *buf, int stream_id) {
     int i;
     int cur = 0;
     int skip = 0;
@@ -759,7 +759,7 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     TM2Context * const l = avctx->priv_data;
     AVFrame * const p= (AVFrame*)&l->pic;
@@ -772,7 +772,7 @@
         return -1;
     }
 
-    l->dsp.bswap_buf((uint32_t*)buf, (uint32_t*)buf, buf_size >> 2);
+    l->dsp.bswap_buf((uint32_t*)buf, (const uint32_t*)buf, buf_size >> 2); //FIXME SERIOUS BUG
     skip = tm2_read_header(l, buf);
 
     if(skip == -1)
diff -u mplayer-1.0~rc2-12/libavcodec/truespeech.c ffmpeg-free-0.svn20080206/libavcodec/truespeech.c
--- mplayer-1.0~rc2-12/libavcodec/truespeech.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/truespeech.c	2008-03-20 19:10:59.000000000 +0100
@@ -57,7 +57,7 @@
     return 0;
 }
 
-static void truespeech_read_frame(TSContext *dec, uint8_t *input)
+static void truespeech_read_frame(TSContext *dec, const uint8_t *input)
 {
     uint32_t t;
 
@@ -329,7 +329,7 @@
 
 static int truespeech_decode_frame(AVCodecContext *avctx,
                 void *data, int *data_size,
-                uint8_t *buf, int buf_size)
+                const uint8_t *buf, int buf_size)
 {
     TSContext *c = avctx->priv_data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/truespeech_data.h ffmpeg-free-0.svn20080206/libavcodec/truespeech_data.h
--- mplayer-1.0~rc2-12/libavcodec/truespeech_data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/truespeech_data.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef TRUESPEECH_DATA_H
-#define TRUESPEECH_DATA_H
+#ifndef FFMPEG_TRUESPEECH_DATA_H
+#define FFMPEG_TRUESPEECH_DATA_H
 
 #include <stdint.h>
 
@@ -156,4 +156,4 @@
 static const int16_t ts_5F2[8] =
     { 0x6000, 0x4800, 0x3600, 0x2880, 0x1E60, 0x16C8, 0x1116, 0x0CD1 };
 
-#endif /* TRUESPEECH_DATA_H */
+#endif /* FFMPEG_TRUESPEECH_DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/tscc.c ffmpeg-free-0.svn20080206/libavcodec/tscc.c
--- mplayer-1.0~rc2-12/libavcodec/tscc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/tscc.c	2008-03-20 19:10:59.000000000 +0100
@@ -182,10 +182,10 @@
  * Decode a frame
  *
  */
-static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size)
 {
     CamtasiaContext * const c = avctx->priv_data;
-    unsigned char *encoded = (unsigned char *)buf;
+    const unsigned char *encoded = buf;
     unsigned char *outptr;
 #ifdef CONFIG_ZLIB
     int zret; // Zlib return code
diff -u mplayer-1.0~rc2-12/libavcodec/tta.c ffmpeg-free-0.svn20080206/libavcodec/tta.c
--- mplayer-1.0~rc2-12/libavcodec/tta.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/tta.c	2008-03-20 19:10:59.000000000 +0100
@@ -287,7 +287,7 @@
 
 static int tta_decode_frame(AVCodecContext *avctx,
         void *data, int *data_size,
-        uint8_t *buf, int buf_size)
+        const uint8_t *buf, int buf_size)
 {
     TTAContext *s = avctx->priv_data;
     int i;
diff -u mplayer-1.0~rc2-12/libavcodec/txd.c ffmpeg-free-0.svn20080206/libavcodec/txd.c
--- mplayer-1.0~rc2-12/libavcodec/txd.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/txd.c	2008-03-20 19:10:59.000000000 +0100
@@ -33,20 +33,21 @@
 
     avcodec_get_frame_defaults(&s->picture);
     avctx->coded_frame = &s->picture;
-    s->picture.data[0] = NULL;
 
     return 0;
 }
 
 static int txd_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
-                            uint8_t *buf, int buf_size) {
+                            const uint8_t *buf, int buf_size) {
     TXDContext * const s = avctx->priv_data;
     AVFrame *picture = data;
     AVFrame * const p = &s->picture;
     unsigned int version, w, h, d3d_format, depth, stride, mipmap_count, flags;
     unsigned int y, v;
-    uint8_t *ptr, *cur = buf;
-    uint32_t *palette = (uint32_t *)(cur + 88), *pal;
+    uint8_t *ptr;
+    const uint8_t *cur = buf;
+    const uint32_t *palette = (const uint32_t *)(cur + 88);
+    uint32_t *pal;
 
     version         = AV_RL32(cur);
     d3d_format      = AV_RL32(cur+76);
diff -u mplayer-1.0~rc2-12/libavcodec/ulti.c ffmpeg-free-0.svn20080206/libavcodec/ulti.c
--- mplayer-1.0~rc2-12/libavcodec/ulti.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ulti.c	2008-03-20 19:10:59.000000000 +0100
@@ -200,7 +200,7 @@
 
 static int ulti_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     UltimotionDecodeContext *s=avctx->priv_data;
     int modifier = 0;
diff -u mplayer-1.0~rc2-12/libavcodec/ulti_cb.h ffmpeg-free-0.svn20080206/libavcodec/ulti_cb.h
--- mplayer-1.0~rc2-12/libavcodec/ulti_cb.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ulti_cb.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_ULTI_CB_H
-#define AVCODEC_ULTI_CB_H
+#ifndef FFMPEG_ULTI_CB_H
+#define FFMPEG_ULTI_CB_H
 
 static const unsigned char ulti_codebook[16384]={
     0x00, 0x01, 0x01, 0x02,
@@ -4121,4 +4121,4 @@
     0x3D, 0x3E, 0x3E, 0x3F
 };
 
-#endif // AVCODEC_ULTI_CB_H
+#endif /* FFMPEG_ULTI_CB_H */
diff -u mplayer-1.0~rc2-12/libavcodec/unary.h ffmpeg-free-0.svn20080206/libavcodec/unary.h
--- mplayer-1.0~rc2-12/libavcodec/unary.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/unary.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_UNARY_H
-#define AVCODEC_UNARY_H
+#ifndef FFMPEG_UNARY_H
+#define FFMPEG_UNARY_H
 
 #include "bitstream.h"
 
@@ -53,4 +53,4 @@
     return get_unary(gb, 0, 9);
 }
 
-#endif /* AVCODEC_UNARY_H */
+#endif /* FFMPEG_UNARY_H */
diff -u mplayer-1.0~rc2-12/libavcodec/utils.c ffmpeg-free-0.svn20080206/libavcodec/utils.c
--- mplayer-1.0~rc2-12/libavcodec/utils.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/utils.c	2008-03-20 19:10:59.000000000 +0100
@@ -126,6 +126,11 @@
 /* encoder management */
 AVCodec *first_avcodec = NULL;
 
+AVCodec *av_codec_next(AVCodec *c){
+    if(c) return c->next;
+    else  return first_avcodec;
+}
+
 void register_avcodec(AVCodec *format)
 {
     AVCodec **p;
@@ -559,7 +564,7 @@
 {"rc_eq", "set rate control equation", OFFSET(rc_eq), FF_OPT_TYPE_STRING, DEFAULT, CHAR_MIN, CHAR_MAX, V|E},
 {"maxrate", "set max video bitrate tolerance (in bits/s)", OFFSET(rc_max_rate), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX, V|E},
 {"minrate", "set min video bitrate tolerance (in bits/s)", OFFSET(rc_min_rate), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX, V|E},
-{"bufsize", "set ratecontrol buffer size (in bits)", OFFSET(rc_buffer_size), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX, V|E},
+{"bufsize", "set ratecontrol buffer size (in bits)", OFFSET(rc_buffer_size), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX, A|V|E},
 {"rc_buf_aggressivity", "currently useless", OFFSET(rc_buffer_aggressivity), FF_OPT_TYPE_FLOAT, 1.0, FLT_MIN, FLT_MAX, V|E},
 {"i_qfactor", "qp factor between p and i frames", OFFSET(i_quant_factor), FF_OPT_TYPE_FLOAT, -0.8, -FLT_MAX, FLT_MAX, V|E},
 {"i_qoffset", "qp offset between p and i frames", OFFSET(i_quant_offset), FF_OPT_TYPE_FLOAT, 0.0, -FLT_MAX, FLT_MAX, V|E},
@@ -756,6 +761,7 @@
 {"drop_frame_timecode", NULL, 0, FF_OPT_TYPE_CONST, CODEC_FLAG2_DROP_FRAME_TIMECODE, INT_MIN, INT_MAX, V|E, "flags2"},
 {"non_linear_q", "use non linear quantizer", 0, FF_OPT_TYPE_CONST, CODEC_FLAG2_NON_LINEAR_QUANT, INT_MIN, INT_MAX, V|E, "flags2"},
 {"request_channels", "set desired number of audio channels", OFFSET(request_channels), FF_OPT_TYPE_INT, DEFAULT, 0, INT_MAX, A|D},
+{"drc_scale", "percentage of dynamic range compression to apply", OFFSET(drc_scale), FF_OPT_TYPE_FLOAT, 1.0, 0.0, 1.0, A|D},
 {NULL},
 };
 
@@ -842,7 +848,7 @@
         goto end;
     }
 
-    if(avctx->codec)
+    if(avctx->codec || !codec)
         goto end;
 
     if (codec->priv_data_size > 0) {
@@ -928,7 +934,7 @@
 
 int attribute_align_arg avcodec_decode_video(AVCodecContext *avctx, AVFrame *picture,
                          int *got_picture_ptr,
-                         uint8_t *buf, int buf_size)
+                         const uint8_t *buf, int buf_size)
 {
     int ret;
 
@@ -951,7 +957,7 @@
 
 int attribute_align_arg avcodec_decode_audio2(AVCodecContext *avctx, int16_t *samples,
                          int *frame_size_ptr,
-                         uint8_t *buf, int buf_size)
+                         const uint8_t *buf, int buf_size)
 {
     int ret;
 
@@ -980,7 +986,7 @@
 #if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
 int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                          int *frame_size_ptr,
-                         uint8_t *buf, int buf_size){
+                         const uint8_t *buf, int buf_size){
     *frame_size_ptr= AVCODEC_MAX_AUDIO_FRAME_SIZE;
     return avcodec_decode_audio2(avctx, samples, frame_size_ptr, buf, buf_size);
 }
@@ -994,7 +1000,7 @@
 
     *got_sub_ptr = 0;
     ret = avctx->codec->decode(avctx, sub, got_sub_ptr,
-                               (uint8_t *)buf, buf_size);
+                               buf, buf_size);
     if (*got_sub_ptr)
         avctx->frame_number++;
     return ret;
@@ -1075,6 +1081,7 @@
     char buf1[32];
     char channels_str[100];
     int bitrate;
+    AVRational display_aspect_ratio;
 
     if (encode)
         p = avcodec_find_encoder(enc->codec_id);
@@ -1125,7 +1132,15 @@
             snprintf(buf + strlen(buf), buf_size - strlen(buf),
                      ", %dx%d",
                      enc->width, enc->height);
-            if(av_log_level >= AV_LOG_DEBUG){
+            av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,
+                      enc->width*enc->sample_aspect_ratio.num,
+                      enc->height*enc->sample_aspect_ratio.den,
+                      1024*1024);
+            snprintf(buf + strlen(buf), buf_size - strlen(buf),
+                     " [PAR %d:%d DAR %d:%d]",
+                     enc->sample_aspect_ratio.num, enc->sample_aspect_ratio.den,
+                     display_aspect_ratio.num, display_aspect_ratio.den);
+            if(av_log_get_level() >= AV_LOG_DEBUG){
                 int g= ff_gcd(enc->time_base.num, enc->time_base.den);
                 snprintf(buf + strlen(buf), buf_size - strlen(buf),
                      ", %d/%d",
@@ -1180,6 +1195,7 @@
             break;
         case CODEC_ID_PCM_S16LE:
         case CODEC_ID_PCM_S16BE:
+        case CODEC_ID_PCM_S16LE_PLANAR:
         case CODEC_ID_PCM_U16LE:
         case CODEC_ID_PCM_U16BE:
             bitrate = enc->sample_rate * enc->channels * 16;
@@ -1203,6 +1219,10 @@
         snprintf(buf, buf_size, "Subtitle: %s", codec_name);
         bitrate = enc->bit_rate;
         break;
+    case CODEC_TYPE_ATTACHMENT:
+        snprintf(buf, buf_size, "Attachment: %s", codec_name);
+        bitrate = enc->bit_rate;
+        break;
     default:
         snprintf(buf, buf_size, "Invalid Codec type %d", enc->codec_type);
         return;
@@ -1231,17 +1251,6 @@
   return LIBAVCODEC_BUILD;
 }
 
-static void init_crcs(void){
-#if LIBAVUTIL_VERSION_INT  < (50<<16)
-    av_crc04C11DB7= av_mallocz_static(sizeof(AVCRC) * 257);
-    av_crc8005    = av_mallocz_static(sizeof(AVCRC) * 257);
-    av_crc07      = av_mallocz_static(sizeof(AVCRC) * 257);
-#endif
-    av_crc_init(av_crc04C11DB7, 0, 32, AV_CRC_32_IEEE, sizeof(AVCRC)*257);
-    av_crc_init(av_crc8005    , 0, 16, AV_CRC_16     , sizeof(AVCRC)*257);
-    av_crc_init(av_crc07      , 0,  8, AV_CRC_8_ATM  , sizeof(AVCRC)*257);
-}
-
 void avcodec_init(void)
 {
     static int inited = 0;
@@ -1251,7 +1260,6 @@
     inited = 1;
 
     dsputil_static_init();
-    init_crcs();
 }
 
 void avcodec_flush_buffers(AVCodecContext *avctx)
@@ -1305,6 +1313,7 @@
         return 8;
     case CODEC_ID_PCM_S16BE:
     case CODEC_ID_PCM_S16LE:
+    case CODEC_ID_PCM_S16LE_PLANAR:
     case CODEC_ID_PCM_U16BE:
     case CODEC_ID_PCM_U16LE:
         return 16;
Only in ffmpeg-free-0.svn20080206/libavcodec: vb.c
diff -u mplayer-1.0~rc2-12/libavcodec/vc1acdata.h ffmpeg-free-0.svn20080206/libavcodec/vc1acdata.h
--- mplayer-1.0~rc2-12/libavcodec/vc1acdata.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vc1acdata.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_VC1ACDATA_H
-#define AVCODEC_VC1ACDATA_H
+#ifndef FFMPEG_VC1ACDATA_H
+#define FFMPEG_VC1ACDATA_H
 
 #include <stdint.h>
 
@@ -589,4 +589,4 @@
 }
 };
 
-#endif // AVCODEC_VC1ACDATA_H
+#endif /* FFMPEG_VC1ACDATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/vc1.c ffmpeg-free-0.svn20080206/libavcodec/vc1.c
--- mplayer-1.0~rc2-12/libavcodec/vc1.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vc1.c	2008-03-20 19:10:59.000000000 +0100
@@ -33,6 +33,7 @@
 #include "vc1acdata.h"
 #include "msmpeg4data.h"
 #include "unary.h"
+#include "simple_idct.h"
 
 #undef NDEBUG
 #include <assert.h>
@@ -43,13 +44,6 @@
 static const uint16_t table_mb_intra[64][2];
 
 
-static inline int decode210(GetBitContext *gb){
-    if (get_bits1(gb))
-        return 0;
-    else
-        return 2 - get_bits1(gb);
-}
-
 /**
  * Init VC-1 specific tables and VC1Context members
  * @param v The VC1Context to initialize
@@ -783,10 +777,14 @@
 
     if (v->profile == PROFILE_ADVANCED)
     {
+        v->zz_8x4 = ff_vc1_adv_progressive_8x4_zz;
+        v->zz_4x8 = ff_vc1_adv_progressive_4x8_zz;
         return decode_sequence_header_adv(v, gb);
     }
     else
     {
+        v->zz_8x4 = ff_vc1_simple_progressive_8x4_zz;
+        v->zz_4x8 = ff_vc1_simple_progressive_4x8_zz;
         v->res_sm = get_bits(gb, 2); //reserved
         if (v->res_sm)
         {
@@ -808,19 +806,14 @@
     }
 
     v->res_x8 = get_bits1(gb); //reserved
-    if (v->res_x8)
-    {
-        av_log(avctx, AV_LOG_ERROR,
-               "1 for reserved RES_X8 is forbidden\n");
-        //return -1;
-    }
     v->multires = get_bits1(gb);
     v->res_fasttx = get_bits1(gb);
     if (!v->res_fasttx)
     {
-        av_log(avctx, AV_LOG_ERROR,
-               "0 for reserved RES_FASTTX is forbidden\n");
-        //return -1;
+        v->s.dsp.vc1_inv_trans_8x8 = ff_simple_idct;
+        v->s.dsp.vc1_inv_trans_8x4 = ff_simple_idct84_add;
+        v->s.dsp.vc1_inv_trans_4x8 = ff_simple_idct48_add;
+        v->s.dsp.vc1_inv_trans_4x4 = ff_simple_idct44_add;
     }
 
     v->fastuvmc =  get_bits1(gb); //common
@@ -1072,6 +1065,7 @@
 
     /* Quantizer stuff */
     pqindex = get_bits(gb, 5);
+    if(!pqindex) return -1;
     if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)
         v->pq = ff_vc1_pquant_table[0][pqindex];
     else
@@ -1101,8 +1095,8 @@
         if (v->multires && v->s.pict_type != B_TYPE) v->respic = get_bits(gb, 2);
 
     if(v->res_x8 && (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)){
-        if(get_bits1(gb))return -1;
-    }
+        v->x8_type = get_bits1(gb);
+    }else v->x8_type = 0;
 //av_log(v->s.avctx, AV_LOG_INFO, "%c Frame: QP=[%i]%i (+%i/2) %i\n",
 //        (v->s.pict_type == P_TYPE) ? 'P' : ((v->s.pict_type == I_TYPE) ? 'I' : 'B'), pqindex, v->pq, v->halfpq, v->rangeredfrm);
 
@@ -1235,14 +1229,17 @@
         break;
     }
 
-    /* AC Syntax */
-    v->c_ac_table_index = decode012(gb);
-    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)
+    if(!v->x8_type)
     {
-        v->y_ac_table_index = decode012(gb);
+        /* AC Syntax */
+        v->c_ac_table_index = decode012(gb);
+        if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)
+        {
+            v->y_ac_table_index = decode012(gb);
+        }
+        /* DC Syntax */
+        v->s.dc_table_index = get_bits1(gb);
     }
-    /* DC Syntax */
-    v->s.dc_table_index = get_bits1(gb);
 
     if(v->s.pict_type == BI_TYPE) {
         v->s.pict_type = B_TYPE;
@@ -1305,6 +1302,7 @@
         }
     }
     pqindex = get_bits(gb, 5);
+    if(!pqindex) return -1;
     v->pqindex = pqindex;
     if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)
         v->pq = ff_vc1_pquant_table[0][pqindex];
@@ -2888,7 +2886,8 @@
 
 /** Decode P block
  */
-static int vc1_decode_p_block(VC1Context *v, DCTELEM block[64], int n, int mquant, int ttmb, int first_block)
+static int vc1_decode_p_block(VC1Context *v, DCTELEM block[64], int n, int mquant, int ttmb, int first_block,
+                              uint8_t *dst, int linesize, int skip_block)
 {
     MpegEncContext *s = &v->s;
     GetBitContext *gb = &s->gb;
@@ -2934,7 +2933,10 @@
             if(!v->pquantizer)
                 block[idx] += (block[idx] < 0) ? -mquant : mquant;
         }
-        s->dsp.vc1_inv_trans_8x8(block);
+        if(!skip_block){
+            s->dsp.vc1_inv_trans_8x8(block);
+            s->dsp.add_pixels_clamped(block, dst, linesize);
+        }
         break;
     case TT_4X4:
         for(j = 0; j < 4; j++) {
@@ -2951,8 +2953,8 @@
                 if(!v->pquantizer)
                     block[idx + off] += (block[idx + off] < 0) ? -mquant : mquant;
             }
-            if(!(subblkpat & (1 << (3 - j))))
-                s->dsp.vc1_inv_trans_4x4(block, j);
+            if(!(subblkpat & (1 << (3 - j))) && !skip_block)
+                s->dsp.vc1_inv_trans_4x4(dst + (j&1)*4 + (j&2)*2*linesize, linesize, block + off);
         }
         break;
     case TT_8X4:
@@ -2965,16 +2967,13 @@
                 i += skip;
                 if(i > 31)
                     break;
-                if(v->profile < PROFILE_ADVANCED)
-                    idx = ff_vc1_simple_progressive_8x4_zz[i++];
-                else
-                    idx = ff_vc1_adv_progressive_8x4_zz[i++];
-                block[idx + off] = value * scale;
+                idx = v->zz_8x4[i++]+off;
+                block[idx] = value * scale;
                 if(!v->pquantizer)
-                    block[idx + off] += (block[idx + off] < 0) ? -mquant : mquant;
+                    block[idx] += (block[idx] < 0) ? -mquant : mquant;
             }
-            if(!(subblkpat & (1 << (1 - j))))
-                s->dsp.vc1_inv_trans_8x4(block, j);
+            if(!(subblkpat & (1 << (1 - j))) && !skip_block)
+                s->dsp.vc1_inv_trans_8x4(dst + j*4*linesize, linesize, block + off);
         }
         break;
     case TT_4X8:
@@ -2987,16 +2986,13 @@
                 i += skip;
                 if(i > 31)
                     break;
-                if(v->profile < PROFILE_ADVANCED)
-                    idx = ff_vc1_simple_progressive_4x8_zz[i++];
-                else
-                    idx = ff_vc1_adv_progressive_4x8_zz[i++];
-                block[idx + off] = value * scale;
+                idx = v->zz_4x8[i++]+off;
+                block[idx] = value * scale;
                 if(!v->pquantizer)
-                    block[idx + off] += (block[idx + off] < 0) ? -mquant : mquant;
+                    block[idx] += (block[idx] < 0) ? -mquant : mquant;
             }
-            if(!(subblkpat & (1 << (1 - j))))
-                s->dsp.vc1_inv_trans_4x8(block, j);
+            if(!(subblkpat & (1 << (1 - j))) && !skip_block)
+                s->dsp.vc1_inv_trans_4x8(dst + j*4, linesize, block + off);
         }
         break;
     }
@@ -3097,9 +3093,7 @@
                     if((i>3) && (s->flags & CODEC_FLAG_GRAY)) continue;
                     s->dsp.vc1_inv_trans_8x8(s->block[i]);
                     if(v->rangeredfrm) for(j = 0; j < 64; j++) s->block[i][j] <<= 1;
-                    for(j = 0; j < 64; j++) s->block[i][j] += 128;
-                    if(!v->res_fasttx && v->res_x8) for(j = 0; j < 64; j++) s->block[i][j] += 16;
-                    s->dsp.put_pixels_clamped(s->block[i], s->dest[dst_idx] + off, s->linesize >> ((i & 4) >> 2));
+                    s->dsp.put_signed_pixels_clamped(s->block[i], s->dest[dst_idx] + off, s->linesize >> ((i & 4) >> 2));
                     if(v->pq >= 9 && v->overlap) {
                         if(v->c_avail)
                             s->dsp.vc1_h_overlap(s->dest[dst_idx] + off, s->linesize >> ((i & 4) >> 2));
@@ -3107,11 +3101,9 @@
                             s->dsp.vc1_v_overlap(s->dest[dst_idx] + off, s->linesize >> ((i & 4) >> 2));
                     }
                 } else if(val) {
-                    vc1_decode_p_block(v, s->block[i], i, mquant, ttmb, first_block);
+                    vc1_decode_p_block(v, s->block[i], i, mquant, ttmb, first_block, s->dest[dst_idx] + off, (i&4)?s->uvlinesize:s->linesize, (i&4) && (s->flags & CODEC_FLAG_GRAY));
                     if(!v->ttmbf && ttmb < 8) ttmb = -1;
                     first_block = 0;
-                    if((i<4) || !(s->flags & CODEC_FLAG_GRAY))
-                        s->dsp.add_pixels_clamped(s->block[i], s->dest[dst_idx] + off, (i&4)?s->uvlinesize:s->linesize);
                 }
             }
         }
@@ -3201,9 +3193,7 @@
                     if((i>3) && (s->flags & CODEC_FLAG_GRAY)) continue;
                     s->dsp.vc1_inv_trans_8x8(s->block[i]);
                     if(v->rangeredfrm) for(j = 0; j < 64; j++) s->block[i][j] <<= 1;
-                    for(j = 0; j < 64; j++) s->block[i][j] += 128;
-                    if(!v->res_fasttx && v->res_x8) for(j = 0; j < 64; j++) s->block[i][j] += 16;
-                    s->dsp.put_pixels_clamped(s->block[i], s->dest[dst_idx] + off, (i&4)?s->uvlinesize:s->linesize);
+                    s->dsp.put_signed_pixels_clamped(s->block[i], s->dest[dst_idx] + off, (i&4)?s->uvlinesize:s->linesize);
                     if(v->pq >= 9 && v->overlap) {
                         if(v->c_avail)
                             s->dsp.vc1_h_overlap(s->dest[dst_idx] + off, s->linesize >> ((i & 4) >> 2));
@@ -3211,11 +3201,9 @@
                             s->dsp.vc1_v_overlap(s->dest[dst_idx] + off, s->linesize >> ((i & 4) >> 2));
                     }
                 } else if(is_coded[i]) {
-                    status = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb, first_block);
+                    status = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb, first_block, s->dest[dst_idx] + off, (i&4)?s->uvlinesize:s->linesize, (i&4) && (s->flags & CODEC_FLAG_GRAY));
                     if(!v->ttmbf && ttmb < 8) ttmb = -1;
                     first_block = 0;
-                    if((i<4) || !(s->flags & CODEC_FLAG_GRAY))
-                        s->dsp.add_pixels_clamped(s->block[i], s->dest[dst_idx] + off, (i&4)?s->uvlinesize:s->linesize);
                 }
             }
             return status;
@@ -3383,14 +3371,11 @@
             if((i>3) && (s->flags & CODEC_FLAG_GRAY)) continue;
             s->dsp.vc1_inv_trans_8x8(s->block[i]);
             if(v->rangeredfrm) for(j = 0; j < 64; j++) s->block[i][j] <<= 1;
-            for(j = 0; j < 64; j++) s->block[i][j] += 128;
-            s->dsp.put_pixels_clamped(s->block[i], s->dest[dst_idx] + off, s->linesize >> ((i & 4) >> 2));
+            s->dsp.put_signed_pixels_clamped(s->block[i], s->dest[dst_idx] + off, s->linesize >> ((i & 4) >> 2));
         } else if(val) {
-            vc1_decode_p_block(v, s->block[i], i, mquant, ttmb, first_block);
+            vc1_decode_p_block(v, s->block[i], i, mquant, ttmb, first_block, s->dest[dst_idx] + off, (i&4)?s->uvlinesize:s->linesize, (i&4) && (s->flags & CODEC_FLAG_GRAY));
             if(!v->ttmbf && ttmb < 8) ttmb = -1;
             first_block = 0;
-            if((i<4) || !(s->flags & CODEC_FLAG_GRAY))
-                s->dsp.add_pixels_clamped(s->block[i], s->dest[dst_idx] + off, (i&4)?s->uvlinesize:s->linesize);
         }
     }
 }
@@ -3466,7 +3451,6 @@
                 vc1_decode_i_block(v, s->block[k], k, val, (k<4)? v->codingset : v->codingset2);
 
                 s->dsp.vc1_inv_trans_8x8(s->block[k]);
-                if(!v->res_fasttx && !v->res_x8) for(j = 0; j < 64; j++) s->block[k][j] -= 16;
                 if(v->pq >= 9 && v->overlap) {
                     for(j = 0; j < 64; j++) s->block[k][j] += 128;
                 }
@@ -3759,36 +3743,40 @@
 {
 
     v->s.esc3_level_length = 0;
+    if(v->x8_type){
+        ff_intrax8_decode_picture(&v->x8, 2*v->pq+v->halfpq, v->pq*(!v->pquantizer) );
+    }else{
 
-    switch(v->s.pict_type) {
-    case I_TYPE:
-        if(v->profile == PROFILE_ADVANCED)
-            vc1_decode_i_blocks_adv(v);
-        else
-            vc1_decode_i_blocks(v);
-        break;
-    case P_TYPE:
-        if(v->p_frame_skipped)
-            vc1_decode_skip_blocks(v);
-        else
-            vc1_decode_p_blocks(v);
-        break;
-    case B_TYPE:
-        if(v->bi_type){
+        switch(v->s.pict_type) {
+        case I_TYPE:
             if(v->profile == PROFILE_ADVANCED)
                 vc1_decode_i_blocks_adv(v);
             else
                 vc1_decode_i_blocks(v);
-        }else
-            vc1_decode_b_blocks(v);
-        break;
+            break;
+        case P_TYPE:
+            if(v->p_frame_skipped)
+                vc1_decode_skip_blocks(v);
+            else
+                vc1_decode_p_blocks(v);
+            break;
+        case B_TYPE:
+            if(v->bi_type){
+                if(v->profile == PROFILE_ADVANCED)
+                    vc1_decode_i_blocks_adv(v);
+                else
+                    vc1_decode_i_blocks(v);
+            }else
+                vc1_decode_b_blocks(v);
+            break;
+        }
     }
 }
 
 /** Find VC-1 marker in buffer
  * @return position where next marker starts or end of buffer if no marker found
  */
-static av_always_inline uint8_t* find_next_marker(uint8_t *src, uint8_t *end)
+static av_always_inline const uint8_t* find_next_marker(const uint8_t *src, const uint8_t *end)
 {
     uint32_t mrk = 0xFFFFFFFF;
 
@@ -3801,7 +3789,7 @@
     return end;
 }
 
-static av_always_inline int vc1_unescape_buffer(uint8_t *src, int size, uint8_t *dst)
+static av_always_inline int vc1_unescape_buffer(const uint8_t *src, int size, uint8_t *dst)
 {
     int dsize = 0, i;
 
@@ -3839,6 +3827,10 @@
     avctx->flags |= CODEC_FLAG_EMU_EDGE;
     v->s.flags |= CODEC_FLAG_EMU_EDGE;
 
+    if(avctx->idct_algo==FF_IDCT_AUTO){
+        avctx->idct_algo=FF_IDCT_WMV2;
+    }
+
     if(ff_h263_decode_init(avctx) < 0)
         return -1;
     if (vc1_init_common(v) < 0) return -1;
@@ -3870,8 +3862,10 @@
             av_log(avctx, AV_LOG_INFO, "Read %i bits in overflow\n", -count);
         }
     } else { // VC1/WVC1
-        uint8_t *start = avctx->extradata, *end = avctx->extradata + avctx->extradata_size;
-        uint8_t *next; int size, buf2_size;
+        const uint8_t *start = avctx->extradata;
+        uint8_t *end = avctx->extradata + avctx->extradata_size;
+        const uint8_t *next;
+        int size, buf2_size;
         uint8_t *buf2 = NULL;
         int seq_inited = 0, ep_inited = 0;
 
@@ -3939,6 +3933,7 @@
 //            return -1;
     }
 
+    ff_intrax8_common_init(&v->x8,s);
     return 0;
 }
 
@@ -3948,7 +3943,7 @@
  */
 static int vc1_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     VC1Context *v = avctx->priv_data;
     MpegEncContext *s = &v->s;
@@ -3981,7 +3976,7 @@
         buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
         if(IS_MARKER(AV_RB32(buf))){ /* frame starts with marker and needs to be parsed */
-            uint8_t *start, *end, *next;
+            const uint8_t *start, *end, *next;
             int size;
 
             next = buf;
@@ -4005,7 +4000,7 @@
                 }
             }
         }else if(v->interlace && ((buf[0] & 0xC0) == 0xC0)){ /* WVC1 interlaced stores both fields divided by marker */
-            uint8_t *divider;
+            const uint8_t *divider;
 
             divider = find_next_marker(buf, buf + buf_size);
             if((divider == (buf + buf_size)) || AV_RB32(divider) != VC1_CODE_FIELD){
@@ -4103,7 +4098,7 @@
     }
 
     /* Return the Picture timestamp as the frame number */
-    /* we substract 1 because it is added on utils.c    */
+    /* we subtract 1 because it is added on utils.c     */
     avctx->frame_number = s->picture_number - 1;
 
     av_free(buf2);
@@ -4126,6 +4121,7 @@
     av_freep(&v->acpred_plane);
     av_freep(&v->over_flags_plane);
     av_freep(&v->mb_type_base);
+    ff_intrax8_common_end(&v->x8);
     return 0;
 }
 
diff -u mplayer-1.0~rc2-12/libavcodec/vc1data.h ffmpeg-free-0.svn20080206/libavcodec/vc1data.h
--- mplayer-1.0~rc2-12/libavcodec/vc1data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vc1data.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * VC-1 tables.
  */
 
-#ifndef VC1DATA_H
-#define VC1DATA_H
+#ifndef FFMPEG_VC1DATA_H
+#define FFMPEG_VC1DATA_H
 
 #include <stdint.h>
 #include "bitstream.h"
@@ -160,4 +160,4 @@
 /* DQScale as specified in 8.1.3.9 - almost identical to 0x40000/i */
 extern const int32_t ff_vc1_dqscale[63];
 
-#endif /* VC1DATA_H */
+#endif /* FFMPEG_VC1DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/vc1dsp.c ffmpeg-free-0.svn20080206/libavcodec/vc1dsp.c
--- mplayer-1.0~rc2-12/libavcodec/vc1dsp.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vc1dsp.c	2008-03-20 19:10:59.000000000 +0100
@@ -90,8 +90,8 @@
     src = block;
     dst = block;
     for(i = 0; i < 8; i++){
-        t1 = 12 * (src[0] + src[4]);
-        t2 = 12 * (src[0] - src[4]);
+        t1 = 12 * (src[0] + src[4]) + 4;
+        t2 = 12 * (src[0] - src[4]) + 4;
         t3 = 16 * src[2] +  6 * src[6];
         t4 =  6 * src[2] - 16 * src[6];
 
@@ -105,14 +105,14 @@
         t3 =  9 * src[1] - 16 * src[3] +  4 * src[5] + 15 * src[7];
         t4 =  4 * src[1] -  9 * src[3] + 15 * src[5] - 16 * src[7];
 
-        dst[0] = (t5 + t1 + 4) >> 3;
-        dst[1] = (t6 + t2 + 4) >> 3;
-        dst[2] = (t7 + t3 + 4) >> 3;
-        dst[3] = (t8 + t4 + 4) >> 3;
-        dst[4] = (t8 - t4 + 4) >> 3;
-        dst[5] = (t7 - t3 + 4) >> 3;
-        dst[6] = (t6 - t2 + 4) >> 3;
-        dst[7] = (t5 - t1 + 4) >> 3;
+        dst[0] = (t5 + t1) >> 3;
+        dst[1] = (t6 + t2) >> 3;
+        dst[2] = (t7 + t3) >> 3;
+        dst[3] = (t8 + t4) >> 3;
+        dst[4] = (t8 - t4) >> 3;
+        dst[5] = (t7 - t3) >> 3;
+        dst[6] = (t6 - t2) >> 3;
+        dst[7] = (t5 - t1) >> 3;
 
         src += 8;
         dst += 8;
@@ -121,8 +121,8 @@
     src = block;
     dst = block;
     for(i = 0; i < 8; i++){
-        t1 = 12 * (src[ 0] + src[32]);
-        t2 = 12 * (src[ 0] - src[32]);
+        t1 = 12 * (src[ 0] + src[32]) + 64;
+        t2 = 12 * (src[ 0] - src[32]) + 64;
         t3 = 16 * src[16] +  6 * src[48];
         t4 =  6 * src[16] - 16 * src[48];
 
@@ -136,14 +136,14 @@
         t3 =  9 * src[ 8] - 16 * src[24] +  4 * src[40] + 15 * src[56];
         t4 =  4 * src[ 8] -  9 * src[24] + 15 * src[40] - 16 * src[56];
 
-        dst[ 0] = (t5 + t1 + 64) >> 7;
-        dst[ 8] = (t6 + t2 + 64) >> 7;
-        dst[16] = (t7 + t3 + 64) >> 7;
-        dst[24] = (t8 + t4 + 64) >> 7;
-        dst[32] = (t8 - t4 + 64 + 1) >> 7;
-        dst[40] = (t7 - t3 + 64 + 1) >> 7;
-        dst[48] = (t6 - t2 + 64 + 1) >> 7;
-        dst[56] = (t5 - t1 + 64 + 1) >> 7;
+        dst[ 0] = (t5 + t1) >> 7;
+        dst[ 8] = (t6 + t2) >> 7;
+        dst[16] = (t7 + t3) >> 7;
+        dst[24] = (t8 + t4) >> 7;
+        dst[32] = (t8 - t4 + 1) >> 7;
+        dst[40] = (t7 - t3 + 1) >> 7;
+        dst[48] = (t6 - t2 + 1) >> 7;
+        dst[56] = (t5 - t1 + 1) >> 7;
 
         src++;
         dst++;
@@ -152,19 +152,18 @@
 
 /** Do inverse transform on 8x4 part of block
 */
-static void vc1_inv_trans_8x4_c(DCTELEM block[64], int n)
+static void vc1_inv_trans_8x4_c(uint8_t *dest, int linesize, DCTELEM *block)
 {
     int i;
     register int t1,t2,t3,t4,t5,t6,t7,t8;
     DCTELEM *src, *dst;
-    int off;
+    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
 
-    off = n * 32;
-    src = block + off;
-    dst = block + off;
+    src = block;
+    dst = block;
     for(i = 0; i < 4; i++){
-        t1 = 12 * (src[0] + src[4]);
-        t2 = 12 * (src[0] - src[4]);
+        t1 = 12 * (src[0] + src[4]) + 4;
+        t2 = 12 * (src[0] - src[4]) + 4;
         t3 = 16 * src[2] +  6 * src[6];
         t4 =  6 * src[2] - 16 * src[6];
 
@@ -178,73 +177,66 @@
         t3 =  9 * src[1] - 16 * src[3] +  4 * src[5] + 15 * src[7];
         t4 =  4 * src[1] -  9 * src[3] + 15 * src[5] - 16 * src[7];
 
-        dst[0] = (t5 + t1 + 4) >> 3;
-        dst[1] = (t6 + t2 + 4) >> 3;
-        dst[2] = (t7 + t3 + 4) >> 3;
-        dst[3] = (t8 + t4 + 4) >> 3;
-        dst[4] = (t8 - t4 + 4) >> 3;
-        dst[5] = (t7 - t3 + 4) >> 3;
-        dst[6] = (t6 - t2 + 4) >> 3;
-        dst[7] = (t5 - t1 + 4) >> 3;
+        dst[0] = (t5 + t1) >> 3;
+        dst[1] = (t6 + t2) >> 3;
+        dst[2] = (t7 + t3) >> 3;
+        dst[3] = (t8 + t4) >> 3;
+        dst[4] = (t8 - t4) >> 3;
+        dst[5] = (t7 - t3) >> 3;
+        dst[6] = (t6 - t2) >> 3;
+        dst[7] = (t5 - t1) >> 3;
 
         src += 8;
         dst += 8;
     }
 
-    src = block + off;
-    dst = block + off;
+    src = block;
     for(i = 0; i < 8; i++){
-        t1 = 17 * (src[ 0] + src[16]);
-        t2 = 17 * (src[ 0] - src[16]);
-        t3 = 22 * src[ 8];
-        t4 = 22 * src[24];
-        t5 = 10 * src[ 8];
-        t6 = 10 * src[24];
-
-        dst[ 0] = (t1 + t3 + t6 + 64) >> 7;
-        dst[ 8] = (t2 - t4 + t5 + 64) >> 7;
-        dst[16] = (t2 + t4 - t5 + 64) >> 7;
-        dst[24] = (t1 - t3 - t6 + 64) >> 7;
+        t1 = 17 * (src[ 0] + src[16]) + 64;
+        t2 = 17 * (src[ 0] - src[16]) + 64;
+        t3 = 22 * src[ 8] + 10 * src[24];
+        t4 = 22 * src[24] - 10 * src[ 8];
+
+        dest[0*linesize] = cm[dest[0*linesize] + ((t1 + t3) >> 7)];
+        dest[1*linesize] = cm[dest[1*linesize] + ((t2 - t4) >> 7)];
+        dest[2*linesize] = cm[dest[2*linesize] + ((t2 + t4) >> 7)];
+        dest[3*linesize] = cm[dest[3*linesize] + ((t1 - t3) >> 7)];
 
         src ++;
-        dst ++;
+        dest++;
     }
 }
 
 /** Do inverse transform on 4x8 parts of block
 */
-static void vc1_inv_trans_4x8_c(DCTELEM block[64], int n)
+static void vc1_inv_trans_4x8_c(uint8_t *dest, int linesize, DCTELEM *block)
 {
     int i;
     register int t1,t2,t3,t4,t5,t6,t7,t8;
     DCTELEM *src, *dst;
-    int off;
+    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
 
-    off = n * 4;
-    src = block + off;
-    dst = block + off;
+    src = block;
+    dst = block;
     for(i = 0; i < 8; i++){
-        t1 = 17 * (src[0] + src[2]);
-        t2 = 17 * (src[0] - src[2]);
-        t3 = 22 * src[1];
-        t4 = 22 * src[3];
-        t5 = 10 * src[1];
-        t6 = 10 * src[3];
-
-        dst[0] = (t1 + t3 + t6 + 4) >> 3;
-        dst[1] = (t2 - t4 + t5 + 4) >> 3;
-        dst[2] = (t2 + t4 - t5 + 4) >> 3;
-        dst[3] = (t1 - t3 - t6 + 4) >> 3;
+        t1 = 17 * (src[0] + src[2]) + 4;
+        t2 = 17 * (src[0] - src[2]) + 4;
+        t3 = 22 * src[1] + 10 * src[3];
+        t4 = 22 * src[3] - 10 * src[1];
+
+        dst[0] = (t1 + t3) >> 3;
+        dst[1] = (t2 - t4) >> 3;
+        dst[2] = (t2 + t4) >> 3;
+        dst[3] = (t1 - t3) >> 3;
 
         src += 8;
         dst += 8;
     }
 
-    src = block + off;
-    dst = block + off;
+    src = block;
     for(i = 0; i < 4; i++){
-        t1 = 12 * (src[ 0] + src[32]);
-        t2 = 12 * (src[ 0] - src[32]);
+        t1 = 12 * (src[ 0] + src[32]) + 64;
+        t2 = 12 * (src[ 0] - src[32]) + 64;
         t3 = 16 * src[16] +  6 * src[48];
         t4 =  6 * src[16] - 16 * src[48];
 
@@ -258,66 +250,60 @@
         t3 =  9 * src[ 8] - 16 * src[24] +  4 * src[40] + 15 * src[56];
         t4 =  4 * src[ 8] -  9 * src[24] + 15 * src[40] - 16 * src[56];
 
-        dst[ 0] = (t5 + t1 + 64) >> 7;
-        dst[ 8] = (t6 + t2 + 64) >> 7;
-        dst[16] = (t7 + t3 + 64) >> 7;
-        dst[24] = (t8 + t4 + 64) >> 7;
-        dst[32] = (t8 - t4 + 64 + 1) >> 7;
-        dst[40] = (t7 - t3 + 64 + 1) >> 7;
-        dst[48] = (t6 - t2 + 64 + 1) >> 7;
-        dst[56] = (t5 - t1 + 64 + 1) >> 7;
+        dest[0*linesize] = cm[dest[0*linesize] + ((t5 + t1) >> 7)];
+        dest[1*linesize] = cm[dest[1*linesize] + ((t6 + t2) >> 7)];
+        dest[2*linesize] = cm[dest[2*linesize] + ((t7 + t3) >> 7)];
+        dest[3*linesize] = cm[dest[3*linesize] + ((t8 + t4) >> 7)];
+        dest[4*linesize] = cm[dest[4*linesize] + ((t8 - t4 + 1) >> 7)];
+        dest[5*linesize] = cm[dest[5*linesize] + ((t7 - t3 + 1) >> 7)];
+        dest[6*linesize] = cm[dest[6*linesize] + ((t6 - t2 + 1) >> 7)];
+        dest[7*linesize] = cm[dest[7*linesize] + ((t5 - t1 + 1) >> 7)];
 
-        src++;
-        dst++;
+        src ++;
+        dest++;
     }
 }
 
 /** Do inverse transform on 4x4 part of block
 */
-static void vc1_inv_trans_4x4_c(DCTELEM block[64], int n)
+static void vc1_inv_trans_4x4_c(uint8_t *dest, int linesize, DCTELEM *block)
 {
     int i;
-    register int t1,t2,t3,t4,t5,t6;
+    register int t1,t2,t3,t4;
     DCTELEM *src, *dst;
-    int off;
+    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
 
-    off = (n&1) * 4 + (n&2) * 16;
-    src = block + off;
-    dst = block + off;
+    src = block;
+    dst = block;
     for(i = 0; i < 4; i++){
-        t1 = 17 * (src[0] + src[2]);
-        t2 = 17 * (src[0] - src[2]);
-        t3 = 22 * src[1];
-        t4 = 22 * src[3];
-        t5 = 10 * src[1];
-        t6 = 10 * src[3];
-
-        dst[0] = (t1 + t3 + t6 + 4) >> 3;
-        dst[1] = (t2 - t4 + t5 + 4) >> 3;
-        dst[2] = (t2 + t4 - t5 + 4) >> 3;
-        dst[3] = (t1 - t3 - t6 + 4) >> 3;
+        t1 = 17 * (src[0] + src[2]) + 4;
+        t2 = 17 * (src[0] - src[2]) + 4;
+        t3 = 22 * src[1] + 10 * src[3];
+        t4 = 22 * src[3] - 10 * src[1];
+
+        dst[0] = (t1 + t3) >> 3;
+        dst[1] = (t2 - t4) >> 3;
+        dst[2] = (t2 + t4) >> 3;
+        dst[3] = (t1 - t3) >> 3;
 
         src += 8;
         dst += 8;
     }
 
-    src = block + off;
-    dst = block + off;
+    src = block;
     for(i = 0; i < 4; i++){
-        t1 = 17 * (src[ 0] + src[16]);
-        t2 = 17 * (src[ 0] - src[16]);
-        t3 = 22 * src[ 8];
-        t4 = 22 * src[24];
-        t5 = 10 * src[ 8];
-        t6 = 10 * src[24];
-
-        dst[ 0] = (t1 + t3 + t6 + 64) >> 7;
-        dst[ 8] = (t2 - t4 + t5 + 64) >> 7;
-        dst[16] = (t2 + t4 - t5 + 64) >> 7;
-        dst[24] = (t1 - t3 - t6 + 64) >> 7;
+        t1 = 17 * (src[ 0] + src[16]) + 64;
+        t2 = 17 * (src[ 0] - src[16]) + 64;
+        t3 = 22 * src[ 8] + 10 * src[24];
+        t4 = 22 * src[24] - 10 * src[ 8];
+
+        dest[0*linesize] = cm[dest[0*linesize] + ((t1 + t3) >> 7)];
+        dest[1*linesize] = cm[dest[1*linesize] + ((t2 - t4) >> 7)];
+        dest[2*linesize] = cm[dest[2*linesize] + ((t2 + t4) >> 7)];
+        dest[3*linesize] = cm[dest[3*linesize] + ((t1 - t3) >> 7)];
 
         src ++;
-        dst ++;
+        dest++;
     }
 }
 
diff -u mplayer-1.0~rc2-12/libavcodec/vc1.h ffmpeg-free-0.svn20080206/libavcodec/vc1.h
--- mplayer-1.0~rc2-12/libavcodec/vc1.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vc1.h	2008-01-14 07:10:02.000000000 +0100
@@ -20,11 +20,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_VC1_H
-#define AVCODEC_VC1_H
+#ifndef FFMPEG_VC1_H
+#define FFMPEG_VC1_H
 
 #include "avcodec.h"
 #include "mpegvideo.h"
+#include "intrax8.h"
 
 /** Markers used in VC-1 AP frame data */
 //@{
@@ -156,6 +157,7 @@
  */
 typedef struct VC1Context{
     MpegEncContext s;
+    IntraX8Context x8;
 
     int bits;
 
@@ -214,6 +216,8 @@
     int k_y;              ///< Number of bits for MVs (depends on MV range)
     int range_x, range_y; ///< MV range
     uint8_t pq, altpq;    ///< Current/alternate frame quantizer scale
+    const uint8_t* zz_8x4;///< Zigzag scan table for TT_8x4 coding mode
+    const uint8_t* zz_4x8;///< Zigzag scan table for TT_4x8 coding mode
     /** pquant parameters */
     //@{
     uint8_t dquantfrm;
@@ -302,6 +306,7 @@
 
     int p_frame_skipped;
     int bi_type;
+    int x8_type;
 } VC1Context;
 
-#endif // AVCODEC_VC1_H
+#endif /* FFMPEG_VC1_H */
diff -u mplayer-1.0~rc2-12/libavcodec/vcr1.c ffmpeg-free-0.svn20080206/libavcodec/vcr1.c
--- mplayer-1.0~rc2-12/libavcodec/vcr1.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vcr1.c	2008-03-20 19:10:59.000000000 +0100
@@ -39,12 +39,12 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     VCR1Context * const a = avctx->priv_data;
     AVFrame *picture = data;
     AVFrame * const p= (AVFrame*)&a->picture;
-    uint8_t *bytestream= buf;
+    const uint8_t *bytestream= buf;
     int i, x, y;
 
     if(p->data[0])
diff -u mplayer-1.0~rc2-12/libavcodec/vmdav.c ffmpeg-free-0.svn20080206/libavcodec/vmdav.c
--- mplayer-1.0~rc2-12/libavcodec/vmdav.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vmdav.c	2008-03-20 19:10:59.000000000 +0100
@@ -61,7 +61,7 @@
     AVFrame frame;
     AVFrame prev_frame;
 
-    unsigned char *buf;
+    const unsigned char *buf;
     int size;
 
     unsigned char palette[PALETTE_COUNT * 4];
@@ -74,9 +74,9 @@
 #define QUEUE_SIZE 0x1000
 #define QUEUE_MASK 0x0FFF
 
-static void lz_unpack(unsigned char *src, unsigned char *dest, int dest_len)
+static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)
 {
-    unsigned char *s;
+    const unsigned char *s;
     unsigned char *d;
     unsigned char *d_end;
     unsigned char queue[QUEUE_SIZE];
@@ -144,10 +144,10 @@
     }
 }
 
-static int rle_unpack(unsigned char *src, unsigned char *dest,
+static int rle_unpack(const unsigned char *src, unsigned char *dest,
     int src_len, int dest_len)
 {
-    unsigned char *ps;
+    const unsigned char *ps;
     unsigned char *pd;
     int i, l;
     unsigned char *dest_end = dest + dest_len;
@@ -190,9 +190,9 @@
     unsigned char r, g, b;
 
     /* point to the start of the encoded data */
-    unsigned char *p = s->buf + 16;
+    const unsigned char *p = s->buf + 16;
 
-    unsigned char *pb;
+    const unsigned char *pb;
     unsigned char meth;
     unsigned char *dp;   /* pointer to current frame */
     unsigned char *pp;   /* pointer to previous frame */
@@ -368,7 +368,7 @@
 
 static int vmdvideo_decode_frame(AVCodecContext *avctx,
                                  void *data, int *data_size,
-                                 uint8_t *buf, int buf_size)
+                                 const uint8_t *buf, int buf_size)
 {
     VmdVideoContext *s = avctx->priv_data;
 
@@ -457,7 +457,7 @@
 }
 
 static void vmdaudio_decode_audio(VmdAudioContext *s, unsigned char *data,
-    uint8_t *buf, int stereo)
+    const uint8_t *buf, int stereo)
 {
     int i;
     int chan = 0;
@@ -475,7 +475,7 @@
 }
 
 static int vmdaudio_loadsound(VmdAudioContext *s, unsigned char *data,
-    uint8_t *buf, int silence)
+    const uint8_t *buf, int silence)
 {
     int bytes_decoded = 0;
     int i;
@@ -522,13 +522,13 @@
 
 static int vmdaudio_decode_frame(AVCodecContext *avctx,
                                  void *data, int *data_size,
-                                 uint8_t *buf, int buf_size)
+                                 const uint8_t *buf, int buf_size)
 {
     VmdAudioContext *s = avctx->priv_data;
     unsigned char *output_samples = (unsigned char *)data;
 
     /* point to the start of the encoded data */
-    unsigned char *p = buf + 16;
+    const unsigned char *p = buf + 16;
 
     if (buf_size < 16)
         return buf_size;
diff -u mplayer-1.0~rc2-12/libavcodec/vmnc.c ffmpeg-free-0.svn20080206/libavcodec/vmnc.c
--- mplayer-1.0~rc2-12/libavcodec/vmnc.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vmnc.c	2008-03-20 19:10:59.000000000 +0100
@@ -70,7 +70,7 @@
 } VmncContext;
 
 /* read pixel value from stream */
-static av_always_inline int vmnc_get_pixel(uint8_t* buf, int bpp, int be) {
+static av_always_inline int vmnc_get_pixel(const uint8_t* buf, int bpp, int be) {
     switch(bpp * 2 + be) {
     case 2:
     case 3: return *buf;
@@ -82,7 +82,7 @@
     }
 }
 
-static void load_cursor(VmncContext *c, uint8_t *src)
+static void load_cursor(VmncContext *c, const uint8_t *src)
 {
     int i, j, p;
     const int bpp = c->bpp2;
@@ -169,7 +169,7 @@
     }
 }
 
-/* fill rectangle with given colour */
+/* fill rectangle with given color */
 static av_always_inline void paint_rect(uint8_t *dst, int dx, int dy, int w, int h, int color, int bpp, int stride)
 {
     int i, j;
@@ -200,7 +200,7 @@
     }
 }
 
-static av_always_inline void paint_raw(uint8_t *dst, int w, int h, uint8_t* src, int bpp, int be, int stride)
+static av_always_inline void paint_raw(uint8_t *dst, int w, int h, const uint8_t* src, int bpp, int be, int stride)
 {
     int i, j, p;
     for(j = 0; j < h; j++) {
@@ -223,14 +223,14 @@
     }
 }
 
-static int decode_hextile(VmncContext *c, uint8_t* dst, uint8_t* src, int ssize, int w, int h, int stride)
+static int decode_hextile(VmncContext *c, uint8_t* dst, const uint8_t* src, int ssize, int w, int h, int stride)
 {
     int i, j, k;
     int bg = 0, fg = 0, rects, color, flags, xy, wh;
     const int bpp = c->bpp2;
     uint8_t *dst2;
     int bw = 16, bh = 16;
-    uint8_t *ssrc=src;
+    const uint8_t *ssrc=src;
 
     for(j = 0; j < h; j += 16) {
         dst2 = dst;
@@ -283,11 +283,11 @@
     return src - ssrc;
 }
 
-static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size)
 {
     VmncContext * const c = avctx->priv_data;
     uint8_t *outptr;
-    uint8_t *src = buf;
+    const uint8_t *src = buf;
     int dx, dy, w, h, depth, enc, chunks, res, size_left;
 
     c->pic.reference = 1;
diff -u mplayer-1.0~rc2-12/libavcodec/vorbis_dec.c ffmpeg-free-0.svn20080206/libavcodec/vorbis_dec.c
--- mplayer-1.0~rc2-12/libavcodec/vorbis_dec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vorbis_dec.c	2008-03-20 19:10:59.000000000 +0100
@@ -237,9 +237,9 @@
 
     AV_DEBUG(" Codebooks: %d \n", vc->codebook_count);
 
-    vc->codebooks=(vorbis_codebook *)av_mallocz(vc->codebook_count * sizeof(vorbis_codebook));
-    tmp_vlc_bits=(uint8_t *)av_mallocz(V_MAX_VLCS * sizeof(uint8_t));
-    tmp_vlc_codes=(uint32_t *)av_mallocz(V_MAX_VLCS * sizeof(uint32_t));
+    vc->codebooks=av_mallocz(vc->codebook_count * sizeof(vorbis_codebook));
+    tmp_vlc_bits =av_mallocz(V_MAX_VLCS * sizeof(uint8_t));
+    tmp_vlc_codes=av_mallocz(V_MAX_VLCS * sizeof(uint32_t));
 
     for(cb=0;cb<vc->codebook_count;++cb) {
         vorbis_codebook *codebook_setup=&vc->codebooks[cb];
@@ -351,7 +351,7 @@
             }
 
 // Weed out unused vlcs and build codevector vector
-            codebook_setup->codevectors=used_entries ? (float *)av_mallocz(used_entries*codebook_setup->dimensions * sizeof(float)) : NULL;
+            codebook_setup->codevectors=used_entries ? av_mallocz(used_entries*codebook_setup->dimensions * sizeof(float)) : NULL;
             for(j=0, i=0;i<entries;++i) {
                 uint_fast8_t dim=codebook_setup->dimensions;
 
@@ -459,7 +459,7 @@
 
     vc->floor_count=get_bits(gb, 6)+1;
 
-    vc->floors=(vorbis_floor *)av_mallocz(vc->floor_count * sizeof(vorbis_floor));
+    vc->floors=av_mallocz(vc->floor_count * sizeof(vorbis_floor));
 
     for (i=0;i<vc->floor_count;++i) {
         vorbis_floor *floor_setup=&vc->floors[i];
@@ -517,7 +517,7 @@
                 floor_setup->data.t1.x_list_dim+=floor_setup->data.t1.class_dimensions[floor_setup->data.t1.partition_class[j]];
             }
 
-            floor_setup->data.t1.list=(floor1_entry_t *)av_mallocz(floor_setup->data.t1.x_list_dim * sizeof(floor1_entry_t));
+            floor_setup->data.t1.list=av_mallocz(floor_setup->data.t1.x_list_dim * sizeof(floor1_entry_t));
 
 
             rangebits=get_bits(gb, 4);
@@ -623,7 +623,7 @@
     uint_fast8_t i, j, k;
 
     vc->residue_count=get_bits(gb, 6)+1;
-    vc->residues=(vorbis_residue *)av_mallocz(vc->residue_count * sizeof(vorbis_residue));
+    vc->residues=av_mallocz(vc->residue_count * sizeof(vorbis_residue));
 
     AV_DEBUG(" There are %d residues. \n", vc->residue_count);
 
@@ -684,7 +684,7 @@
     uint_fast8_t i, j;
 
     vc->mapping_count=get_bits(gb, 6)+1;
-    vc->mappings=(vorbis_mapping *)av_mallocz(vc->mapping_count * sizeof(vorbis_mapping));
+    vc->mappings=av_mallocz(vc->mapping_count * sizeof(vorbis_mapping));
 
     AV_DEBUG(" There are %d mappings. \n", vc->mapping_count);
 
@@ -703,8 +703,8 @@
 
         if (get_bits1(gb)) {
             mapping_setup->coupling_steps=get_bits(gb, 8)+1;
-            mapping_setup->magnitude=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));
-            mapping_setup->angle=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));
+            mapping_setup->magnitude=av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));
+            mapping_setup->angle    =av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));
             for(j=0;j<mapping_setup->coupling_steps;++j) {
                 mapping_setup->magnitude[j]=get_bits(gb, ilog(vc->audio_channels-1));
                 mapping_setup->angle[j]=get_bits(gb, ilog(vc->audio_channels-1));
@@ -722,7 +722,7 @@
         }
 
         if (mapping_setup->submaps>1) {
-            mapping_setup->mux=(uint_fast8_t *)av_mallocz(vc->audio_channels * sizeof(uint_fast8_t));
+            mapping_setup->mux=av_mallocz(vc->audio_channels * sizeof(uint_fast8_t));
             for(j=0;j<vc->audio_channels;++j) {
                 mapping_setup->mux[j]=get_bits(gb, 4);
             }
@@ -784,7 +784,7 @@
     uint_fast8_t i;
 
     vc->mode_count=get_bits(gb, 6)+1;
-    vc->modes=(vorbis_mode *)av_mallocz(vc->mode_count * sizeof(vorbis_mode));
+    vc->modes=av_mallocz(vc->mode_count * sizeof(vorbis_mode));
 
     AV_DEBUG(" There are %d modes.\n", vc->mode_count);
 
@@ -897,12 +897,12 @@
         return 2;
     }
 
-    vc->channel_residues=(float *)av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));
-    vc->channel_floors=(float *)av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));
-    vc->saved=(float *)av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));
-    vc->ret=(float *)av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));
-    vc->buf=(float *)av_malloc(vc->blocksize[1] * sizeof(float));
-    vc->buf_tmp=(float *)av_malloc(vc->blocksize[1] * sizeof(float));
+    vc->channel_residues= av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));
+    vc->channel_floors  = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));
+    vc->saved           = av_mallocz((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));
+    vc->ret             = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));
+    vc->buf             = av_malloc( vc->blocksize[1]                       * sizeof(float));
+    vc->buf_tmp         = av_malloc( vc->blocksize[1]                       * sizeof(float));
     vc->saved_start=0;
 
     ff_mdct_init(&vc->mdct[0], bl0, 1);
@@ -1006,6 +1006,7 @@
         if ( book_idx >= vf->num_books ) {
             av_log( vc->avccontext, AV_LOG_ERROR,
                     "floor0 dec: booknumber too high!\n" );
+            book_idx= 0;
             //FIXME: look above
         }
         AV_DEBUG( "floor0 dec: booknumber: %u\n", book_idx );
@@ -1578,7 +1579,7 @@
 
 static int vorbis_decode_frame(AVCodecContext *avccontext,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     vorbis_context *vc = avccontext->priv_data ;
     GetBitContext *gb = &(vc->gb);
diff -u mplayer-1.0~rc2-12/libavcodec/vorbis_enc_data.h ffmpeg-free-0.svn20080206/libavcodec/vorbis_enc_data.h
--- mplayer-1.0~rc2-12/libavcodec/vorbis_enc_data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vorbis_enc_data.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_VORBIS_ENC_DATA_H
-#define AVCODEC_VORBIS_ENC_DATA_H
+#ifndef FFMPEG_VORBIS_ENC_DATA_H
+#define FFMPEG_VORBIS_ENC_DATA_H
 
 #include <stdint.h>
 
@@ -502,4 +502,4 @@
     { 3, 2, 3, (const int[]){ -1, 12, 13, 14 } },
 };
 
-#endif // AVCODEC_VORBIS_ENC_DATA_H
+#endif /* FFMPEG_VORBIS_ENC_DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/vorbis.h ffmpeg-free-0.svn20080206/libavcodec/vorbis.h
--- mplayer-1.0~rc2-12/libavcodec/vorbis.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vorbis.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef VORBIS_H
-#define VORBIS_H
+#ifndef FFMPEG_VORBIS_H
+#define FFMPEG_VORBIS_H
 
 #include "avcodec.h"
 
@@ -40,4 +40,4 @@
 
 #define ilog(i) av_log2(2*(i))
 
-#endif
+#endif /* FFMPEG_VORBIS_H */
diff -u mplayer-1.0~rc2-12/libavcodec/vp3.c ffmpeg-free-0.svn20080206/libavcodec/vp3.c
--- mplayer-1.0~rc2-12/libavcodec/vp3.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vp3.c	2008-03-20 19:10:59.000000000 +0100
@@ -2126,7 +2126,7 @@
  */
 static int vp3_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     Vp3DecodeContext *s = avctx->priv_data;
     GetBitContext gb;
diff -u mplayer-1.0~rc2-12/libavcodec/vp3data.h ffmpeg-free-0.svn20080206/libavcodec/vp3data.h
--- mplayer-1.0~rc2-12/libavcodec/vp3data.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vp3data.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef VP3DATA_H
-#define VP3DATA_H
+#ifndef FFMPEG_VP3DATA_H
+#define FFMPEG_VP3DATA_H
 
 #include <stdint.h>
 #include <stdlib.h>
@@ -3178,4 +3178,4 @@
   }
 };
 
-#endif /* VP3DATA_H */
+#endif /* FFMPEG_VP3DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/vp56.c ffmpeg-free-0.svn20080206/libavcodec/vp56.c
--- mplayer-1.0~rc2-12/libavcodec/vp56.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vp56.c	2008-03-20 19:10:59.000000000 +0100
@@ -495,7 +495,7 @@
 }
 
 int vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
-                      uint8_t *buf, int buf_size)
+                      const uint8_t *buf, int buf_size)
 {
     vp56_context_t *s = avctx->priv_data;
     AVFrame *const p = s->framep[VP56_FRAME_CURRENT];
diff -u mplayer-1.0~rc2-12/libavcodec/vp56data.c ffmpeg-free-0.svn20080206/libavcodec/vp56data.c
--- mplayer-1.0~rc2-12/libavcodec/vp56data.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vp56data.c	2008-03-20 19:10:59.000000000 +0100
@@ -62,5 +62,5 @@
     { 2,10}, {-4}, {-5},
 };
 
-const uint8_t vp56_coeff_bias[] = { 5, 7, 11, 19, 35, 67 };
+const uint8_t vp56_coeff_bias[] = { 0, 1, 2, 3, 4, 5, 7, 11, 19, 35, 67 };
 const uint8_t vp56_coeff_bit_length[] = { 0, 1, 2, 3, 4, 10 };
diff -u mplayer-1.0~rc2-12/libavcodec/vp56data.h ffmpeg-free-0.svn20080206/libavcodec/vp56data.h
--- mplayer-1.0~rc2-12/libavcodec/vp56data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vp56data.h	2007-10-17 11:37:46.000000000 +0200
@@ -21,8 +21,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef VP56DATA_H
-#define VP56DATA_H
+#ifndef FFMPEG_VP56DATA_H
+#define FFMPEG_VP56DATA_H
 
 #include "common.h"
 
@@ -248,4 +248,4 @@
     {  2, -2 },
 };
 
-#endif /* VP56DATA */
+#endif /* FFMPEG_VP56DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/vp56.h ffmpeg-free-0.svn20080206/libavcodec/vp56.h
--- mplayer-1.0~rc2-12/libavcodec/vp56.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vp56.h	2008-02-01 17:16:40.000000000 +0100
@@ -21,8 +21,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef VP56_H
-#define VP56_H
+#ifndef FFMPEG_VP56_H
+#define FFMPEG_VP56_H
 
 #include "vp56data.h"
 #include "dsputil.h"
@@ -43,13 +43,13 @@
 typedef void (*vp56_default_models_init_t)(vp56_context_t *s);
 typedef void (*vp56_parse_vector_models_t)(vp56_context_t *s);
 typedef void (*vp56_parse_coeff_models_t)(vp56_context_t *s);
-typedef int (*vp56_parse_header_t)(vp56_context_t *s, uint8_t *buf,
+typedef int (*vp56_parse_header_t)(vp56_context_t *s, const uint8_t *buf,
                                    int buf_size, int *golden_frame);
 
 typedef struct {
     int high;
     int bits;
-    uint8_t *buffer;
+    const uint8_t *buffer;
     unsigned long code_word;
 } vp56_range_coder_t;
 
@@ -157,6 +157,14 @@
 
     vp56_model_t *modelp;
     vp56_model_t models[2];
+
+    /* huffman decoding */
+    int use_huffman;
+    GetBitContext gb;
+    VLC dccv_vlc[2];
+    VLC runv_vlc[2];
+    VLC ract_vlc[2][3][6];
+    unsigned int nb_null[2][2];       /* number of consecutive NULL DC/AC */
 };
 
 
@@ -164,7 +172,7 @@
 int vp56_free(AVCodecContext *avctx);
 void vp56_init_dequant(vp56_context_t *s, int quantizer);
 int vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
-                      uint8_t *buf, int buf_size);
+                      const uint8_t *buf, int buf_size);
 
 
 /**
@@ -172,7 +180,7 @@
  */
 
 static inline void vp56_init_range_decoder(vp56_range_coder_t *c,
-                                           uint8_t *buf, int buf_size)
+                                           const uint8_t *buf, int buf_size)
 {
     c->high = 255;
     c->bits = 8;
@@ -257,4 +265,4 @@
     return -tree->val;
 }
 
-#endif /* VP56_H */
+#endif /* FFMPEG_VP56_H */
diff -u mplayer-1.0~rc2-12/libavcodec/vp5.c ffmpeg-free-0.svn20080206/libavcodec/vp5.c
--- mplayer-1.0~rc2-12/libavcodec/vp5.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vp5.c	2008-03-20 19:10:59.000000000 +0100
@@ -34,7 +34,7 @@
 #include "vp5data.h"
 
 
-static int vp5_parse_header(vp56_context_t *s, uint8_t *buf, int buf_size,
+static int vp5_parse_header(vp56_context_t *s, const uint8_t *buf, int buf_size,
                             int *golden_frame)
 {
     vp56_range_coder_t *c = &s->c;
@@ -205,7 +205,7 @@
                         s->coeff_ctx[vp56_b6to4[b]][coeff_idx] = 4;
                         idx = vp56_rac_get_tree(c, vp56_pc_tree, model1);
                         sign = vp56_rac_get(c);
-                        coeff = vp56_coeff_bias[idx];
+                        coeff = vp56_coeff_bias[idx+5];
                         for (i=vp56_coeff_bit_length[idx]; i>=0; i--)
                             coeff += vp56_rac_get_prob(c, vp56_coeff_parse_table[idx][i]) << i;
                     } else {
diff -u mplayer-1.0~rc2-12/libavcodec/vp5data.h ffmpeg-free-0.svn20080206/libavcodec/vp5data.h
--- mplayer-1.0~rc2-12/libavcodec/vp5data.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vp5data.h	2007-10-17 11:37:46.000000000 +0200
@@ -21,8 +21,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef VP5DATA_H
-#define VP5DATA_H
+#ifndef FFMPEG_VP5DATA_H
+#define FFMPEG_VP5DATA_H
 
 #include <stdint.h>
 
@@ -172,4 +172,4 @@
 
 static const uint8_t vp5_coord_div[] = { 2, 2, 2, 2, 4, 4 };
 
-#endif /* VP5DATA_H */
+#endif /* FFMPEG_VP5DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/vp6.c ffmpeg-free-0.svn20080206/libavcodec/vp6.c
--- mplayer-1.0~rc2-12/libavcodec/vp6.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vp6.c	2008-03-20 19:10:59.000000000 +0100
@@ -30,6 +30,7 @@
 #include "avcodec.h"
 #include "dsputil.h"
 #include "bitstream.h"
+#include "huffman.h"
 #include "mpegvideo.h"
 
 #include "vp56.h"
@@ -37,7 +38,10 @@
 #include "vp6data.h"
 
 
-static int vp6_parse_header(vp56_context_t *s, uint8_t *buf, int buf_size,
+static void vp6_parse_coeff(vp56_context_t *s);
+static void vp6_parse_coeff_huffman(vp56_context_t *s);
+
+static int vp6_parse_header(vp56_context_t *s, const uint8_t *buf, int buf_size,
                             int *golden_frame)
 {
     vp56_range_coder_t *c = &s->c;
@@ -126,14 +130,19 @@
             s->filter_selection = 16;
     }
 
-    if (vp56_rac_get(c))
-        av_log(s->avctx, AV_LOG_WARNING,
-               "alternative entropy decoding not supported\n");
+    s->use_huffman = vp56_rac_get(c);
 
+    s->parse_coeff = vp6_parse_coeff;
     if (coeff_offset) {
-        vp56_init_range_decoder(&s->cc, buf+coeff_offset,
-                                buf_size-coeff_offset);
-        s->ccp = &s->cc;
+        buf      += coeff_offset;
+        buf_size -= coeff_offset;
+        if (s->use_huffman) {
+            s->parse_coeff = vp6_parse_coeff_huffman;
+            init_get_bits(&s->gb, buf, buf_size<<3);
+        } else {
+            vp56_init_range_decoder(&s->cc, buf, buf_size);
+            s->ccp = &s->cc;
+        }
     } else {
         s->ccp = &s->c;
     }
@@ -194,6 +203,31 @@
                 model->vector_fdv[comp][node] = vp56_rac_gets_nn(c, 7);
 }
 
+static int vp6_huff_cmp(const void *va, const void *vb)
+{
+    const Node *a = va, *b = vb;
+    return a->count >= b->count;
+}
+
+static void vp6_build_huff_tree(vp56_context_t *s, uint8_t coeff_model[],
+                                const uint8_t *map, unsigned size, VLC *vlc)
+{
+    Node nodes[2*size], *tmp = &nodes[size];
+    int a, b, i;
+
+    /* first compute probabilities from model */
+    tmp[0].count = 256;
+    for (i=0; i<size-1; i++) {
+        a = tmp[i].count *        coeff_model[i]  >> 8;
+        b = tmp[i].count * (255 - coeff_model[i]) >> 8;
+        nodes[map[2*i  ]].count = a + !a;
+        nodes[map[2*i+1]].count = b + !b;
+    }
+
+    /* then build the huffman tree accodring to probabilities */
+    ff_huff_build_tree(s->avctx, vlc, size, nodes, vp6_huff_cmp, 1);
+}
+
 static void vp6_parse_coeff_models(vp56_context_t *s)
 {
     vp56_range_coder_t *c = &s->c;
@@ -237,11 +271,26 @@
                         model->coeff_ract[pt][ct][cg][node] = def_prob[node];
                     }
 
+    if (s->use_huffman) {
+        for (pt=0; pt<2; pt++) {
+            vp6_build_huff_tree(s, model->coeff_dccv[pt],
+                                vp6_huff_coeff_map, 12, &s->dccv_vlc[pt]);
+            vp6_build_huff_tree(s, model->coeff_runv[pt],
+                                vp6_huff_run_map, 9, &s->runv_vlc[pt]);
+            for (ct=0; ct<3; ct++)
+                for (cg = 0; cg < 6; cg++)
+                    vp6_build_huff_tree(s, model->coeff_ract[pt][ct][cg],
+                                        vp6_huff_coeff_map, 12,
+                                        &s->ract_vlc[pt][ct][cg]);
+        }
+        memset(s->nb_null, 0, sizeof(s->nb_null));
+    } else {
     /* coeff_dcct is a linear combination of coeff_dccv */
     for (pt=0; pt<2; pt++)
         for (ctx=0; ctx<3; ctx++)
             for (node=0; node<5; node++)
                 model->coeff_dcct[pt][ctx][node] = av_clip(((model->coeff_dccv[pt][node] * vp6_dccv_lc[ctx][node][0] + 128) >> 8) + vp6_dccv_lc[ctx][node][1], 1, 255);
+    }
 }
 
 static void vp6_parse_vector_adjustment(vp56_context_t *s, vp56_mv_t *vect)
@@ -282,6 +331,77 @@
     }
 }
 
+/**
+ * Read number of consecutive blocks with null DC or AC.
+ * This value is < 74.
+ */
+static unsigned vp6_get_nb_null(vp56_context_t *s)
+{
+    unsigned val = get_bits(&s->gb, 2);
+    if (val == 2)
+        val += get_bits(&s->gb, 2);
+    else if (val == 3) {
+        val = get_bits1(&s->gb) << 2;
+        val = 6+val + get_bits(&s->gb, 2+val);
+    }
+    return val;
+}
+
+static void vp6_parse_coeff_huffman(vp56_context_t *s)
+{
+    vp56_model_t *model = s->modelp;
+    uint8_t *permute = s->scantable.permutated;
+    VLC *vlc_coeff;
+    int coeff, sign, coeff_idx;
+    int b, cg, idx;
+    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */
+
+    for (b=0; b<6; b++) {
+        int ct = 0;    /* code type */
+        if (b > 3) pt = 1;
+        vlc_coeff = &s->dccv_vlc[pt];
+
+        for (coeff_idx=0; coeff_idx<64; ) {
+            int run = 1;
+            if (coeff_idx<2 && s->nb_null[coeff_idx][pt]) {
+                s->nb_null[coeff_idx][pt]--;
+                if (coeff_idx)
+                    break;
+            } else {
+                coeff = get_vlc2(&s->gb, vlc_coeff->table, 9, 3);
+                if (coeff == 0) {
+                    if (coeff_idx) {
+                        int pt = (coeff_idx >= 6);
+                        run += get_vlc2(&s->gb, s->runv_vlc[pt].table, 9, 3);
+                        if (run >= 9)
+                            run += get_bits(&s->gb, 6);
+                    } else
+                        s->nb_null[0][pt] = vp6_get_nb_null(s);
+                    ct = 0;
+                } else if (coeff == 11) {  /* end of block */
+                    if (coeff_idx == 1)    /* first AC coeff ? */
+                        s->nb_null[1][pt] = vp6_get_nb_null(s);
+                    break;
+                } else {
+                    int coeff2 = vp56_coeff_bias[coeff];
+                    if (coeff > 4)
+                        coeff2 += get_bits(&s->gb, coeff <= 9 ? coeff - 4 : 11);
+                    ct = 1 + (coeff2 > 1);
+                    sign = get_bits1(&s->gb);
+                    coeff2 = (coeff2 ^ -sign) + sign;
+                    if (coeff_idx)
+                        coeff2 *= s->dequant_ac;
+                    idx = model->coeff_index_to_pos[coeff_idx];
+                    s->block_coeff[b][permute[idx]] = coeff2;
+                }
+            }
+            coeff_idx+=run;
+            cg = FFMIN(vp6_coeff_groups[coeff_idx], 3);
+            vlc_coeff = &s->ract_vlc[pt][ct][cg];
+        }
+    }
+}
+
 static void vp6_parse_coeff(vp56_context_t *s)
 {
     vp56_range_coder_t *c = s->ccp;
@@ -309,7 +429,7 @@
                 if (vp56_rac_get_prob(c, model2[2])) {
                     if (vp56_rac_get_prob(c, model2[3])) {
                         idx = vp56_rac_get_tree(c, vp56_pc_tree, model1);
-                        coeff = vp56_coeff_bias[idx];
+                        coeff = vp56_coeff_bias[idx+5];
                         for (i=vp56_coeff_bit_length[idx]; i>=0; i--)
                             coeff += vp56_rac_get_prob(c, vp56_coeff_parse_table[idx][i]) << i;
                     } else {
@@ -500,7 +620,6 @@
     s->parse_vector_adjustment = vp6_parse_vector_adjustment;
     s->adjust = vp6_adjust;
     s->filter = vp6_filter;
-    s->parse_coeff = vp6_parse_coeff;
     s->default_models_init = vp6_default_models_init;
     s->parse_vector_models = vp6_parse_vector_models;
     s->parse_coeff_models = vp6_parse_coeff_models;
diff -u mplayer-1.0~rc2-12/libavcodec/vp6data.h ffmpeg-free-0.svn20080206/libavcodec/vp6data.h
--- mplayer-1.0~rc2-12/libavcodec/vp6data.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vp6data.h	2007-10-17 11:37:46.000000000 +0200
@@ -21,8 +21,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef VP6DATA_H
-#define VP6DATA_H
+#ifndef FFMPEG_VP6DATA_H
+#define FFMPEG_VP6DATA_H
 
 #include "vp56data.h"
 
@@ -297,4 +297,12 @@
 
 static const uint8_t vp6_coord_div[] = { 4, 4, 4, 4, 8, 8 };
 
-#endif /* VP6DATA_H */
+static const uint8_t vp6_huff_coeff_map[] = {
+    13, 14, 11, 0, 1, 15, 16, 18, 2, 17, 3, 4, 19, 20, 5, 6, 21, 22, 7, 8, 9, 10
+};
+
+static const uint8_t vp6_huff_run_map[] = {
+    10, 13, 11, 12, 0, 1, 2, 3, 14, 8, 15, 16, 4, 5, 6, 7
+};
+
+#endif /* FFMPEG_VP6DATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/vqavideo.c ffmpeg-free-0.svn20080206/libavcodec/vqavideo.c
--- mplayer-1.0~rc2-12/libavcodec/vqavideo.c	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/vqavideo.c	2008-03-20 19:10:59.000000000 +0100
@@ -104,7 +104,7 @@
     DSPContext dsp;
     AVFrame frame;
 
-    unsigned char *buf;
+    const unsigned char *buf;
     int size;
 
     uint32_t palette[PALETTE_COUNT];
@@ -202,7 +202,7 @@
         return; \
     }
 
-static void decode_format80(unsigned char *src, int src_size,
+static void decode_format80(const unsigned char *src, int src_size,
     unsigned char *dest, int dest_size, int check_size) {
 
     int src_index = 0;
@@ -567,7 +567,7 @@
 
 static int vqa_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     VqaContext *s = avctx->priv_data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/wavpack.c ffmpeg-free-0.svn20080206/libavcodec/wavpack.c
--- mplayer-1.0~rc2-12/libavcodec/wavpack.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/wavpack.c	2008-03-20 19:10:59.000000000 +0100
@@ -364,22 +364,15 @@
     return 0;
 }
 
-static int wavpack_decode_close(AVCodecContext *avctx)
-{
-//    WavpackContext *s = avctx->priv_data;
-
-    return 0;
-}
-
 static int wavpack_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     WavpackContext *s = avctx->priv_data;
     int16_t *samples = data;
     int samplecount;
     int got_terms = 0, got_weights = 0, got_samples = 0, got_entropy = 0, got_bs = 0;
-    uint8_t* buf_end = buf + buf_size;
+    const uint8_t* buf_end = buf + buf_size;
     int i, j, id, size, ssize, weights, t;
 
     if (buf_size == 0){
@@ -587,6 +580,6 @@
     sizeof(WavpackContext),
     wavpack_decode_init,
     NULL,
-    wavpack_decode_close,
+    NULL,
     wavpack_decode_frame,
 };
diff -u mplayer-1.0~rc2-12/libavcodec/wmadata.h ffmpeg-free-0.svn20080206/libavcodec/wmadata.h
--- mplayer-1.0~rc2-12/libavcodec/wmadata.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/wmadata.h	2007-10-17 11:37:46.000000000 +0200
@@ -24,8 +24,8 @@
  * Various WMA tables.
  */
 
-#ifndef AVCODEC_WMADATA_H
-#define AVCODEC_WMADATA_H
+#ifndef FFMPEG_WMADATA_H
+#define FFMPEG_WMADATA_H
 
 #include <stdint.h>
 #include "wma.h"
@@ -1438,4 +1438,4 @@
     },
 };
 
-#endif // AVCODEC_WMADATA_H
+#endif /* FFMPEG_WMADATA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/wmadec.c ffmpeg-free-0.svn20080206/libavcodec/wmadec.c
--- mplayer-1.0~rc2-12/libavcodec/wmadec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/wmadec.c	2008-03-20 19:10:59.000000000 +0100
@@ -755,7 +755,7 @@
 
 static int wma_decode_superframe(AVCodecContext *avctx,
                                  void *data, int *data_size,
-                                 uint8_t *buf, int buf_size)
+                                 const uint8_t *buf, int buf_size)
 {
     WMACodecContext *s = avctx->priv_data;
     int nb_frames, bit_offset, i, pos, len;
@@ -768,6 +768,9 @@
         s->last_superframe_len = 0;
         return 0;
     }
+    if (buf_size < s->block_align)
+        return 0;
+    buf_size = s->block_align;
 
     samples = data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/wmaenc.c ffmpeg-free-0.svn20080206/libavcodec/wmaenc.c
--- mplayer-1.0~rc2-12/libavcodec/wmaenc.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/wmaenc.c	2008-03-20 19:10:59.000000000 +0100
@@ -178,7 +178,7 @@
     }
 
     for(ch = 0; ch < s->nb_channels; ch++) {
-        if (s->channel_coded[ch]= 1) { //FIXME
+        if (s->channel_coded[ch]= 1) { //FIXME only set channel_coded when needed, instead of always
             init_exp(s, ch, fixed_exp);
         }
     }
diff -u mplayer-1.0~rc2-12/libavcodec/wma.h ffmpeg-free-0.svn20080206/libavcodec/wma.h
--- mplayer-1.0~rc2-12/libavcodec/wma.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/wma.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef WMA_H
-#define WMA_H
+#ifndef FFMPEG_WMA_H
+#define FFMPEG_WMA_H
 
 #include "bitstream.h"
 #include "dsputil.h"
@@ -147,4 +147,4 @@
 int ff_wma_total_gain_to_bits(int total_gain);
 int ff_wma_end(AVCodecContext *avctx);
 
-#endif
+#endif /* FFMPEG_WMA_H */
diff -u mplayer-1.0~rc2-12/libavcodec/wmv2.c ffmpeg-free-0.svn20080206/libavcodec/wmv2.c
--- mplayer-1.0~rc2-12/libavcodec/wmv2.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/wmv2.c	2008-03-20 19:10:59.000000000 +0100
@@ -18,572 +18,20 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-/**
- * @file wmv2.c
- * wmv2 codec.
- */
-
+#include "avcodec.h"
+#include "mpegvideo.h"
+#include "msmpeg4data.h"
 #include "simple_idct.h"
+#include "wmv2.h"
 
-#define SKIP_TYPE_NONE 0
-#define SKIP_TYPE_MPEG 1
-#define SKIP_TYPE_ROW  2
-#define SKIP_TYPE_COL  3
-
-
-typedef struct Wmv2Context{
-    MpegEncContext s;
-    int j_type_bit;
-    int j_type;
-    int abt_flag;
-    int abt_type;
-    int abt_type_table[6];
-    int per_mb_abt;
-    int per_block_abt;
-    int mspel_bit;
-    int cbp_table_index;
-    int top_left_mv_flag;
-    int per_mb_rl_bit;
-    int skip_type;
-    int hshift;
-
-    ScanTable abt_scantable[2];
-    DECLARE_ALIGNED_8(DCTELEM, abt_block2[6][64]);
-}Wmv2Context;
 
-static void wmv2_common_init(Wmv2Context * w){
+void ff_wmv2_common_init(Wmv2Context * w){
     MpegEncContext * const s= &w->s;
 
     ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], wmv2_scantableA);
     ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], wmv2_scantableB);
 }
 
-#ifdef CONFIG_WMV2_ENCODER
-
-static int encode_ext_header(Wmv2Context *w){
-    MpegEncContext * const s= &w->s;
-    PutBitContext pb;
-    int code;
-
-    init_put_bits(&pb, s->avctx->extradata, s->avctx->extradata_size);
-
-    put_bits(&pb, 5, s->avctx->time_base.den / s->avctx->time_base.num); //yes 29.97 -> 29
-    put_bits(&pb, 11, FFMIN(s->bit_rate/1024, 2047));
-
-    put_bits(&pb, 1, w->mspel_bit=1);
-    put_bits(&pb, 1, s->loop_filter);
-    put_bits(&pb, 1, w->abt_flag=1);
-    put_bits(&pb, 1, w->j_type_bit=1);
-    put_bits(&pb, 1, w->top_left_mv_flag=0);
-    put_bits(&pb, 1, w->per_mb_rl_bit=1);
-    put_bits(&pb, 3, code=1);
-
-    flush_put_bits(&pb);
-
-    s->slice_height = s->mb_height / code;
-
-    return 0;
-}
-
-static int wmv2_encode_init(AVCodecContext *avctx){
-    Wmv2Context * const w= avctx->priv_data;
-
-    if(MPV_encode_init(avctx) < 0)
-        return -1;
-
-    wmv2_common_init(w);
-
-    avctx->extradata_size= 4;
-    avctx->extradata= av_mallocz(avctx->extradata_size + 10);
-    encode_ext_header(w);
-
-    return 0;
-}
-
-#if 0 /* unused, remove? */
-static int wmv2_encode_end(AVCodecContext *avctx){
-
-    if(MPV_encode_end(avctx) < 0)
-        return -1;
-
-    avctx->extradata_size= 0;
-    av_freep(&avctx->extradata);
-
-    return 0;
-}
-#endif
-
-int ff_wmv2_encode_picture_header(MpegEncContext * s, int picture_number)
-{
-    Wmv2Context * const w= (Wmv2Context*)s;
-
-    put_bits(&s->pb, 1, s->pict_type - 1);
-    if(s->pict_type == I_TYPE){
-        put_bits(&s->pb, 7, 0);
-    }
-    put_bits(&s->pb, 5, s->qscale);
-
-    s->dc_table_index = 1;
-    s->mv_table_index = 1; /* only if P frame */
-//    s->use_skip_mb_code = 1; /* only if P frame */
-    s->per_mb_rl_table = 0;
-    s->mspel= 0;
-    w->per_mb_abt=0;
-    w->abt_type=0;
-    w->j_type=0;
-
-    assert(s->flipflop_rounding);
-
-    if (s->pict_type == I_TYPE) {
-        assert(s->no_rounding==1);
-        if(w->j_type_bit) put_bits(&s->pb, 1, w->j_type);
-
-        if(w->per_mb_rl_bit) put_bits(&s->pb, 1, s->per_mb_rl_table);
-
-        if(!s->per_mb_rl_table){
-            ff_code012(&s->pb, s->rl_chroma_table_index);
-            ff_code012(&s->pb, s->rl_table_index);
-        }
-
-        put_bits(&s->pb, 1, s->dc_table_index);
-
-        s->inter_intra_pred= 0;
-    }else{
-        int cbp_index;
-
-        put_bits(&s->pb, 2, SKIP_TYPE_NONE);
-
-        ff_code012(&s->pb, cbp_index=0);
-        if(s->qscale <= 10){
-            int map[3]= {0,2,1};
-            w->cbp_table_index= map[cbp_index];
-        }else if(s->qscale <= 20){
-            int map[3]= {1,0,2};
-            w->cbp_table_index= map[cbp_index];
-        }else{
-            int map[3]= {2,1,0};
-            w->cbp_table_index= map[cbp_index];
-        }
-
-        if(w->mspel_bit) put_bits(&s->pb, 1, s->mspel);
-
-        if(w->abt_flag){
-            put_bits(&s->pb, 1, w->per_mb_abt^1);
-            if(!w->per_mb_abt){
-                ff_code012(&s->pb, w->abt_type);
-            }
-        }
-
-        if(w->per_mb_rl_bit) put_bits(&s->pb, 1, s->per_mb_rl_table);
-
-        if(!s->per_mb_rl_table){
-            ff_code012(&s->pb, s->rl_table_index);
-            s->rl_chroma_table_index = s->rl_table_index;
-        }
-        put_bits(&s->pb, 1, s->dc_table_index);
-        put_bits(&s->pb, 1, s->mv_table_index);
-
-        s->inter_intra_pred= 0;//(s->width*s->height < 320*240 && s->bit_rate<=II_BITRATE);
-    }
-    s->esc3_level_length= 0;
-    s->esc3_run_length= 0;
-
-    return 0;
-}
-
-/* Nearly identical to wmv1 but that is just because we do not use the
- * useless M$ crap features. It is duplicated here in case someone wants
- * to add support for these crap features. */
-void ff_wmv2_encode_mb(MpegEncContext * s,
-                       DCTELEM block[6][64],
-                       int motion_x, int motion_y)
-{
-    Wmv2Context * const w= (Wmv2Context*)s;
-    int cbp, coded_cbp, i;
-    int pred_x, pred_y;
-    uint8_t *coded_block;
-
-    handle_slices(s);
-
-    if (!s->mb_intra) {
-        /* compute cbp */
-        cbp = 0;
-        for (i = 0; i < 6; i++) {
-            if (s->block_last_index[i] >= 0)
-                cbp |= 1 << (5 - i);
-        }
-
-        put_bits(&s->pb,
-                 wmv2_inter_table[w->cbp_table_index][cbp + 64][1],
-                 wmv2_inter_table[w->cbp_table_index][cbp + 64][0]);
-
-        /* motion vector */
-        h263_pred_motion(s, 0, 0, &pred_x, &pred_y);
-        msmpeg4_encode_motion(s, motion_x - pred_x,
-                              motion_y - pred_y);
-    } else {
-        /* compute cbp */
-        cbp = 0;
-        coded_cbp = 0;
-        for (i = 0; i < 6; i++) {
-            int val, pred;
-            val = (s->block_last_index[i] >= 1);
-            cbp |= val << (5 - i);
-            if (i < 4) {
-                /* predict value for close blocks only for luma */
-                pred = coded_block_pred(s, i, &coded_block);
-                *coded_block = val;
-                val = val ^ pred;
-            }
-            coded_cbp |= val << (5 - i);
-        }
-#if 0
-        if (coded_cbp)
-            printf("cbp=%x %x\n", cbp, coded_cbp);
-#endif
-
-        if (s->pict_type == I_TYPE) {
-            put_bits(&s->pb,
-                     ff_msmp4_mb_i_table[coded_cbp][1], ff_msmp4_mb_i_table[coded_cbp][0]);
-        } else {
-            put_bits(&s->pb,
-                     wmv2_inter_table[w->cbp_table_index][cbp][1],
-                     wmv2_inter_table[w->cbp_table_index][cbp][0]);
-        }
-        put_bits(&s->pb, 1, 0);         /* no AC prediction yet */
-        if(s->inter_intra_pred){
-            s->h263_aic_dir=0;
-            put_bits(&s->pb, table_inter_intra[s->h263_aic_dir][1], table_inter_intra[s->h263_aic_dir][0]);
-        }
-    }
-
-    for (i = 0; i < 6; i++) {
-        ff_msmpeg4_encode_block(s, block[i], i);
-    }
-}
-#endif //CONFIG_WMV2_ENCODER
-
-static void parse_mb_skip(Wmv2Context * w){
-    int mb_x, mb_y;
-    MpegEncContext * const s= &w->s;
-    uint32_t * const mb_type= s->current_picture_ptr->mb_type;
-
-    w->skip_type= get_bits(&s->gb, 2);
-    switch(w->skip_type){
-    case SKIP_TYPE_NONE:
-        for(mb_y=0; mb_y<s->mb_height; mb_y++){
-            for(mb_x=0; mb_x<s->mb_width; mb_x++){
-                mb_type[mb_y*s->mb_stride + mb_x]= MB_TYPE_16x16 | MB_TYPE_L0;
-            }
-        }
-        break;
-    case SKIP_TYPE_MPEG:
-        for(mb_y=0; mb_y<s->mb_height; mb_y++){
-            for(mb_x=0; mb_x<s->mb_width; mb_x++){
-                mb_type[mb_y*s->mb_stride + mb_x]= (get_bits1(&s->gb) ? MB_TYPE_SKIP : 0) | MB_TYPE_16x16 | MB_TYPE_L0;
-            }
-        }
-        break;
-    case SKIP_TYPE_ROW:
-        for(mb_y=0; mb_y<s->mb_height; mb_y++){
-            if(get_bits1(&s->gb)){
-                for(mb_x=0; mb_x<s->mb_width; mb_x++){
-                    mb_type[mb_y*s->mb_stride + mb_x]=  MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_L0;
-                }
-            }else{
-                for(mb_x=0; mb_x<s->mb_width; mb_x++){
-                    mb_type[mb_y*s->mb_stride + mb_x]= (get_bits1(&s->gb) ? MB_TYPE_SKIP : 0) | MB_TYPE_16x16 | MB_TYPE_L0;
-                }
-            }
-        }
-        break;
-    case SKIP_TYPE_COL:
-        for(mb_x=0; mb_x<s->mb_width; mb_x++){
-            if(get_bits1(&s->gb)){
-                for(mb_y=0; mb_y<s->mb_height; mb_y++){
-                    mb_type[mb_y*s->mb_stride + mb_x]=  MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_L0;
-                }
-            }else{
-                for(mb_y=0; mb_y<s->mb_height; mb_y++){
-                    mb_type[mb_y*s->mb_stride + mb_x]= (get_bits1(&s->gb) ? MB_TYPE_SKIP : 0) | MB_TYPE_16x16 | MB_TYPE_L0;
-                }
-            }
-        }
-        break;
-    }
-}
-
-static int decode_ext_header(Wmv2Context *w){
-    MpegEncContext * const s= &w->s;
-    GetBitContext gb;
-    int fps;
-    int code;
-
-    if(s->avctx->extradata_size<4) return -1;
-
-    init_get_bits(&gb, s->avctx->extradata, s->avctx->extradata_size*8);
-
-    fps                = get_bits(&gb, 5);
-    s->bit_rate        = get_bits(&gb, 11)*1024;
-    w->mspel_bit       = get_bits1(&gb);
-    s->loop_filter     = get_bits1(&gb);
-    w->abt_flag        = get_bits1(&gb);
-    w->j_type_bit      = get_bits1(&gb);
-    w->top_left_mv_flag= get_bits1(&gb);
-    w->per_mb_rl_bit   = get_bits1(&gb);
-    code               = get_bits(&gb, 3);
-
-    if(code==0) return -1;
-
-    s->slice_height = s->mb_height / code;
-
-    if(s->avctx->debug&FF_DEBUG_PICT_INFO){
-        av_log(s->avctx, AV_LOG_DEBUG, "fps:%d, br:%d, qpbit:%d, abt_flag:%d, j_type_bit:%d, tl_mv_flag:%d, mbrl_bit:%d, code:%d, loop_filter:%d, slices:%d\n",
-        fps, s->bit_rate, w->mspel_bit, w->abt_flag, w->j_type_bit, w->top_left_mv_flag, w->per_mb_rl_bit, code, s->loop_filter,
-        code);
-    }
-    return 0;
-}
-
-int ff_wmv2_decode_picture_header(MpegEncContext * s)
-{
-    Wmv2Context * const w= (Wmv2Context*)s;
-    int code;
-
-#if 0
-{
-int i;
-for(i=0; i<s->gb.size*8; i++)
-    printf("%d", get_bits1(&s->gb));
-//    get_bits1(&s->gb);
-printf("END\n");
-return -1;
-}
-#endif
-    if(s->picture_number==0)
-        decode_ext_header(w);
-
-    s->pict_type = get_bits1(&s->gb) + 1;
-    if(s->pict_type == I_TYPE){
-        code = get_bits(&s->gb, 7);
-        av_log(s->avctx, AV_LOG_DEBUG, "I7:%X/\n", code);
-    }
-    s->chroma_qscale= s->qscale = get_bits(&s->gb, 5);
-    if(s->qscale < 0)
-       return -1;
-
-    return 0;
-}
-
-int ff_wmv2_decode_secondary_picture_header(MpegEncContext * s)
-{
-    Wmv2Context * const w= (Wmv2Context*)s;
-
-    if (s->pict_type == I_TYPE) {
-        if(w->j_type_bit) w->j_type= get_bits1(&s->gb);
-        else              w->j_type= 0; //FIXME check
-
-        if(!w->j_type){
-            if(w->per_mb_rl_bit) s->per_mb_rl_table= get_bits1(&s->gb);
-            else                 s->per_mb_rl_table= 0;
-
-            if(!s->per_mb_rl_table){
-                s->rl_chroma_table_index = decode012(&s->gb);
-                s->rl_table_index = decode012(&s->gb);
-            }
-
-            s->dc_table_index = get_bits1(&s->gb);
-        }
-        s->inter_intra_pred= 0;
-        s->no_rounding = 1;
-        if(s->avctx->debug&FF_DEBUG_PICT_INFO){
-            av_log(s->avctx, AV_LOG_DEBUG, "qscale:%d rlc:%d rl:%d dc:%d mbrl:%d j_type:%d \n",
-                s->qscale,
-                s->rl_chroma_table_index,
-                s->rl_table_index,
-                s->dc_table_index,
-                s->per_mb_rl_table,
-                w->j_type);
-        }
-    }else{
-        int cbp_index;
-        w->j_type=0;
-
-        parse_mb_skip(w);
-        cbp_index= decode012(&s->gb);
-        if(s->qscale <= 10){
-            int map[3]= {0,2,1};
-            w->cbp_table_index= map[cbp_index];
-        }else if(s->qscale <= 20){
-            int map[3]= {1,0,2};
-            w->cbp_table_index= map[cbp_index];
-        }else{
-            int map[3]= {2,1,0};
-            w->cbp_table_index= map[cbp_index];
-        }
-
-        if(w->mspel_bit) s->mspel= get_bits1(&s->gb);
-        else             s->mspel= 0; //FIXME check
-
-        if(w->abt_flag){
-            w->per_mb_abt= get_bits1(&s->gb)^1;
-            if(!w->per_mb_abt){
-                w->abt_type= decode012(&s->gb);
-            }
-        }
-
-        if(w->per_mb_rl_bit) s->per_mb_rl_table= get_bits1(&s->gb);
-        else                 s->per_mb_rl_table= 0;
-
-        if(!s->per_mb_rl_table){
-            s->rl_table_index = decode012(&s->gb);
-            s->rl_chroma_table_index = s->rl_table_index;
-        }
-
-        s->dc_table_index = get_bits1(&s->gb);
-        s->mv_table_index = get_bits1(&s->gb);
-
-        s->inter_intra_pred= 0;//(s->width*s->height < 320*240 && s->bit_rate<=II_BITRATE);
-        s->no_rounding ^= 1;
-
-        if(s->avctx->debug&FF_DEBUG_PICT_INFO){
-            av_log(s->avctx, AV_LOG_DEBUG, "rl:%d rlc:%d dc:%d mv:%d mbrl:%d qp:%d mspel:%d per_mb_abt:%d abt_type:%d cbp:%d ii:%d\n",
-                s->rl_table_index,
-                s->rl_chroma_table_index,
-                s->dc_table_index,
-                s->mv_table_index,
-                s->per_mb_rl_table,
-                s->qscale,
-                s->mspel,
-                w->per_mb_abt,
-                w->abt_type,
-                w->cbp_table_index,
-                s->inter_intra_pred);
-        }
-    }
-    s->esc3_level_length= 0;
-    s->esc3_run_length= 0;
-
-s->picture_number++; //FIXME ?
-
-
-//    if(w->j_type)
-//        return wmv2_decode_j_picture(w); //FIXME
-
-    if(w->j_type){
-        av_log(s->avctx, AV_LOG_ERROR, "J-type picture is not supported\n");
-        return -1;
-    }
-
-    return 0;
-}
-
-static inline int wmv2_decode_motion(Wmv2Context *w, int *mx_ptr, int *my_ptr){
-    MpegEncContext * const s= &w->s;
-    int ret;
-
-    ret= msmpeg4_decode_motion(s, mx_ptr, my_ptr);
-
-    if(ret<0) return -1;
-
-    if((((*mx_ptr)|(*my_ptr)) & 1) && s->mspel)
-        w->hshift= get_bits1(&s->gb);
-    else
-        w->hshift= 0;
-
-//printf("%d %d  ", *mx_ptr, *my_ptr);
-
-    return 0;
-}
-
-static int16_t *wmv2_pred_motion(Wmv2Context *w, int *px, int *py){
-    MpegEncContext * const s= &w->s;
-    int xy, wrap, diff, type;
-    int16_t *A, *B, *C, *mot_val;
-
-    wrap = s->b8_stride;
-    xy = s->block_index[0];
-
-    mot_val = s->current_picture.motion_val[0][xy];
-
-    A = s->current_picture.motion_val[0][xy - 1];
-    B = s->current_picture.motion_val[0][xy - wrap];
-    C = s->current_picture.motion_val[0][xy + 2 - wrap];
-
-    if(s->mb_x && !s->first_slice_line && !s->mspel && w->top_left_mv_flag)
-        diff= FFMAX(FFABS(A[0] - B[0]), FFABS(A[1] - B[1]));
-    else
-        diff=0;
-
-    if(diff >= 8)
-        type= get_bits1(&s->gb);
-    else
-        type= 2;
-
-    if(type == 0){
-        *px= A[0];
-        *py= A[1];
-    }else if(type == 1){
-        *px= B[0];
-        *py= B[1];
-    }else{
-        /* special case for first (slice) line */
-        if (s->first_slice_line) {
-            *px = A[0];
-            *py = A[1];
-        } else {
-            *px = mid_pred(A[0], B[0], C[0]);
-            *py = mid_pred(A[1], B[1], C[1]);
-        }
-    }
-
-    return mot_val;
-}
-
-static inline int wmv2_decode_inter_block(Wmv2Context *w, DCTELEM *block, int n, int cbp){
-    MpegEncContext * const s= &w->s;
-    static const int sub_cbp_table[3]= {2,3,1};
-    int sub_cbp;
-
-    if(!cbp){
-        s->block_last_index[n] = -1;
-
-        return 0;
-    }
-
-    if(w->per_block_abt)
-        w->abt_type= decode012(&s->gb);
-#if 0
-    if(w->per_block_abt)
-        printf("B%d", w->abt_type);
-#endif
-    w->abt_type_table[n]= w->abt_type;
-
-    if(w->abt_type){
-//        const uint8_t *scantable= w->abt_scantable[w->abt_type-1].permutated;
-        const uint8_t *scantable= w->abt_scantable[w->abt_type-1].scantable;
-//        const uint8_t *scantable= w->abt_type-1 ? w->abt_scantable[1].permutated : w->abt_scantable[0].scantable;
-
-        sub_cbp= sub_cbp_table[ decode012(&s->gb) ];
-//        printf("S%d", sub_cbp);
-
-        if(sub_cbp&1){
-            if (msmpeg4_decode_block(s, block, n, 1, scantable) < 0)
-                return -1;
-        }
-
-        if(sub_cbp&2){
-            if (msmpeg4_decode_block(s, w->abt_block2[n], n, 1, scantable) < 0)
-                return -1;
-        }
-        s->block_last_index[n] = 63;
-
-        return 0;
-    }else{
-        return msmpeg4_decode_block(s, block, n, 1, s->inter_scantable.permutated);
-    }
-}
-
 static void wmv2_add_block(Wmv2Context *w, DCTELEM *block1, uint8_t *dst, int stride, int n){
     MpegEncContext * const s= &w->s;
 
@@ -593,13 +41,13 @@
         s->dsp.idct_add (dst, stride, block1);
         break;
     case 1:
-        simple_idct84_add(dst           , stride, block1);
-        simple_idct84_add(dst + 4*stride, stride, w->abt_block2[n]);
+        ff_simple_idct84_add(dst           , stride, block1);
+        ff_simple_idct84_add(dst + 4*stride, stride, w->abt_block2[n]);
         memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));
         break;
     case 2:
-        simple_idct48_add(dst           , stride, block1);
-        simple_idct48_add(dst + 4       , stride, w->abt_block2[n]);
+        ff_simple_idct48_add(dst           , stride, block1);
+        ff_simple_idct48_add(dst + 4       , stride, w->abt_block2[n]);
         memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));
         break;
     default:
@@ -709,153 +157,3 @@
     }
     pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);
 }
-
-
-static int wmv2_decode_mb(MpegEncContext *s, DCTELEM block[6][64])
-{
-    Wmv2Context * const w= (Wmv2Context*)s;
-    int cbp, code, i;
-    uint8_t *coded_val;
-
-    if(w->j_type) return 0;
-
-    if (s->pict_type == P_TYPE) {
-        if(IS_SKIP(s->current_picture.mb_type[s->mb_y * s->mb_stride + s->mb_x])){
-            /* skip mb */
-            s->mb_intra = 0;
-            for(i=0;i<6;i++)
-                s->block_last_index[i] = -1;
-            s->mv_dir = MV_DIR_FORWARD;
-            s->mv_type = MV_TYPE_16X16;
-            s->mv[0][0][0] = 0;
-            s->mv[0][0][1] = 0;
-            s->mb_skipped = 1;
-            w->hshift=0;
-            return 0;
-        }
-
-        code = get_vlc2(&s->gb, mb_non_intra_vlc[w->cbp_table_index].table, MB_NON_INTRA_VLC_BITS, 3);
-        if (code < 0)
-            return -1;
-        s->mb_intra = (~code & 0x40) >> 6;
-
-        cbp = code & 0x3f;
-    } else {
-        s->mb_intra = 1;
-        code = get_vlc2(&s->gb, ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS, 2);
-        if (code < 0){
-            av_log(s->avctx, AV_LOG_ERROR, "II-cbp illegal at %d %d\n", s->mb_x, s->mb_y);
-            return -1;
-        }
-        /* predict coded block pattern */
-        cbp = 0;
-        for(i=0;i<6;i++) {
-            int val = ((code >> (5 - i)) & 1);
-            if (i < 4) {
-                int pred = coded_block_pred(s, i, &coded_val);
-                val = val ^ pred;
-                *coded_val = val;
-            }
-            cbp |= val << (5 - i);
-        }
-    }
-
-    if (!s->mb_intra) {
-        int mx, my;
-//printf("P at %d %d\n", s->mb_x, s->mb_y);
-        wmv2_pred_motion(w, &mx, &my);
-
-        if(cbp){
-            s->dsp.clear_blocks(s->block[0]);
-            if(s->per_mb_rl_table){
-                s->rl_table_index = decode012(&s->gb);
-                s->rl_chroma_table_index = s->rl_table_index;
-            }
-
-            if(w->abt_flag && w->per_mb_abt){
-                w->per_block_abt= get_bits1(&s->gb);
-                if(!w->per_block_abt)
-                    w->abt_type= decode012(&s->gb);
-            }else
-                w->per_block_abt=0;
-        }
-
-        if (wmv2_decode_motion(w, &mx, &my) < 0)
-            return -1;
-
-        s->mv_dir = MV_DIR_FORWARD;
-        s->mv_type = MV_TYPE_16X16;
-        s->mv[0][0][0] = mx;
-        s->mv[0][0][1] = my;
-
-        for (i = 0; i < 6; i++) {
-            if (wmv2_decode_inter_block(w, block[i], i, (cbp >> (5 - i)) & 1) < 0)
-            {
-                av_log(s->avctx, AV_LOG_ERROR, "\nerror while decoding inter block: %d x %d (%d)\n", s->mb_x, s->mb_y, i);
-                return -1;
-            }
-        }
-    } else {
-//if(s->pict_type==P_TYPE)
-//   printf("%d%d ", s->inter_intra_pred, cbp);
-//printf("I at %d %d %d %06X\n", s->mb_x, s->mb_y, ((cbp&3)? 1 : 0) +((cbp&0x3C)? 2 : 0), show_bits(&s->gb, 24));
-        s->ac_pred = get_bits1(&s->gb);
-        if(s->inter_intra_pred){
-            s->h263_aic_dir= get_vlc2(&s->gb, inter_intra_vlc.table, INTER_INTRA_VLC_BITS, 1);
-//            printf("%d%d %d %d/", s->ac_pred, s->h263_aic_dir, s->mb_x, s->mb_y);
-        }
-        if(s->per_mb_rl_table && cbp){
-            s->rl_table_index = decode012(&s->gb);
-            s->rl_chroma_table_index = s->rl_table_index;
-        }
-
-        s->dsp.clear_blocks(s->block[0]);
-        for (i = 0; i < 6; i++) {
-            if (msmpeg4_decode_block(s, block[i], i, (cbp >> (5 - i)) & 1, NULL) < 0)
-            {
-                av_log(s->avctx, AV_LOG_ERROR, "\nerror while decoding intra block: %d x %d (%d)\n", s->mb_x, s->mb_y, i);
-                return -1;
-            }
-        }
-    }
-
-    return 0;
-}
-
-static int wmv2_decode_init(AVCodecContext *avctx){
-    Wmv2Context * const w= avctx->priv_data;
-
-    if(ff_h263_decode_init(avctx) < 0)
-        return -1;
-
-    wmv2_common_init(w);
-
-    return 0;
-}
-
-#ifdef CONFIG_WMV2_DECODER
-AVCodec wmv2_decoder = {
-    "wmv2",
-    CODEC_TYPE_VIDEO,
-    CODEC_ID_WMV2,
-    sizeof(Wmv2Context),
-    wmv2_decode_init,
-    NULL,
-    ff_h263_decode_end,
-    ff_h263_decode_frame,
-    CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1,
-};
-#endif
-
-#ifdef CONFIG_WMV2_ENCODER
-AVCodec wmv2_encoder = {
-    "wmv2",
-    CODEC_TYPE_VIDEO,
-    CODEC_ID_WMV2,
-    sizeof(Wmv2Context),
-    wmv2_encode_init,
-    MPV_encode_picture,
-    MPV_encode_end,
-    .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, -1},
-};
-#endif
Only in ffmpeg-free-0.svn20080206/libavcodec: wmv2dec.c
Only in ffmpeg-free-0.svn20080206/libavcodec: wmv2enc.c
Only in ffmpeg-free-0.svn20080206/libavcodec: wmv2.h
diff -u mplayer-1.0~rc2-12/libavcodec/ws-snd1.c ffmpeg-free-0.svn20080206/libavcodec/ws-snd1.c
--- mplayer-1.0~rc2-12/libavcodec/ws-snd1.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/ws-snd1.c	2008-03-20 19:10:59.000000000 +0100
@@ -45,7 +45,7 @@
 
 static int ws_snd_decode_frame(AVCodecContext *avctx,
                 void *data, int *data_size,
-                uint8_t *buf, int buf_size)
+                const uint8_t *buf, int buf_size)
 {
 //    WSSNDContext *c = avctx->priv_data;
 
diff -u mplayer-1.0~rc2-12/libavcodec/xan.c ffmpeg-free-0.svn20080206/libavcodec/xan.c
--- mplayer-1.0~rc2-12/libavcodec/xan.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/xan.c	2008-03-20 19:10:59.000000000 +0100
@@ -41,7 +41,7 @@
     AVFrame last_frame;
     AVFrame current_frame;
 
-    unsigned char *buf;
+    const unsigned char *buf;
     int size;
 
     /* scratch space */
@@ -87,7 +87,7 @@
  * memcpy doesn't like that; it's not uncommon, for example, for
  * dest = src+1, to turn byte A into  pattern AAAAAAAA.
  * This was originally repz movsb in Intel x86 ASM. */
-static inline void bytecopy(unsigned char *dest, unsigned char *src, int count)
+static inline void bytecopy(unsigned char *dest, const unsigned char *src, int count)
 {
     int i;
 
@@ -95,12 +95,12 @@
         dest[i] = src[i];
 }
 
-static int xan_huffman_decode(unsigned char *dest, unsigned char *src,
+static int xan_huffman_decode(unsigned char *dest, const unsigned char *src,
     int dest_len)
 {
     unsigned char byte = *src++;
     unsigned char ival = byte + 0x16;
-    unsigned char * ptr = src + byte*2;
+    const unsigned char * ptr = src + byte*2;
     unsigned char val = ival;
     int counter = 0;
     unsigned char *dest_end = dest + dest_len;
@@ -129,7 +129,7 @@
     return 0;
 }
 
-static void xan_unpack(unsigned char *dest, unsigned char *src, int dest_len)
+static void xan_unpack(unsigned char *dest, const unsigned char *src, int dest_len)
 {
     unsigned char opcode;
     int size;
@@ -206,7 +206,7 @@
 }
 
 static inline void xan_wc3_output_pixel_run(XanContext *s,
-    unsigned char *pixel_buffer, int x, int y, int pixel_count)
+    const unsigned char *pixel_buffer, int x, int y, int pixel_count)
 {
     int stride;
     int line_inc;
@@ -284,14 +284,13 @@
 
     unsigned char *opcode_buffer = s->buffer1;
     int opcode_buffer_size = s->buffer1_size;
-    unsigned char *imagedata_buffer = s->buffer2;
-    int imagedata_buffer_size = s->buffer2_size;
+    const unsigned char *imagedata_buffer = s->buffer2;
 
     /* pointers to segments inside the compressed chunk */
-    unsigned char *huffman_segment;
-    unsigned char *size_segment;
-    unsigned char *vector_segment;
-    unsigned char *imagedata_segment;
+    const unsigned char *huffman_segment;
+    const unsigned char *size_segment;
+    const unsigned char *vector_segment;
+    const unsigned char *imagedata_segment;
 
     huffman_segment =   s->buf + AV_RL16(&s->buf[0]);
     size_segment =      s->buf + AV_RL16(&s->buf[2]);
@@ -301,8 +300,7 @@
     xan_huffman_decode(opcode_buffer, huffman_segment, opcode_buffer_size);
 
     if (imagedata_segment[0] == 2)
-        xan_unpack(imagedata_buffer, &imagedata_segment[1],
-            imagedata_buffer_size);
+        xan_unpack(s->buffer2, &imagedata_segment[1], s->buffer2_size);
     else
         imagedata_buffer = &imagedata_segment[1];
 
@@ -406,7 +404,7 @@
 
 static int xan_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     XanContext *s = avctx->priv_data;
     AVPaletteControl *palette_control = avctx->palctrl;
diff -u mplayer-1.0~rc2-12/libavcodec/xiph.h ffmpeg-free-0.svn20080206/libavcodec/xiph.h
--- mplayer-1.0~rc2-12/libavcodec/xiph.h	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/xiph.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_XIPH_H
-#define AVCODEC_XIPH_H
+#ifndef FFMPEG_XIPH_H
+#define FFMPEG_XIPH_H
 
 #include "common.h"
 
@@ -40,4 +40,4 @@
                           int first_header_size, uint8_t *header_start[3],
                           int header_len[3]);
 
-#endif // AVCODEC_XIPH_H
+#endif /* FFMPEG_XIPH_H */
diff -u mplayer-1.0~rc2-12/libavcodec/xl.c ffmpeg-free-0.svn20080206/libavcodec/xl.c
--- mplayer-1.0~rc2-12/libavcodec/xl.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/xl.c	2008-03-20 19:10:59.000000000 +0100
@@ -40,7 +40,7 @@
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     VideoXLContext * const a = avctx->priv_data;
     AVFrame * const p= (AVFrame*)&a->pic;
diff -u mplayer-1.0~rc2-12/libavcodec/xsubdec.c ffmpeg-free-0.svn20080206/libavcodec/xsubdec.c
--- mplayer-1.0~rc2-12/libavcodec/xsubdec.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/xsubdec.c	2008-03-20 19:10:59.000000000 +0100
@@ -30,7 +30,7 @@
 static const uint8_t tc_offsets[9] = { 0, 1, 3, 4, 6, 7, 9, 10, 11 };
 static const uint8_t tc_muls[9] = { 10, 6, 10, 6, 10, 6, 10, 10, 1 };
 
-static uint64_t parse_timecode(uint8_t *buf) {
+static uint64_t parse_timecode(const uint8_t *buf) {
     int i;
     int64_t ms = 0;
     if (buf[2] != ':' || buf[5] != ':' || buf[8] != '.')
@@ -44,9 +44,9 @@
 }
 
 static int decode_frame(AVCodecContext *avctx, void *data, int *data_size,
-                        uint8_t *buf, int buf_size) {
+                        const uint8_t *buf, int buf_size) {
     AVSubtitle *sub = data;
-    uint8_t *buf_end = buf + buf_size;
+    const uint8_t *buf_end = buf + buf_size;
     uint8_t *bitmap;
     int w, h, x, y, rlelen, i;
     GetBitContext gb;
@@ -108,11 +108,11 @@
         for (x = 0; x < w; ) {
             int log2 = ff_log2_tab[show_bits(&gb, 8)];
             int run = get_bits(&gb, 14 - 4 * (log2 >> 1));
-            int colour = get_bits(&gb, 2);
+            int color = get_bits(&gb, 2);
             run = FFMIN(run, w - x);
             // run length 0 means till end of row
             if (!run) run = w - x;
-            memset(bitmap, colour, run);
+            memset(bitmap, color, run);
             bitmap += run;
             x += run;
         }
diff -u mplayer-1.0~rc2-12/libavcodec/xvmc_render.h ffmpeg-free-0.svn20080206/libavcodec/xvmc_render.h
--- mplayer-1.0~rc2-12/libavcodec/xvmc_render.h	2007-10-07 21:49:36.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/xvmc_render.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVCODEC_XVMC_RENDER_H
-#define AVCODEC_XVMC_RENDER_H
+#ifndef FFMPEG_XVMC_RENDER_H
+#define FFMPEG_XVMC_RENDER_H
 
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
@@ -72,4 +72,4 @@
 
 } xvmc_render_state_t;
 
-#endif // AVCODEC_XVMC_RENDER_H
+#endif /* FFMPEG_XVMC_RENDER_H */
diff -u mplayer-1.0~rc2-12/libavcodec/zmbv.c ffmpeg-free-0.svn20080206/libavcodec/zmbv.c
--- mplayer-1.0~rc2-12/libavcodec/zmbv.c	2007-10-07 21:49:37.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavcodec/zmbv.c	2008-03-20 19:10:59.000000000 +0100
@@ -391,7 +391,7 @@
     return 0;
 }
 
-static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size)
 {
     ZmbvContext * const c = avctx->priv_data;
     uint8_t *outptr;
diff -u mplayer-1.0~rc2-12/libavformat/4xm.c ffmpeg-free-0.svn20080206/libavformat/4xm.c
--- mplayer-1.0~rc2-12/libavformat/4xm.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/4xm.c	2007-11-21 08:41:00.000000000 +0100
@@ -92,7 +92,7 @@
 static int fourxm_read_header(AVFormatContext *s,
                               AVFormatParameters *ap)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     unsigned int fourcc_tag;
     unsigned int size;
     int header_size;
@@ -224,7 +224,7 @@
                               AVPacket *pkt)
 {
     FourxmDemuxContext *fourxm = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     unsigned int fourcc_tag;
     unsigned int size, out_size;
     int ret = 0;
@@ -235,7 +235,7 @@
 
     while (!packet_read) {
 
-        if ((ret = get_buffer(&s->pb, header, 8)) < 0)
+        if ((ret = get_buffer(s->pb, header, 8)) < 0)
             return ret;
         fourcc_tag = AV_RL32(&header[0]);
         size = AV_RL32(&header[4]);
@@ -265,9 +265,9 @@
                 return AVERROR(EIO);
             pkt->stream_index = fourxm->video_stream_index;
             pkt->pts = fourxm->video_pts;
-            pkt->pos = url_ftell(&s->pb);
+            pkt->pos = url_ftell(s->pb);
             memcpy(pkt->data, header, 8);
-            ret = get_buffer(&s->pb, &pkt->data[8], size);
+            ret = get_buffer(s->pb, &pkt->data[8], size);
 
             if (ret < 0)
                 av_free_packet(pkt);
@@ -282,7 +282,7 @@
             size-=8;
 
             if (track_number == fourxm->selected_track) {
-                ret= av_get_packet(&s->pb, pkt, size);
+                ret= av_get_packet(s->pb, pkt, size);
                 if(ret<0)
                     return AVERROR(EIO);
                 pkt->stream_index =
diff -u mplayer-1.0~rc2-12/libavformat/adtsenc.c ffmpeg-free-0.svn20080206/libavformat/adtsenc.c
--- mplayer-1.0~rc2-12/libavformat/adtsenc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/adtsenc.c	2007-11-21 08:41:00.000000000 +0100
@@ -84,7 +84,7 @@
     put_bits(&pb, 2, 0);        /* number_of_raw_data_blocks_in_frame */
 
     flush_put_bits(&pb);
-    put_buffer(&s->pb, buf, ADTS_HEADER_SIZE);
+    put_buffer(s->pb, buf, ADTS_HEADER_SIZE);
 
     return 0;
 }
@@ -92,7 +92,7 @@
 static int adts_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
     ADTSContext *adts = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
 
     if (!pkt->size)
         return 0;
diff -u mplayer-1.0~rc2-12/libavformat/aiff.c ffmpeg-free-0.svn20080206/libavformat/aiff.c
--- mplayer-1.0~rc2-12/libavformat/aiff.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/aiff.c	2007-11-21 08:41:00.000000000 +0100
@@ -161,7 +161,7 @@
 static int aiff_write_header(AVFormatContext *s)
 {
     AIFFOutputContext *aiff = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVCodecContext *enc = s->streams[0]->codec;
     AVExtFloat sample_rate;
     int aifc = 0;
@@ -231,14 +231,14 @@
 
 static int aiff_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     put_buffer(pb, pkt->data, pkt->size);
     return 0;
 }
 
 static int aiff_write_trailer(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AIFFOutputContext *aiff = s->priv_data;
     AVCodecContext *enc = s->streams[0]->codec;
 
@@ -250,7 +250,7 @@
         end_size++;
     }
 
-    if (!url_is_streamed(&s->pb)) {
+    if (!url_is_streamed(s->pb)) {
         /* File length */
         url_fseek(pb, aiff->form, SEEK_SET);
         put_be32(pb, (uint32_t)(file_size - aiff->form - 4));
@@ -293,7 +293,7 @@
     offset_t offset = 0;
     uint32_t tag;
     unsigned version = AIFF_C_VERSION1;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream * st = s->streams[0];
 
     /* check FORM header */
@@ -399,11 +399,11 @@
     int res;
 
     /* End of stream may be reached */
-    if (url_feof(&s->pb))
+    if (url_feof(s->pb))
         return AVERROR(EIO);
 
     /* Now for that packet */
-    res = av_get_packet(&s->pb, pkt, (MAX_SIZE / st->codec->block_align) * st->codec->block_align);
+    res = av_get_packet(s->pb, pkt, (MAX_SIZE / st->codec->block_align) * st->codec->block_align);
     if (res < 0)
         return res;
 
diff -u mplayer-1.0~rc2-12/libavformat/allformats.c ffmpeg-free-0.svn20080206/libavformat/allformats.c
--- mplayer-1.0~rc2-12/libavformat/allformats.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/allformats.c	2008-01-29 10:25:49.000000000 +0100
@@ -21,9 +21,6 @@
 #include "avformat.h"
 #include "rtp_internal.h"
 
-/* rtp.c */
-void av_register_rtp_dynamic_payload_handlers(void);
-
 #define REGISTER_MUXER(X,x) { \
           extern AVOutputFormat x##_muxer; \
           if(ENABLE_##X##_MUXER)   av_register_output_format(&x##_muxer); }
@@ -43,15 +40,16 @@
  */
 void av_register_all(void)
 {
-    static int inited = 0;
+    static int inited;
 
-    if (inited != 0)
+    if (inited)
         return;
     inited = 1;
 
     avcodec_init();
     avcodec_register_all();
 
+    /* (de)muxers */
     REGISTER_DEMUXER  (AAC, aac);
     REGISTER_MUXDEMUX (AC3, ac3);
     REGISTER_MUXER    (ADTS, adts);
@@ -62,21 +60,20 @@
     REGISTER_MUXDEMUX (ASF, asf);
     REGISTER_MUXER    (ASF_STREAM, asf_stream);
     REGISTER_MUXDEMUX (AU, au);
-    REGISTER_MUXDEMUX (AUDIO_BEOS, audio_beos);
     REGISTER_MUXDEMUX (AVI, avi);
     REGISTER_DEMUXER  (AVISYNTH, avisynth);
+    REGISTER_MUXER    (AVM2, avm2);
     REGISTER_DEMUXER  (AVS, avs);
     REGISTER_DEMUXER  (BETHSOFTVID, bethsoftvid);
-    REGISTER_DEMUXER  (BKTR, bktr);
     REGISTER_DEMUXER  (C93, c93);
     REGISTER_MUXER    (CRC, crc);
     REGISTER_DEMUXER  (DAUD, daud);
     REGISTER_DEMUXER  (DSICIN, dsicin);
     REGISTER_DEMUXER  (DTS, dts);
     REGISTER_MUXDEMUX (DV, dv);
-    REGISTER_DEMUXER  (DV1394, dv1394);
     REGISTER_DEMUXER  (DXA, dxa);
     REGISTER_DEMUXER  (EA, ea);
+    REGISTER_DEMUXER  (EA_CDATA, ea_cdata);
     REGISTER_MUXDEMUX (FFM, ffm);
     REGISTER_MUXDEMUX (FLAC, flac);
     REGISTER_DEMUXER  (FLIC, flic);
@@ -93,9 +90,7 @@
     REGISTER_MUXDEMUX (IMAGE2PIPE, image2pipe);
     REGISTER_DEMUXER  (INGENIENT, ingenient);
     REGISTER_DEMUXER  (IPMOVIE, ipmovie);
-    REGISTER_DEMUXER  (LIBDC1394, libdc1394);
-    if (!ENABLE_NUT_DEMUXER) REGISTER_DEMUXER (LIBNUT, libnut);
-    if (!ENABLE_NUT_MUXER)   REGISTER_MUXER   (LIBNUT, libnut);
+    REGISTER_DEMUXER  (LMLM4, lmlm4);
     REGISTER_MUXDEMUX (M4V, m4v);
     REGISTER_MUXDEMUX (MATROSKA, matroska);
     REGISTER_MUXER    (MATROSKA_AUDIO, matroska_audio);
@@ -107,6 +102,7 @@
     REGISTER_MUXDEMUX (MP3, mp3);
     REGISTER_MUXER    (MP4, mp4);
     REGISTER_DEMUXER  (MPC, mpc);
+    REGISTER_DEMUXER  (MPC8, mpc8);
     REGISTER_MUXER    (MPEG1SYSTEM, mpeg1system);
     REGISTER_MUXER    (MPEG1VCD, mpeg1vcd);
     REGISTER_MUXER    (MPEG1VIDEO, mpeg1video);
@@ -126,7 +122,6 @@
     REGISTER_MUXDEMUX (NUT, nut);
     REGISTER_DEMUXER  (NUV, nuv);
     REGISTER_MUXDEMUX (OGG, ogg);
-    REGISTER_MUXDEMUX (OSS, oss);
     REGISTER_MUXDEMUX (PCM_ALAW,  pcm_alaw);
     REGISTER_MUXDEMUX (PCM_MULAW, pcm_mulaw);
     REGISTER_MUXDEMUX (PCM_S16BE, pcm_s16be);
@@ -136,6 +131,7 @@
     REGISTER_MUXDEMUX (PCM_U16LE, pcm_u16le);
     REGISTER_MUXDEMUX (PCM_U8,    pcm_u8);
     REGISTER_MUXER    (PSP, psp);
+    REGISTER_DEMUXER  (PVA, pva);
     REGISTER_MUXDEMUX (RAWVIDEO, rawvideo);
     REGISTER_MUXDEMUX (RM, rm);
     REGISTER_MUXDEMUX (ROQ, roq);
@@ -143,11 +139,12 @@
     REGISTER_MUXER    (RTP, rtp);
     REGISTER_DEMUXER  (RTSP, rtsp);
     REGISTER_DEMUXER  (SDP, sdp);
-#ifdef CONFIG_RTP_MUXER
+#ifdef CONFIG_SDP_DEMUXER
     av_register_rtp_dynamic_payload_handlers();
 #endif
     REGISTER_DEMUXER  (SEGAFILM, segafilm);
     REGISTER_DEMUXER  (SHORTEN, shorten);
+    REGISTER_DEMUXER  (SIFF, siff);
     REGISTER_DEMUXER  (SMACKER, smacker);
     REGISTER_DEMUXER  (SOL, sol);
     REGISTER_DEMUXER  (STR, str);
@@ -158,9 +155,8 @@
     REGISTER_DEMUXER  (TIERTEXSEQ, tiertexseq);
     REGISTER_DEMUXER  (TTA, tta);
     REGISTER_DEMUXER  (TXD, txd);
-    REGISTER_DEMUXER  (V4L2, v4l2);
-    REGISTER_DEMUXER  (V4L, v4l);
     REGISTER_DEMUXER  (VC1, vc1);
+    REGISTER_DEMUXER  (VC1T, vc1t);
     REGISTER_DEMUXER  (VMD, vmd);
     REGISTER_MUXDEMUX (VOC, voc);
     REGISTER_MUXDEMUX (WAV, wav);
@@ -168,9 +164,12 @@
     REGISTER_DEMUXER  (WSAUD, wsaud);
     REGISTER_DEMUXER  (WSVQA, wsvqa);
     REGISTER_DEMUXER  (WV, wv);
-    REGISTER_DEMUXER  (X11_GRAB_DEVICE, x11_grab_device);
     REGISTER_MUXDEMUX (YUV4MPEGPIPE, yuv4mpegpipe);
 
+    /* external libraries */
+    REGISTER_MUXDEMUX (LIBNUT, libnut);
+
+    /* protocols */
     REGISTER_PROTOCOL (FILE, file);
     REGISTER_PROTOCOL (HTTP, http);
     REGISTER_PROTOCOL (PIPE, pipe);
diff -u mplayer-1.0~rc2-12/libavformat/amr.c ffmpeg-free-0.svn20080206/libavformat/amr.c
--- mplayer-1.0~rc2-12/libavformat/amr.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/amr.c	2007-11-21 08:41:00.000000000 +0100
@@ -33,7 +33,7 @@
 #ifdef CONFIG_MUXERS
 static int amr_write_header(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVCodecContext *enc = s->streams[0]->codec;
 
     s->priv_data = NULL;
@@ -56,8 +56,8 @@
 
 static int amr_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
-    put_buffer(&s->pb, pkt->data, pkt->size);
-    put_flush_packet(&s->pb);
+    put_buffer(s->pb, pkt->data, pkt->size);
+    put_flush_packet(s->pb);
     return 0;
 }
 #endif /* CONFIG_MUXERS */
@@ -78,7 +78,7 @@
 static int amr_read_header(AVFormatContext *s,
                            AVFormatParameters *ap)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st;
     uint8_t header[9];
 
@@ -120,13 +120,13 @@
     AVCodecContext *enc = s->streams[0]->codec;
     int read, size = 0, toc, mode;
 
-    if (url_feof(&s->pb))
+    if (url_feof(s->pb))
     {
         return AVERROR(EIO);
     }
 
 //FIXME this is wrong, this should rather be in a AVParset
-    toc=get_byte(&s->pb);
+    toc=get_byte(s->pb);
     mode = (toc >> 3) & 0x0F;
 
     if (enc->codec_id == CODEC_ID_AMR_NB)
@@ -152,10 +152,10 @@
     }
 
     pkt->stream_index = 0;
-    pkt->pos= url_ftell(&s->pb);
+    pkt->pos= url_ftell(s->pb);
     pkt->data[0]=toc;
     pkt->duration= enc->codec_id == CODEC_ID_AMR_NB ? 160 : 320;
-    read = get_buffer(&s->pb, pkt->data+1, size-1);
+    read = get_buffer(s->pb, pkt->data+1, size-1);
 
     if (read != size-1)
     {
diff -u mplayer-1.0~rc2-12/libavformat/apc.c ffmpeg-free-0.svn20080206/libavformat/apc.c
--- mplayer-1.0~rc2-12/libavformat/apc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/apc.c	2007-11-21 08:41:00.000000000 +0100
@@ -32,7 +32,7 @@
 
 static int apc_read_header(AVFormatContext *s, AVFormatParameters *ap)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st;
 
     get_le32(pb); /* CRYO */
@@ -74,7 +74,7 @@
 
 static int apc_read_packet(AVFormatContext *s, AVPacket *pkt)
 {
-    if (av_get_packet(&s->pb, pkt, MAX_READ_SIZE) <= 0)
+    if (av_get_packet(s->pb, pkt, MAX_READ_SIZE) <= 0)
         return AVERROR(EIO);
     pkt->stream_index = 0;
     return 0;
diff -u mplayer-1.0~rc2-12/libavformat/ape.c ffmpeg-free-0.svn20080206/libavformat/ape.c
--- mplayer-1.0~rc2-12/libavformat/ape.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/ape.c	2008-02-04 01:42:27.000000000 +0100
@@ -50,7 +50,7 @@
 #define TAG(name, field)  {name, offsetof(AVFormatContext, field), sizeof(((AVFormatContext *)0)->field)}
 
 static const struct {
-    char *name;
+    const char *name;
     int offset;
     int size;
 } tags[] = {
@@ -110,7 +110,7 @@
 
 static void ape_tag_read_field(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     uint8_t buf[1024];
     uint32_t size;
     int i;
@@ -143,7 +143,7 @@
 
 static void ape_parse_tag(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int file_size = url_fsize(pb);
     uint32_t val, fields, tag_bytes;
     uint8_t buf[8];
@@ -270,7 +270,7 @@
 
 static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     APEContext *ape = s->priv_data;
     AVStream *st;
     uint32_t tag;
@@ -456,12 +456,12 @@
     APEContext *ape = s->priv_data;
     uint32_t extra_size = 8;
 
-    if (url_feof(&s->pb))
+    if (url_feof(s->pb))
         return AVERROR_IO;
     if (ape->currentframe > ape->totalframes)
         return AVERROR_IO;
 
-    url_fseek (&s->pb, ape->frames[ape->currentframe].pos, SEEK_SET);
+    url_fseek (s->pb, ape->frames[ape->currentframe].pos, SEEK_SET);
 
     /* Calculate how many blocks there are in this frame */
     if (ape->currentframe == (ape->totalframes - 1))
@@ -474,7 +474,7 @@
 
     AV_WL32(pkt->data    , nblocks);
     AV_WL32(pkt->data + 4, ape->frames[ape->currentframe].skip);
-    ret = get_buffer(&s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);
+    ret = get_buffer(s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);
 
     pkt->pts = ape->frames[ape->currentframe].pts;
     pkt->stream_index = 0;
diff -u mplayer-1.0~rc2-12/libavformat/asf.c ffmpeg-free-0.svn20080206/libavformat/asf.c
--- mplayer-1.0~rc2-12/libavformat/asf.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/asf.c	2008-02-03 12:18:53.000000000 +0100
@@ -23,6 +23,9 @@
 #include "mpegaudio.h"
 #include "asf.h"
 #include "common.h"
+#include "asfcrypt.h"
+
+extern void ff_mms_set_stream_selection(URLContext *h, AVFormatContext *format);
 
 #undef NDEBUG
 #include <assert.h>
@@ -84,7 +87,7 @@
 static void get_guid(ByteIOContext *s, GUID *g)
 {
     assert(sizeof(*g) == 16);
-    get_buffer(s, g, sizeof(*g));
+    get_buffer(s, *g, sizeof(*g));
 }
 
 #if 0
@@ -139,7 +142,7 @@
 {
     ASFContext *asf = s->priv_data;
     GUID g;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st;
     ASFStream *asf_st;
     int size, i;
@@ -390,6 +393,11 @@
                         {
                                 if     (!strcmp(name,"WM/AlbumTitle")) get_str16_nolen(pb, value_len, s->album, sizeof(s->album));
                                 else if(!strcmp(name,"WM/Genre"     )) get_str16_nolen(pb, value_len, s->genre, sizeof(s->genre));
+                                else if(!strcmp(name,"WM/Year"      )) {
+                                    char year[8];
+                                    get_str16_nolen(pb, value_len, year, sizeof(year));
+                                    s->year = atoi(year);
+                                }
                                 else if(!strcmp(name,"WM/Track") && s->track == 0) {
                                     char track[8];
                                     get_str16_nolen(pb, value_len, track, sizeof(track));
@@ -562,12 +570,12 @@
 static int asf_get_packet(AVFormatContext *s)
 {
     ASFContext *asf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     uint32_t packet_length, padsize;
     int rsize = 8;
     int c, d, e, off;
 
-    off= (url_ftell(&s->pb) - s->data_offset) % asf->packet_size + 3;
+    off= (url_ftell(s->pb) - s->data_offset) % asf->packet_size + 3;
 
     c=d=e=-1;
     while(off-- > 0){
@@ -638,7 +646,7 @@
  */
 static int asf_read_frame_header(AVFormatContext *s){
     ASFContext *asf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int rsize = 1;
     int num = get_byte(pb);
     int64_t ts0, ts1;
@@ -674,7 +682,7 @@
             url_fskip(pb, asf->packet_replic_size - 8);
         rsize += asf->packet_replic_size; // FIXME - check validity
     } else if (asf->packet_replic_size==1){
-        // multipacket - frag_offset is begining timestamp
+        // multipacket - frag_offset is beginning timestamp
         asf->packet_time_start = asf->packet_frag_offset;
         asf->packet_frag_offset = 0;
         asf->packet_frag_timestamp = asf->packet_timestamp;
@@ -711,7 +719,7 @@
 {
     ASFContext *asf = s->priv_data;
     ASFStream *asf_st = 0;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     //static int pc = 0;
     for (;;) {
         if(url_feof(pb))
@@ -725,7 +733,7 @@
             /* fail safe */
             url_fskip(pb, ret);
 
-            asf->packet_pos= url_ftell(&s->pb);
+            asf->packet_pos= url_ftell(s->pb);
             if (asf->data_object_size != (uint64_t)-1 &&
                 (asf->packet_pos - asf->data_object_offset >= asf->data_object_size))
                 return AVERROR(EIO); /* Do not exceed the size of the data object */
@@ -758,7 +766,7 @@
         asf_st = asf->asf_st;
 
         if (asf->packet_replic_size == 1) {
-            // frag_offset is here used as the begining timestamp
+            // frag_offset is here used as the beginning timestamp
             asf->packet_frag_timestamp = asf->packet_time_start;
             asf->packet_time_start += asf->packet_time_delta;
             asf->packet_obj_size = asf->packet_frag_size = get_byte(pb);
@@ -823,6 +831,9 @@
 
         get_buffer(pb, asf_st->pkt.data + asf->packet_frag_offset,
                    asf->packet_frag_size);
+        if (s->key && s->keylen == 20)
+            ff_asfcrypt_dec(s->key, asf_st->pkt.data + asf->packet_frag_offset,
+                            asf->packet_frag_size);
         asf_st->frag_offset += asf->packet_frag_size;
         /* test if whole packet is read */
         if (asf_st->frag_offset == asf_st->pkt.size) {
@@ -878,18 +889,6 @@
     return 0;
 }
 
-static int asf_read_close(AVFormatContext *s)
-{
-    int i;
-
-    for(i=0;i<s->nb_streams;i++) {
-        AVStream *st = s->streams[i];
-        av_free(st->priv_data);
-        av_free(st->codec->palctrl);
-    }
-    return 0;
-}
-
 // Added to support seeking after packets have been read
 // If information is not reset, read_packet fails due to
 // leftover information from previous reads
@@ -928,6 +927,19 @@
     asf->asf_st= NULL;
 }
 
+static int asf_read_close(AVFormatContext *s)
+{
+    int i;
+
+    asf_reset_header(s);
+    for(i=0;i<s->nb_streams;i++) {
+        AVStream *st = s->streams[i];
+        av_free(st->priv_data);
+        av_free(st->codec->palctrl);
+    }
+    return 0;
+}
+
 static int64_t asf_read_pts(AVFormatContext *s, int stream_index, int64_t *ppos, int64_t pos_limit)
 {
     ASFContext *asf = s->priv_data;
@@ -944,7 +956,7 @@
 
     pos= (pos+asf->packet_size-1-s->data_offset)/asf->packet_size*asf->packet_size+ s->data_offset;
     *ppos= pos;
-    url_fseek(&s->pb, pos, SEEK_SET);
+    url_fseek(s->pb, pos, SEEK_SET);
 
 //printf("asf_read_pts\n");
     asf_reset_header(s);
@@ -988,21 +1000,21 @@
     int i;
     int pct,ict;
 
-    current_pos = url_ftell(&s->pb);
+    current_pos = url_ftell(s->pb);
 
-    url_fseek(&s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET);
-    get_guid(&s->pb, &g);
+    url_fseek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET);
+    get_guid(s->pb, &g);
     if (!memcmp(&g, &index_guid, sizeof(GUID))) {
-        gsize = get_le64(&s->pb);
-        get_guid(&s->pb, &g);
-        itime=get_le64(&s->pb);
-        pct=get_le32(&s->pb);
-        ict=get_le32(&s->pb);
+        gsize = get_le64(s->pb);
+        get_guid(s->pb, &g);
+        itime=get_le64(s->pb);
+        pct=get_le32(s->pb);
+        ict=get_le32(s->pb);
         av_log(NULL, AV_LOG_DEBUG, "itime:0x%"PRIx64", pct:%d, ict:%d\n",itime,pct,ict);
 
         for (i=0;i<ict;i++){
-            int pktnum=get_le32(&s->pb);
-            int pktct =get_le16(&s->pb);
+            int pktnum=get_le32(s->pb);
+            int pktct =get_le16(s->pb);
             av_log(NULL, AV_LOG_DEBUG, "pktnum:%d, pktct:%d\n", pktnum, pktct);
 
             pos=s->data_offset + asf->packet_size*(int64_t)pktnum;
@@ -1012,7 +1024,7 @@
         }
         asf->index_read= 1;
     }
-    url_fseek(&s->pb, current_pos, SEEK_SET);
+    url_fseek(s->pb, current_pos, SEEK_SET);
 }
 
 static int asf_read_seek(AVFormatContext *s, int stream_index, int64_t pts, int flags)
@@ -1025,6 +1037,15 @@
     if (asf->packet_size <= 0)
         return -1;
 
+    /* Try using the protocol's read_seek if available */
+    if(s->pb) {
+        int ret = av_url_read_fseek(s->pb, stream_index, pts, flags);
+        if(ret >= 0)
+            asf_reset_header(s);
+        if (ret != AVERROR(ENOSYS))
+            return ret;
+    }
+
     if (!asf->index_read)
         asf_build_simple_index(s, stream_index);
 
@@ -1042,10 +1063,10 @@
 
     // various attempts to find key frame have failed so far
     //    asf_reset_header(s);
-    //    url_fseek(&s->pb, pos, SEEK_SET);
+    //    url_fseek(s->pb, pos, SEEK_SET);
     //    key_pos = pos;
     //     for(i=0;i<16;i++){
-    //         pos = url_ftell(&s->pb);
+    //         pos = url_ftell(s->pb);
     //         if (av_read_frame(s, &pkt) < 0){
     //             av_log(s, AV_LOG_INFO, "seek failed\n");
     //             return -1;
@@ -1063,7 +1084,7 @@
 
         /* do the seek */
         av_log(NULL, AV_LOG_DEBUG, "SEEKTO: %"PRId64"\n", pos);
-        url_fseek(&s->pb, pos, SEEK_SET);
+        url_fseek(s->pb, pos, SEEK_SET);
     }
     asf_reset_header(s);
     return 0;
Only in ffmpeg-free-0.svn20080206/libavformat: asfcrypt.c
Only in ffmpeg-free-0.svn20080206/libavformat: asfcrypt.h
diff -u mplayer-1.0~rc2-12/libavformat/asf-enc.c ffmpeg-free-0.svn20080206/libavformat/asf-enc.c
--- mplayer-1.0~rc2-12/libavformat/asf-enc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/asf-enc.c	2008-01-31 01:34:22.000000000 +0100
@@ -199,7 +199,7 @@
 static void put_guid(ByteIOContext *s, const GUID *g)
 {
     assert(sizeof(*g) == 16);
-    put_buffer(s, g, sizeof(*g));
+    put_buffer(s, *g, sizeof(*g));
 }
 
 static void put_str16_nolen(ByteIOContext *s, const char *tag);
@@ -244,7 +244,7 @@
 static void put_chunk(AVFormatContext *s, int type, int payload_length, int flags)
 {
     ASFContext *asf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int length;
 
     length = payload_length + 8;
@@ -270,7 +270,7 @@
 static int asf_write_header1(AVFormatContext *s, int64_t file_size, int64_t data_chunk_size)
 {
     ASFContext *asf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int header_size, n, extra_size, extra_size2, wav_extra_size, file_time;
     int has_title;
     AVCodecContext *enc;
@@ -493,17 +493,20 @@
     asf->nb_packets = 0;
 
     asf->last_indexed_pts = 0;
-    asf->index_ptr = (ASFIndex*)av_malloc( sizeof(ASFIndex) * ASF_INDEX_BLOCK );
+    asf->index_ptr = av_malloc( sizeof(ASFIndex) * ASF_INDEX_BLOCK );
     asf->nb_index_memory_alloc = ASF_INDEX_BLOCK;
     asf->nb_index_count = 0;
     asf->maximum_packet = 0;
 
-    if (asf_write_header1(s, 0, 0) < 0) {
+    /* the data-chunk-size has to be 50, which is data_size - asf->data_offset
+     *  at the moment this function is done. It is needed to use asf as
+     *  streamable format. */
+    if (asf_write_header1(s, 0, 50) < 0) {
         //av_free(asf);
         return -1;
     }
 
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
 
     asf->packet_nb_payloads = 0;
     asf->packet_timestamp_start = -1;
@@ -532,7 +535,7 @@
             )
 {
     ASFContext *asf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int ppi_size, i;
     int64_t start= url_ftell(pb);
 
@@ -581,6 +584,8 @@
     ASFContext *asf = s->priv_data;
     int packet_hdr_size, packet_filled_size;
 
+    assert(asf->packet_timestamp_end >= asf->packet_timestamp_start);
+
     if (asf->is_streamed) {
         put_chunk(s, 0x4424, asf->packet_size, 0);
     }
@@ -597,9 +602,9 @@
     assert(packet_hdr_size <= asf->packet_size_left);
     memset(asf->packet_buf + packet_filled_size, 0, asf->packet_size_left);
 
-    put_buffer(&s->pb, asf->packet_buf, asf->packet_size - packet_hdr_size);
+    put_buffer(s->pb, asf->packet_buf, asf->packet_size - packet_hdr_size);
 
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
     asf->nb_packets++;
     asf->packet_nb_payloads = 0;
     asf->packet_timestamp_start = -1;
@@ -677,8 +682,6 @@
             // multi payloads
             frag_len1 = asf->packet_size_left - PAYLOAD_HEADER_SIZE_MULTIPLE_PAYLOADS - PACKET_HEADER_MIN_SIZE - 1;
 
-            asf->packet_timestamp_start = timestamp;
-
             if(frag_len1 < payload_len && avst->codec->codec_type == CODEC_TYPE_AUDIO){
                 flush_packet(s);
                 continue;
@@ -763,7 +766,7 @@
 //
 static int asf_write_index(AVFormatContext *s, ASFIndex *index, uint16_t max, uint32_t count)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int i;
 
     put_guid(pb, &simple_index_header);
@@ -790,22 +793,22 @@
         flush_packet(s);
 
     /* write index */
-    data_size = url_ftell(&s->pb);
+    data_size = url_ftell(s->pb);
     if ((!asf->is_streamed) && (asf->nb_index_count != 0)) {
         asf_write_index(s, asf->index_ptr, asf->maximum_packet, asf->nb_index_count);
     }
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
 
-    if (asf->is_streamed || url_is_streamed(&s->pb)) {
+    if (asf->is_streamed || url_is_streamed(s->pb)) {
         put_chunk(s, 0x4524, 0, 0); /* end of stream */
     } else {
         /* rewrite an updated header */
-        file_size = url_ftell(&s->pb);
-        url_fseek(&s->pb, 0, SEEK_SET);
+        file_size = url_ftell(s->pb);
+        url_fseek(s->pb, 0, SEEK_SET);
         asf_write_header1(s, file_size, data_size - asf->data_offset);
     }
 
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
     av_free(asf->index_ptr);
     return 0;
 }
diff -u mplayer-1.0~rc2-12/libavformat/asf.h ffmpeg-free-0.svn20080206/libavformat/asf.h
--- mplayer-1.0~rc2-12/libavformat/asf.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/asf.h	2007-12-23 22:01:09.000000000 +0100
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVFORMAT_ASF_H
-#define AVFORMAT_ASF_H
+#ifndef FFMPEG_ASF_H
+#define FFMPEG_ASF_H
 
 #include <stdint.h>
 #include "avformat.h"
@@ -56,7 +56,7 @@
     uint64_t send_time;         /**< time to send file, in 100-nanosecond units
                                  *   invalid if broadcasting (could be ignored) */
     uint32_t preroll;           /**< timestamp of the first packet, in milliseconds
-                                 *   if nonzero - substract from time */
+                                 *   if nonzero - subtract from time */
     uint32_t ignore;            ///< preroll is 64bit - but let's just ignore it
     uint32_t flags;             /**< 0x01 - broadcast
                                  *   0x02 - seekable
@@ -97,7 +97,7 @@
     uint8_t packet_buf[PACKET_SIZE];
     ByteIOContext pb;
     /* only for reading */
-    uint64_t data_offset;                ///< begining of the first data packet
+    uint64_t data_offset;                ///< beginning of the first data packet
     uint64_t data_object_offset;         ///< data object offset (excl. GUID & size)
     uint64_t data_object_size;           ///< size of the data object
     int index_read;
@@ -286,4 +286,4 @@
 
 #define ASF_PL_FLAG_KEY_FRAME 0x80 //1000 0000
 
-#endif // AVFORMAT_ASF_H
+#endif /* FFMPEG_ASF_H */
diff -u mplayer-1.0~rc2-12/libavformat/au.c ffmpeg-free-0.svn20080206/libavformat/au.c
--- mplayer-1.0~rc2-12/libavformat/au.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/au.c	2008-01-13 16:08:33.000000000 +0100
@@ -37,6 +37,7 @@
 /* The ffmpeg codecs we support, and the IDs they have in the file */
 static const AVCodecTag codec_au_tags[] = {
     { CODEC_ID_PCM_MULAW, 1 },
+    { CODEC_ID_PCM_S8, 2 },
     { CODEC_ID_PCM_S16BE, 3 },
     { CODEC_ID_PCM_ALAW, 27 },
     { 0, 0 },
@@ -59,7 +60,7 @@
 
 static int au_write_header(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
 
     s->priv_data = NULL;
 
@@ -75,17 +76,17 @@
 
 static int au_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     put_buffer(pb, pkt->data, pkt->size);
     return 0;
 }
 
 static int au_write_trailer(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     offset_t file_size;
 
-    if (!url_is_streamed(&s->pb)) {
+    if (!url_is_streamed(s->pb)) {
 
         /* update file size */
         file_size = url_ftell(pb);
@@ -116,7 +117,7 @@
 {
     int size;
     unsigned int tag;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     unsigned int id, codec, channels, rate;
     AVStream *st;
 
@@ -158,9 +159,9 @@
 {
     int ret;
 
-    if (url_feof(&s->pb))
+    if (url_feof(s->pb))
         return AVERROR(EIO);
-    ret= av_get_packet(&s->pb, pkt, MAX_SIZE);
+    ret= av_get_packet(s->pb, pkt, MAX_SIZE);
     if (ret < 0)
         return AVERROR(EIO);
     pkt->stream_index = 0;
Only in mplayer-1.0~rc2-12/libavformat: audio.c
Only in ffmpeg-free-0.svn20080206/libavformat: avc.c
Only in ffmpeg-free-0.svn20080206/libavformat: avc.h
diff -u mplayer-1.0~rc2-12/libavformat/avformat.h ffmpeg-free-0.svn20080206/libavformat/avformat.h
--- mplayer-1.0~rc2-12/libavformat/avformat.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/avformat.h	2008-01-29 10:25:49.000000000 +0100
@@ -18,11 +18,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVFORMAT_H
-#define AVFORMAT_H
+#ifndef FFMPEG_AVFORMAT_H
+#define FFMPEG_AVFORMAT_H
 
-#define LIBAVFORMAT_VERSION_INT ((51<<16)+(14<<8)+0)
-#define LIBAVFORMAT_VERSION     51.14.0
+#define LIBAVFORMAT_VERSION_INT ((52<<16)+(7<<8)+0)
+#define LIBAVFORMAT_VERSION     52.7.0
 #define LIBAVFORMAT_BUILD       LIBAVFORMAT_VERSION_INT
 
 #define LIBAVFORMAT_IDENT       "Lavf" AV_STRINGIFY(LIBAVFORMAT_VERSION)
@@ -136,9 +136,6 @@
     int height;
     enum PixelFormat pix_fmt;
     int channel; /**< used to select dv channel */
-#if LIBAVFORMAT_VERSION_INT < (52<<16)
-    const char *device; /**< video, audio or DV device */
-#endif
     const char *standard; /**< tv standard, NTSC, PAL, SECAM */
     int mpeg2ts_raw:1;  /**< force raw MPEG2 transport stream output, if possible */
     int mpeg2ts_compute_pcr:1; /**< compute exact PCR for each transport
@@ -147,8 +144,10 @@
     int initial_pause:1;       /**< do not begin to play the stream
                                   immediately (RTSP only) */
     int prealloced_context:1;
+#if LIBAVFORMAT_VERSION_INT < (53<<16)
     enum CodecID video_codec_id;
     enum CodecID audio_codec_id;
+#endif
 } AVFormatParameters;
 
 //! demuxer will use url_fopen, no opened file should be provided by the caller
@@ -198,9 +197,9 @@
     /** size of private data so that it can be allocated in the wrapper */
     int priv_data_size;
     /**
-     * tell if a given file has a chance of being parsed by this format.
-     * The buffer provided is guranteed to be AVPROBE_PADDING_SIZE bytes big
-     * so you dont have to check for that unless you need more.
+     * Tell if a given file has a chance of being parsed by this format.
+     * The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes
+     * big so you do not have to check for that unless you need more.
      */
     int (*read_probe)(AVProbeData *);
     /** read the format header and initialize the AVFormatContext
@@ -227,7 +226,8 @@
     int (*read_seek)(struct AVFormatContext *,
                      int stream_index, int64_t timestamp, int flags);
     /**
-     * gets the next timestamp in AV_TIME_BASE units.
+     * gets the next timestamp in stream[stream_index].time_base units.
+     * @return the timestamp or AV_NOPTS_VALUE if an error occured
      */
     int64_t (*read_timestamp)(struct AVFormatContext *s, int stream_index,
                               int64_t *pos, int64_t pos_limit);
@@ -270,33 +270,37 @@
     int min_distance;         /**< min distance between this and the previous keyframe, used to avoid unneeded searching */
 } AVIndexEntry;
 
+/**
+ * Stream structure.
+ * New fields can be added to the end with minor version bumps.
+ * Removal, reordering and changes to existing fields require a major
+ * version bump.
+ * sizeof(AVStream) must not be used outside libav*.
+ */
 typedef struct AVStream {
     int index;    /**< stream index in AVFormatContext */
     int id;       /**< format specific stream id */
     AVCodecContext *codec; /**< codec context */
     /**
-     * real base frame rate of the stream.
-     * this is the lowest framerate with which all timestamps can be
+     * Real base frame rate of the stream.
+     * This is the lowest frame rate with which all timestamps can be
      * represented accurately (it is the least common multiple of all
-     * framerates in the stream), Note, this value is just a guess!
-     * for example if the timebase is 1/90000 and all frames have either
-     * approximately 3600 or 1800 timer ticks then r_frame_rate will be 50/1
+     * frame rates in the stream), Note, this value is just a guess!
+     * For example if the timebase is 1/90000 and all frames have either
+     * approximately 3600 or 1800 timer ticks then r_frame_rate will be 50/1.
      */
     AVRational r_frame_rate;
     void *priv_data;
 
     /* internal data used in av_find_stream_info() */
     int64_t first_dts;
-#if LIBAVFORMAT_VERSION_INT < (52<<16)
-    int codec_info_nb_frames;
-#endif
     /** encoding: PTS generation when outputing stream */
     struct AVFrac pts;
 
     /**
-     * this is the fundamental unit of time (in seconds) in terms
-     * of which frame timestamps are represented. for fixed-fps content,
-     * timebase should be 1/framerate and timestamp increments should be
+     * This is the fundamental unit of time (in seconds) in terms
+     * of which frame timestamps are represented. For fixed-fps content,
+     * timebase should be 1/frame rate and timestamp increments should be
      * identically 1.
      */
     AVRational time_base;
@@ -309,16 +313,16 @@
      * MN: dunno if that is the right place for it */
     float quality;
     /**
-     * decoding: pts of the first frame of the stream, in stream time base.
-     * only set this if you are absolutely 100% sure that the value you set
-     * it to really is the pts of the first frame
+     * Decoding: pts of the first frame of the stream, in stream time base.
+     * Only set this if you are absolutely 100% sure that the value you set
+     * it to really is the pts of the first frame.
      * This may be undefined (AV_NOPTS_VALUE).
-     * @note the ASF header does NOT contain a correct start_time the ASF
-     * demuxer must NOT set this
+     * @note The ASF header does NOT contain a correct start_time the ASF
+     * demuxer must NOT set this.
      */
     int64_t start_time;
     /**
-     * decoding: duration of the stream, in stream time base.
+     * Decoding: duration of the stream, in stream time base.
      * If a source file does not specify a duration, but does specify
      * a bitrate, this value will be estimates from bit rate and file size.
      */
@@ -343,16 +347,26 @@
 
 #define MAX_REORDER_DELAY 4
     int64_t pts_buffer[MAX_REORDER_DELAY+1];
+
+    char *filename; /**< source filename of the stream */
 } AVStream;
 
 #define AV_PROGRAM_RUNNING 1
 
+/**
+ * New fields can be added to the end with minor version bumps.
+ * Removal, reordering and changes to existing fields require a major
+ * version bump.
+ * sizeof(AVProgram) must not be used outside libav*.
+ */
 typedef struct AVProgram {
     int            id;
     char           *provider_name; ///< Network name for DVB streams
     char           *name;          ///< Service name for DVB streams
     int            flags;
     enum AVDiscard discard;        ///< selects which program to discard and which to feed to the caller
+    unsigned int   *stream_index;
+    unsigned int   nb_stream_indexes;
 } AVProgram;
 
 #define AVFMTCTX_NOHEADER      0x0001 /**< signal that no header is present
@@ -360,14 +374,20 @@
 
 #define MAX_STREAMS 20
 
-/* format I/O context */
+/**
+ * format I/O context.
+ * New fields can be added to the end with minor version bumps.
+ * Removal, reordering and changes to existing fields require a major
+ * version bump.
+ * sizeof(AVFormatContext) must not be used outside libav*.
+ */
 typedef struct AVFormatContext {
     const AVClass *av_class; /**< set by av_alloc_format_context */
     /* can only be iformat or oformat, not both at the same time */
     struct AVInputFormat *iformat;
     struct AVOutputFormat *oformat;
     void *priv_data;
-    ByteIOContext pb;
+    ByteIOContext *pb;
     unsigned int nb_streams;
     AVStream *streams[MAX_STREAMS];
     char filename[1024]; /**< input or output filename */
@@ -443,6 +463,34 @@
 
     unsigned int nb_programs;
     AVProgram **programs;
+
+    /**
+     * Forced video codec_id.
+     * demuxing: set by user
+     */
+    enum CodecID video_codec_id;
+    /**
+     * Forced audio codec_id.
+     * demuxing: set by user
+     */
+    enum CodecID audio_codec_id;
+    /**
+     * Forced subtitle codec_id.
+     * demuxing: set by user
+     */
+    enum CodecID subtitle_codec_id;
+
+    /**
+     * Maximum amount of memory in bytes to use per stream for the index.
+     * If the needed index exceeds this size entries will be discarded as
+     * needed to maintain a smaller size. This can lead to slower or less
+     * accurate seeking (depends on demuxer).
+     * Demuxers for which a full in memory index is mandatory will ignore
+     * this.
+     * muxing  : unused
+     * demuxing: set by user
+     */
+    unsigned int max_index_size;
 } AVFormatContext;
 
 typedef struct AVPacketList {
@@ -450,18 +498,19 @@
     struct AVPacketList *next;
 } AVPacketList;
 
+#if LIBAVFORMAT_VERSION_INT < (53<<16)
 extern AVInputFormat *first_iformat;
 extern AVOutputFormat *first_oformat;
+#endif
+
+AVInputFormat  *av_iformat_next(AVInputFormat  *f);
+AVOutputFormat *av_oformat_next(AVOutputFormat *f);
 
 enum CodecID av_guess_image2_codec(const char *filename);
 
 /* XXX: use automatic init with either ELF sections or C file parser */
 /* modules */
 
-#include "rtp.h"
-
-#include "rtsp.h"
-
 /* utils.c */
 void av_register_input_format(AVInputFormat *format);
 void av_register_output_format(AVOutputFormat *format);
@@ -566,7 +615,11 @@
                        AVInputFormat *fmt,
                        int buf_size,
                        AVFormatParameters *ap);
-/** no av_open for output, so applications will need this: */
+/**
+ * Allocate an AVFormatContext.
+ * Can be freed with av_free() but do not forget to free everything you
+ * explicitly allocated as well!
+ */
 AVFormatContext *av_alloc_format_context(void);
 
 /**
@@ -579,7 +632,7 @@
  *
  * @param ic media file handle
  * @return >=0 if OK. AVERROR_xxx if error.
- * @todo Let user decide somehow what information is needed so we do not waste time geting stuff the user does not need.
+ * @todo Let user decide somehow what information is needed so we do not waste time getting stuff the user does not need.
  */
 int av_find_stream_info(AVFormatContext *ic);
 
@@ -643,6 +696,12 @@
 int av_read_pause(AVFormatContext *s);
 
 /**
+ * Free a AVFormatContext allocated by av_open_input_stream.
+ * @param s context to free
+ */
+void av_close_input_stream(AVFormatContext *s);
+
+/**
  * Close a media file (but not its codecs).
  *
  * @param s media file handle
@@ -691,6 +750,15 @@
 int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags);
 
 /**
+ * Ensures the index uses less memory than the maximum specified in
+ * AVFormatContext.max_index_size, by discarding entries if it grows
+ * too large.
+ * This function is not part of the public API and should only be called
+ * by demuxers.
+ */
+void ff_reduce_index(AVFormatContext *s, int stream_index);
+
+/**
  * Add a index entry into a sorted list updateing if it is already there.
  *
  * @param timestamp timestamp in the timebase of the given stream
@@ -828,7 +896,7 @@
  * @endcode
  * Returns the number of microseconds contained in a time interval
  * with the specified duration or INT64_MIN if \p datestr cannot be
- * succesfully parsed.
+ * successfully parsed.
  * @param duration Flag which tells how to interpret \p datestr, if
  * not zero \p datestr is interpreted as a duration, otherwise as a
  * date.
@@ -860,7 +928,7 @@
  * @param buf destination buffer
  * @param buf_size destination buffer size
  * @param path numbered sequence string
- * @number frame number
+ * @param number frame number
  * @return 0 if OK, -1 if format error.
  */
 int av_get_frame_filename(char *buf, int buf_size,
@@ -892,8 +960,6 @@
 
 #ifdef HAVE_AV_CONFIG_H
 
-#include "os_support.h"
-
 void __dynarray_add(unsigned long **tab_ptr, int *nb_ptr, unsigned long elem);
 
 #ifdef __GNUC__
@@ -930,5 +996,4 @@
 
 #endif /* HAVE_AV_CONFIG_H */
 
-#endif /* AVFORMAT_H */
-
+#endif /* FFMPEG_AVFORMAT_H */
diff -u mplayer-1.0~rc2-12/libavformat/avidec.c ffmpeg-free-0.svn20080206/libavformat/avidec.c
--- mplayer-1.0~rc2-12/libavformat/avidec.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/avidec.c	2008-01-01 23:05:51.000000000 +0100
@@ -106,7 +106,7 @@
 
 static int read_braindead_odml_indx(AVFormatContext *s, int frame_num){
     AVIContext *avi = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int longs_pre_entry= get_le16(pb);
     int index_sub_type = get_byte(pb);
     int index_type     = get_byte(pb);
@@ -118,7 +118,7 @@
     AVIStream *ast;
     int i;
     int64_t last_pos= -1;
-    int64_t filesize= url_fsize(&s->pb);
+    int64_t filesize= url_fsize(s->pb);
 
 #ifdef DEBUG_SEEK
     av_log(s, AV_LOG_ERROR, "longs_pre_entry:%d index_type:%d entries_in_use:%d chunk_id:%X base:%16"PRIX64"\n",
@@ -225,7 +225,7 @@
 static int avi_read_header(AVFormatContext *s, AVFormatParameters *ap)
 {
     AVIContext *avi = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     uint32_t tag, tag1, handler;
     int codec_type, stream_index, frame_period, bit_rate;
     unsigned int size, nb_frames;
@@ -523,6 +523,31 @@
             }
             url_fseek(pb, i+size, SEEK_SET);
             break;
+        case MKTAG('v', 'p', 'r', 'p'):
+            if(stream_index < (unsigned)s->nb_streams && size > 9*4){
+                AVRational active, active_aspect;
+
+                st = s->streams[stream_index];
+                get_le32(pb);
+                get_le32(pb);
+                get_le32(pb);
+                get_le32(pb);
+                get_le32(pb);
+
+                active_aspect.num= get_le16(pb);
+                active_aspect.den= get_le16(pb);
+                active.num       = get_le32(pb);
+                active.den       = get_le32(pb);
+                get_le32(pb); //nbFieldsPerFrame
+
+                if(active_aspect.num && active_aspect.den && active.num && active.den){
+                    st->codec->sample_aspect_ratio= av_div_q(active_aspect, active);
+//av_log(s, AV_LOG_ERROR, "vprp %d/%d %d/%d\n", active_aspect.num, active_aspect.den, active.num, active.den);
+                }
+                size -= 9*4;
+            }
+            url_fseek(pb, size, SEEK_CUR);
+            break;
         case MKTAG('I', 'N', 'A', 'M'):
             avi_read_tag(pb, s->title, sizeof(s->title), size);
             break;
@@ -583,7 +608,7 @@
 static int avi_read_packet(AVFormatContext *s, AVPacket *pkt)
 {
     AVIContext *avi = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int n, d[8], size;
     offset_t i, sync;
     void* dstr;
@@ -628,7 +653,7 @@
         if(i>=0){
             int64_t pos= best_st->index_entries[i].pos;
             pos += best_ast->packet_size - best_ast->remaining;
-            url_fseek(&s->pb, pos + 8, SEEK_SET);
+            url_fseek(s->pb, pos + 8, SEEK_SET);
 //        av_log(NULL, AV_LOG_DEBUG, "pos=%"PRId64"\n", pos);
 
             assert(best_ast->remaining <= best_ast->packet_size);
@@ -819,7 +844,7 @@
 static int avi_read_idx1(AVFormatContext *s, int size)
 {
     AVIContext *avi = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int nb_index_entries, i;
     AVStream *st;
     AVIStream *ast;
@@ -890,7 +915,7 @@
 static int avi_load_index(AVFormatContext *s)
 {
     AVIContext *avi = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     uint32_t tag, size;
     offset_t pos= url_ftell(pb);
 
@@ -965,7 +990,7 @@
         /* DV demux so it can synth correct timestamps              */
         dv_offset_reset(avi->dv_demux, timestamp);
 
-        url_fseek(&s->pb, pos, SEEK_SET);
+        url_fseek(s->pb, pos, SEEK_SET);
         avi->stream_index= -1;
         return 0;
     }
@@ -1005,7 +1030,7 @@
     }
 
     /* do the seek */
-    url_fseek(&s->pb, pos, SEEK_SET);
+    url_fseek(s->pb, pos, SEEK_SET);
     avi->stream_index= -1;
     return 0;
 }
diff -u mplayer-1.0~rc2-12/libavformat/avienc.c ffmpeg-free-0.svn20080206/libavformat/avienc.c
--- mplayer-1.0~rc2-12/libavformat/avienc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/avienc.c	2007-11-21 08:41:00.000000000 +0100
@@ -105,7 +105,7 @@
 
 static int avi_write_counters(AVFormatContext* s, int riff_id)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVIContext *avi = s->priv_data;
     int n, au_byterate, au_ssize, au_scale, nb_frames = 0;
     offset_t file_size;
@@ -138,7 +138,7 @@
 static int avi_write_header(AVFormatContext *s)
 {
     AVIContext *avi = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int bitrate, n, i, nb_frames, au_byterate, au_ssize, au_scale;
     AVCodecContext *stream, *video_enc;
     offset_t list1, list2, strh, strf;
@@ -332,7 +332,7 @@
 
 static int avi_write_ix(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVIContext *avi = s->priv_data;
     char tag[5];
     char ix_tag[] = "ix00";
@@ -389,7 +389,7 @@
 
 static int avi_write_idx1(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVIContext *avi = s->priv_data;
     offset_t idx_chunk;
     int i;
@@ -435,7 +435,7 @@
 static int avi_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
     AVIContext *avi = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     unsigned char tag[5];
     unsigned int flags=0;
     const int stream_index= pkt->stream_index;
@@ -476,7 +476,7 @@
        avi->audio_strm_length[stream_index] += size;
     }
 
-    if (!url_is_streamed(&s->pb)) {
+    if (!url_is_streamed(s->pb)) {
         AVIIndex* idx = &avi->indexes[stream_index];
         int cl = idx->entry / AVI_INDEX_CLUSTER_SIZE;
         int id = idx->entry % AVI_INDEX_CLUSTER_SIZE;
@@ -509,7 +509,7 @@
 static int avi_write_trailer(AVFormatContext *s)
 {
     AVIContext *avi = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int res = 0;
     int i, j, n, nb_frames;
     offset_t file_size;
diff -u mplayer-1.0~rc2-12/libavformat/aviobuf.c ffmpeg-free-0.svn20080206/libavformat/aviobuf.c
--- mplayer-1.0~rc2-12/libavformat/aviobuf.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/aviobuf.c	2008-01-05 00:09:58.000000000 +0100
@@ -20,6 +20,7 @@
  */
 #include "avformat.h"
 #include "avio.h"
+#include "crc.h"
 #include <stdarg.h>
 
 #define IO_BUFFER_SIZE 32768
@@ -38,11 +39,7 @@
     s->buffer = buffer;
     s->buffer_size = buffer_size;
     s->buf_ptr = buffer;
-    s->write_flag = write_flag;
-    if (!s->write_flag)
-        s->buf_end = buffer;
-    else
-        s->buf_end = buffer + buffer_size;
+    url_resetbuf(s, write_flag ? URL_WRONLY : URL_RDONLY);
     s->opaque = opaque;
     s->write_packet = write_packet;
     s->read_packet = read_packet;
@@ -58,9 +55,25 @@
         s->pos = buffer_size;
         s->buf_end = s->buffer + buffer_size;
     }
+    s->read_pause = NULL;
+    s->read_seek  = NULL;
     return 0;
 }
 
+ByteIOContext *av_alloc_put_byte(
+                  unsigned char *buffer,
+                  int buffer_size,
+                  int write_flag,
+                  void *opaque,
+                  int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
+                  int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
+                  offset_t (*seek)(void *opaque, offset_t offset, int whence)) {
+    ByteIOContext *s = av_mallocz(sizeof(ByteIOContext));
+    init_put_byte(s, buffer, buffer_size, write_flag, opaque,
+                  read_packet, write_packet, seek);
+    return s;
+}
+
 static void flush_buffer(ByteIOContext *s)
 {
     if (s->buf_ptr > s->buffer) {
@@ -114,7 +127,12 @@
 offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)
 {
     offset_t offset1;
-    offset_t pos= s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));
+    offset_t pos;
+
+    if(!s)
+        return AVERROR(EINVAL);
+
+    pos = s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));
 
     if (whence != SEEK_CUR && whence != SEEK_SET)
         return AVERROR(EINVAL);
@@ -134,6 +152,8 @@
               offset1 >= 0 && offset1 < (s->buf_end - s->buffer) + (1<<16)){
         while(s->pos < offset && !s->eof_reached)
             fill_buffer(s);
+        if (s->eof_reached)
+            return AVERROR(EPIPE);
         s->buf_ptr = s->buf_end + offset - s->pos;
     } else {
         offset_t res = AVERROR(EPIPE);
@@ -170,6 +190,9 @@
 {
     offset_t size;
 
+    if(!s)
+        return AVERROR(EINVAL);
+
     if (!s->seek)
         return AVERROR(EPIPE);
     size = s->seek(s->opaque, 0, AVSEEK_SIZE);
@@ -184,11 +207,15 @@
 
 int url_feof(ByteIOContext *s)
 {
+    if(!s)
+        return 0;
     return s->eof_reached;
 }
 
 int url_ferror(ByteIOContext *s)
 {
+    if(!s)
+        return 0;
     return s->error;
 }
 
@@ -290,6 +317,10 @@
     }
 }
 
+unsigned long ff_crc04C11DB7_update(unsigned long checksum, const uint8_t *buf, unsigned int len){
+    return av_crc(av_crc_get_table(AV_CRC_32_IEEE), checksum, buf, len);
+}
+
 unsigned long get_checksum(ByteIOContext *s){
     s->checksum= s->update_checksum(s->checksum, s->checksum_ptr, s->buf_ptr - s->checksum_ptr);
     s->update_checksum= NULL;
@@ -471,32 +502,18 @@
     return val;
 }
 
-/* link with avio functions */
-
-#ifdef CONFIG_MUXERS
-static int url_write_packet(void *opaque, uint8_t *buf, int buf_size)
-{
-    URLContext *h = opaque;
-    return url_write(h, buf, buf_size);
-}
-#else
-#define         url_write_packet NULL
-#endif //CONFIG_MUXERS
-
-static int url_read_packet(void *opaque, uint8_t *buf, int buf_size)
-{
-    URLContext *h = opaque;
-    return url_read(h, buf, buf_size);
-}
-
-static offset_t url_seek_packet(void *opaque, offset_t offset, int whence)
-{
-    URLContext *h = opaque;
-    return url_seek(h, offset, whence);
-    //return 0;
+uint64_t ff_get_v(ByteIOContext *bc){
+    uint64_t val = 0;
+    int tmp;
+
+    do{
+        tmp = get_byte(bc);
+        val= (val<<7) + (tmp&127);
+    }while(tmp&128);
+    return val;
 }
 
-int url_fdopen(ByteIOContext *s, URLContext *h)
+int url_fdopen(ByteIOContext **s, URLContext *h)
 {
     uint8_t *buffer;
     int buffer_size, max_packet_size;
@@ -512,14 +529,25 @@
     if (!buffer)
         return AVERROR(ENOMEM);
 
-    if (init_put_byte(s, buffer, buffer_size,
+    *s = av_mallocz(sizeof(ByteIOContext));
+    if(!*s) {
+        av_free(buffer);
+        return AVERROR(ENOMEM);
+    }
+
+    if (init_put_byte(*s, buffer, buffer_size,
                       (h->flags & URL_WRONLY || h->flags & URL_RDWR), h,
-                      url_read_packet, url_write_packet, url_seek_packet) < 0) {
+                      url_read, url_write, url_seek) < 0) {
         av_free(buffer);
+        av_freep(s);
         return AVERROR(EIO);
     }
-    s->is_streamed = h->is_streamed;
-    s->max_packet_size = max_packet_size;
+    (*s)->is_streamed = h->is_streamed;
+    (*s)->max_packet_size = max_packet_size;
+    if(h->prot) {
+        (*s)->read_pause = (int (*)(void *, int))h->prot->url_read_pause;
+        (*s)->read_seek  = (offset_t (*)(void *, int, int64_t, int))h->prot->url_read_seek;
+    }
     return 0;
 }
 
@@ -534,14 +562,27 @@
     s->buffer = buffer;
     s->buffer_size = buf_size;
     s->buf_ptr = buffer;
-    if (!s->write_flag)
-        s->buf_end = buffer;
-    else
-        s->buf_end = buffer + buf_size;
+    url_resetbuf(s, s->write_flag ? URL_WRONLY : URL_RDONLY);
+    return 0;
+}
+
+int url_resetbuf(ByteIOContext *s, int flags)
+{
+    URLContext *h = s->opaque;
+    if ((flags & URL_RDWR) || (h && h->flags != flags && !h->flags & URL_RDWR))
+        return AVERROR(EINVAL);
+
+    if (flags & URL_WRONLY) {
+        s->buf_end = s->buffer + s->buffer_size;
+        s->write_flag = 1;
+    } else {
+        s->buf_end = s->buffer;
+        s->write_flag = 0;
+    }
     return 0;
 }
 
-int url_fopen(ByteIOContext *s, const char *filename, int flags)
+int url_fopen(ByteIOContext **s, const char *filename, int flags)
 {
     URLContext *h;
     int err;
@@ -562,7 +603,7 @@
     URLContext *h = s->opaque;
 
     av_free(s->buffer);
-    memset(s, 0, sizeof(ByteIOContext));
+    av_free(s);
     return url_close(h);
 }
 
@@ -612,15 +653,44 @@
     return s->max_packet_size;
 }
 
+int av_url_read_fpause(ByteIOContext *s, int pause)
+{
+    if (!s->read_pause)
+        return AVERROR(ENOSYS);
+    return s->read_pause(s->opaque, pause);
+}
+
+offset_t av_url_read_fseek(ByteIOContext *s,
+        int stream_index, int64_t timestamp, int flags)
+{
+    URLContext *h = s->opaque;
+    offset_t ret;
+    if (!s->read_seek)
+        return AVERROR(ENOSYS);
+    ret = s->read_seek(h, stream_index, timestamp, flags);
+    if(ret >= 0) {
+        s->buf_ptr = s->buf_end; // Flush buffer
+        s->pos = s->seek(h, 0, SEEK_CUR);
+    }
+    return ret;
+}
+
 /* url_open_dyn_buf and url_close_dyn_buf are used in rtp.c to send a response
  * back to the server even if CONFIG_MUXERS is not set. */
 #if defined(CONFIG_MUXERS) || defined(CONFIG_NETWORK)
 /* buffer handling */
-int url_open_buf(ByteIOContext *s, uint8_t *buf, int buf_size, int flags)
+int url_open_buf(ByteIOContext **s, uint8_t *buf, int buf_size, int flags)
 {
-    return init_put_byte(s, buf, buf_size,
-                         (flags & URL_WRONLY || flags & URL_RDWR),
-                         NULL, NULL, NULL, NULL);
+    int ret;
+    *s = av_mallocz(sizeof(ByteIOContext));
+    if(!*s)
+        return AVERROR(ENOMEM);
+    ret = init_put_byte(*s, buf, buf_size,
+                        (flags & URL_WRONLY || flags & URL_RDWR),
+                        NULL, NULL, NULL, NULL);
+    if(ret != 0)
+        av_freep(s);
+    return ret;
 }
 
 int url_close_buf(ByteIOContext *s)
@@ -700,7 +770,7 @@
     return 0;
 }
 
-static int url_open_dyn_buf_internal(ByteIOContext *s, int max_packet_size)
+static int url_open_dyn_buf_internal(ByteIOContext **s, int max_packet_size)
 {
     DynBuffer *d;
     int io_buffer_size, ret;
@@ -715,27 +785,35 @@
     d = av_malloc(sizeof(DynBuffer) + io_buffer_size);
     if (!d)
         return -1;
+    *s = av_mallocz(sizeof(ByteIOContext));
+    if(!*s) {
+        av_free(d);
+        return AVERROR(ENOMEM);
+    }
     d->io_buffer_size = io_buffer_size;
     d->buffer = NULL;
     d->pos = 0;
     d->size = 0;
     d->allocated_size = 0;
-    ret = init_put_byte(s, d->io_buffer, io_buffer_size,
+    ret = init_put_byte(*s, d->io_buffer, io_buffer_size,
                         1, d, NULL,
                         max_packet_size ? dyn_packet_buf_write : dyn_buf_write,
                         max_packet_size ? NULL : dyn_buf_seek);
     if (ret == 0) {
-        s->max_packet_size = max_packet_size;
+        (*s)->max_packet_size = max_packet_size;
+    } else {
+        av_free(d);
+        av_freep(s);
     }
     return ret;
 }
 
-int url_open_dyn_buf(ByteIOContext *s)
+int url_open_dyn_buf(ByteIOContext **s)
 {
     return url_open_dyn_buf_internal(s, 0);
 }
 
-int url_open_dyn_packet_buf(ByteIOContext *s, int max_packet_size)
+int url_open_dyn_packet_buf(ByteIOContext **s, int max_packet_size)
 {
     if (max_packet_size <= 0)
         return -1;
@@ -752,6 +830,7 @@
     *pbuffer = d->buffer;
     size = d->size;
     av_free(d);
+    av_free(s);
     return size;
 }
 #endif /* CONFIG_MUXERS || CONFIG_NETWORK */
diff -u mplayer-1.0~rc2-12/libavformat/avio.c ffmpeg-free-0.svn20080206/libavformat/avio.c
--- mplayer-1.0~rc2-12/libavformat/avio.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/avio.c	2008-01-08 23:07:59.000000000 +0100
@@ -26,6 +26,12 @@
 URLProtocol *first_protocol = NULL;
 URLInterruptCB *url_interrupt_cb = default_interrupt_cb;
 
+URLProtocol *av_protocol_next(URLProtocol *p)
+{
+    if(p) return p->next;
+    else  return first_protocol;
+}
+
 int register_protocol(URLProtocol *protocol)
 {
     URLProtocol **p;
@@ -76,9 +82,7 @@
         err = AVERROR(ENOMEM);
         goto fail;
     }
-#if LIBAVFORMAT_VERSION_INT >= (52<<16)
     uc->filename = (char *) &uc[1];
-#endif
     strcpy(uc->filename, filename);
     uc->prot = up;
     uc->flags = flags;
@@ -106,7 +110,6 @@
     return ret;
 }
 
-#if defined(CONFIG_MUXERS) || defined(CONFIG_PROTOCOLS)
 int url_write(URLContext *h, unsigned char *buf, int size)
 {
     int ret;
@@ -118,7 +121,6 @@
     ret = h->prot->url_write(h, buf, size);
     return ret;
 }
-#endif //CONFIG_MUXERS || CONFIG_PROTOCOLS
 
 offset_t url_seek(URLContext *h, offset_t pos, int whence)
 {
@@ -132,9 +134,11 @@
 
 int url_close(URLContext *h)
 {
-    int ret;
+    int ret = 0;
+    if (!h) return 0; /* can happen when url_open fails */
 
-    ret = h->prot->url_close(h);
+    if (h->prot->url_close)
+        ret = h->prot->url_close(h);
     av_free(h);
     return ret;
 }
@@ -185,3 +189,18 @@
         interrupt_cb = default_interrupt_cb;
     url_interrupt_cb = interrupt_cb;
 }
+
+int av_url_read_pause(URLContext *h, int pause)
+{
+    if (!h->prot->url_read_pause)
+        return AVERROR(ENOSYS);
+    return h->prot->url_read_pause(h, pause);
+}
+
+offset_t av_url_read_seek(URLContext *h,
+        int stream_index, int64_t timestamp, int flags)
+{
+    if (!h->prot->url_read_seek)
+        return AVERROR(ENOSYS);
+    return h->prot->url_read_seek(h, stream_index, timestamp, flags);
+}
diff -u mplayer-1.0~rc2-12/libavformat/avio.h ffmpeg-free-0.svn20080206/libavformat/avio.h
--- mplayer-1.0~rc2-12/libavformat/avio.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/avio.h	2007-12-22 17:18:07.000000000 +0100
@@ -18,8 +18,8 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-#ifndef AVIO_H
-#define AVIO_H
+#ifndef FFMPEG_AVIO_H
+#define FFMPEG_AVIO_H
 
 #include <stdint.h>
 
@@ -29,17 +29,20 @@
 
 /* unbuffered I/O */
 
+/**
+ * URL Context.
+ * New fields can be added to the end with minor version bumps.
+ * Removal, reordering and changes to existing fields require a major
+ * version bump.
+ * sizeof(URLContext) must not be used outside libav*.
+ */
 struct URLContext {
     struct URLProtocol *prot;
     int flags;
     int is_streamed;  /**< true if streamed (no seek possible), default = false */
     int max_packet_size;  /**< if non zero, the stream is packetized with this max packet size */
     void *priv_data;
-#if LIBAVFORMAT_VERSION_INT >= (52<<16)
     char *filename; /**< specified filename */
-#else
-    char filename[1]; /**< specified filename */
-#endif
 };
 
 typedef struct URLContext URLContext;
@@ -66,7 +69,7 @@
 
 /**
  * Return the maximum packet size associated to packetized file
- * handle. If the file is not packetized (stream like http or file on
+ * handle. If the file is not packetized (stream like HTTP or file on
  * disk), then 0 is returned.
  *
  * @param h file handle
@@ -76,10 +79,10 @@
 void url_get_filename(URLContext *h, char *buf, int buf_size);
 
 /**
- * the callback is called in blocking functions to test regulary if
+ * The callback is called in blocking functions to test regulary if
  * asynchronous interruption is needed. AVERROR(EINTR) is returned
  * in this case by the interrupted function. 'NULL' means no interrupt
- * callback is given. i
+ * callback is given.
  */
 void url_set_interrupt_cb(URLInterruptCB *interrupt_cb);
 
@@ -87,6 +90,33 @@
 int url_poll(URLPollEntry *poll_table, int n, int timeout);
 
 /**
+ * Pause and resume playing - only meaningful if using a network streaming
+ * protocol (e.g. MMS).
+ * @param pause 1 for pause, 0 for resume
+ */
+int av_url_read_pause(URLContext *h, int pause);
+
+/**
+ * Seek to a given timestamp relative to some component stream.
+ * Only meaningful if using a network streaming protocol (e.g. MMS.).
+ * @param stream_index The stream index that the timestamp is relative to.
+ *        If stream_index is (-1) the timestamp should be in AV_TIME_BASE
+ *        units from the beginning of the presentation.
+ *        If a stream_index >= 0 is used and the protocol does not support
+ *        seeking based on component streams, the call will fail with ENOTSUP.
+ * @param timestamp timestamp in AVStream.time_base units
+ *        or if there is no stream specified then in AV_TIME_BASE units.
+ * @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE
+ *        and AVSEEK_FLAG_ANY. The protocol may silently ignore
+ *        AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will
+ *        fail with ENOTSUP if used and not supported.
+ * @return >= 0 on success
+ * @see AVInputFormat::read_seek
+ */
+offset_t av_url_read_seek(URLContext *h,
+                     int stream_index, int64_t timestamp, int flags);
+
+/**
  * Passing this as the "whence" parameter to a seek function causes it to
  * return the filesize without seeking anywhere. Supporting this is optional.
  * If it is not supported then the seek function will return <0.
@@ -101,13 +131,25 @@
     offset_t (*url_seek)(URLContext *h, offset_t pos, int whence);
     int (*url_close)(URLContext *h);
     struct URLProtocol *next;
+    int (*url_read_pause)(URLContext *h, int pause);
+    offset_t (*url_read_seek)(URLContext *h,
+                         int stream_index, int64_t timestamp, int flags);
 } URLProtocol;
 
 extern URLProtocol *first_protocol;
 extern URLInterruptCB *url_interrupt_cb;
 
+URLProtocol *av_protocol_next(URLProtocol *p);
+
 int register_protocol(URLProtocol *protocol);
 
+/**
+ * Bytestream IO Context.
+ * New fields can be added to the end with minor version bumps.
+ * Removal, reordering and changes to existing fields require a major
+ * version bump.
+ * sizeof(ByteIOContext) must not be used outside libav*.
+ */
 typedef struct {
     unsigned char *buffer;
     int buffer_size;
@@ -126,6 +168,9 @@
     unsigned char *checksum_ptr;
     unsigned long (*update_checksum)(unsigned long checksum, const uint8_t *buf, unsigned int size);
     int error;         ///< contains the error code or 0 if no error happened
+    int (*read_pause)(void *opaque, int pause);
+    offset_t (*read_seek)(void *opaque,
+                     int stream_index, int64_t timestamp, int flags);
 } ByteIOContext;
 
 int init_put_byte(ByteIOContext *s,
@@ -136,6 +181,14 @@
                   int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
                   int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
                   offset_t (*seek)(void *opaque, offset_t offset, int whence));
+ByteIOContext *av_alloc_put_byte(
+                  unsigned char *buffer,
+                  int buffer_size,
+                  int write_flag,
+                  void *opaque,
+                  int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
+                  int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
+                  offset_t (*seek)(void *opaque, offset_t offset, int whence));
 
 void put_byte(ByteIOContext *s, int b);
 void put_buffer(ByteIOContext *s, const unsigned char *buf, int size);
@@ -158,6 +211,10 @@
 int url_feof(ByteIOContext *s);
 int url_ferror(ByteIOContext *s);
 
+int av_url_read_fpause(ByteIOContext *h, int pause);
+offset_t av_url_read_fseek(ByteIOContext *h,
+                      int stream_index, int64_t timestamp, int flags);
+
 #define URL_EOF (-1)
 /** @note return URL_EOF (-1) if EOF */
 int url_fgetc(ByteIOContext *s);
@@ -192,6 +249,8 @@
 unsigned int get_be32(ByteIOContext *s);
 uint64_t get_be64(ByteIOContext *s);
 
+uint64_t ff_get_v(ByteIOContext *bc);
+
 static inline int url_is_streamed(ByteIOContext *s)
 {
     return s->is_streamed;
@@ -199,14 +258,19 @@
 
 /** @note when opened as read/write, the buffers are only used for
    writing */
-int url_fdopen(ByteIOContext *s, URLContext *h);
+int url_fdopen(ByteIOContext **s, URLContext *h);
 
 /** @warning must be called before any I/O */
 int url_setbufsize(ByteIOContext *s, int buf_size);
+/** Reset the buffer for reading or writing.
+ * @note Will drop any data currently in the buffer without transmitting it.
+ * @param flags URL_RDONLY to set up the buffer for reading, or URL_WRONLY
+ *        to set up the buffer for writing. */
+int url_resetbuf(ByteIOContext *s, int flags);
 
 /** @note when opened as read/write, the buffers are only used for
    writing */
-int url_fopen(ByteIOContext *s, const char *filename, int flags);
+int url_fopen(ByteIOContext **s, const char *filename, int flags);
 int url_fclose(ByteIOContext *s);
 URLContext *url_fileno(ByteIOContext *s);
 
@@ -215,12 +279,12 @@
  * handle. If the file is not packetized (stream like http or file on
  * disk), then 0 is returned.
  *
- * @param h buffered file handle
+ * @param s buffered file handle
  * @return maximum packet size in bytes
  */
 int url_fget_max_packet_size(ByteIOContext *s);
 
-int url_open_buf(ByteIOContext *s, uint8_t *buf, int buf_size, int flags);
+int url_open_buf(ByteIOContext **s, uint8_t *buf, int buf_size, int flags);
 
 /** return the written or read size */
 int url_close_buf(ByteIOContext *s);
@@ -231,7 +295,7 @@
  * @param s new IO context
  * @return zero if no error.
  */
-int url_open_dyn_buf(ByteIOContext *s);
+int url_open_dyn_buf(ByteIOContext **s);
 
 /**
  * Open a write only packetized memory stream with a maximum packet
@@ -242,17 +306,18 @@
  * @param max_packet_size maximum packet size (must be > 0)
  * @return zero if no error.
  */
-int url_open_dyn_packet_buf(ByteIOContext *s, int max_packet_size);
+int url_open_dyn_packet_buf(ByteIOContext **s, int max_packet_size);
 
 /**
  * Return the written size and a pointer to the buffer. The buffer
  *  must be freed with av_free().
  * @param s IO context
- * @param pointer to a byte buffer
+ * @param pbuffer pointer to a byte buffer
  * @return the length of the byte buffer
  */
 int url_close_dyn_buf(ByteIOContext *s, uint8_t **pbuffer);
 
+unsigned long ff_crc04C11DB7_update(unsigned long checksum, const uint8_t *buf, unsigned int len);
 unsigned long get_checksum(ByteIOContext *s);
 void init_checksum(ByteIOContext *s, unsigned long (*update_checksum)(unsigned long c, const uint8_t *p, unsigned int len), unsigned long checksum);
 
@@ -261,5 +326,4 @@
 int udp_get_local_port(URLContext *h);
 int udp_get_file_handle(URLContext *h);
 
-#endif
-
+#endif /* FFMPEG_AVIO_H */
diff -u mplayer-1.0~rc2-12/libavformat/avs.c ffmpeg-free-0.svn20080206/libavformat/avs.c
--- mplayer-1.0~rc2-12/libavformat/avs.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/avs.c	2007-11-21 08:41:00.000000000 +0100
@@ -60,12 +60,12 @@
 
     s->ctx_flags |= AVFMTCTX_NOHEADER;
 
-    url_fskip(&s->pb, 4);
-    avs->width = get_le16(&s->pb);
-    avs->height = get_le16(&s->pb);
-    avs->bits_per_sample = get_le16(&s->pb);
-    avs->fps = get_le16(&s->pb);
-    avs->nb_frames = get_le32(&s->pb);
+    url_fskip(s->pb, 4);
+    avs->width = get_le16(s->pb);
+    avs->height = get_le16(s->pb);
+    avs->bits_per_sample = get_le16(s->pb);
+    avs->fps = get_le16(s->pb);
+    avs->nb_frames = get_le32(s->pb);
     avs->remaining_frame_size = 0;
     avs->remaining_audio_size = 0;
 
@@ -103,7 +103,7 @@
     pkt->data[palette_size + 1] = type;
     pkt->data[palette_size + 2] = size & 0xFF;
     pkt->data[palette_size + 3] = (size >> 8) & 0xFF;
-    ret = get_buffer(&s->pb, pkt->data + palette_size + 4, size - 4) + 4;
+    ret = get_buffer(s->pb, pkt->data + palette_size + 4, size - 4) + 4;
     if (ret < size) {
         av_free_packet(pkt);
         return AVERROR(EIO);
@@ -122,9 +122,9 @@
     avs_format_t *avs = s->priv_data;
     int ret, size;
 
-    size = url_ftell(&s->pb);
+    size = url_ftell(s->pb);
     ret = voc_get_packet(s, pkt, avs->st_audio, avs->remaining_audio_size);
-    size = url_ftell(&s->pb) - size;
+    size = url_ftell(s->pb) - size;
     avs->remaining_audio_size -= size;
 
     if (ret == AVERROR(EIO))
@@ -153,20 +153,20 @@
 
     while (1) {
         if (avs->remaining_frame_size <= 0) {
-            if (!get_le16(&s->pb))    /* found EOF */
+            if (!get_le16(s->pb))    /* found EOF */
                 return AVERROR(EIO);
-            avs->remaining_frame_size = get_le16(&s->pb) - 4;
+            avs->remaining_frame_size = get_le16(s->pb) - 4;
         }
 
         while (avs->remaining_frame_size > 0) {
-            sub_type = get_byte(&s->pb);
-            type = get_byte(&s->pb);
-            size = get_le16(&s->pb);
+            sub_type = get_byte(s->pb);
+            type = get_byte(s->pb);
+            size = get_le16(s->pb);
             avs->remaining_frame_size -= size;
 
             switch (type) {
             case AVS_PALETTE:
-                ret = get_buffer(&s->pb, palette, size - 4);
+                ret = get_buffer(s->pb, palette, size - 4);
                 if (ret < size - 4)
                     return AVERROR(EIO);
                 palette_size = size;
@@ -203,7 +203,7 @@
                 break;
 
             default:
-                url_fskip(&s->pb, size - 4);
+                url_fskip(s->pb, size - 4);
             }
         }
     }
Only in mplayer-1.0~rc2-12/libavformat: beosaudio.cpp
diff -u mplayer-1.0~rc2-12/libavformat/bethsoftvid.c ffmpeg-free-0.svn20080206/libavformat/bethsoftvid.c
--- mplayer-1.0~rc2-12/libavformat/bethsoftvid.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/bethsoftvid.c	2007-11-21 08:41:00.000000000 +0100
@@ -59,7 +59,7 @@
                             AVFormatParameters *ap)
 {
     BVID_DemuxContext *vid = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *stream;
 
     /* load main header. Contents:
@@ -173,7 +173,7 @@
                            AVPacket *pkt)
 {
     BVID_DemuxContext *vid = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     unsigned char block_type;
     int audio_length;
     int ret_value;
Only in mplayer-1.0~rc2-12/libavformat: bktr.c
diff -u mplayer-1.0~rc2-12/libavformat/c93.c ffmpeg-free-0.svn20080206/libavformat/c93.c
--- mplayer-1.0~rc2-12/libavformat/c93.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/c93.c	2007-11-21 08:41:00.000000000 +0100
@@ -56,7 +56,7 @@
                            AVFormatParameters *ap)
 {
     AVStream *video;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     C93DemuxContext *c93 = s->priv_data;
     int i;
     int framecount = 0;
@@ -101,7 +101,7 @@
 
 static int read_packet(AVFormatContext *s, AVPacket *pkt)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     C93DemuxContext *c93 = s->priv_data;
     C93BlockRecord *br = &c93->block_records[c93->current_block];
     int datasize;
Only in mplayer-1.0~rc2-12/libavformat: crc.c
Only in ffmpeg-free-0.svn20080206/libavformat: crcenc.c
diff -u mplayer-1.0~rc2-12/libavformat/daud.c ffmpeg-free-0.svn20080206/libavformat/daud.c
--- mplayer-1.0~rc2-12/libavformat/daud.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/daud.c	2007-11-21 08:41:00.000000000 +0100
@@ -34,7 +34,7 @@
 }
 
 static int daud_packet(AVFormatContext *s, AVPacket *pkt) {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int ret, size;
     if (url_feof(pb))
         return AVERROR(EIO);
diff -u mplayer-1.0~rc2-12/libavformat/dsicin.c ffmpeg-free-0.svn20080206/libavformat/dsicin.c
--- mplayer-1.0~rc2-12/libavformat/dsicin.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/dsicin.c	2007-11-21 08:41:00.000000000 +0100
@@ -94,7 +94,7 @@
     int rc;
     CinDemuxContext *cin = s->priv_data;
     CinFileHeader *hdr = &cin->file_header;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st;
 
     rc = cin_read_file_header(cin, pb);
@@ -158,7 +158,7 @@
 static int cin_read_packet(AVFormatContext *s, AVPacket *pkt)
 {
     CinDemuxContext *cin = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     CinFrameHeader *hdr = &cin->frame_header;
     int rc, palette_type, pkt_size;
 
Only in mplayer-1.0~rc2-12/libavformat: dv1394.c
Only in mplayer-1.0~rc2-12/libavformat: dv1394.h
diff -u mplayer-1.0~rc2-12/libavformat/dv.c ffmpeg-free-0.svn20080206/libavformat/dv.c
--- mplayer-1.0~rc2-12/libavformat/dv.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/dv.c	2007-11-21 08:41:00.000000000 +0100
@@ -347,7 +347,7 @@
     // FIXME: sys may be wrong if last dv_read_packet() failed (buffer is junk)
     const DVprofile* sys = dv_codec_profile(c->vst->codec);
     int64_t offset;
-    int64_t size = url_fsize(&s->pb);
+    int64_t size = url_fsize(s->pb);
     int64_t max_offset = ((size-1) / sys->frame_size) * sys->frame_size;
 
     offset = sys->frame_size * timestamp;
@@ -386,8 +386,8 @@
     if (!c->dv_demux)
         return -1;
 
-    if (get_buffer(&s->pb, c->buf, DV_PROFILE_BYTES) <= 0 ||
-        url_fseek(&s->pb, -DV_PROFILE_BYTES, SEEK_CUR) < 0)
+    if (get_buffer(s->pb, c->buf, DV_PROFILE_BYTES) <= 0 ||
+        url_fseek(s->pb, -DV_PROFILE_BYTES, SEEK_CUR) < 0)
         return AVERROR(EIO);
 
     c->dv_demux->sys = dv_frame_profile(c->buf);
@@ -408,7 +408,7 @@
 
     if (size < 0) {
         size = c->dv_demux->sys->frame_size;
-        if (get_buffer(&s->pb, c->buf, size) <= 0)
+        if (get_buffer(s->pb, c->buf, size) <= 0)
             return AVERROR(EIO);
 
         size = dv_produce_packet(c->dv_demux, pkt, c->buf, size);
@@ -426,7 +426,7 @@
 
     dv_offset_reset(c, offset / c->sys->frame_size);
 
-    offset = url_fseek(&s->pb, offset, SEEK_SET);
+    offset = url_fseek(s->pb, offset, SEEK_SET);
     return (offset < 0)?offset:0;
 }
 
diff -u mplayer-1.0~rc2-12/libavformat/dvenc.c ffmpeg-free-0.svn20080206/libavformat/dvenc.c
--- mplayer-1.0~rc2-12/libavformat/dvenc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/dvenc.c	2007-11-21 08:41:00.000000000 +0100
@@ -380,8 +380,8 @@
     fsize = dv_assemble_frame(s->priv_data, s->streams[pkt->stream_index],
                               pkt->data, pkt->size, &frame);
     if (fsize > 0) {
-        put_buffer(&s->pb, frame, fsize);
-        put_flush_packet(&s->pb);
+        put_buffer(s->pb, frame, fsize);
+        put_flush_packet(s->pb);
     }
     return 0;
 }
diff -u mplayer-1.0~rc2-12/libavformat/dv.h ffmpeg-free-0.svn20080206/libavformat/dv.h
--- mplayer-1.0~rc2-12/libavformat/dv.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/dv.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVFORMAT_DV_H
-#define AVFORMAT_DV_H
+#ifndef FFMPEG_DV_H
+#define FFMPEG_DV_H
 
 #include "avformat.h"
 
@@ -41,4 +41,4 @@
 int dv_assemble_frame(DVMuxContext *c, AVStream*, const uint8_t*, int, uint8_t**);
 void dv_delete_mux(DVMuxContext*);
 
-#endif // AVFORMAT_DV_H
+#endif /* FFMPEG_DV_H */
diff -u mplayer-1.0~rc2-12/libavformat/dxa.c ffmpeg-free-0.svn20080206/libavformat/dxa.c
--- mplayer-1.0~rc2-12/libavformat/dxa.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/dxa.c	2007-11-21 08:41:00.000000000 +0100
@@ -45,7 +45,7 @@
 
 static int dxa_read_header(AVFormatContext *s, AVFormatParameters *ap)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     DXAContext *c = s->priv_data;
     AVStream *st, *ast;
     uint32_t tag;
@@ -144,19 +144,19 @@
 
     if(!c->readvid && c->has_sound && c->bytes_left){
         c->readvid = 1;
-        url_fseek(&s->pb, c->wavpos, SEEK_SET);
+        url_fseek(s->pb, c->wavpos, SEEK_SET);
         size = FFMIN(c->bytes_left, c->bpc);
-        ret = av_get_packet(&s->pb, pkt, size);
+        ret = av_get_packet(s->pb, pkt, size);
         pkt->stream_index = 1;
         if(ret != size)
             return AVERROR(EIO);
         c->bytes_left -= size;
-        c->wavpos = url_ftell(&s->pb);
+        c->wavpos = url_ftell(s->pb);
         return 0;
     }
-    url_fseek(&s->pb, c->vidpos, SEEK_SET);
-    while(!url_feof(&s->pb) && c->frames){
-        get_buffer(&s->pb, buf, 4);
+    url_fseek(s->pb, c->vidpos, SEEK_SET);
+    while(!url_feof(s->pb) && c->frames){
+        get_buffer(s->pb, buf, 4);
         switch(AV_RL32(buf)){
         case MKTAG('N', 'U', 'L', 'L'):
             if(av_new_packet(pkt, 4 + pal_size) < 0)
@@ -165,16 +165,16 @@
             if(pal_size) memcpy(pkt->data, pal, pal_size);
             memcpy(pkt->data + pal_size, buf, 4);
             c->frames--;
-            c->vidpos = url_ftell(&s->pb);
+            c->vidpos = url_ftell(s->pb);
             c->readvid = 0;
             return 0;
         case MKTAG('C', 'M', 'A', 'P'):
             pal_size = 768+4;
             memcpy(pal, buf, 4);
-            get_buffer(&s->pb, pal + 4, 768);
+            get_buffer(s->pb, pal + 4, 768);
             break;
         case MKTAG('F', 'R', 'A', 'M'):
-            get_buffer(&s->pb, buf + 4, DXA_EXTRA_SIZE - 4);
+            get_buffer(s->pb, buf + 4, DXA_EXTRA_SIZE - 4);
             size = AV_RB32(buf + 5);
             if(size > 0xFFFFFF){
                 av_log(s, AV_LOG_ERROR, "Frame size is too big: %d\n", size);
@@ -183,7 +183,7 @@
             if(av_new_packet(pkt, size + DXA_EXTRA_SIZE + pal_size) < 0)
                 return AVERROR(ENOMEM);
             memcpy(pkt->data + pal_size, buf, DXA_EXTRA_SIZE);
-            ret = get_buffer(&s->pb, pkt->data + DXA_EXTRA_SIZE + pal_size, size);
+            ret = get_buffer(s->pb, pkt->data + DXA_EXTRA_SIZE + pal_size, size);
             if(ret != size){
                 av_free_packet(pkt);
                 return AVERROR(EIO);
@@ -191,7 +191,7 @@
             if(pal_size) memcpy(pkt->data, pal, pal_size);
             pkt->stream_index = 0;
             c->frames--;
-            c->vidpos = url_ftell(&s->pb);
+            c->vidpos = url_ftell(s->pb);
             c->readvid = 0;
             return 0;
         default:
Only in ffmpeg-free-0.svn20080206/libavformat: eacdata.c
diff -u mplayer-1.0~rc2-12/libavformat/electronicarts.c ffmpeg-free-0.svn20080206/libavformat/electronicarts.c
--- mplayer-1.0~rc2-12/libavformat/electronicarts.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/electronicarts.c	2007-11-25 17:32:47.000000000 +0100
@@ -27,33 +27,42 @@
 #include "avformat.h"
 
 #define SCHl_TAG MKTAG('S', 'C', 'H', 'l')
+#define SEAD_TAG MKTAG('S', 'E', 'A', 'D')    /* Sxxx header */
+#define SNDC_TAG MKTAG('S', 'N', 'D', 'C')    /* Sxxx data */
+#define SEND_TAG MKTAG('S', 'E', 'N', 'D')    /* Sxxx end */
+#define ISNh_TAG MKTAG('1', 'S', 'N', 'h')    /* 1SNx header */
+#define EACS_TAG MKTAG('E', 'A', 'C', 'S')
+#define ISNd_TAG MKTAG('1', 'S', 'N', 'd')    /* 1SNx data */
+#define ISNe_TAG MKTAG('1', 'S', 'N', 'e')    /* 1SNx end */
 #define PT00_TAG MKTAG('P', 'T', 0x0, 0x0)
+#define GSTR_TAG MKTAG('G', 'S', 'T', 'R')
 #define SCDl_TAG MKTAG('S', 'C', 'D', 'l')
-#define pIQT_TAG MKTAG('p', 'I', 'Q', 'T')
 #define SCEl_TAG MKTAG('S', 'C', 'E', 'l')
-#define _TAG MKTAG('', '', '', '')
-
-#define EA_SAMPLE_RATE 22050
-#define EA_BITS_PER_SAMPLE 16
-#define EA_PREAMBLE_SIZE 8
+#define kVGT_TAG MKTAG('k', 'V', 'G', 'T')    /* TGV i-frame */
+#define MADk_TAG MKTAG('M', 'A', 'D', 'k')    /* MAD i-frame */
+#define MPCh_TAG MKTAG('M', 'P', 'C', 'h')    /* MPEG2 */
+#define MVhd_TAG MKTAG('M', 'V', 'h', 'd')
+#define MV0K_TAG MKTAG('M', 'V', '0', 'K')
+#define MV0F_TAG MKTAG('M', 'V', '0', 'F')
+#define MVIh_TAG MKTAG('M', 'V', 'I', 'h')    /* CMV header */
 
 typedef struct EaDemuxContext {
-    int width;
-    int height;
+    int big_endian;
+
+    int video_codec;
+    AVRational time_base;
     int video_stream_index;
-    int track_count;
 
+    int audio_codec;
     int audio_stream_index;
     int audio_frame_counter;
 
     int64_t audio_pts;
-    int64_t video_pts;
-    int video_pts_inc;
-    float fps;
 
+    int bytes;
+    int sample_rate;
     int num_channels;
     int num_samples;
-    int compression_type;
 } EaDemuxContext;
 
 static uint32_t read_arbitary(ByteIOContext *pb) {
@@ -74,40 +83,24 @@
 }
 
 /*
- * Process WVE file header
- * Returns 1 if the WVE file is valid and successfully opened, 0 otherwise
+ * Process PT/GSTR sound header
+ * return 1 if success, 0 if invalid format, otherwise AVERROR_xxx
  */
-static int process_ea_header(AVFormatContext *s) {
-    int inHeader;
-    uint32_t blockid, size;
+static int process_audio_header_elements(AVFormatContext *s)
+{
+    int inHeader = 1;
     EaDemuxContext *ea = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
+    int compression_type = -1, revision = -1, revision2 = -1;
 
-    if (get_buffer(pb, (void*)&blockid, 4) != 4) {
-        return 0;
-    }
-    if (le2me_32(blockid) != SCHl_TAG) {
-        return 0;
-    }
-
-    if (get_buffer(pb, (void*)&size, 4) != 4) {
-        return 0;
-    }
-    size = le2me_32(size);
+    ea->bytes = 2;
+    ea->sample_rate = -1;
+    ea->num_channels = 1;
 
-    if (get_buffer(pb, (void*)&blockid, 4) != 4) {
-        return 0;
-    }
-    if (le2me_32(blockid) != PT00_TAG) {
-        av_log (s, AV_LOG_ERROR, "PT header missing\n");
-        return 0;
-    }
-
-    inHeader = 1;
     while (inHeader) {
         int inSubheader;
         uint8_t byte;
-        byte = get_byte(pb) & 0xFF;
+        byte = get_byte(pb);
 
         switch (byte) {
         case 0xFD:
@@ -115,16 +108,24 @@
             inSubheader = 1;
             while (inSubheader) {
                 uint8_t subbyte;
-                subbyte = get_byte(pb) & 0xFF;
+                subbyte = get_byte(pb);
 
                 switch (subbyte) {
+                case 0x80:
+                    revision = read_arbitary(pb);
+                    av_log (s, AV_LOG_INFO, "revision (element 0x80) set to 0x%08x\n", revision);
+                    break;
                 case 0x82:
                     ea->num_channels = read_arbitary(pb);
                     av_log (s, AV_LOG_INFO, "num_channels (element 0x82) set to 0x%08x\n", ea->num_channels);
                     break;
                 case 0x83:
-                    ea->compression_type = read_arbitary(pb);
-                    av_log (s, AV_LOG_INFO, "compression_type (element 0x83) set to 0x%08x\n", ea->compression_type);
+                    compression_type = read_arbitary(pb);
+                    av_log (s, AV_LOG_INFO, "compression_type (element 0x83) set to 0x%08x\n", compression_type);
+                    break;
+                case 0x84:
+                    ea->sample_rate = read_arbitary(pb);
+                    av_log (s, AV_LOG_INFO, "sample_rate (element 0x84) set to %i\n", ea->sample_rate);
                     break;
                 case 0x85:
                     ea->num_samples = read_arbitary(pb);
@@ -135,6 +136,15 @@
                     av_log (s, AV_LOG_INFO, "exited audio subheader\n");
                     inSubheader = 0;
                     break;
+                case 0xA0:
+                    revision2 = read_arbitary(pb);
+                    av_log (s, AV_LOG_INFO, "revision2 (element 0xA0) set to 0x%08x\n", revision2);
+                    break;
+                case 0xFF:
+                    av_log (s, AV_LOG_INFO, "end of header block reached (within audio subheader)\n");
+                    inSubheader = 0;
+                    inHeader = 0;
+                    break;
                 default:
                     av_log (s, AV_LOG_INFO, "element 0x%02x set to 0x%08x\n", subbyte, read_arbitary(pb));
                     break;
@@ -151,24 +161,177 @@
         }
     }
 
-    if ((ea->num_channels != 2) || (ea->compression_type != 7)) {
-        av_log (s, AV_LOG_ERROR, "unsupported stream type\n");
+    switch (compression_type) {
+    case  0: ea->audio_codec = CODEC_ID_PCM_S16LE; break;
+    case  7: ea->audio_codec = CODEC_ID_ADPCM_EA; break;
+    case -1:
+        switch (revision) {
+        case  1: ea->audio_codec = CODEC_ID_ADPCM_EA_R1; break;
+        case  2: ea->audio_codec = CODEC_ID_ADPCM_EA_R2; break;
+        case  3: ea->audio_codec = CODEC_ID_ADPCM_EA_R3; break;
+        case -1: break;
+        default:
+            av_log(s, AV_LOG_ERROR, "unsupported stream type; revision=%i\n", revision);
+            return 0;
+        }
+        switch (revision2) {
+        case  8: ea->audio_codec = CODEC_ID_PCM_S16LE_PLANAR; break;
+        default:
+            av_log(s, AV_LOG_ERROR, "unsupported stream type; revision2=%i\n", revision2);
+            return 0;
+        }
+        break;
+    default:
+        av_log(s, AV_LOG_ERROR, "unsupported stream type; compression_type=%i\n", compression_type);
         return 0;
     }
 
-    /* skip to the start of the data */
-    url_fseek(pb, size, SEEK_SET);
+    if (ea->sample_rate == -1)
+        ea->sample_rate = revision==3 ? 48000 : 22050;
 
     return 1;
 }
 
+/*
+ * Process EACS sound header
+ * return 1 if success, 0 if invalid format, otherwise AVERROR_xxx
+ */
+static int process_audio_header_eacs(AVFormatContext *s)
+{
+    EaDemuxContext *ea = s->priv_data;
+    ByteIOContext *pb = s->pb;
+    int compression_type;
+
+    ea->sample_rate  = ea->big_endian ? get_be32(pb) : get_le32(pb);
+    ea->bytes        = get_byte(pb);   /* 1=8-bit, 2=16-bit */
+    ea->num_channels = get_byte(pb);
+    compression_type = get_byte(pb);
+    url_fskip(pb, 13);
+
+    switch (compression_type) {
+    case 0:
+        switch (ea->bytes) {
+        case 1: ea->audio_codec = CODEC_ID_PCM_S8;    break;
+        case 2: ea->audio_codec = CODEC_ID_PCM_S16LE; break;
+        }
+        break;
+    case 1: ea->audio_codec = CODEC_ID_PCM_MULAW; ea->bytes = 1; break;
+    case 2: ea->audio_codec = CODEC_ID_ADPCM_IMA_EA_EACS; break;
+    default:
+        av_log (s, AV_LOG_ERROR, "unsupported stream type; audio compression_type=%i\n", compression_type);
+    }
 
-static int ea_probe(AVProbeData *p)
+    return 1;
+}
+
+/*
+ * Process SEAD sound header
+ * return 1 if success, 0 if invalid format, otherwise AVERROR_xxx
+ */
+static int process_audio_header_sead(AVFormatContext *s)
 {
-    if (AV_RL32(&p->buf[0]) != SCHl_TAG)
-        return 0;
+    EaDemuxContext *ea = s->priv_data;
+    ByteIOContext *pb = s->pb;
 
-    return AVPROBE_SCORE_MAX;
+    ea->sample_rate  = get_le32(pb);
+    ea->bytes        = get_le32(pb);  /* 1=8-bit, 2=16-bit */
+    ea->num_channels = get_le32(pb);
+    ea->audio_codec  = CODEC_ID_ADPCM_IMA_EA_SEAD;
+
+    return 1;
+}
+
+static int process_video_header_vp6(AVFormatContext *s)
+{
+    EaDemuxContext *ea = s->priv_data;
+    ByteIOContext *pb = s->pb;
+
+    url_fskip(pb, 16);
+    ea->time_base.den = get_le32(pb);
+    ea->time_base.num = get_le32(pb);
+    ea->video_codec = CODEC_ID_VP6;
+
+    return 1;
+}
+
+/*
+ * Process EA file header
+ * Returns 1 if the EA file is valid and successfully opened, 0 otherwise
+ */
+static int process_ea_header(AVFormatContext *s) {
+    uint32_t blockid, size = 0;
+    EaDemuxContext *ea = s->priv_data;
+    ByteIOContext *pb = s->pb;
+    int i;
+
+    for (i=0; i<5 && (!ea->audio_codec || !ea->video_codec); i++) {
+        unsigned int startpos = url_ftell(pb);
+        int err = 0;
+
+        blockid = get_le32(pb);
+        size = get_le32(pb);
+        if (i == 0)
+            ea->big_endian = size > 0x000FFFFF;
+        if (ea->big_endian)
+            size = bswap_32(size);
+
+        switch (blockid) {
+            case ISNh_TAG:
+                if (get_le32(pb) != EACS_TAG) {
+                    av_log (s, AV_LOG_ERROR, "unknown 1SNh headerid\n");
+                    return 0;
+                }
+                err = process_audio_header_eacs(s);
+                break;
+
+            case SCHl_TAG :
+                blockid = get_le32(pb);
+                if (blockid == GSTR_TAG) {
+                    url_fskip(pb, 4);
+                } else if (blockid != PT00_TAG) {
+                    av_log (s, AV_LOG_ERROR, "unknown SCHl headerid\n");
+                    return 0;
+                }
+                err = process_audio_header_elements(s);
+                break;
+
+            case SEAD_TAG:
+                err = process_audio_header_sead(s);
+                break;
+
+            case MVhd_TAG :
+                err = process_video_header_vp6(s);
+                break;
+        }
+
+        if (err < 0) {
+            av_log(s, AV_LOG_ERROR, "error parsing header: %i\n", err);
+            return err;
+        }
+
+        url_fseek(pb, startpos + size, SEEK_SET);
+    }
+
+    url_fseek(pb, 0, SEEK_SET);
+
+    return 1;
+}
+
+
+static int ea_probe(AVProbeData *p)
+{
+    switch (AV_RL32(&p->buf[0])) {
+    case ISNh_TAG:
+    case SCHl_TAG:
+    case SEAD_TAG:
+    case kVGT_TAG:
+    case MADk_TAG:
+    case MPCh_TAG:
+    case MVhd_TAG:
+    case MVIh_TAG:
+        return AVPROBE_SCORE_MAX;
+    }
+    return 0;
 }
 
 static int ea_read_header(AVFormatContext *s,
@@ -180,35 +343,36 @@
     if (!process_ea_header(s))
         return AVERROR(EIO);
 
-#if 0
-    /* initialize the video decoder stream */
-    st = av_new_stream(s, 0);
-    if (!st)
-        return AVERROR(ENOMEM);
-    av_set_pts_info(st, 33, 1, 90000);
-    ea->video_stream_index = st->index;
-    st->codec->codec_type = CODEC_TYPE_VIDEO;
-    st->codec->codec_id = CODEC_ID_EA_MJPEG;
-    st->codec->codec_tag = 0;  /* no fourcc */
-#endif
-
-    /* initialize the audio decoder stream */
-    st = av_new_stream(s, 0);
-    if (!st)
-        return AVERROR(ENOMEM);
-    av_set_pts_info(st, 33, 1, EA_SAMPLE_RATE);
-    st->codec->codec_type = CODEC_TYPE_AUDIO;
-    st->codec->codec_id = CODEC_ID_ADPCM_EA;
-    st->codec->codec_tag = 0;  /* no tag */
-    st->codec->channels = ea->num_channels;
-    st->codec->sample_rate = EA_SAMPLE_RATE;
-    st->codec->bits_per_sample = EA_BITS_PER_SAMPLE;
-    st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *
-        st->codec->bits_per_sample / 4;
-    st->codec->block_align = st->codec->channels * st->codec->bits_per_sample;
+    if (ea->video_codec) {
+        /* initialize the video decoder stream */
+        st = av_new_stream(s, 0);
+        if (!st)
+            return AVERROR(ENOMEM);
+        ea->video_stream_index = st->index;
+        st->codec->codec_type = CODEC_TYPE_VIDEO;
+        st->codec->codec_id = ea->video_codec;
+        st->codec->codec_tag = 0;  /* no fourcc */
+        st->codec->time_base = ea->time_base;
+    }
 
-    ea->audio_stream_index = st->index;
-    ea->audio_frame_counter = 0;
+    if (ea->audio_codec) {
+        /* initialize the audio decoder stream */
+        st = av_new_stream(s, 0);
+        if (!st)
+            return AVERROR(ENOMEM);
+        av_set_pts_info(st, 33, 1, ea->sample_rate);
+        st->codec->codec_type = CODEC_TYPE_AUDIO;
+        st->codec->codec_id = ea->audio_codec;
+        st->codec->codec_tag = 0;  /* no tag */
+        st->codec->channels = ea->num_channels;
+        st->codec->sample_rate = ea->sample_rate;
+        st->codec->bits_per_sample = ea->bytes * 8;
+        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *
+            st->codec->bits_per_sample / 4;
+        st->codec->block_align = st->codec->channels*st->codec->bits_per_sample;
+        ea->audio_stream_index = st->index;
+        ea->audio_frame_counter = 0;
+    }
 
     return 1;
 }
@@ -217,22 +381,32 @@
                           AVPacket *pkt)
 {
     EaDemuxContext *ea = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int ret = 0;
     int packet_read = 0;
-    unsigned char preamble[EA_PREAMBLE_SIZE];
     unsigned int chunk_type, chunk_size;
+    int key = 0;
 
     while (!packet_read) {
-
-        if (get_buffer(pb, preamble, EA_PREAMBLE_SIZE) != EA_PREAMBLE_SIZE)
-            return AVERROR(EIO);
-        chunk_type = AV_RL32(&preamble[0]);
-        chunk_size = AV_RL32(&preamble[4]) - EA_PREAMBLE_SIZE;
+        chunk_type = get_le32(pb);
+        chunk_size = (ea->big_endian ? get_be32(pb) : get_le32(pb)) - 8;
 
         switch (chunk_type) {
         /* audio data */
+        case ISNh_TAG:
+            /* header chunk also contains data; skip over the header portion*/
+            url_fskip(pb, 32);
+            chunk_size -= 32;
+        case ISNd_TAG:
         case SCDl_TAG:
+        case SNDC_TAG:
+            if (!ea->audio_codec) {
+                url_fskip(pb, chunk_size);
+                break;
+            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR) {
+                url_fskip(pb, 12);  /* planar header */
+                chunk_size -= 12;
+            }
             ret = av_get_packet(pb, pkt, chunk_size);
             if (ret != chunk_size)
                 ret = AVERROR(EIO);
@@ -240,43 +414,55 @@
                     pkt->stream_index = ea->audio_stream_index;
                     pkt->pts = 90000;
                     pkt->pts *= ea->audio_frame_counter;
-                    pkt->pts /= EA_SAMPLE_RATE;
+                    pkt->pts /= ea->sample_rate;
 
+                    switch (ea->audio_codec) {
+                    case CODEC_ID_ADPCM_EA:
                     /* 2 samples/byte, 1 or 2 samples per frame depending
                      * on stereo; chunk also has 12-byte header */
                     ea->audio_frame_counter += ((chunk_size - 12) * 2) /
                         ea->num_channels;
+                        break;
+                    default:
+                        ea->audio_frame_counter += chunk_size /
+                            (ea->bytes * ea->num_channels);
+                    }
             }
 
             packet_read = 1;
             break;
 
         /* ending tag */
+        case 0:
+        case ISNe_TAG:
         case SCEl_TAG:
+        case SEND_TAG:
             ret = AVERROR(EIO);
             packet_read = 1;
             break;
 
+        case MV0K_TAG:
+            key = PKT_FLAG_KEY;
+        case MV0F_TAG:
+            ret = av_get_packet(pb, pkt, chunk_size);
+            if (ret != chunk_size)
+                ret = AVERROR_IO;
+            else {
+                pkt->stream_index = ea->video_stream_index;
+                pkt->flags |= key;
+            }
+            packet_read = 1;
+            break;
+
         default:
             url_fseek(pb, chunk_size, SEEK_CUR);
             break;
         }
-
-        /* ending packet */
-        if (chunk_type == SCEl_TAG) {
-        }
     }
 
     return ret;
 }
 
-static int ea_read_close(AVFormatContext *s)
-{
-//    EaDemuxContext *ea = s->priv_data;
-
-    return 0;
-}
-
 AVInputFormat ea_demuxer = {
     "ea",
     "Electronic Arts Multimedia Format",
@@ -284,5 +470,4 @@
     ea_probe,
     ea_read_header,
     ea_read_packet,
-    ea_read_close,
 };
diff -u mplayer-1.0~rc2-12/libavformat/ffm.c ffmpeg-free-0.svn20080206/libavformat/ffm.c
--- mplayer-1.0~rc2-12/libavformat/ffm.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/ffm.c	2008-01-09 00:08:51.000000000 +0100
@@ -64,7 +64,7 @@
 {
     FFMContext *ffm = s->priv_data;
     int fill_size, h;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
 
     fill_size = ffm->packet_end - ffm->packet_ptr;
     memset(ffm->packet_ptr, 0, fill_size);
@@ -128,7 +128,7 @@
     FFMContext *ffm = s->priv_data;
     AVStream *st;
     FFMStream *fst;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVCodecContext *codec;
     int bit_rate, i;
 
@@ -278,7 +278,7 @@
 
 static int ffm_write_trailer(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     FFMContext *ffm = s->priv_data;
 
     /* flush packets */
@@ -314,7 +314,7 @@
         if (size <= len)
             return 1;
     }
-    pos = url_ftell(&s->pb);
+    pos = url_ftell(s->pb);
     if (pos == ffm->write_index) {
         /* exactly at the end of stream */
         return 0;
@@ -335,7 +335,7 @@
                          uint8_t *buf, int size, int first)
 {
     FFMContext *ffm = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int len, fill_size, size1, frame_offset;
 
     size1 = size;
@@ -393,7 +393,7 @@
 static void adjust_write_index(AVFormatContext *s)
 {
     FFMContext *ffm = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int64_t pts;
     //offset_t orig_write_index = ffm->write_index;
     offset_t pos_min, pos_max;
@@ -452,7 +452,7 @@
     FFMContext *ffm = s->priv_data;
     AVStream *st;
     FFMStream *fst;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVCodecContext *codec;
     int i, nb_streams;
     uint32_t tag;
@@ -585,7 +585,7 @@
         }
 #if 0
         printf("pos=%08"PRIx64" spos=%"PRIx64", write_index=%"PRIx64" size=%"PRIx64"\n",
-               url_ftell(&s->pb), s->pb.pos, ffm->write_index, ffm->file_size);
+               url_ftell(s->pb), s->pb.pos, ffm->write_index, ffm->file_size);
 #endif
         if (ffm_read_data(s, ffm->header, FRAME_HEADER_SIZE, 1) !=
             FRAME_HEADER_SIZE)
@@ -610,7 +610,7 @@
 
         av_new_packet(pkt, size);
         pkt->stream_index = ffm->header[0];
-        pkt->pos = url_ftell(&s->pb);
+        pkt->pos = url_ftell(s->pb);
         if (ffm->header[1] & FLAG_KEY_FRAME)
             pkt->flags |= PKT_FLAG_KEY;
 
@@ -638,7 +638,7 @@
 static void ffm_seek1(AVFormatContext *s, offset_t pos1)
 {
     FFMContext *ffm = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     offset_t pos;
 
     pos = pos1 + ffm->write_index;
@@ -652,7 +652,7 @@
 
 static int64_t get_pts(AVFormatContext *s, offset_t pos)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int64_t pts;
 
     ffm_seek1(s, pos);
@@ -665,7 +665,7 @@
 }
 
 /* seek to a given time in the file. The file read pointer is
-   positionned at or before pts. XXX: the following code is quite
+   positioned at or before pts. XXX: the following code is quite
    approximative */
 static int ffm_seek(AVFormatContext *s, int stream_index, int64_t wanted_pts, int flags)
 {
diff -u mplayer-1.0~rc2-12/libavformat/file.c ffmpeg-free-0.svn20080206/libavformat/file.c
--- mplayer-1.0~rc2-12/libavformat/file.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/file.c	2007-11-22 03:27:39.000000000 +0100
@@ -24,6 +24,7 @@
 #include <unistd.h>
 #include <sys/time.h>
 #include <stdlib.h>
+#include "os_support.h"
 
 
 /* standard file protocol */
@@ -110,16 +111,9 @@
     return 0;
 }
 
-static int pipe_close(URLContext *h)
-{
-    return 0;
-}
-
 URLProtocol pipe_protocol = {
     "pipe",
     pipe_open,
     file_read,
     file_write,
-    NULL,
-    pipe_close,
 };
diff -u mplayer-1.0~rc2-12/libavformat/flic.c ffmpeg-free-0.svn20080206/libavformat/flic.c
--- mplayer-1.0~rc2-12/libavformat/flic.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/flic.c	2007-11-21 08:41:00.000000000 +0100
@@ -67,7 +67,7 @@
                             AVFormatParameters *ap)
 {
     FlicDemuxContext *flic = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     unsigned char header[FLIC_HEADER_SIZE];
     AVStream *st;
     int speed;
@@ -142,7 +142,7 @@
                             AVPacket *pkt)
 {
     FlicDemuxContext *flic = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int packet_read = 0;
     unsigned int size;
     int magic;
diff -u mplayer-1.0~rc2-12/libavformat/flvdec.c ffmpeg-free-0.svn20080206/libavformat/flvdec.c
--- mplayer-1.0~rc2-12/libavformat/flvdec.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/flvdec.c	2007-12-20 12:22:39.000000000 +0100
@@ -50,6 +50,8 @@
         case FLV_CODECID_NELLYMOSER_8HZ_MONO:
             acodec->sample_rate = 8000; //in case metadata does not otherwise declare samplerate
         case FLV_CODECID_NELLYMOSER:
+            acodec->codec_id = CODEC_ID_NELLYMOSER;
+            break;
         default:
             av_log(s, AV_LOG_INFO, "Unsupported audio codec (%x)\n", flv_codecid >> FLV_AUDIO_CODECID_OFFSET);
             acodec->codec_tag = flv_codecid >> FLV_AUDIO_CODECID_OFFSET;
@@ -69,7 +71,7 @@
                 vcodec->extradata_size = 1;
                 vcodec->extradata = av_malloc(1);
             }
-            vcodec->extradata[0] = get_byte(&s->pb);
+            vcodec->extradata[0] = get_byte(s->pb);
             return 1; // 1 byte body size adjustment for flv_read_packet()
         default:
             av_log(s, AV_LOG_INFO, "Unsupported video codec (%x)\n", flv_codecid);
@@ -101,7 +103,7 @@
     double num_val;
 
     num_val = 0;
-    ioc = &s->pb;
+    ioc = s->pb;
 
     amf_type = get_byte(ioc);
 
@@ -177,12 +179,14 @@
             }
             else if(!strcmp(key, "audiosamplerate") && acodec && num_val >= 0) {
                 //some tools, like FLVTool2, write consistently approximate metadata sample rates
-                switch((int)num_val) {
-                    case 44000: acodec->sample_rate = 44100  ; break;
-                    case 22000: acodec->sample_rate = 22050  ; break;
-                    case 11000: acodec->sample_rate = 11025  ; break;
-                    case 5000 : acodec->sample_rate = 5512   ; break;
-                    default   : acodec->sample_rate = num_val;
+                if (!acodec->sample_rate) {
+                    switch((int)num_val) {
+                        case 44000: acodec->sample_rate = 44100  ; break;
+                        case 22000: acodec->sample_rate = 22050  ; break;
+                        case 11000: acodec->sample_rate = 11025  ; break;
+                        case 5000 : acodec->sample_rate = 5512   ; break;
+                        default   : acodec->sample_rate = num_val;
+                    }
                 }
             }
         }
@@ -201,7 +205,7 @@
     astream = NULL;
     vstream = NULL;
     keylen = 0;
-    ioc = &s->pb;
+    ioc = s->pb;
 
     //first object needs to be "onMetaData" string
     type = get_byte(ioc);
@@ -222,14 +226,22 @@
     return 0;
 }
 
+static AVStream *create_stream(AVFormatContext *s, int is_audio){
+    AVStream *st = av_new_stream(s, is_audio);
+    if (!st)
+        return NULL;
+    st->codec->codec_type = is_audio ? CODEC_TYPE_AUDIO : CODEC_TYPE_VIDEO;
+    av_set_pts_info(st, 24, 1, 1000); /* 24 bit pts in ms */
+    return st;
+}
+
 static int flv_read_header(AVFormatContext *s,
                            AVFormatParameters *ap)
 {
     int offset, flags;
-    AVStream *st;
 
-    url_fskip(&s->pb, 4);
-    flags = get_byte(&s->pb);
+    url_fskip(s->pb, 4);
+    flags = get_byte(s->pb);
     /* old flvtool cleared this field */
     /* FIXME: better fix needed */
     if (!flags) {
@@ -238,22 +250,16 @@
     }
 
     if(flags & FLV_HEADER_FLAG_HASVIDEO){
-        st = av_new_stream(s, 0);
-        if (!st)
+        if(!create_stream(s, 0))
             return AVERROR(ENOMEM);
-        st->codec->codec_type = CODEC_TYPE_VIDEO;
-        av_set_pts_info(st, 24, 1, 1000); /* 24 bit pts in ms */
     }
     if(flags & FLV_HEADER_FLAG_HASAUDIO){
-        st = av_new_stream(s, 1);
-        if (!st)
+        if(!create_stream(s, 1))
             return AVERROR(ENOMEM);
-        st->codec->codec_type = CODEC_TYPE_AUDIO;
-        av_set_pts_info(st, 24, 1, 1000); /* 24 bit pts in ms */
     }
 
-    offset = get_be32(&s->pb);
-    url_fseek(&s->pb, offset, SEEK_SET);
+    offset = get_be32(s->pb);
+    url_fseek(s->pb, offset, SEEK_SET);
 
     s->start_time = 0;
 
@@ -266,34 +272,35 @@
     AVStream *st = NULL;
 
  for(;;){
-    pos = url_ftell(&s->pb);
-    url_fskip(&s->pb, 4); /* size of previous packet */
-    type = get_byte(&s->pb);
-    size = get_be24(&s->pb);
-    pts = get_be24(&s->pb);
+    pos = url_ftell(s->pb);
+    url_fskip(s->pb, 4); /* size of previous packet */
+    type = get_byte(s->pb);
+    size = get_be24(s->pb);
+    pts = get_be24(s->pb);
+    pts |= get_byte(s->pb) << 24;
 //    av_log(s, AV_LOG_DEBUG, "type:%d, size:%d, pts:%d\n", type, size, pts);
-    if (url_feof(&s->pb))
+    if (url_feof(s->pb))
         return AVERROR(EIO);
-    url_fskip(&s->pb, 4); /* reserved */
+    url_fskip(s->pb, 3); /* stream id, always 0 */
     flags = 0;
 
     if(size == 0)
         continue;
 
-    next= size + url_ftell(&s->pb);
+    next= size + url_ftell(s->pb);
 
     if (type == FLV_TAG_TYPE_AUDIO) {
         is_audio=1;
-        flags = get_byte(&s->pb);
+        flags = get_byte(s->pb);
     } else if (type == FLV_TAG_TYPE_VIDEO) {
         is_audio=0;
-        flags = get_byte(&s->pb);
+        flags = get_byte(s->pb);
     } else {
         if (type == FLV_TAG_TYPE_META && size > 13+1+4)
             flv_read_metabody(s, next);
         else /* skip packet */
             av_log(s, AV_LOG_ERROR, "skipping flv packet: type %d, size %d, flags %d\n", type, size, flags);
-        url_fseek(&s->pb, next, SEEK_SET);
+        url_fseek(s->pb, next, SEEK_SET);
         continue;
     }
 
@@ -305,15 +312,14 @@
     }
     if(i == s->nb_streams){
         av_log(NULL, AV_LOG_ERROR, "invalid stream\n");
-        url_fseek(&s->pb, next, SEEK_SET);
-        continue;
+        st= create_stream(s, is_audio);
     }
 //    av_log(NULL, AV_LOG_DEBUG, "%d %X %d \n", is_audio, flags, st->discard);
     if(  (st->discard >= AVDISCARD_NONKEY && !((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY ||         is_audio))
        ||(st->discard >= AVDISCARD_BIDIR  &&  ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_DISP_INTER && !is_audio))
        || st->discard >= AVDISCARD_ALL
        ){
-        url_fseek(&s->pb, next, SEEK_SET);
+        url_fseek(s->pb, next, SEEK_SET);
         continue;
     }
     if ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY)
@@ -322,17 +328,17 @@
  }
 
     // if not streamed and no duration from metadata then seek to end to find the duration from the timestamps
-    if(!url_is_streamed(&s->pb) && s->duration==AV_NOPTS_VALUE){
+    if(!url_is_streamed(s->pb) && s->duration==AV_NOPTS_VALUE){
         int size;
-        const int pos= url_ftell(&s->pb);
-        const int fsize= url_fsize(&s->pb);
-        url_fseek(&s->pb, fsize-4, SEEK_SET);
-        size= get_be32(&s->pb);
-        url_fseek(&s->pb, fsize-3-size, SEEK_SET);
-        if(size == get_be24(&s->pb) + 11){
-            s->duration= get_be24(&s->pb) * (int64_t)AV_TIME_BASE / 1000;
+        const int pos= url_ftell(s->pb);
+        const int fsize= url_fsize(s->pb);
+        url_fseek(s->pb, fsize-4, SEEK_SET);
+        size= get_be32(s->pb);
+        url_fseek(s->pb, fsize-3-size, SEEK_SET);
+        if(size == get_be24(s->pb) + 11){
+            s->duration= get_be24(s->pb) * (int64_t)AV_TIME_BASE / 1000;
         }
-        url_fseek(&s->pb, pos, SEEK_SET);
+        url_fseek(s->pb, pos, SEEK_SET);
     }
 
     if(is_audio){
@@ -349,7 +355,7 @@
         size -= flv_set_video_codec(s, st, flags & FLV_VIDEO_CODECID_MASK);
     }
 
-    ret= av_get_packet(&s->pb, pkt, size - 1);
+    ret= av_get_packet(s->pb, pkt, size - 1);
     if (ret <= 0) {
         return AVERROR(EIO);
     }
@@ -376,7 +382,7 @@
     int index = av_index_search_timestamp(st, timestamp, flags);
     if (index < 0)
         return -1;
-    url_fseek(&s->pb, st->index_entries[index].pos, SEEK_SET);
+    url_fseek(s->pb, st->index_entries[index].pos, SEEK_SET);
 
     return 0;
 }
diff -u mplayer-1.0~rc2-12/libavformat/flvenc.c ffmpeg-free-0.svn20080206/libavformat/flvenc.c
--- mplayer-1.0~rc2-12/libavformat/flvenc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/flvenc.c	2007-11-21 08:41:00.000000000 +0100
@@ -66,8 +66,10 @@
             break;
         case     8000: //nellymoser only
         case     5512: //not mp3
-            flags |= FLV_SAMPLERATE_SPECIAL;
-            break;
+            if(enc->codec_id != CODEC_ID_MP3){
+                flags |= FLV_SAMPLERATE_SPECIAL;
+                break;
+            }
         default:
             av_log(enc, AV_LOG_ERROR, "flv does not support that sample rate, choose from (44100, 22050, 11025).\n");
             return -1;
@@ -124,7 +126,7 @@
 
 static int flv_write_header(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     FLVContext *flv = s->priv_data;
     int i, width, height, samplerate, samplesize, channels, audiocodecid, videocodecid;
     double framerate = 0.0;
@@ -254,7 +256,7 @@
 {
     int64_t file_size;
 
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     FLVContext *flv = s->priv_data;
 
     file_size = url_ftell(pb);
@@ -271,7 +273,7 @@
 
 static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVCodecContext *enc = s->streams[pkt->stream_index]->codec;
     FLVContext *flv = s->priv_data;
     int size= pkt->size;
@@ -305,7 +307,8 @@
 
     put_be24(pb,size + flags_size);
     put_be24(pb,pkt->pts);
-    put_be32(pb,flv->reserved);
+    put_byte(pb,pkt->pts >> 24);
+    put_be24(pb,flv->reserved);
     put_byte(pb,flags);
     if (enc->codec_id == CODEC_ID_VP6)
         put_byte(pb,0);
@@ -328,7 +331,7 @@
 #ifdef CONFIG_LIBMP3LAME
     CODEC_ID_MP3,
 #else // CONFIG_LIBMP3LAME
-    CODEC_ID_NONE,
+    CODEC_ID_ADPCM_SWF,
 #endif // CONFIG_LIBMP3LAME
     CODEC_ID_FLV1,
     flv_write_header,
diff -u mplayer-1.0~rc2-12/libavformat/flv.h ffmpeg-free-0.svn20080206/libavformat/flv.h
--- mplayer-1.0~rc2-12/libavformat/flv.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/flv.h	2007-10-17 11:37:46.000000000 +0200
@@ -21,8 +21,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef FLV_H
-#define FLV_H
+#ifndef FFMPEG_FLV_H
+#define FFMPEG_FLV_H
 
 /* offsets for packed values */
 #define FLV_AUDIO_SAMPLESSIZE_OFFSET 1
@@ -107,4 +107,4 @@
     AMF_DATA_TYPE_UNSUPPORTED = 0x0d,
 } AMFDataType;
 
-#endif /* FLV_H */
+#endif /* FFMPEG_FLV_H */
Only in ffmpeg-free-0.svn20080206/libavformat: framecrcenc.c
diff -u mplayer-1.0~rc2-12/libavformat/framehook.c ffmpeg-free-0.svn20080206/libavformat/framehook.c
--- mplayer-1.0~rc2-12/libavformat/framehook.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/framehook.c	2008-01-06 17:02:55.000000000 +0100
@@ -28,8 +28,8 @@
 #endif
 
 
-typedef struct _FrameHookEntry {
-    struct _FrameHookEntry *next;
+typedef struct FrameHookEntry {
+    struct FrameHookEntry *next;
     FrameHookConfigureFn Configure;
     FrameHookProcessFn Process;
     FrameHookReleaseFn Release;
diff -u mplayer-1.0~rc2-12/libavformat/framehook.h ffmpeg-free-0.svn20080206/libavformat/framehook.h
--- mplayer-1.0~rc2-12/libavformat/framehook.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/framehook.h	2008-01-03 03:12:08.000000000 +0100
@@ -19,10 +19,10 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef FRAMEHOOK_H
-#define FRAMEHOOK_H
+#ifndef FFMPEG_FRAMEHOOK_H
+#define FFMPEG_FRAMEHOOK_H
 
-#warning VHOOK is deprecated. Please help porting libmpcodecs or a better filter system to FFmpeg instead of wasting your time writing new filters for this crappy one.
+#warning VHOOK is deprecated. Please help finishing libavfilter instead of wasting your time writing new filters for this crappy filter system.
 
 /*
  * Prototypes for interface to .so that implement a video processing hook
@@ -49,4 +49,4 @@
 extern void frame_hook_process(struct AVPicture *pict, enum PixelFormat pix_fmt, int width, int height, int64_t pts);
 extern void frame_hook_release(void);
 
-#endif
+#endif /* FFMPEG_FRAMEHOOK_H */
diff -u mplayer-1.0~rc2-12/libavformat/gif.c ffmpeg-free-0.svn20080206/libavformat/gif.c
--- mplayer-1.0~rc2-12/libavformat/gif.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/gif.c	2008-01-17 01:12:04.000000000 +0100
@@ -137,7 +137,7 @@
         //printf("bitbuf = %08x\n", bit_buf);
         s->buf_ptr+=4;
         if (s->buf_ptr >= s->buf_end)
-            puts("bit buffer overflow !!"); // should never happen ! who got rid of the callback ???
+            abort();
 //            flush_buffer_rev(s);
         bit_cnt=bit_cnt + n - 32;
         if (bit_cnt == 0) {
@@ -313,7 +313,7 @@
 static int gif_write_header(AVFormatContext *s)
 {
     GIFContext *gif = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVCodecContext *enc, *video_enc;
     int i, width, height, loop_count /*, rate*/;
 
@@ -348,14 +348,14 @@
 
     gif_image_write_header(pb, width, height, loop_count, NULL);
 
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
     return 0;
 }
 
 static int gif_write_video(AVFormatContext *s,
                            AVCodecContext *enc, const uint8_t *buf, int size)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     GIFContext *gif = s->priv_data;
     int jiffies;
     int64_t delay;
@@ -383,7 +383,7 @@
     gif_image_write_image(pb, 0, 0, enc->width, enc->height,
                           buf, enc->width * 3, PIX_FMT_RGB24);
 
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
     return 0;
 }
 
@@ -398,10 +398,10 @@
 
 static int gif_write_trailer(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
 
     put_byte(pb, 0x3b);
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
     return 0;
 }
 
diff -u mplayer-1.0~rc2-12/libavformat/gifdec.c ffmpeg-free-0.svn20080206/libavformat/gifdec.c
--- mplayer-1.0~rc2-12/libavformat/gifdec.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/gifdec.c	2007-11-21 08:41:00.000000000 +0100
@@ -526,7 +526,7 @@
                            AVFormatParameters * ap)
 {
     GifState *s = s1->priv_data;
-    ByteIOContext *f = &s1->pb;
+    ByteIOContext *f = s1->pb;
     AVStream *st;
 
     s->f = f;
diff -u mplayer-1.0~rc2-12/libavformat/gxf.c ffmpeg-free-0.svn20080206/libavformat/gxf.c
--- mplayer-1.0~rc2-12/libavformat/gxf.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/gxf.c	2007-11-21 08:41:00.000000000 +0100
@@ -228,7 +228,7 @@
  * \brief read index from FLT packet into stream 0 av_index
  */
 static void gxf_read_index(AVFormatContext *s, int pkt_len) {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st = s->streams[0];
     uint32_t fields_per_map = get_le32(pb);
     uint32_t map_cnt = get_le32(pb);
@@ -252,7 +252,7 @@
 }
 
 static int gxf_header(AVFormatContext *s, AVFormatParameters *ap) {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     pkt_type_t pkt_type;
     int map_len;
     int len;
@@ -378,7 +378,7 @@
     int cur_track;
     int64_t cur_timestamp = AV_NOPTS_VALUE;
     int len;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     pkt_type_t type;
     tmp = get_be32(pb);
 start:
@@ -408,7 +408,7 @@
 }
 
 static int gxf_packet(AVFormatContext *s, AVPacket *pkt) {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     pkt_type_t pkt_type;
     int pkt_len;
     while (!url_feof(pb)) {
@@ -466,7 +466,7 @@
     if (idx < st->nb_index_entries - 2)
         maxlen = st->index_entries[idx + 2].pos - pos;
     maxlen = FFMAX(maxlen, 200 * 1024);
-    url_fseek(&s->pb, pos, SEEK_SET);
+    url_fseek(s->pb, pos, SEEK_SET);
     found = gxf_resync_media(s, maxlen, -1, timestamp);
     if (FFABS(found - timestamp) > 4)
         return -1;
@@ -475,7 +475,7 @@
 
 static int64_t gxf_read_timestamp(AVFormatContext *s, int stream_index,
                                   int64_t *pos, int64_t pos_limit) {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int64_t res;
     url_fseek(pb, *pos, SEEK_SET);
     res = gxf_resync_media(s, pos_limit - *pos, -1, -1);
diff -u mplayer-1.0~rc2-12/libavformat/gxfenc.c ffmpeg-free-0.svn20080206/libavformat/gxfenc.c
--- mplayer-1.0~rc2-12/libavformat/gxfenc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/gxfenc.c	2007-11-21 08:41:00.000000000 +0100
@@ -576,7 +576,7 @@
 
 static int gxf_write_header(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     GXFContext *gxf = s->priv_data;
     int i;
 
@@ -671,7 +671,7 @@
 
 static int gxf_write_trailer(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     GXFContext *gxf = s->priv_data;
     offset_t end;
     int i;
@@ -763,8 +763,8 @@
 {
     GXFContext *gxf = s->priv_data;
 
-    gxf_write_media_packet(&s->pb, gxf, pkt);
-    put_flush_packet(&s->pb);
+    gxf_write_media_packet(s->pb, gxf, pkt);
+    put_flush_packet(s->pb);
     return 0;
 }
 
diff -u mplayer-1.0~rc2-12/libavformat/http.c ffmpeg-free-0.svn20080206/libavformat/http.c
--- mplayer-1.0~rc2-12/libavformat/http.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/http.c	2008-02-02 23:03:01.000000000 +0100
@@ -21,6 +21,7 @@
 #include "avformat.h"
 #include <unistd.h>
 #include "network.h"
+#include "os_support.h"
 
 #include "base64.h"
 #include "avstring.h"
@@ -218,7 +219,7 @@
     /* send http header */
     post = h->flags & URL_WRONLY;
     auth_b64 = av_malloc(auth_b64_len);
-    av_base64_encode(auth_b64, auth_b64_len, (uint8_t *)auth, strlen(auth));
+    av_base64_encode(auth_b64, auth_b64_len, auth, strlen(auth));
     snprintf(s->buffer, sizeof(s->buffer),
              "%s %s HTTP/1.1\r\n"
              "User-Agent: %s\r\n"
@@ -246,7 +247,6 @@
     s->off = 0;
     s->filesize = -1;
     if (post) {
-        usleep(1000*1000);
         return 0;
     }
 
diff -u mplayer-1.0~rc2-12/libavformat/idcin.c ffmpeg-free-0.svn20080206/libavformat/idcin.c
--- mplayer-1.0~rc2-12/libavformat/idcin.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/idcin.c	2007-11-21 08:41:00.000000000 +0100
@@ -136,7 +136,7 @@
 static int idcin_read_header(AVFormatContext *s,
                              AVFormatParameters *ap)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     IdcinDemuxContext *idcin = s->priv_data;
     AVStream *st;
     unsigned int width, height;
@@ -215,13 +215,13 @@
     unsigned int command;
     unsigned int chunk_size;
     IdcinDemuxContext *idcin = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int i;
     int palette_scale;
     unsigned char r, g, b;
     unsigned char palette_buffer[768];
 
-    if (url_feof(&s->pb))
+    if (url_feof(s->pb))
         return AVERROR(EIO);
 
     if (idcin->next_chunk_is_video) {
diff -u mplayer-1.0~rc2-12/libavformat/idroq.c ffmpeg-free-0.svn20080206/libavformat/idroq.c
--- mplayer-1.0~rc2-12/libavformat/idroq.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/idroq.c	2007-11-21 08:41:00.000000000 +0100
@@ -69,7 +69,7 @@
                            AVFormatParameters *ap)
 {
     RoqDemuxContext *roq = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st;
     unsigned char preamble[RoQ_CHUNK_PREAMBLE_SIZE];
     int i;
@@ -174,7 +174,7 @@
                            AVPacket *pkt)
 {
     RoqDemuxContext *roq = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int ret = 0;
     unsigned int chunk_size;
     unsigned int chunk_type;
@@ -185,7 +185,7 @@
 
     while (!packet_read) {
 
-        if (url_feof(&s->pb))
+        if (url_feof(s->pb))
             return AVERROR(EIO);
 
         /* get the next chunk preamble */
diff -u mplayer-1.0~rc2-12/libavformat/img2.c ffmpeg-free-0.svn20080206/libavformat/img2.c
--- mplayer-1.0~rc2-12/libavformat/img2.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/img2.c	2007-12-28 14:07:43.000000000 +0100
@@ -57,6 +57,14 @@
     { CODEC_ID_TIFF      , "tiff"},
     { CODEC_ID_SGI       , "sgi"},
     { CODEC_ID_PTX       , "ptx"},
+    { CODEC_ID_PCX       , "pcx"},
+    { CODEC_ID_SUNRAST   , "sun"},
+    { CODEC_ID_SUNRAST   , "ras"},
+    { CODEC_ID_SUNRAST   , "rs"},
+    { CODEC_ID_SUNRAST   , "im1"},
+    { CODEC_ID_SUNRAST   , "im8"},
+    { CODEC_ID_SUNRAST   , "im24"},
+    { CODEC_ID_SUNRAST   , "sunras"},
     {0, NULL}
 };
 
@@ -239,7 +247,7 @@
     char filename[1024];
     int i;
     int size[3]={0}, ret[3]={0};
-    ByteIOContext f1[3], *f[3]= {&f1[0], &f1[1], &f1[2]};
+    ByteIOContext *f[3];
     AVCodecContext *codec= s1->streams[0]->codec;
 
     if (!s->is_pipe) {
@@ -251,7 +259,7 @@
                                   s->path, s->img_number)<0 && s->img_number > 1)
             return AVERROR(EIO);
         for(i=0; i<3; i++){
-            if (url_fopen(f[i], filename, URL_RDONLY) < 0)
+            if (url_fopen(&f[i], filename, URL_RDONLY) < 0)
                 return AVERROR(EIO);
             size[i]= url_fsize(f[i]);
 
@@ -263,7 +271,7 @@
         if(codec->codec_id == CODEC_ID_RAWVIDEO && !codec->width)
             infer_size(&codec->width, &codec->height, size[0]);
     } else {
-        f[0] = &s1->pb;
+        f[0] = s1->pb;
         if (url_feof(f[0]))
             return AVERROR(EIO);
         size[0]= 4096;
@@ -322,7 +330,7 @@
 static int img_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
     VideoData *img = s->priv_data;
-    ByteIOContext pb1[3], *pb[3]= {&pb1[0], &pb1[1], &pb1[2]};
+    ByteIOContext *pb[3];
     char filename[1024];
     AVCodecContext *codec= s->streams[ pkt->stream_index ]->codec;
     int i;
@@ -332,7 +340,7 @@
                                   img->path, img->img_number) < 0 && img->img_number>1)
             return AVERROR(EIO);
         for(i=0; i<3; i++){
-            if (url_fopen(pb[i], filename, URL_WRONLY) < 0)
+            if (url_fopen(&pb[i], filename, URL_WRONLY) < 0)
                 return AVERROR(EIO);
 
             if(codec->codec_id != CODEC_ID_RAWVIDEO)
@@ -340,7 +348,7 @@
             filename[ strlen(filename) - 1 ]= 'U' + i;
         }
     } else {
-        pb[0] = &s->pb;
+        pb[0] = s->pb;
     }
 
     if(codec->codec_id == CODEC_ID_RAWVIDEO){
diff -u mplayer-1.0~rc2-12/libavformat/ipmovie.c ffmpeg-free-0.svn20080206/libavformat/ipmovie.c
--- mplayer-1.0~rc2-12/libavformat/ipmovie.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/ipmovie.c	2007-11-21 08:41:00.000000000 +0100
@@ -517,7 +517,7 @@
                                AVFormatParameters *ap)
 {
     IPMVEContext *ipmovie = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVPacket pkt;
     AVStream *st;
     unsigned char chunk_preamble[CHUNK_PREAMBLE_SIZE];
@@ -589,7 +589,7 @@
                                AVPacket *pkt)
 {
     IPMVEContext *ipmovie = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int ret;
 
     ret = process_ipmovie_chunk(ipmovie, pb, pkt);
diff -u mplayer-1.0~rc2-12/libavformat/isom.c ffmpeg-free-0.svn20080206/libavformat/isom.c
--- mplayer-1.0~rc2-12/libavformat/isom.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/isom.c	2008-01-29 23:37:07.000000000 +0100
@@ -26,12 +26,13 @@
 #include "isom.h"
 
 /* http://www.mp4ra.org */
+/* ordered by muxing preference */
 const AVCodecTag ff_mp4_obj_type[] = {
     { CODEC_ID_MPEG4     ,  32 },
     { CODEC_ID_H264      ,  33 },
     { CODEC_ID_AAC       ,  64 },
-    { CODEC_ID_MPEG2VIDEO,  96 }, /* MPEG2 Simple */
     { CODEC_ID_MPEG2VIDEO,  97 }, /* MPEG2 Main */
+    { CODEC_ID_MPEG2VIDEO,  96 }, /* MPEG2 Simple */
     { CODEC_ID_MPEG2VIDEO,  98 }, /* MPEG2 SNR */
     { CODEC_ID_MPEG2VIDEO,  99 }, /* MPEG2 Spatial */
     { CODEC_ID_MPEG2VIDEO, 100 }, /* MPEG2 High */
@@ -39,22 +40,16 @@
     { CODEC_ID_AAC       , 102 }, /* MPEG2 AAC Main */
     { CODEC_ID_AAC       , 103 }, /* MPEG2 AAC Low */
     { CODEC_ID_AAC       , 104 }, /* MPEG2 AAC SSR */
+    { CODEC_ID_MP3       , 107 }, /* 11172-3 */
     { CODEC_ID_MP3       , 105 }, /* 13818-3 */
     { CODEC_ID_MPEG1VIDEO, 106 }, /* 11172-2 */
-    { CODEC_ID_MP3       , 107 }, /* 11172-3 */
     { CODEC_ID_MJPEG     , 108 }, /* 10918-1 */
     { CODEC_ID_PNG       , 109 },
     { CODEC_ID_JPEG2000  , 110 }, /* 15444-1 */
     { CODEC_ID_VC1       , 163 },
-    { CODEC_ID_VORBIS    , 221 },
-    { CODEC_ID_PCM_S16LE , 224 },
+    { CODEC_ID_VORBIS    , 221 }, /* non standard, gpac uses it */
+    { CODEC_ID_DVD_SUBTITLE, 224 }, /* non standard, see unsupported-embedded-subs-2.mp4 */
     { CODEC_ID_QCELP     , 225 },
-    { CODEC_ID_AC3       , 226 },
-    { CODEC_ID_PCM_ALAW  , 227 },
-    { CODEC_ID_PCM_MULAW , 228 },
-    { CODEC_ID_PCM_S16BE , 230 },
-    { CODEC_ID_H263      , 242 },
-    { CODEC_ID_H261      , 243 },
     { 0, 0 },
 };
 
@@ -174,6 +169,12 @@
     { CODEC_ID_NONE, 0 },
 };
 
+const AVCodecTag ff_codec_movsubtitle_tags[] = {
+    { CODEC_ID_MOV_TEXT, MKTAG('t', 'e', 'x', 't') },
+    { CODEC_ID_MOV_TEXT, MKTAG('t', 'x', '3', 'g') },
+    { CODEC_ID_NONE, 0 },
+};
+
 /* map numeric codes from mdhd atom to ISO 639 */
 /* cf. QTFileFormat.pdf p253, qtff.pdf p205 */
 /* http://developer.apple.com/documentation/mac/Text/Text-368.html */
diff -u mplayer-1.0~rc2-12/libavformat/isom.h ffmpeg-free-0.svn20080206/libavformat/isom.h
--- mplayer-1.0~rc2-12/libavformat/isom.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/isom.h	2008-01-26 21:30:03.000000000 +0100
@@ -30,6 +30,7 @@
 extern const AVCodecTag ff_mp4_obj_type[];
 extern const AVCodecTag codec_movvideo_tags[];
 extern const AVCodecTag codec_movaudio_tags[];
+extern const AVCodecTag ff_codec_movsubtitle_tags[];
 
 int ff_mov_iso639_to_lang(const char *lang, int mp4);
 int ff_mov_lang_to_iso639(int code, char *to);
Only in mplayer-1.0~rc2-12/libavformat: libdc1394.c
diff -u mplayer-1.0~rc2-12/libavformat/libnut.c ffmpeg-free-0.svn20080206/libavformat/libnut.c
--- mplayer-1.0~rc2-12/libavformat/libnut.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/libnut.c	2007-11-21 08:41:00.000000000 +0100
@@ -54,7 +54,7 @@
 
 static int nut_write_header(AVFormatContext * avf) {
     NUTContext * priv = avf->priv_data;
-    ByteIOContext * bc = &avf->pb;
+    ByteIOContext * bc = avf->pb;
     nut_muxer_opts_t mopts = {
         .output = {
             .priv = bc,
@@ -137,7 +137,7 @@
 }
 
 static int nut_write_trailer(AVFormatContext * avf) {
-    ByteIOContext * bc = &avf->pb;
+    ByteIOContext * bc = avf->pb;
     NUTContext * priv = avf->priv_data;
     int i;
 
@@ -151,7 +151,7 @@
 }
 
 AVOutputFormat libnut_muxer = {
-    "nut",
+    "libnut",
     "nut format",
     "video/x-nut",
     "nut",
@@ -187,7 +187,7 @@
 
 static int nut_read_header(AVFormatContext * avf, AVFormatParameters * ap) {
     NUTContext * priv = avf->priv_data;
-    ByteIOContext * bc = &avf->pb;
+    ByteIOContext * bc = avf->pb;
     nut_demuxer_opts_t dopts = {
         .input = {
             .priv = bc,
@@ -272,7 +272,7 @@
     if (pd.flags & NUT_FLAG_KEY) pkt->flags |= PKT_FLAG_KEY;
     pkt->pts = pd.pts;
     pkt->stream_index = pd.stream;
-    pkt->pos = url_ftell(&avf->pb);
+    pkt->pos = url_ftell(avf->pb);
 
     ret = nut_read_frame(priv->nut, &pd.len, pkt->data);
 
Only in ffmpeg-free-0.svn20080206/libavformat: lmlm4.c
diff -u mplayer-1.0~rc2-12/libavformat/Makefile ffmpeg-free-0.svn20080206/libavformat/Makefile
--- mplayer-1.0~rc2-12/libavformat/Makefile	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/Makefile	2008-01-29 10:25:49.000000000 +0100
@@ -8,7 +8,7 @@
 
 OBJS = allformats.o cutils.o os_support.o sdp.o utils.o
 
-HEADERS = avformat.h avio.h rtp.h rtsp.h rtspcodes.h
+HEADERS = avformat.h avio.h rtsp.h rtspcodes.h
 
 # muxers/demuxers
 OBJS-$(CONFIG_AAC_DEMUXER)               += raw.o
@@ -21,7 +21,7 @@
 OBJS-$(CONFIG_AMR_MUXER)                 += amr.o
 OBJS-$(CONFIG_APC_DEMUXER)               += apc.o
 OBJS-$(CONFIG_APE_DEMUXER)               += ape.o
-OBJS-$(CONFIG_ASF_DEMUXER)               += asf.o riff.o
+OBJS-$(CONFIG_ASF_DEMUXER)               += asf.o asfcrypt.o riff.o
 OBJS-$(CONFIG_ASF_MUXER)                 += asf-enc.o riff.o
 OBJS-$(CONFIG_ASF_STREAM_MUXER)          += asf-enc.o riff.o
 OBJS-$(CONFIG_AU_DEMUXER)                += au.o raw.o
@@ -29,18 +29,18 @@
 OBJS-$(CONFIG_AVI_DEMUXER)               += avidec.o riff.o
 OBJS-$(CONFIG_AVI_MUXER)                 += avienc.o riff.o
 OBJS-$(CONFIG_AVISYNTH)                  += avisynth.o
+OBJS-$(CONFIG_AVM2_MUXER)                += swf.o
 OBJS-$(CONFIG_AVS_DEMUXER)               += avs.o vocdec.o voc.o
 OBJS-$(CONFIG_BETHSOFTVID_DEMUXER)       += bethsoftvid.o
-OBJS-$(CONFIG_BKTR_DEMUXER)              += bktr.o
 OBJS-$(CONFIG_C93_DEMUXER)               += c93.o vocdec.o voc.o
-OBJS-$(CONFIG_CRC_MUXER)                 += crc.o
+OBJS-$(CONFIG_CRC_MUXER)                 += crcenc.o
 OBJS-$(CONFIG_DAUD_DEMUXER)              += daud.o
 OBJS-$(CONFIG_DSICIN_DEMUXER)            += dsicin.o
 OBJS-$(CONFIG_DTS_DEMUXER)               += raw.o
 OBJS-$(CONFIG_DV_DEMUXER)                += dv.o
 OBJS-$(CONFIG_DV_MUXER)                  += dvenc.o
-OBJS-$(CONFIG_DV1394_DEMUXER)            += dv1394.o dv.o
 OBJS-$(CONFIG_DXA_DEMUXER)               += dxa.o riff.o
+OBJS-$(CONFIG_EA_CDATA_DEMUXER)          += eacdata.o
 OBJS-$(CONFIG_EA_DEMUXER)                += electronicarts.o
 OBJS-$(CONFIG_FFM_DEMUXER)               += ffm.o
 OBJS-$(CONFIG_FFM_MUXER)                 += ffm.o
@@ -50,7 +50,7 @@
 OBJS-$(CONFIG_FLV_DEMUXER)               += flvdec.o
 OBJS-$(CONFIG_FLV_MUXER)                 += flvenc.o
 OBJS-$(CONFIG_FOURXM_DEMUXER)            += 4xm.o
-OBJS-$(CONFIG_FRAMECRC_MUXER)            += crc.o
+OBJS-$(CONFIG_FRAMECRC_MUXER)            += framecrcenc.o
 OBJS-$(CONFIG_GIF_MUXER)                 += gif.o
 OBJS-$(CONFIG_GIF_DEMUXER)               += gifdec.o
 OBJS-$(CONFIG_GXF_DEMUXER)               += gxf.o
@@ -68,23 +68,25 @@
 OBJS-$(CONFIG_IMAGE2PIPE_MUXER)          += img2.o
 OBJS-$(CONFIG_INGENIENT_DEMUXER)         += raw.o
 OBJS-$(CONFIG_IPMOVIE_DEMUXER)           += ipmovie.o
+OBJS-$(CONFIG_LMLM4_DEMUXER)             += lmlm4.o
 OBJS-$(CONFIG_M4V_DEMUXER)               += raw.o
 OBJS-$(CONFIG_M4V_MUXER)                 += raw.o
-OBJS-$(CONFIG_MATROSKA_AUDIO_MUXER)      += matroskaenc.o matroska.o riff.o
+OBJS-$(CONFIG_MATROSKA_AUDIO_MUXER)      += matroskaenc.o matroska.o riff.o avc.o
 OBJS-$(CONFIG_MATROSKA_DEMUXER)          += matroskadec.o matroska.o riff.o
-OBJS-$(CONFIG_MATROSKA_MUXER)            += matroskaenc.o matroska.o riff.o
+OBJS-$(CONFIG_MATROSKA_MUXER)            += matroskaenc.o matroska.o riff.o avc.o
 OBJS-$(CONFIG_MJPEG_DEMUXER)             += raw.o
 OBJS-$(CONFIG_MJPEG_MUXER)               += raw.o
 OBJS-$(CONFIG_MM_DEMUXER)                += mm.o
 OBJS-$(CONFIG_MMF_DEMUXER)               += mmf.o raw.o
 OBJS-$(CONFIG_MMF_MUXER)                 += mmf.o riff.o
 OBJS-$(CONFIG_MOV_DEMUXER)               += mov.o riff.o isom.o
-OBJS-$(CONFIG_MOV_MUXER)                 += movenc.o riff.o isom.o
+OBJS-$(CONFIG_MOV_MUXER)                 += movenc.o riff.o isom.o avc.o
 OBJS-$(CONFIG_MP2_MUXER)                 += mp3.o
 OBJS-$(CONFIG_MP3_DEMUXER)               += mp3.o
 OBJS-$(CONFIG_MP3_MUXER)                 += mp3.o
-OBJS-$(CONFIG_MP4_MUXER)                 += movenc.o riff.o isom.o
+OBJS-$(CONFIG_MP4_MUXER)                 += movenc.o riff.o isom.o avc.o
 OBJS-$(CONFIG_MPC_DEMUXER)               += mpc.o
+OBJS-$(CONFIG_MPC8_DEMUXER)              += mpc8.o
 OBJS-$(CONFIG_MPEG1SYSTEM_MUXER)         += mpegenc.o
 OBJS-$(CONFIG_MPEG1VCD_MUXER)            += mpegenc.o
 OBJS-$(CONFIG_MPEG2DVD_MUXER)            += mpegenc.o
@@ -105,16 +107,31 @@
 OBJS-$(CONFIG_NUT_DEMUXER)               += nutdec.o nut.o riff.o
 OBJS-$(CONFIG_NUT_MUXER)                 += nutenc.o nut.o riff.o
 OBJS-$(CONFIG_NUV_DEMUXER)               += nuv.o riff.o
-OBJS-$(CONFIG_OGG_DEMUXER)               += ogg2.o           \
-                                            oggparsevorbis.o \
-                                            oggparsetheora.o \
+OBJS-$(CONFIG_OGG_DEMUXER)               += oggdec.o         \
                                             oggparseflac.o   \
                                             oggparseogm.o    \
+                                            oggparsetheora.o \
+                                            oggparsevorbis.o \
                                             riff.o
-OBJS-$(CONFIG_OGG_MUXER)                 += ogg.o
-OBJS-$(CONFIG_OSS_DEMUXER)               += audio.o
-OBJS-$(CONFIG_OSS_MUXER)                 += audio.o
-OBJS-$(CONFIG_PSP_MUXER)                 += movenc.o riff.o isom.o
+OBJS-$(CONFIG_OGG_MUXER)                 += oggenc.o
+OBJS-$(CONFIG_PCM_ALAW_DEMUXER)          += raw.o
+OBJS-$(CONFIG_PCM_ALAW_MUXER)            += raw.o
+OBJS-$(CONFIG_PCM_MULAW_DEMUXER)         += raw.o
+OBJS-$(CONFIG_PCM_MULAW_MUXER)           += raw.o
+OBJS-$(CONFIG_PCM_S16BE_DEMUXER)         += raw.o
+OBJS-$(CONFIG_PCM_S16BE_MUXER)           += raw.o
+OBJS-$(CONFIG_PCM_S16LE_DEMUXER)         += raw.o
+OBJS-$(CONFIG_PCM_S16LE_MUXER)           += raw.o
+OBJS-$(CONFIG_PCM_S8_DEMUXER)            += raw.o
+OBJS-$(CONFIG_PCM_S8_MUXER)              += raw.o
+OBJS-$(CONFIG_PCM_U16BE_DEMUXER)         += raw.o
+OBJS-$(CONFIG_PCM_U16BE_MUXER)           += raw.o
+OBJS-$(CONFIG_PCM_U16LE_DEMUXER)         += raw.o
+OBJS-$(CONFIG_PCM_U16LE_MUXER)           += raw.o
+OBJS-$(CONFIG_PCM_U8_DEMUXER)            += raw.o
+OBJS-$(CONFIG_PCM_U8_MUXER)              += raw.o
+OBJS-$(CONFIG_PSP_MUXER)                 += movenc.o riff.o isom.o avc.o
+OBJS-$(CONFIG_PVA_DEMUXER)               += pva.o
 OBJS-$(CONFIG_RAWVIDEO_DEMUXER)          += raw.o
 OBJS-$(CONFIG_RAWVIDEO_MUXER)            += raw.o
 OBJS-$(CONFIG_REDIR_DEMUXER)             += rtsp.o
@@ -122,25 +139,30 @@
 OBJS-$(CONFIG_RM_MUXER)                  += rmenc.o
 OBJS-$(CONFIG_ROQ_DEMUXER)               += idroq.o
 OBJS-$(CONFIG_ROQ_MUXER)                 += raw.o
-OBJS-$(CONFIG_RTP_MUXER)                 += rtp.o rtp_h264.o rtp_mpv.o rtp_aac.o
+OBJS-$(CONFIG_RTP_MUXER)                 += rtp.o         \
+                                            rtpenc.o      \
+                                            rtp_mpv.o     \
+                                            rtp_aac.o     \
+                                            rtpenc_h264.o \
+                                            avc.o
 OBJS-$(CONFIG_RTSP_DEMUXER)              += rtsp.o
-OBJS-$(CONFIG_SDP_DEMUXER)               += rtsp.o
+OBJS-$(CONFIG_SDP_DEMUXER)               += rtsp.o rtp.o rtpdec.o rtp_h264.o
 OBJS-$(CONFIG_SEGAFILM_DEMUXER)          += segafilm.o
 OBJS-$(CONFIG_SHORTEN_DEMUXER)           += raw.o
+OBJS-$(CONFIG_SIFF_DEMUXER)              += siff.o
 OBJS-$(CONFIG_SMACKER_DEMUXER)           += smacker.o
 OBJS-$(CONFIG_SOL_DEMUXER)               += sol.o raw.o
 OBJS-$(CONFIG_STR_DEMUXER)               += psxstr.o
 OBJS-$(CONFIG_SWF_DEMUXER)               += swf.o
 OBJS-$(CONFIG_SWF_MUXER)                 += swf.o
-OBJS-$(CONFIG_TG2_MUXER)                 += movenc.o riff.o isom.o
-OBJS-$(CONFIG_TGP_MUXER)                 += movenc.o riff.o isom.o
+OBJS-$(CONFIG_TG2_MUXER)                 += movenc.o riff.o isom.o avc.o
+OBJS-$(CONFIG_TGP_MUXER)                 += movenc.o riff.o isom.o avc.o
 OBJS-$(CONFIG_THP_DEMUXER)               += thp.o
 OBJS-$(CONFIG_TIERTEXSEQ_DEMUXER)        += tiertexseq.o
 OBJS-$(CONFIG_TTA_DEMUXER)               += tta.o
 OBJS-$(CONFIG_TXD_DEMUXER)               += txd.o
-OBJS-$(CONFIG_V4L2_DEMUXER)              += v4l2.o
-OBJS-$(CONFIG_V4L_DEMUXER)               += v4l.o
 OBJS-$(CONFIG_VC1_DEMUXER)               += raw.o
+OBJS-$(CONFIG_VC1T_DEMUXER)              += vc1test.o
 OBJS-$(CONFIG_VMD_DEMUXER)               += sierravmd.o
 OBJS-$(CONFIG_VOC_DEMUXER)               += vocdec.o voc.o
 OBJS-$(CONFIG_VOC_MUXER)                 += vocenc.o voc.o
@@ -150,22 +172,17 @@
 OBJS-$(CONFIG_WSAUD_DEMUXER)             += westwood.o
 OBJS-$(CONFIG_WSVQA_DEMUXER)             += westwood.o
 OBJS-$(CONFIG_WV_DEMUXER)                += wv.o
-OBJS-$(CONFIG_X11_GRAB_DEVICE_DEMUXER)   += x11grab.o
 OBJS-$(CONFIG_YUV4MPEGPIPE_MUXER)        += yuv4mpeg.o
 OBJS-$(CONFIG_YUV4MPEGPIPE_DEMUXER)      += yuv4mpeg.o
 
 # external libraries
-OBJS-$(CONFIG_LIBDC1394_DEMUXER)         += libdc1394.o
 OBJS-$(CONFIG_LIBNUT_DEMUXER)            += libnut.o riff.o
 OBJS-$(CONFIG_LIBNUT_MUXER)              += libnut.o riff.o
 
 OBJS-$(CONFIG_VHOOK)                     += framehook.o
 
-EXTRALIBS := -L$(BUILD_ROOT)/libavutil -lavutil$(BUILDSUF) \
-             -lavcodec$(BUILDSUF) -L$(BUILD_ROOT)/libavcodec $(EXTRALIBS)
-
-CPPOBJS-$(CONFIG_AUDIO_BEOS_DEMUXER)     += beosaudio.o
-CPPOBJS-$(CONFIG_AUDIO_BEOS_MUXER)       += beosaudio.o
+EXTRALIBS := -L$(BUILD_ROOT)/libavcodec -lavcodec$(BUILDSUF) \
+             -L$(BUILD_ROOT)/libavutil  -lavutil$(BUILDSUF) $(EXTRALIBS)
 
 # protocols I/O
 OBJS+= avio.o aviobuf.o
diff -u mplayer-1.0~rc2-12/libavformat/matroska.c ffmpeg-free-0.svn20080206/libavformat/matroska.c
--- mplayer-1.0~rc2-12/libavformat/matroska.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/matroska.c	2008-01-27 16:43:17.000000000 +0100
@@ -21,7 +21,7 @@
 
 #include "matroska.h"
 
-CodecTags ff_mkv_codec_tags[]={
+const CodecTags ff_mkv_codec_tags[]={
 //    {"V_MS/VFW/FOURCC"  , CODEC_ID_NONE},
     {"V_UNCOMPRESSED"   , CODEC_ID_RAWVIDEO},
     {"V_MPEG4/ISO/ASP"  , CODEC_ID_MPEG4},
@@ -62,12 +62,24 @@
 
     {"S_TEXT/UTF8"      , CODEC_ID_TEXT},
     {"S_TEXT/ASCII"     , CODEC_ID_TEXT},
-    {"S_TEXT/ASS"       , CODEC_ID_TEXT},
-    {"S_TEXT/SSA"       , CODEC_ID_TEXT},
-    {"S_ASS"            , CODEC_ID_TEXT},
-    {"S_SSA"            , CODEC_ID_TEXT},
+    {"S_TEXT/ASS"       , CODEC_ID_SSA},
+    {"S_TEXT/SSA"       , CODEC_ID_SSA},
+    {"S_ASS"            , CODEC_ID_SSA},
+    {"S_SSA"            , CODEC_ID_SSA},
     {"S_VOBSUB"         , CODEC_ID_DVD_SUBTITLE},
 
-    {NULL               , CODEC_ID_NONE}
+    {""                 , CODEC_ID_NONE}
 /* TODO: AC3-9/10 (?), Real, Musepack, Quicktime */
 };
+
+const CodecMime ff_mkv_mime_tags[] = {
+    {"text/plain"                 , CODEC_ID_TEXT},
+    {"image/gif"                  , CODEC_ID_GIF},
+    {"image/jpeg"                 , CODEC_ID_MJPEG},
+    {"image/png"                  , CODEC_ID_PNG},
+    {"image/tiff"                 , CODEC_ID_TIFF},
+    {"application/x-truetype-font", CODEC_ID_TTF},
+    {"application/x-font"         , CODEC_ID_TTF},
+
+    {""                           , CODEC_ID_NONE}
+};
diff -u mplayer-1.0~rc2-12/libavformat/matroskadec.c ffmpeg-free-0.svn20080206/libavformat/matroskadec.c
--- mplayer-1.0~rc2-12/libavformat/matroskadec.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/matroskadec.c	2008-02-04 02:04:27.000000000 +0100
@@ -94,8 +94,6 @@
 
 typedef struct MatroskaSubtitleTrack {
     MatroskaTrack track;
-
-    int ass;
     //..
 } MatroskaSubtitleTrack;
 
@@ -176,7 +174,7 @@
 static int
 ebml_read_element_level_up (MatroskaDemuxContext *matroska)
 {
-    ByteIOContext *pb = &matroska->ctx->pb;
+    ByteIOContext *pb = matroska->ctx->pb;
     offset_t pos = url_ftell(pb);
     int num = 0;
 
@@ -208,7 +206,7 @@
                int                   max_size,
                uint64_t             *number)
 {
-    ByteIOContext *pb = &matroska->ctx->pb;
+    ByteIOContext *pb = matroska->ctx->pb;
     int len_mask = 0x80, read = 1, n = 1;
     int64_t total = 0;
 
@@ -325,7 +323,7 @@
 ebml_read_seek (MatroskaDemuxContext *matroska,
                 offset_t              offset)
 {
-    ByteIOContext *pb = &matroska->ctx->pb;
+    ByteIOContext *pb = matroska->ctx->pb;
 
     /* clear ID cache, if any */
     matroska->peek_id = 0;
@@ -341,7 +339,7 @@
 static int
 ebml_read_skip (MatroskaDemuxContext *matroska)
 {
-    ByteIOContext *pb = &matroska->ctx->pb;
+    ByteIOContext *pb = matroska->ctx->pb;
     uint32_t id;
     uint64_t length;
     int res;
@@ -365,7 +363,7 @@
                 uint32_t             *id,
                 uint64_t             *num)
 {
-    ByteIOContext *pb = &matroska->ctx->pb;
+    ByteIOContext *pb = matroska->ctx->pb;
     int n = 0, size, res;
     uint64_t rlength;
 
@@ -399,7 +397,7 @@
                 uint32_t             *id,
                 int64_t              *num)
 {
-    ByteIOContext *pb = &matroska->ctx->pb;
+    ByteIOContext *pb = matroska->ctx->pb;
     int size, n = 1, negative = 0, res;
     uint64_t rlength;
 
@@ -438,7 +436,7 @@
                  uint32_t             *id,
                  double               *num)
 {
-    ByteIOContext *pb = &matroska->ctx->pb;
+    ByteIOContext *pb = matroska->ctx->pb;
     int size, res;
     uint64_t rlength;
 
@@ -472,7 +470,7 @@
                  uint32_t             *id,
                  char                **str)
 {
-    ByteIOContext *pb = &matroska->ctx->pb;
+    ByteIOContext *pb = matroska->ctx->pb;
     int size, res;
     uint64_t rlength;
 
@@ -534,7 +532,7 @@
 ebml_read_master (MatroskaDemuxContext *matroska,
                   uint32_t             *id)
 {
-    ByteIOContext *pb = &matroska->ctx->pb;
+    ByteIOContext *pb = matroska->ctx->pb;
     uint64_t length;
     MatroskaLevel *level;
     int res;
@@ -569,7 +567,7 @@
                   uint8_t             **binary,
                   int                  *size)
 {
-    ByteIOContext *pb = &matroska->ctx->pb;
+    ByteIOContext *pb = matroska->ctx->pb;
     uint64_t rlength;
     int res;
 
@@ -846,6 +844,24 @@
     matroska->num_packets++;
 }
 
+/*
+ * Free all packets in our internal queue.
+ */
+static void
+matroska_clear_queue (MatroskaDemuxContext *matroska)
+{
+    if (matroska->packets) {
+        int n;
+        for (n = 0; n < matroska->num_packets; n++) {
+            av_free_packet(matroska->packets[n]);
+            av_free(matroska->packets[n]);
+        }
+        av_free(matroska->packets);
+        matroska->packets = NULL;
+        matroska->num_packets = 0;
+    }
+}
+
 
 /*
  * Autodetecting...
@@ -1199,9 +1215,9 @@
                             break;
                         }
 
-                        /* colourspace (only matters for raw video)
+                        /* colorspace (only matters for raw video)
                          * fourcc */
-                        case MATROSKA_ID_VIDEOCOLOURSPACE: {
+                        case MATROSKA_ID_VIDEOCOLORSPACE: {
                             uint64_t num;
                             if ((res = ebml_read_uint(matroska, &id,
                                                       &num)) < 0)
@@ -1748,7 +1764,7 @@
 
                         /* remember the peeked ID and the current position */
                         peek_id_cache = matroska->peek_id;
-                        before_pos = url_ftell(&matroska->ctx->pb);
+                        before_pos = url_ftell(matroska->ctx->pb);
 
                         /* seek */
                         if ((res = ebml_read_seek(matroska, seek_pos +
@@ -1788,14 +1804,14 @@
                         switch (id) {
                             case MATROSKA_ID_CUES:
                                 if (!(res = matroska_parse_index(matroska)) ||
-                                    url_feof(&matroska->ctx->pb)) {
+                                    url_feof(matroska->ctx->pb)) {
                                     matroska->index_parsed = 1;
                                     res = 0;
                                 }
                                 break;
                             case MATROSKA_ID_TAGS:
                                 if (!(res = matroska_parse_metadata(matroska)) ||
-                                   url_feof(&matroska->ctx->pb)) {
+                                   url_feof(matroska->ctx->pb)) {
                                     matroska->metadata_parsed = 1;
                                     res = 0;
                                 }
@@ -1849,6 +1865,119 @@
     return res;
 }
 
+static int
+matroska_parse_attachments(AVFormatContext *s)
+{
+    MatroskaDemuxContext *matroska = s->priv_data;
+    int res = 0;
+    uint32_t id;
+
+    av_log(matroska->ctx, AV_LOG_DEBUG, "parsing attachments...\n");
+
+    while (res == 0) {
+        if (!(id = ebml_peek_id(matroska, &matroska->level_up))) {
+            res = AVERROR(EIO);
+            break;
+        } else if (matroska->level_up) {
+            matroska->level_up--;
+            break;
+        }
+
+        switch (id) {
+        case MATROSKA_ID_ATTACHEDFILE: {
+            char* name = NULL;
+            char* mime = NULL;
+            uint8_t* data = NULL;
+            int i, data_size = 0;
+            AVStream *st;
+
+            if ((res = ebml_read_master(matroska, &id)) < 0)
+                break;
+
+            while (res == 0) {
+                if (!(id = ebml_peek_id(matroska, &matroska->level_up))) {
+                    res = AVERROR(EIO);
+                    break;
+                } else if (matroska->level_up) {
+                    matroska->level_up--;
+                    break;
+                }
+
+                switch (id) {
+                case MATROSKA_ID_FILENAME:
+                    res = ebml_read_utf8 (matroska, &id, &name);
+                    break;
+
+                case MATROSKA_ID_FILEMIMETYPE:
+                    res = ebml_read_ascii (matroska, &id, &mime);
+                    break;
+
+                case MATROSKA_ID_FILEDATA:
+                    res = ebml_read_binary(matroska, &id, &data, &data_size);
+                    break;
+
+                default:
+                    av_log(matroska->ctx, AV_LOG_INFO,
+                           "Unknown attachedfile ID 0x%x\n", id);
+                case EBML_ID_VOID:
+                    res = ebml_read_skip(matroska);
+                    break;
+                }
+
+                if (matroska->level_up) {
+                    matroska->level_up--;
+                    break;
+                }
+            }
+
+            if (!(name && mime && data && data_size > 0)) {
+                av_log(matroska->ctx, AV_LOG_ERROR, "incomplete attachment\n");
+                break;
+            }
+
+            st = av_new_stream(s, matroska->num_streams++);
+            if (st == NULL)
+                return AVERROR(ENOMEM);
+            st->filename = av_strdup(name);
+            st->codec->codec_id = CODEC_ID_NONE;
+            st->codec->codec_type = CODEC_TYPE_ATTACHMENT;
+            st->codec->extradata = av_malloc(data_size);
+            if(st->codec->extradata == NULL)
+                return AVERROR(ENOMEM);
+            st->codec->extradata_size = data_size;
+            memcpy(st->codec->extradata, data, data_size);
+
+            for (i=0; ff_mkv_mime_tags[i].id != CODEC_ID_NONE; i++) {
+                if (!strncmp(ff_mkv_mime_tags[i].str, mime,
+                             strlen(ff_mkv_mime_tags[i].str))) {
+                    st->codec->codec_id = ff_mkv_mime_tags[i].id;
+                    break;
+                }
+            }
+
+            av_log(matroska->ctx, AV_LOG_DEBUG, "new attachment: %s, %s, size %d \n", name, mime, data_size);
+            break;
+        }
+
+        default:
+            av_log(matroska->ctx, AV_LOG_INFO,
+                   "Unknown attachments ID 0x%x\n", id);
+            /* fall-through */
+
+        case EBML_ID_VOID:
+            res = ebml_read_skip(matroska);
+            break;
+        }
+
+        if (matroska->level_up) {
+            matroska->level_up--;
+            break;
+        }
+    }
+
+    return res;
+}
+
 #define ARRAY_SIZE(x)  (sizeof(x)/sizeof(*x))
 
 static int
@@ -1931,7 +2060,7 @@
      * after the segment ID/length. */
     if ((res = ebml_read_master(matroska, &id)) < 0)
         return res;
-    matroska->segment_start = url_ftell(&s->pb);
+    matroska->segment_start = url_ftell(s->pb);
 
     matroska->time_scale = 1000000;
     /* we've found our segment, start reading the different contents in here */
@@ -1991,6 +2120,13 @@
                 break;
             }
 
+            case MATROSKA_ID_ATTACHMENTS: {
+                if ((res = ebml_read_master(matroska, &id)) < 0)
+                    break;
+                res = matroska_parse_attachments(s);
+                break;
+            }
+
             case MATROSKA_ID_CLUSTER: {
                 /* Do not read the master - this will be done in the next
                  * call to matroska_read_packet. */
@@ -2032,7 +2168,7 @@
             if (track->codec_id == NULL)
                 continue;
 
-            for(j=0; ff_mkv_codec_tags[j].str; j++){
+            for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){
                 if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,
                             strlen(ff_mkv_codec_tags[j].str))){
                     codec_id= ff_mkv_codec_tags[j].id;
@@ -2098,7 +2234,7 @@
                     return AVERROR(ENOMEM);
                 init_put_byte(&b, extradata, extradata_size, 1,
                               NULL, NULL, NULL, NULL);
-                put_buffer(&b, (uint8_t *) "TTA1", 4);
+                put_buffer(&b, "TTA1", 4);
                 put_le16(&b, 1);
                 put_le16(&b, audiotrack->channels);
                 put_le16(&b, audiotrack->bitdepth);
@@ -2110,7 +2246,6 @@
                      codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {
                 extradata_offset = 26;
                 track->codec_priv_size -= extradata_offset;
-                track->flags |= MATROSKA_TRACK_REAL_V;
             }
 
             else if (codec_id == CODEC_ID_RA_144) {
@@ -2144,15 +2279,6 @@
                 }
             }
 
-            else if (codec_id == CODEC_ID_TEXT) {
-                MatroskaSubtitleTrack *subtrack=(MatroskaSubtitleTrack *)track;
-                if (!strcmp(track->codec_id, "S_TEXT/ASS") ||
-                    !strcmp(track->codec_id, "S_TEXT/SSA") ||
-                    !strcmp(track->codec_id, "S_ASS") ||
-                    !strcmp(track->codec_id, "S_SSA"))
-                    subtrack->ass = 1;
-            }
-
             if (codec_id == CODEC_ID_NONE) {
                 av_log(matroska->ctx, AV_LOG_INFO,
                        "Unknown/unsupported CodecID %s.\n",
@@ -2237,12 +2363,6 @@
     return res;
 }
 
-static inline int
-rv_offset(uint8_t *data, int slice, int slices)
-{
-    return AV_RL32(data+8*slice+4) + 8*slices;
-}
-
 static int
 matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,
                      int64_t pos, uint64_t cluster_time, uint64_t duration,
@@ -2275,8 +2395,10 @@
         av_free(origdata);
         return res;
     }
-    if (matroska->tracks[track]->stream_index < 0)
+    if (matroska->tracks[track]->stream_index < 0) {
+        av_free(origdata);
         return res;
+    }
     st = matroska->ctx->streams[matroska->tracks[track]->stream_index];
     if (st->discard >= AVDISCARD_ALL) {
         av_free(origdata);
@@ -2294,8 +2416,10 @@
         is_keyframe = flags & 0x80 ? PKT_FLAG_KEY : 0;
 
     if (matroska->skip_to_keyframe) {
-        if (!is_keyframe || st != matroska->skip_to_stream)
+        if (!is_keyframe || st != matroska->skip_to_stream) {
+            av_free(origdata);
             return res;
+        }
         matroska->skip_to_keyframe = 0;
     }
 
@@ -2379,7 +2503,6 @@
     }
 
     if (res == 0) {
-        int real_v = matroska->tracks[track]->flags & MATROSKA_TRACK_REAL_V;
         uint64_t timecode = AV_NOPTS_VALUE;
 
         if (cluster_time != (uint64_t)-1
@@ -2387,91 +2510,66 @@
             timecode = cluster_time + block_time;
 
         for (n = 0; n < laces; n++) {
-            int slice, slices = 1;
-
-            if (real_v) {
-                slices = *data++ + 1;
-                lace_size[n]--;
-            }
-
-            for (slice=0; slice<slices; slice++) {
-                int slice_size, slice_offset = 0;
-                if (real_v)
-                    slice_offset = rv_offset(data, slice, slices);
-                if (slice+1 == slices)
-                    slice_size = lace_size[n] - slice_offset;
-                else
-                    slice_size = rv_offset(data, slice+1, slices) - slice_offset;
-
-                if (st->codec->codec_id == CODEC_ID_RA_288 ||
-                    st->codec->codec_id == CODEC_ID_COOK ||
-                    st->codec->codec_id == CODEC_ID_ATRAC3) {
-                    MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];
-                    int a = st->codec->block_align;
-                    int sps = audiotrack->sub_packet_size;
-                    int cfs = audiotrack->coded_framesize;
-                    int h = audiotrack->sub_packet_h;
-                    int y = audiotrack->sub_packet_cnt;
-                    int w = audiotrack->frame_size;
-                    int x;
-
-                    if (!audiotrack->pkt_cnt) {
-                        if (st->codec->codec_id == CODEC_ID_RA_288)
-                            for (x=0; x<h/2; x++)
-                                memcpy(audiotrack->buf+x*2*w+y*cfs,
-                                       data+x*cfs, cfs);
-                        else
-                            for (x=0; x<w/sps; x++)
-                                memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);
-
-                        if (++audiotrack->sub_packet_cnt >= h) {
-                            audiotrack->sub_packet_cnt = 0;
-                            audiotrack->pkt_cnt = h*w / a;
-                        }
-                    }
-                    while (audiotrack->pkt_cnt) {
-                        pkt = av_mallocz(sizeof(AVPacket));
-                        av_new_packet(pkt, a);
-                        memcpy(pkt->data, audiotrack->buf
-                               + a * (h*w / a - audiotrack->pkt_cnt--), a);
-                        pkt->pos = pos;
-                        pkt->stream_index = matroska->tracks[track]->stream_index;
-                        matroska_queue_packet(matroska, pkt);
-                    }
-                } else {
-                    int offset = 0;
-
-                    if (st->codec->codec_id == CODEC_ID_TEXT
-                        && ((MatroskaSubtitleTrack *)(matroska->tracks[track]))->ass) {
-                        int i;
-                        for (i=0; i<8 && data[slice_offset+offset]; offset++)
-                            if (data[slice_offset+offset] == ',')
-                                i++;
+            if (st->codec->codec_id == CODEC_ID_RA_288 ||
+                st->codec->codec_id == CODEC_ID_COOK ||
+                st->codec->codec_id == CODEC_ID_ATRAC3) {
+                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];
+                int a = st->codec->block_align;
+                int sps = audiotrack->sub_packet_size;
+                int cfs = audiotrack->coded_framesize;
+                int h = audiotrack->sub_packet_h;
+                int y = audiotrack->sub_packet_cnt;
+                int w = audiotrack->frame_size;
+                int x;
+
+                if (!audiotrack->pkt_cnt) {
+                    if (st->codec->codec_id == CODEC_ID_RA_288)
+                        for (x=0; x<h/2; x++)
+                            memcpy(audiotrack->buf+x*2*w+y*cfs,
+                                   data+x*cfs, cfs);
+                    else
+                        for (x=0; x<w/sps; x++)
+                            memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);
+
+                    if (++audiotrack->sub_packet_cnt >= h) {
+                        audiotrack->sub_packet_cnt = 0;
+                        audiotrack->pkt_cnt = h*w / a;
                     }
-
+                }
+                while (audiotrack->pkt_cnt) {
                     pkt = av_mallocz(sizeof(AVPacket));
-                    /* XXX: prevent data copy... */
-                    if (av_new_packet(pkt, slice_size-offset) < 0) {
-                        res = AVERROR(ENOMEM);
-                        n = laces-1;
-                        break;
-                    }
-                    memcpy (pkt->data, data+slice_offset+offset, slice_size-offset);
-
-                    if (n == 0)
-                        pkt->flags = is_keyframe;
-                    pkt->stream_index = matroska->tracks[track]->stream_index;
-
-                    pkt->pts = timecode;
+                    av_new_packet(pkt, a);
+                    memcpy(pkt->data, audiotrack->buf
+                           + a * (h*w / a - audiotrack->pkt_cnt--), a);
                     pkt->pos = pos;
-                    pkt->duration = duration;
-
+                    pkt->stream_index = matroska->tracks[track]->stream_index;
                     matroska_queue_packet(matroska, pkt);
                 }
+            } else {
+                int offset = 0;
+
+                pkt = av_mallocz(sizeof(AVPacket));
+                /* XXX: prevent data copy... */
+                if (av_new_packet(pkt, lace_size[n]-offset) < 0) {
+                    res = AVERROR(ENOMEM);
+                    n = laces-1;
+                    break;
+                }
+                memcpy (pkt->data, data+offset, lace_size[n]-offset);
+
+                if (n == 0)
+                    pkt->flags = is_keyframe;
+                pkt->stream_index = matroska->tracks[track]->stream_index;
 
-                if (timecode != AV_NOPTS_VALUE)
-                    timecode = duration ? timecode + duration : AV_NOPTS_VALUE;
+                pkt->pts = timecode;
+                pkt->pos = pos;
+                pkt->duration = duration;
+
+                matroska_queue_packet(matroska, pkt);
             }
+
+            if (timecode != AV_NOPTS_VALUE)
+                timecode = duration ? timecode + duration : AV_NOPTS_VALUE;
             data += lace_size[n];
         }
     }
@@ -2510,7 +2608,7 @@
              * of the harder things, so this code is a bit complicated.
              * See http://www.matroska.org/ for documentation. */
             case MATROSKA_ID_BLOCK: {
-                pos = url_ftell(&matroska->ctx->pb);
+                pos = url_ftell(matroska->ctx->pb);
                 res = ebml_read_binary(matroska, &id, &data, &size);
                 break;
             }
@@ -2572,7 +2670,7 @@
     int size;
 
     av_log(matroska->ctx, AV_LOG_DEBUG,
-           "parsing cluster at %"PRId64"\n", url_ftell(&matroska->ctx->pb));
+           "parsing cluster at %"PRId64"\n", url_ftell(matroska->ctx->pb));
 
     while (res == 0) {
         if (!(id = ebml_peek_id(matroska, &matroska->level_up))) {
@@ -2601,7 +2699,7 @@
                 break;
 
             case MATROSKA_ID_SIMPLEBLOCK:
-                pos = url_ftell(&matroska->ctx->pb);
+                pos = url_ftell(matroska->ctx->pb);
                 res = ebml_read_binary(matroska, &id, &data, &size);
                 if (res == 0)
                     res = matroska_parse_block(matroska, data, size, pos,
@@ -2692,11 +2790,12 @@
     if (index < 0)
         return 0;
 
+    matroska_clear_queue(matroska);
+
     /* do the seek */
-    url_fseek(&s->pb, st->index_entries[index].pos, SEEK_SET);
+    url_fseek(s->pb, st->index_entries[index].pos, SEEK_SET);
     matroska->skip_to_keyframe = !(flags & AVSEEK_FLAG_ANY);
     matroska->skip_to_stream = st;
-    matroska->num_packets = 0;
     matroska->peek_id = 0;
     return 0;
 }
@@ -2711,13 +2810,7 @@
     av_free(matroska->muxing_app);
     av_free(matroska->index);
 
-    if (matroska->packets != NULL) {
-        for (n = 0; n < matroska->num_packets; n++) {
-            av_free_packet(matroska->packets[n]);
-            av_free(matroska->packets[n]);
-        }
-        av_free(matroska->packets);
-    }
+    matroska_clear_queue(matroska);
 
     for (n = 0; n < matroska->num_tracks; n++) {
         MatroskaTrack *track = matroska->tracks[n];
diff -u mplayer-1.0~rc2-12/libavformat/matroskaenc.c ffmpeg-free-0.svn20080206/libavformat/matroskaenc.c
--- mplayer-1.0~rc2-12/libavformat/matroskaenc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/matroskaenc.c	2008-01-12 01:15:05.000000000 +0100
@@ -24,6 +24,7 @@
 #include "riff.h"
 #include "xiph.h"
 #include "matroska.h"
+#include "avc.h"
 
 typedef struct ebml_master {
     offset_t        pos;                ///< absolute offset in the file where the master's elements start
@@ -196,7 +197,8 @@
         put_ebml_num(pb, size-1, 0);
     else
         put_ebml_num(pb, size-9, 8);
-    url_fseek(pb, currentpos + size, SEEK_SET);
+    while(url_ftell(pb) < currentpos + size)
+        put_byte(pb, 0);
 }
 
 static ebml_master start_ebml_master(ByteIOContext *pb, unsigned int elementid, uint64_t expectedsize)
@@ -466,19 +468,23 @@
 
 static int mkv_write_codecprivate(AVFormatContext *s, ByteIOContext *pb, AVCodecContext *codec, int native_id)
 {
-    ByteIOContext dyn_cp;
+    ByteIOContext *dyn_cp;
     uint8_t *codecpriv;
-    int ret = 0, codecpriv_size;
+    int ret, codecpriv_size;
 
-    url_open_dyn_buf(&dyn_cp);
+    ret = url_open_dyn_buf(&dyn_cp);
+    if(ret < 0)
+        return ret;
 
     if (native_id) {
         if (codec->codec_id == CODEC_ID_VORBIS || codec->codec_id == CODEC_ID_THEORA)
-            ret = put_xiph_codecpriv(s, &dyn_cp, codec);
+            ret = put_xiph_codecpriv(s, dyn_cp, codec);
         else if (codec->codec_id == CODEC_ID_FLAC)
-            ret = put_flac_codecpriv(s, &dyn_cp, codec);
+            ret = put_flac_codecpriv(s, dyn_cp, codec);
+        else if (codec->codec_id == CODEC_ID_H264)
+            ret = ff_isom_write_avcc(dyn_cp, codec->extradata, codec->extradata_size);
         else if (codec->extradata_size)
-            put_buffer(&dyn_cp, codec->extradata, codec->extradata_size);
+            put_buffer(dyn_cp, codec->extradata, codec->extradata_size);
     } else if (codec->codec_type == CODEC_TYPE_VIDEO) {
         if (!codec->codec_tag)
             codec->codec_tag = codec_get_tag(codec_bmp_tags, codec->codec_id);
@@ -487,7 +493,7 @@
             ret = -1;
         }
 
-        put_bmp_header(&dyn_cp, codec, codec_bmp_tags, 0);
+        put_bmp_header(dyn_cp, codec, codec_bmp_tags, 0);
 
     } else if (codec->codec_type == CODEC_TYPE_AUDIO) {
         if (!codec->codec_tag)
@@ -497,10 +503,10 @@
             ret = -1;
         }
 
-        put_wav_header(&dyn_cp, codec);
+        put_wav_header(dyn_cp, codec);
     }
 
-    codecpriv_size = url_close_dyn_buf(&dyn_cp, &codecpriv);
+    codecpriv_size = url_close_dyn_buf(dyn_cp, &codecpriv);
     if (codecpriv_size)
         put_ebml_binary(pb, MATROSKA_ID_CODECPRIVATE, codecpriv, codecpriv_size);
     av_free(codecpriv);
@@ -510,7 +516,7 @@
 static int mkv_write_tracks(AVFormatContext *s)
 {
     MatroskaMuxContext *mkv = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     ebml_master tracks;
     int i, j, ret;
 
@@ -613,7 +619,7 @@
 static int mkv_write_header(AVFormatContext *s)
 {
     MatroskaMuxContext *mkv = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     ebml_master ebml_header, segment_info;
     int ret;
 
@@ -703,7 +709,7 @@
 static void mkv_write_block(AVFormatContext *s, unsigned int blockid, AVPacket *pkt, int flags)
 {
     MatroskaMuxContext *mkv = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
 
     av_log(s, AV_LOG_DEBUG, "Writing block at offset %" PRIu64 ", size %d, "
            "pts %" PRId64 ", dts %" PRId64 ", duration %d, flags %d\n",
@@ -719,7 +725,7 @@
 static int mkv_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
     MatroskaMuxContext *mkv = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVCodecContext *codec = s->streams[pkt->stream_index]->codec;
     int keyframe = !!(pkt->flags & PKT_FLAG_KEY);
     int ret;
@@ -740,6 +746,16 @@
         av_md5_update(mkv->md5_ctx, pkt->data, FFMIN(200, pkt->size));
     }
 
+    if (codec->codec_id == CODEC_ID_H264 &&
+        codec->extradata_size > 0 && AV_RB32(codec->extradata) == 0x00000001) {
+        /* from x264 or from bytestream h264 */
+        /* nal reformating needed */
+        int ret = ff_avc_parse_nal_units(pkt->data, &pkt->data, &pkt->size);
+        if (ret < 0)
+            return ret;
+        assert(pkt->size);
+    }
+
     if (codec->codec_type != CODEC_TYPE_SUBTITLE) {
         mkv_write_block(s, MATROSKA_ID_SIMPLEBLOCK, pkt, keyframe << 7);
     } else {
@@ -761,7 +777,7 @@
 static int mkv_write_trailer(AVFormatContext *s)
 {
     MatroskaMuxContext *mkv = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     offset_t currentpos, second_seekhead, cuespos;
     int ret;
 
diff -u mplayer-1.0~rc2-12/libavformat/matroska.h ffmpeg-free-0.svn20080206/libavformat/matroska.h
--- mplayer-1.0~rc2-12/libavformat/matroska.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/matroska.h	2008-01-27 16:43:17.000000000 +0100
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef MATROSKA_H
-#define MATROSKA_H
+#ifndef FFMPEG_MATROSKA_H
+#define FFMPEG_MATROSKA_H
 
 #include "avcodec.h"
 
@@ -55,6 +55,7 @@
 #define MATROSKA_ID_CUES       0x1C53BB6B
 #define MATROSKA_ID_TAGS       0x1254C367
 #define MATROSKA_ID_SEEKHEAD   0x114D9B74
+#define MATROSKA_ID_ATTACHMENTS 0x1941A469
 #define MATROSKA_ID_CLUSTER    0x1F43B675
 
 /* IDs in the info master */
@@ -98,7 +99,7 @@
 #define MATROSKA_ID_VIDEOFLAGINTERLACED 0x9A
 #define MATROSKA_ID_VIDEOSTEREOMODE 0x53B9
 #define MATROSKA_ID_VIDEOASPECTRATIO 0x54B3
-#define MATROSKA_ID_VIDEOCOLOURSPACE 0x2EB524
+#define MATROSKA_ID_VIDEOCOLORSPACE 0x2EB524
 
 /* IDs in the trackaudio master */
 #define MATROSKA_ID_AUDIOSAMPLINGFREQ 0xB5
@@ -138,6 +139,13 @@
 #define MATROSKA_ID_BLOCKDURATION 0x9B
 #define MATROSKA_ID_BLOCKREFERENCE 0xFB
 
+/* IDs in the attachments master */
+#define MATROSKA_ID_ATTACHEDFILE        0x61A7
+#define MATROSKA_ID_FILENAME            0x466E
+#define MATROSKA_ID_FILEMIMETYPE        0x4660
+#define MATROSKA_ID_FILEDATA            0x465C
+#define MATROSKA_ID_FILEUID             0x46AE
+
 typedef enum {
   MATROSKA_TRACK_TYPE_VIDEO    = 0x1,
   MATROSKA_TRACK_TYPE_AUDIO    = 0x2,
@@ -169,7 +177,6 @@
   MATROSKA_TRACK_ENABLED = (1<<0),
   MATROSKA_TRACK_DEFAULT = (1<<1),
   MATROSKA_TRACK_LACING  = (1<<2),
-  MATROSKA_TRACK_REAL_V  = (1<<4),
   MATROSKA_TRACK_SHIFT   = (1<<16)
 } MatroskaTrackFlags;
 
@@ -182,16 +189,22 @@
  */
 
 typedef struct CodecTags{
-    const char *str;
+    char str[16];
     enum CodecID id;
 }CodecTags;
 
+typedef struct CodecMime{
+    char str[32];
+    enum CodecID id;
+}CodecMime;
+
 #define MATROSKA_CODEC_ID_VIDEO_VFW_FOURCC   "V_MS/VFW/FOURCC"
 #define MATROSKA_CODEC_ID_AUDIO_ACM          "A_MS/ACM"
 
 /* max. depth in the EBML tree structure */
 #define EBML_MAX_DEPTH 16
 
-extern CodecTags ff_mkv_codec_tags[];
+extern const CodecTags ff_mkv_codec_tags[];
+extern const CodecMime ff_mkv_mime_tags[];
 
-#endif /* MATROSKA_H */
+#endif /* FFMPEG_MATROSKA_H */
diff -u mplayer-1.0~rc2-12/libavformat/mm.c ffmpeg-free-0.svn20080206/libavformat/mm.c
--- mplayer-1.0~rc2-12/libavformat/mm.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mm.c	2007-11-21 08:41:00.000000000 +0100
@@ -72,7 +72,7 @@
                            AVFormatParameters *ap)
 {
     MmDemuxContext *mm = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st;
 
     unsigned int type, length;
@@ -127,7 +127,7 @@
                            AVPacket *pkt)
 {
     MmDemuxContext *mm = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     unsigned char preamble[MM_PREAMBLE_SIZE];
     unsigned char pal[MM_PALETTE_SIZE];
     unsigned int type, length;
@@ -178,7 +178,7 @@
             return 0;
 
         case MM_TYPE_AUDIO :
-            if (av_get_packet(&s->pb, pkt, length)<0)
+            if (av_get_packet(s->pb, pkt, length)<0)
                 return AVERROR(ENOMEM);
             pkt->size = length;
             pkt->stream_index = 1;
diff -u mplayer-1.0~rc2-12/libavformat/mmf.c ffmpeg-free-0.svn20080206/libavformat/mmf.c
--- mplayer-1.0~rc2-12/libavformat/mmf.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mmf.c	2007-11-21 08:41:00.000000000 +0100
@@ -60,7 +60,7 @@
 static int mmf_write_header(AVFormatContext *s)
 {
     MMFContext *mmf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     offset_t pos;
     int rate;
 
@@ -108,7 +108,7 @@
 
 static int mmf_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     put_buffer(pb, pkt->data, pkt->size);
     return 0;
 }
@@ -127,12 +127,12 @@
 
 static int mmf_write_trailer(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     MMFContext *mmf = s->priv_data;
     offset_t pos, size;
     int gatetime;
 
-    if (!url_is_streamed(&s->pb)) {
+    if (!url_is_streamed(s->pb)) {
         /* Fill in length fields */
         end_tag_be(pb, mmf->awapos);
         end_tag_be(pb, mmf->atrpos);
@@ -183,7 +183,7 @@
 {
     MMFContext *mmf = s->priv_data;
     unsigned int tag;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st;
     offset_t file_size, size;
     int rate, params;
@@ -265,7 +265,7 @@
     AVStream *st;
     int ret, size;
 
-    if (url_feof(&s->pb))
+    if (url_feof(s->pb))
         return AVERROR(EIO);
     st = s->streams[0];
 
@@ -280,7 +280,7 @@
         return AVERROR(EIO);
     pkt->stream_index = 0;
 
-    ret = get_buffer(&s->pb, pkt->data, pkt->size);
+    ret = get_buffer(s->pb, pkt->data, pkt->size);
     if (ret < 0)
         av_free_packet(pkt);
 
diff -u mplayer-1.0~rc2-12/libavformat/mov.c ffmpeg-free-0.svn20080206/libavformat/mov.c
--- mplayer-1.0~rc2-12/libavformat/mov.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mov.c	2008-01-27 20:57:04.000000000 +0100
@@ -107,6 +107,7 @@
     unsigned int bytes_per_frame;
     unsigned int samples_per_frame;
     int dv_audio_container;
+    int pseudo_stream_id;
 } MOVStreamContext;
 
 typedef struct MOVContext {
@@ -115,13 +116,6 @@
     int64_t duration; /* duration of the longest track */
     int found_moov; /* when both 'moov' and 'mdat' sections has been found */
     int found_mdat; /* we suppose we have enough data to read the file */
-    int64_t mdat_offset;
-    int total_streams;
-    MOVStreamContext *streams[MAX_STREAMS];
-
-    const struct MOVParseTableEntry *parse_table; /* could be eventually used to change the table */
-    /* NOTE: for recursion save to/ restore from local variable! */
-
     AVPaletteControl palette_control;
     MOV_mdat_t *mdat_list;
     int mdat_count;
@@ -139,14 +133,14 @@
  0: continue to parse next atom
  -1: error occured, exit
  */
-typedef int (*mov_parse_function)(MOVContext *ctx, ByteIOContext *pb, MOV_atom_t atom);
-
 /* links atom IDs to parse functions */
 typedef struct MOVParseTableEntry {
     uint32_t type;
-    mov_parse_function func;
+    int (*parse)(MOVContext *ctx, ByteIOContext *pb, MOV_atom_t atom);
 } MOVParseTableEntry;
 
+static const MOVParseTableEntry mov_default_parse_table[];
+
 static int mov_read_default(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     int64_t total_size = 0;
@@ -160,14 +154,15 @@
         atom.size = INT64_MAX;
     while(((total_size + 8) < atom.size) && !url_feof(pb) && !err) {
         a.size = atom.size;
-        a.type=0L;
+        a.type=0;
         if(atom.size >= 8) {
             a.size = get_be32(pb);
             a.type = get_le32(pb);
         }
         total_size += 8;
         a.offset += 8;
-        dprintf(c->fc, "type: %08x  %.4s  sz: %"PRIx64"  %"PRIx64"   %"PRIx64"\n", a.type, (char*)&a.type, a.size, atom.size, total_size);
+        dprintf(c->fc, "type: %08x  %.4s  sz: %"PRIx64"  %"PRIx64"   %"PRIx64"\n",
+                a.type, (char*)&a.type, a.size, atom.size, total_size);
         if (a.size == 1) { /* 64 bit extended size */
             a.size = get_be64(pb) - 8;
             a.offset += 8;
@@ -179,19 +174,22 @@
                 break;
         }
         a.size -= 8;
-        if(a.size < 0 || a.size > atom.size - total_size)
+        if(a.size < 0)
             break;
+        a.size = FFMIN(a.size, atom.size - total_size);
 
-        for (i = 0; c->parse_table[i].type != 0L
-             && c->parse_table[i].type != a.type; i++)
+        for (i = 0; mov_default_parse_table[i].type != 0
+             && mov_default_parse_table[i].type != a.type; i++)
             /* empty */;
 
-        if (c->parse_table[i].type == 0) { /* skip leaf atoms data */
+        if (mov_default_parse_table[i].type == 0) { /* skip leaf atoms data */
             url_fskip(pb, a.size);
         } else {
             offset_t start_pos = url_ftell(pb);
             int64_t left;
-            err = (c->parse_table[i].func)(c, pb, a);
+            err = mov_default_parse_table[i].parse(c, pb, a);
+            if (c->found_moov && c->found_mdat)
+                break;
             left = a.size - url_ftell(pb) + start_pos;
             if (left > 0) /* skip garbage at atom end */
                 url_fskip(pb, left);
@@ -221,8 +219,10 @@
     ctype = get_le32(pb);
     type = get_le32(pb); /* component subtype */
 
-    dprintf(c->fc, "ctype= %c%c%c%c (0x%08x)\n", *((char *)&ctype), ((char *)&ctype)[1], ((char *)&ctype)[2], ((char *)&ctype)[3], (int) ctype);
-    dprintf(c->fc, "stype= %c%c%c%c\n", *((char *)&type), ((char *)&type)[1], ((char *)&type)[2], ((char *)&type)[3]);
+    dprintf(c->fc, "ctype= %c%c%c%c (0x%08x)\n", *((char *)&ctype), ((char *)&ctype)[1],
+            ((char *)&ctype)[2], ((char *)&ctype)[3], (int) ctype);
+    dprintf(c->fc, "stype= %c%c%c%c\n",
+            *((char *)&type), ((char *)&type)[1], ((char *)&type)[2], ((char *)&type)[3]);
     if(!ctype)
         c->isom = 1;
     if(type == MKTAG('v', 'i', 'd', 'e'))
@@ -233,7 +233,6 @@
         st->codec->codec_id = CODEC_ID_MP2;
     else if(type == MKTAG('s', 'u', 'b', 'p')) {
         st->codec->codec_type = CODEC_TYPE_SUBTITLE;
-        st->codec->codec_id = CODEC_ID_DVD_SUBTITLE;
     }
     get_be32(pb); /* component  manufacture */
     get_be32(pb); /* component flags */
@@ -322,7 +321,6 @@
     c->mdat_list[c->mdat_count].size = atom.size;
     c->mdat_count++;
     c->found_mdat=1;
-    c->mdat_offset = atom.offset;
     if(c->found_moov)
         return 1; /* found both, just go */
     url_fskip(pb, atom.size);
@@ -344,9 +342,8 @@
 /* this atom should contain all header atoms */
 static int mov_read_moov(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
-    int err;
-
-    err = mov_read_default(c, pb, atom);
+    if (mov_read_default(c, pb, atom) < 0)
+        return -1;
     /* we parsed the 'moov' atom, we can terminate the parsing as soon as we find the 'mdat' */
     /* so we don't parse the whole file if over a network */
     c->found_moov=1;
@@ -470,16 +467,19 @@
 static int mov_read_extradata(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c->fc->streams[c->fc->nb_streams-1];
-    if((uint64_t)atom.size > (1<<30))
-        return -1;
-    av_free(st->codec->extradata);
-    st->codec->extradata_size = atom.size + 8;
-    st->codec->extradata = av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
-    if (st->codec->extradata) {
-        AV_WL32(st->codec->extradata + 4, atom.type);
-        get_buffer(pb, st->codec->extradata + 8, atom.size);
-    } else
-        url_fskip(pb, atom.size);
+    uint64_t size= (uint64_t)st->codec->extradata_size + atom.size + 8 + FF_INPUT_BUFFER_PADDING_SIZE;
+    uint8_t *buf;
+    if(size > INT_MAX || (uint64_t)atom.size > INT_MAX)
+        return -1;
+    buf= av_realloc(st->codec->extradata, size);
+    if(!buf)
+        return -1;
+    st->codec->extradata= buf;
+    buf+= st->codec->extradata_size;
+    st->codec->extradata_size= size - FF_INPUT_BUFFER_PADDING_SIZE;
+    AV_WB32(       buf    , atom.size + 8);
+    AV_WL32(       buf + 4, atom.type);
+    get_buffer(pb, buf + 8, atom.size);
     return 0;
 }
 
@@ -501,13 +501,18 @@
         } else
             url_fskip(pb, atom.size);
     } else if (atom.size > 8) { /* to read frma, esds atoms */
-        mov_read_default(c, pb, atom);
+        if (mov_read_default(c, pb, atom) < 0)
+            return -1;
     } else
         url_fskip(pb, atom.size);
     return 0;
 }
 
-static int mov_read_avcC(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
+/**
+ * This function reads atom content and puts data in extradata without tag
+ * nor size unlike mov_read_extradata.
+ */
+static int mov_read_glbl(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c->fc->streams[c->fc->nb_streams-1];
 
@@ -568,15 +573,15 @@
     uint8_t codec_name[32];
 
     /* for palette traversal */
-    int color_depth;
-    int color_start;
-    int color_count;
-    int color_end;
+    unsigned int color_depth;
+    unsigned int color_start;
+    unsigned int color_count;
+    unsigned int color_end;
     int color_index;
     int color_dec;
     int color_greyscale;
-    unsigned char *color_table;
-    int j;
+    const uint8_t *color_table;
+    int j, pseudo_stream_id;
     unsigned char r, g, b;
 
     get_byte(pb); /* version */
@@ -584,7 +589,7 @@
 
     entries = get_be32(pb);
 
-    while(entries--) { //Parsing Sample description table
+    for(pseudo_stream_id=0; pseudo_stream_id<entries; pseudo_stream_id++) { //Parsing Sample description table
         enum CodecID id;
         MOV_atom_t a = { 0, 0, 0 };
         offset_t start_pos = url_ftell(pb);
@@ -595,11 +600,14 @@
         get_be16(pb); /* reserved */
         get_be16(pb); /* index */
 
-        if (st->codec->codec_tag) {
-            /* multiple fourcc, just skip for now */
+        if (st->codec->codec_tag && st->codec->codec_tag != MKTAG('j', 'p', 'e', 'g')) {
+            /* multiple fourcc, we skip jpeg, this isnt correct, we should export it as
+               seperate AVStream but this needs a few changes in the mov demuxer, patch
+               welcome */
             url_fskip(pb, size - (url_ftell(pb) - start_pos));
             continue;
         }
+        sc->pseudo_stream_id= pseudo_stream_id;
 
         st->codec->codec_tag = format;
         id = codec_get_id(codec_movaudio_tags, format);
@@ -615,12 +623,16 @@
                 id = codec_get_id(codec_bmp_tags, format);
             if (id > 0)
                 st->codec->codec_type = CODEC_TYPE_VIDEO;
+            else if(st->codec->codec_type == CODEC_TYPE_DATA){
+                id = codec_get_id(ff_codec_movsubtitle_tags, format);
+                if(id > 0)
+                    st->codec->codec_type = CODEC_TYPE_SUBTITLE;
+            }
         }
 
-        dprintf(c->fc, "size=%d 4CC= %c%c%c%c codec_type=%d\n",
-                size,
-                (format >> 0) & 0xff, (format >> 8) & 0xff, (format >> 16) & 0xff, (format >> 24) & 0xff,
-                st->codec->codec_type);
+        dprintf(c->fc, "size=%d 4CC= %c%c%c%c codec_type=%d\n", size,
+                (format >> 0) & 0xff, (format >> 8) & 0xff, (format >> 16) & 0xff,
+                (format >> 24) & 0xff, st->codec->codec_type);
 
         if(st->codec->codec_type==CODEC_TYPE_VIDEO) {
             st->codec->codec_id = id;
@@ -628,7 +640,7 @@
             get_be16(pb); /* revision level */
             get_be32(pb); /* vendor */
             get_be32(pb); /* temporal quality */
-            get_be32(pb); /* spacial quality */
+            get_be32(pb); /* spatial quality */
 
             st->codec->width = get_be16(pb); /* width */
             st->codec->height = get_be16(pb); /* height */
@@ -656,9 +668,7 @@
             /* if the depth is 2, 4, or 8 bpp, file is palettized */
             if ((color_depth == 2) || (color_depth == 4) ||
                 (color_depth == 8)) {
-
                 if (color_greyscale) {
-
                     /* compute the greyscale palette */
                     color_count = 1 << color_depth;
                     color_index = 255;
@@ -671,9 +681,7 @@
                         if (color_index < 0)
                             color_index = 0;
                     }
-
                 } else if (st->codec->color_table_id & 0x08) {
-
                     /* if flag bit 3 is set, use the default palette */
                     color_count = 1 << color_depth;
                     if (color_depth == 2)
@@ -690,30 +698,30 @@
                         c->palette_control.palette[j] =
                             (r << 16) | (g << 8) | (b);
                     }
-
                 } else {
-
                     /* load the palette from the file */
                     color_start = get_be32(pb);
                     color_count = get_be16(pb);
                     color_end = get_be16(pb);
-                    for (j = color_start; j <= color_end; j++) {
-                        /* each R, G, or B component is 16 bits;
-                         * only use the top 8 bits; skip alpha bytes
-                         * up front */
-                        get_byte(pb);
-                        get_byte(pb);
-                        r = get_byte(pb);
-                        get_byte(pb);
-                        g = get_byte(pb);
-                        get_byte(pb);
-                        b = get_byte(pb);
-                        get_byte(pb);
-                        c->palette_control.palette[j] =
-                            (r << 16) | (g << 8) | (b);
+                    if ((color_start <= 255) &&
+                        (color_end <= 255)) {
+                        for (j = color_start; j <= color_end; j++) {
+                            /* each R, G, or B component is 16 bits;
+                             * only use the top 8 bits; skip alpha bytes
+                             * up front */
+                            get_byte(pb);
+                            get_byte(pb);
+                            r = get_byte(pb);
+                            get_byte(pb);
+                            g = get_byte(pb);
+                            get_byte(pb);
+                            b = get_byte(pb);
+                            get_byte(pb);
+                            c->palette_control.palette[j] =
+                                (r << 16) | (g << 8) | (b);
+                        }
                     }
                 }
-
                 st->codec->palctrl = &c->palette_control;
                 st->codec->palctrl->palette_changed = 1;
             } else
@@ -779,15 +787,18 @@
                 st->codec->bits_per_sample = bits_per_sample;
                 sc->sample_size = (bits_per_sample >> 3) * st->codec->channels;
             }
+        } else if(st->codec->codec_type==CODEC_TYPE_SUBTITLE){
+            st->codec->codec_id= id;
         } else {
             /* other codec type, just skip (rtp, mp4s, tmcd ...) */
             url_fskip(pb, size - (url_ftell(pb) - start_pos));
         }
         /* this will read extra atoms at the end (wave, alac, damr, avcC, SMI ...) */
         a.size = size - (url_ftell(pb) - start_pos);
-        if (a.size > 8)
-            mov_read_default(c, pb, a);
-        else if (a.size > 0)
+        if (a.size > 8) {
+            if (mov_read_default(c, pb, a) < 0)
+                return -1;
+        } else if (a.size > 0)
             url_fskip(pb, a.size);
     }
 
@@ -959,7 +970,8 @@
 
     sc->stts_count = entries;
     sc->stts_data = av_malloc(entries * sizeof(MOV_stts_t));
-
+    if (!sc->stts_data)
+        return -1;
     dprintf(c->fc, "track[%i].stts.entries = %i\n", c->fc->nb_streams-1, entries);
 
     sc->time_rate=0;
@@ -1001,7 +1013,8 @@
 
     sc->ctts_count = entries;
     sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t));
-
+    if (!sc->ctts_data)
+        return -1;
     dprintf(c->fc, "track[%i].ctts.entries = %i\n", c->fc->nb_streams-1, entries);
 
     for(i=0; i<entries; i++) {
@@ -1038,7 +1051,6 @@
     st->priv_data = sc;
     st->codec->codec_type = CODEC_TYPE_DATA;
     st->start_time = 0; /* XXX: check */
-    c->streams[c->fc->nb_streams-1] = sc;
 
     return mov_read_default(c, pb, atom);
 }
@@ -1206,18 +1218,19 @@
 /* edit list atom */
 static int mov_read_elst(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
+    MOVStreamContext *sc = c->fc->streams[c->fc->nb_streams-1]->priv_data;
     int i, edit_count;
 
     get_byte(pb); /* version */
     get_byte(pb); get_byte(pb); get_byte(pb); /* flags */
-    edit_count= c->streams[c->fc->nb_streams-1]->edit_count = get_be32(pb);     /* entries */
+    edit_count= sc->edit_count = get_be32(pb);     /* entries */
 
     for(i=0; i<edit_count; i++){
         get_be32(pb); /* Track duration */
         get_be32(pb); /* Media time */
         get_be32(pb); /* Media rate */
     }
-    dprintf(c->fc, "track[%i].edit_count = %i\n", c->fc->nb_streams-1, c->streams[c->fc->nb_streams-1]->edit_count);
+    dprintf(c->fc, "track[%i].edit_count = %i\n", c->fc->nb_streams-1, sc->edit_count);
     return 0;
 }
 
@@ -1230,6 +1243,7 @@
 { MKTAG( 'e', 'n', 'd', 'a' ), mov_read_enda },
 { MKTAG( 'f', 'i', 'e', 'l' ), mov_read_extradata },
 { MKTAG( 'f', 't', 'y', 'p' ), mov_read_ftyp },
+{ MKTAG( 'g', 'l', 'b', 'l' ), mov_read_glbl },
 { MKTAG( 'h', 'd', 'l', 'r' ), mov_read_hdlr },
 { MKTAG( 'j', 'p', '2', 'h' ), mov_read_extradata },
 { MKTAG( 'm', 'd', 'a', 't' ), mov_read_mdat },
@@ -1240,7 +1254,7 @@
 { MKTAG( 'm', 'v', 'h', 'd' ), mov_read_mvhd },
 { MKTAG( 'S', 'M', 'I', ' ' ), mov_read_smi }, /* Sorenson extension ??? */
 { MKTAG( 'a', 'l', 'a', 'c' ), mov_read_extradata }, /* alac specific atom */
-{ MKTAG( 'a', 'v', 'c', 'C' ), mov_read_avcC },
+{ MKTAG( 'a', 'v', 'c', 'C' ), mov_read_glbl },
 { MKTAG( 's', 't', 'b', 'l' ), mov_read_default },
 { MKTAG( 's', 't', 'c', 'o' ), mov_read_stco },
 { MKTAG( 's', 't', 's', 'c' ), mov_read_stsc },
@@ -1255,7 +1269,7 @@
 { MKTAG( 'e', 's', 'd', 's' ), mov_read_esds },
 { MKTAG( 'w', 'i', 'd', 'e' ), mov_read_wide }, /* place holder */
 { MKTAG( 'c', 'm', 'o', 'v' ), mov_read_cmov },
-{ 0L, NULL }
+{ 0, NULL }
 };
 
 /* XXX: is it sufficient ? */
@@ -1321,7 +1335,8 @@
         st->nb_frames = sc->sample_count;
         for (i = 0; i < sc->chunk_count; i++) {
             current_offset = sc->chunk_offsets[i];
-            if (stsc_index + 1 < sc->sample_to_chunk_sz && i + 1 == sc->sample_to_chunk[stsc_index + 1].first)
+            if (stsc_index + 1 < sc->sample_to_chunk_sz &&
+                i + 1 == sc->sample_to_chunk[stsc_index + 1].first)
                 stsc_index++;
             for (j = 0; j < sc->sample_to_chunk[stsc_index].count; j++) {
                 if (current_sample >= sc->sample_count) {
@@ -1335,9 +1350,12 @@
                         stss_index++;
                 }
                 sample_size = sc->sample_size > 0 ? sc->sample_size : sc->sample_sizes[current_sample];
-                dprintf(mov->fc, "AVIndex stream %d, sample %d, offset %"PRIx64", dts %"PRId64", size %d, distance %d, keyframe %d\n",
-                        st->index, current_sample, current_offset, current_dts, sample_size, distance, keyframe);
-                av_add_index_entry(st, current_offset, current_dts, sample_size, distance, keyframe ? AVINDEX_KEYFRAME : 0);
+                dprintf(mov->fc, "AVIndex stream %d, sample %d, offset %"PRIx64", dts %"PRId64", "
+                        "size %d, distance %d, keyframe %d\n", st->index, current_sample,
+                        current_offset, current_dts, sample_size, distance, keyframe);
+                if(sc->sample_to_chunk[stsc_index].id - 1 == sc->pseudo_stream_id)
+                    av_add_index_entry(st, current_offset, current_dts, sample_size, distance,
+                                    keyframe ? AVINDEX_KEYFRAME : 0);
                 current_offset += sample_size;
                 assert(sc->stts_data[stts_index].duration % sc->time_rate == 0);
                 current_dts += sc->stts_data[stts_index].duration / sc->time_rate;
@@ -1352,24 +1370,26 @@
         }
     } else { /* read whole chunk */
         unsigned int chunk_samples, chunk_size, chunk_duration;
-
         for (i = 0; i < sc->chunk_count; i++) {
             current_offset = sc->chunk_offsets[i];
-            if (stsc_index + 1 < sc->sample_to_chunk_sz && i + 1 == sc->sample_to_chunk[stsc_index + 1].first)
+            if (stsc_index + 1 < sc->sample_to_chunk_sz &&
+                i + 1 == sc->sample_to_chunk[stsc_index + 1].first)
                 stsc_index++;
             chunk_samples = sc->sample_to_chunk[stsc_index].count;
             /* get chunk size */
-            if (sc->sample_size > 1 || st->codec->codec_id == CODEC_ID_PCM_U8 || st->codec->codec_id == CODEC_ID_PCM_S8)
+            if (sc->sample_size > 1 ||
+                st->codec->codec_id == CODEC_ID_PCM_U8 || st->codec->codec_id == CODEC_ID_PCM_S8)
                 chunk_size = chunk_samples * sc->sample_size;
-            else if (sc->samples_per_frame > 0 && (chunk_samples * sc->bytes_per_frame % sc->samples_per_frame == 0))
+            else if (sc->samples_per_frame > 0 &&
+                     (chunk_samples * sc->bytes_per_frame % sc->samples_per_frame == 0))
                 chunk_size = chunk_samples * sc->bytes_per_frame / sc->samples_per_frame;
             else { /* workaround to find nearest next chunk offset */
                 chunk_size = INT_MAX;
-                for (j = 0; j < mov->total_streams; j++) {
-                    MOVStreamContext *msc = mov->streams[j];
-
+                for (j = 0; j < mov->fc->nb_streams; j++) {
+                    MOVStreamContext *msc = mov->fc->streams[j]->priv_data;
                     for (k = msc->next_chunk; k < msc->chunk_count; k++) {
-                        if (msc->chunk_offsets[k] > current_offset && msc->chunk_offsets[k] - current_offset < chunk_size) {
+                        if (msc->chunk_offsets[k] > current_offset &&
+                            msc->chunk_offsets[k] - current_offset < chunk_size) {
                             chunk_size = msc->chunk_offsets[k] - current_offset;
                             msc->next_chunk = k;
                             break;
@@ -1381,12 +1401,14 @@
                     for (j = 0; j < mov->mdat_count; j++) {
                         dprintf(mov->fc, "mdat %d, offset %"PRIx64", size %"PRId64", current offset %"PRIx64"\n",
                                 j, mov->mdat_list[j].offset, mov->mdat_list[j].size, current_offset);
-                        if (mov->mdat_list[j].offset <= current_offset && mov->mdat_list[j].offset + mov->mdat_list[j].size > current_offset)
+                        if (mov->mdat_list[j].offset <= current_offset &&
+                            mov->mdat_list[j].offset + mov->mdat_list[j].size > current_offset)
                             chunk_size = mov->mdat_list[j].offset + mov->mdat_list[j].size - current_offset;
                     }
                 assert(chunk_size != INT_MAX);
-                for (j = 0; j < mov->total_streams; j++) {
-                    mov->streams[j]->next_chunk = 0;
+                for (j = 0; j < mov->fc->nb_streams; j++) {
+                    MOVStreamContext *msc = mov->fc->streams[j]->priv_data;
+                    msc->next_chunk = 0;
                 }
             }
             av_add_index_entry(st, current_offset, current_dts, chunk_size, 0, AVINDEX_KEYFRAME);
@@ -1405,8 +1427,8 @@
                     }
                 }
             }
-            dprintf(mov->fc, "AVIndex stream %d, chunk %d, offset %"PRIx64", dts %"PRId64", size %d, duration %d\n",
-                    st->index, i, current_offset, current_dts, chunk_size, chunk_duration);
+            dprintf(mov->fc, "AVIndex stream %d, chunk %d, offset %"PRIx64", dts %"PRId64", size %d, "
+                    "duration %d\n", st->index, i, current_offset, current_dts, chunk_size, chunk_duration);
             assert(chunk_duration % sc->time_rate == 0);
             current_dts += chunk_duration / sc->time_rate;
         }
@@ -1419,12 +1441,11 @@
 static int mov_read_header(AVFormatContext *s, AVFormatParameters *ap)
 {
     MOVContext *mov = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int i, err;
     MOV_atom_t atom = { 0, 0, 0 };
 
     mov->fc = s;
-    mov->parse_table = mov_default_parse_table;
 
     if(!url_is_streamed(pb)) /* .mov and .mp4 aren't streamable anyway (only progressive download if moov is before mdat) */
         atom.size = url_fsize(pb);
@@ -1440,15 +1461,9 @@
     }
     dprintf(mov->fc, "on_parse_exit_offset=%d\n", (int) url_ftell(pb));
 
-    /* some cleanup : make sure we are on the mdat atom */
-    if(!url_is_streamed(pb) && (url_ftell(pb) != mov->mdat_offset))
-        url_fseek(pb, mov->mdat_offset, SEEK_SET);
-
-    mov->total_streams = s->nb_streams;
-
-    for(i=0; i<mov->total_streams; i++) {
-        MOVStreamContext *sc = mov->streams[i];
+    for(i=0; i<s->nb_streams; i++) {
         AVStream *st = s->streams[i];
+        MOVStreamContext *sc = st->priv_data;
         /* sanity checks */
         if(!sc->stts_count || !sc->chunk_count || !sc->sample_to_chunk_sz ||
            (!sc->sample_size && !sc->sample_count)){
@@ -1473,13 +1488,14 @@
         mov_build_index(mov, st);
     }
 
-    for(i=0; i<mov->total_streams; i++) {
+    for(i=0; i<s->nb_streams; i++) {
+        MOVStreamContext *sc = s->streams[i]->priv_data;
         /* Do not need those anymore. */
-        av_freep(&mov->streams[i]->chunk_offsets);
-        av_freep(&mov->streams[i]->sample_to_chunk);
-        av_freep(&mov->streams[i]->sample_sizes);
-        av_freep(&mov->streams[i]->keyframes);
-        av_freep(&mov->streams[i]->stts_data);
+        av_freep(&sc->chunk_offsets);
+        av_freep(&sc->sample_to_chunk);
+        av_freep(&sc->sample_sizes);
+        av_freep(&sc->keyframes);
+        av_freep(&sc->stts_data);
     }
     av_freep(&mov->mdat_list);
     return 0;
@@ -1493,15 +1509,18 @@
     int64_t best_dts = INT64_MAX;
     int i;
 
-    for (i = 0; i < mov->total_streams; i++) {
-        MOVStreamContext *msc = mov->streams[i];
-
-        if (s->streams[i]->discard != AVDISCARD_ALL && msc->current_sample < msc->sample_count) {
-            AVIndexEntry *current_sample = &s->streams[i]->index_entries[msc->current_sample];
-            int64_t dts = av_rescale(current_sample->timestamp * (int64_t)msc->time_rate, AV_TIME_BASE, msc->time_scale);
-
+    for (i = 0; i < s->nb_streams; i++) {
+        AVStream *st = s->streams[i];
+        MOVStreamContext *msc = st->priv_data;
+        if (st->discard != AVDISCARD_ALL && msc->current_sample < msc->sample_count) {
+            AVIndexEntry *current_sample = &st->index_entries[msc->current_sample];
+            int64_t dts = av_rescale(current_sample->timestamp * (int64_t)msc->time_rate,
+                                     AV_TIME_BASE, msc->time_scale);
             dprintf(s, "stream %d, sample %d, dts %"PRId64"\n", i, msc->current_sample, dts);
-            if (dts < best_dts) {
+            if (!sample || (url_is_streamed(s->pb) && current_sample->pos < sample->pos) ||
+                (!url_is_streamed(s->pb) &&
+                 ((FFABS(best_dts - dts) <= AV_TIME_BASE && current_sample->pos < sample->pos) ||
+                  (FFABS(best_dts - dts) > AV_TIME_BASE && dts < best_dts)))) {
                 sample = current_sample;
                 best_dts = dts;
                 sc = msc;
@@ -1512,8 +1531,9 @@
         return -1;
     /* must be done just before reading, to avoid infinite loop on sample */
     sc->current_sample++;
-    if (sample->pos >= url_fsize(&s->pb)) {
-        av_log(mov->fc, AV_LOG_ERROR, "stream %d, offset 0x%"PRIx64": partial file\n", sc->ffindex, sample->pos);
+    if (url_fseek(s->pb, sample->pos, SEEK_SET) != sample->pos) {
+        av_log(mov->fc, AV_LOG_ERROR, "stream %d, offset 0x%"PRIx64": partial file\n",
+               sc->ffindex, sample->pos);
         return -1;
     }
 #ifdef CONFIG_DV_DEMUXER
@@ -1522,8 +1542,7 @@
         dprintf(s, "dv audio pkt size %d\n", pkt->size);
     } else {
 #endif
-        url_fseek(&s->pb, sample->pos, SEEK_SET);
-        av_get_packet(&s->pb, pkt, sample->size);
+        av_get_packet(s->pb, pkt, sample->size);
 #ifdef CONFIG_DV_DEMUXER
         if (mov->dv_demux) {
             void *pkt_destruct_func = pkt->destruct;
@@ -1539,7 +1558,8 @@
         pkt->pts = pkt->dts + sc->ctts_data[sc->sample_to_ctime_index].duration / sc->time_rate;
         /* update ctts context */
         sc->sample_to_ctime_sample++;
-        if (sc->sample_to_ctime_index < sc->ctts_count && sc->ctts_data[sc->sample_to_ctime_index].count == sc->sample_to_ctime_sample) {
+        if (sc->sample_to_ctime_index < sc->ctts_count &&
+            sc->ctts_data[sc->sample_to_ctime_index].count == sc->sample_to_ctime_sample) {
             sc->sample_to_ctime_index++;
             sc->sample_to_ctime_sample = 0;
         }
@@ -1548,7 +1568,8 @@
     }
     pkt->flags |= sample->flags & AVINDEX_KEYFRAME ? PKT_FLAG_KEY : 0;
     pkt->pos = sample->pos;
-    dprintf(s, "stream %d, pts %"PRId64", dts %"PRId64", pos 0x%"PRIx64", duration %d\n", pkt->stream_index, pkt->pts, pkt->dts, pkt->pos, pkt->duration);
+    dprintf(s, "stream %d, pts %"PRId64", dts %"PRId64", pos 0x%"PRIx64", duration %d\n",
+            pkt->stream_index, pkt->pts, pkt->dts, pkt->pos, pkt->duration);
     return 0;
 }
 
@@ -1613,9 +1634,9 @@
 {
     int i;
     MOVContext *mov = s->priv_data;
-    for(i=0; i<mov->total_streams; i++) {
-        av_freep(&mov->streams[i]->ctts_data);
-        av_freep(&mov->streams[i]);
+    for(i=0; i<s->nb_streams; i++) {
+        MOVStreamContext *sc = s->streams[i]->priv_data;
+        av_freep(&sc->ctts_data);
     }
     if(mov->dv_demux){
         for(i=0; i<mov->dv_fctx->nb_streams; i++){
diff -u mplayer-1.0~rc2-12/libavformat/movenc.c ffmpeg-free-0.svn20080206/libavformat/movenc.c
--- mplayer-1.0~rc2-12/libavformat/movenc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/movenc.c	2008-02-04 02:06:04.000000000 +0100
@@ -23,6 +23,7 @@
 #include "riff.h"
 #include "avio.h"
 #include "isom.h"
+#include "avc.h"
 
 #undef NDEBUG
 #include <assert.h>
@@ -59,7 +60,7 @@
     int         hasBframes;
     int         language;
     int         trackID;
-    int         tag;
+    int         tag; ///< stsd fourcc
     AVCodecContext *enc;
 
     int         vosLen;
@@ -322,6 +323,14 @@
     return updateSize (pb, pos);
 }
 
+static int mov_write_glbl_tag(ByteIOContext *pb, MOVTrack* track)
+{
+    put_be32(pb, track->vosLen+8);
+    put_tag(pb, "glbl");
+    put_buffer(pb, track->vosData, track->vosLen);
+    return 8+track->vosLen;
+}
+
 static int mov_write_audio_tag(ByteIOContext *pb, MOVTrack* track)
 {
     offset_t pos = url_ftell(pb);
@@ -372,10 +381,12 @@
         track->enc->codec_id == CODEC_ID_PCM_S24LE ||
         track->enc->codec_id == CODEC_ID_PCM_S32LE))
         mov_write_wave_tag(pb, track);
-    else if(track->enc->codec_id == CODEC_ID_AAC)
+    else if(track->tag == MKTAG('m','p','4','a'))
         mov_write_esds_tag(pb, track);
     else if(track->enc->codec_id == CODEC_ID_AMR_NB)
         mov_write_amr_tag(pb, track);
+    else if(track->vosLen > 0)
+        mov_write_glbl_tag(pb, track);
 
     return updateSize (pb, pos);
 }
@@ -405,170 +416,128 @@
     return 0x15;
 }
 
-static uint8_t *avc_find_startcode( uint8_t *p, uint8_t *end )
-{
-    uint8_t *a = p + 4 - ((long)p & 3);
-
-    for( end -= 3; p < a && p < end; p++ ) {
-        if( p[0] == 0 && p[1] == 0 && p[2] == 1 )
-            return p;
-    }
-
-    for( end -= 3; p < end; p += 4 ) {
-        uint32_t x = *(uint32_t*)p;
-//      if( (x - 0x01000100) & (~x) & 0x80008000 ) // little endian
-//      if( (x - 0x00010001) & (~x) & 0x00800080 ) // big endian
-        if( (x - 0x01010101) & (~x) & 0x80808080 ) { // generic
-            if( p[1] == 0 ) {
-                if( p[0] == 0 && p[2] == 1 )
-                    return p-1;
-                if( p[2] == 0 && p[3] == 1 )
-                    return p;
-            }
-            if( p[3] == 0 ) {
-                if( p[2] == 0 && p[4] == 1 )
-                    return p+1;
-                if( p[4] == 0 && p[5] == 1 )
-                    return p+2;
-            }
-        }
-    }
-
-    for( end += 3; p < end; p++ ) {
-        if( p[0] == 0 && p[1] == 0 && p[2] == 1 )
-            return p;
-    }
-
-    return end + 3;
-}
-
-static void avc_parse_nal_units(uint8_t **buf, int *size)
-{
-    ByteIOContext pb;
-    uint8_t *p = *buf;
-    uint8_t *end = p + *size;
-    uint8_t *nal_start, *nal_end;
-
-    url_open_dyn_buf(&pb);
-    nal_start = avc_find_startcode(p, end);
-    while (nal_start < end) {
-        while(!*(nal_start++));
-        nal_end = avc_find_startcode(nal_start, end);
-        put_be32(&pb, nal_end - nal_start);
-        put_buffer(&pb, nal_start, nal_end - nal_start);
-        nal_start = nal_end;
-    }
-    av_freep(buf);
-    *size = url_close_dyn_buf(&pb, buf);
-}
-
 static int mov_write_avcc_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
 
     put_be32(pb, 0);
     put_tag(pb, "avcC");
-    if (track->vosLen > 6) {
-        /* check for h264 start code */
-        if (AV_RB32(track->vosData) == 0x00000001) {
-            uint8_t *buf, *end;
-            uint32_t sps_size=0, pps_size=0;
-            uint8_t *sps=0, *pps=0;
-
-            avc_parse_nal_units(&track->vosData, &track->vosLen);
-            buf = track->vosData;
-            end = track->vosData + track->vosLen;
-
-            /* look for sps and pps */
-            while (buf < end) {
-                unsigned int size;
-                uint8_t nal_type;
-                size = AV_RB32(buf);
-                nal_type = buf[4] & 0x1f;
-                if (nal_type == 7) { /* SPS */
-                    sps = buf + 4;
-                    sps_size = size;
-                } else if (nal_type == 8) { /* PPS */
-                    pps = buf + 4;
-                    pps_size = size;
-                }
-                buf += size + 4;
-            }
-            assert(sps);
-            assert(pps);
-
-            put_byte(pb, 1); /* version */
-            put_byte(pb, sps[1]); /* profile */
-            put_byte(pb, sps[2]); /* profile compat */
-            put_byte(pb, sps[3]); /* level */
-            put_byte(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
-            put_byte(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
-
-            put_be16(pb, sps_size);
-            put_buffer(pb, sps, sps_size);
-            put_byte(pb, 1); /* number of pps */
-            put_be16(pb, pps_size);
-            put_buffer(pb, pps, pps_size);
-        } else {
-            put_buffer(pb, track->vosData, track->vosLen);
-        }
-    }
+    ff_isom_write_avcc(pb, track->vosData, track->vosLen);
     return updateSize(pb, pos);
 }
 
-static int mov_find_video_codec_tag(AVFormatContext *s, MOVTrack *track)
+/* also used by all avid codecs (dv, imx, meridien) and their variants */
+static int mov_write_avid_tag(ByteIOContext *pb, MOVTrack *track)
 {
-    int tag = track->enc->codec_tag;
-    if (!tag) {
-        if (track->enc->codec_id == CODEC_ID_DVVIDEO) {
-            if (track->enc->height == 480) { /* NTSC */
-                if (track->enc->pix_fmt == PIX_FMT_YUV422P)
-                    tag = MKTAG('d', 'v', '5', 'n');
-                else
-                    tag = MKTAG('d', 'v', 'c', ' ');
-            } else { /* assume PAL */
-                if (track->enc->pix_fmt == PIX_FMT_YUV422P)
-                    tag = MKTAG('d', 'v', '5', 'p');
-                else if (track->enc->pix_fmt == PIX_FMT_YUV420P)
-                    tag = MKTAG('d', 'v', 'c', 'p');
-                else
-                    tag = MKTAG('d', 'v', 'p', 'p');
-            }
-        } else if (track->enc->codec_id == CODEC_ID_H263) {
-            if (track->mode == MODE_MOV)
-                tag = MKTAG('h', '2', '6', '3');
-            else
-                tag = MKTAG('s', '2', '6', '3');
-        } else {
-            tag = codec_get_tag(codec_movvideo_tags, track->enc->codec_id);
-        }
-    }
-    // if no mac fcc found, try with Microsoft tags
-    if (!tag) {
-        tag = codec_get_tag(codec_bmp_tags, track->enc->codec_id);
-        if (tag) {
-            av_log(s, AV_LOG_INFO, "Warning, using MS style video codec tag, the file may be unplayable!\n");
-        }
+    int i;
+    put_be32(pb, 24); /* size */
+    put_tag(pb, "ACLR");
+    put_tag(pb, "ACLR");
+    put_tag(pb, "0001");
+    put_be32(pb, 1); /* yuv 1 / rgb 2 ? */
+    put_be32(pb, 0); /* unknown */
+
+    put_be32(pb, 24); /* size */
+    put_tag(pb, "APRG");
+    put_tag(pb, "APRG");
+    put_tag(pb, "0001");
+    put_be32(pb, 1); /* unknown */
+    put_be32(pb, 0); /* unknown */
+
+    put_be32(pb, 120); /* size */
+    put_tag(pb, "ARES");
+    put_tag(pb, "ARES");
+    put_tag(pb, "0001");
+    put_be32(pb, AV_RB32(track->vosData + 0x28)); /* dnxhd cid, some id ? */
+    put_be32(pb, track->enc->width);
+    /* values below are based on samples created with quicktime and avid codecs */
+    if (track->vosData[5] & 2) { // interlaced
+        put_be32(pb, track->enc->height/2);
+        put_be32(pb, 2); /* unknown */
+        put_be32(pb, 0); /* unknown */
+        put_be32(pb, 4); /* unknown */
+    } else {
+        put_be32(pb, track->enc->height);
+        put_be32(pb, 1); /* unknown */
+        put_be32(pb, 0); /* unknown */
+        if (track->enc->height == 1080)
+            put_be32(pb, 5); /* unknown */
+        else
+            put_be32(pb, 6); /* unknown */
     }
-    assert(tag);
-    return tag;
+    /* padding */
+    for (i = 0; i < 10; i++)
+        put_be64(pb, 0);
+
+    /* extra padding for stsd needed */
+    put_be32(pb, 0);
+    return 0;
 }
 
-static int mov_find_audio_codec_tag(AVFormatContext *s, MOVTrack *track)
+static const AVCodecTag codec_3gp_tags[] = {
+    { CODEC_ID_H263,   MKTAG('s','2','6','3') },
+    { CODEC_ID_H264,   MKTAG('a','v','c','1') },
+    { CODEC_ID_MPEG4,  MKTAG('m','p','4','v') },
+    { CODEC_ID_AAC,    MKTAG('m','p','4','a') },
+    { CODEC_ID_AMR_NB, MKTAG('s','a','m','r') },
+    { CODEC_ID_AMR_WB, MKTAG('s','a','w','b') },
+};
+
+static const AVCodecTag mov_pix_fmt_tags[] = {
+    { PIX_FMT_YUYV422, MKTAG('y','u','v','s') },
+    { PIX_FMT_UYVY422, MKTAG('2','v','u','y') },
+    { PIX_FMT_BGR555,  MKTAG('r','a','w',' ') },
+    { PIX_FMT_RGB24,   MKTAG('r','a','w',' ') },
+    { PIX_FMT_BGR32_1, MKTAG('r','a','w',' ') },
+};
+
+static int mov_find_codec_tag(AVFormatContext *s, MOVTrack *track)
 {
     int tag = track->enc->codec_tag;
-    if (!tag) {
-        tag = codec_get_tag(codec_movaudio_tags, track->enc->codec_id);
-    }
-    // if no mac fcc found, try with Microsoft tags
-    if (!tag) {
-        int ms_tag = codec_get_tag(codec_wav_tags, track->enc->codec_id);
-        if (ms_tag) {
-            tag = MKTAG('m', 's', ((ms_tag >> 8) & 0xff), (ms_tag & 0xff));
-            av_log(s, AV_LOG_INFO, "Warning, using MS style audio codec tag, the file may be unplayable!\n");
+    if (track->mode == MODE_MP4 || track->mode == MODE_PSP) {
+        if (!codec_get_tag(ff_mp4_obj_type, track->enc->codec_id))
+            return 0;
+        if (track->enc->codec_id == CODEC_ID_H264)           tag = MKTAG('a','v','c','1');
+        else if (track->enc->codec_type == CODEC_TYPE_VIDEO) tag = MKTAG('m','p','4','v');
+        else if (track->enc->codec_type == CODEC_TYPE_AUDIO) tag = MKTAG('m','p','4','a');
+    } else if (track->mode == MODE_3GP || track->mode == MODE_3G2) {
+        tag = codec_get_tag(codec_3gp_tags, track->enc->codec_id);
+    } else if (!tag || (track->enc->strict_std_compliance >= FF_COMPLIANCE_NORMAL &&
+                        (tag == MKTAG('d','v','c','p') ||
+                         track->enc->codec_id == CODEC_ID_RAWVIDEO))) {
+        if (track->enc->codec_id == CODEC_ID_DVVIDEO) {
+            if (track->enc->height == 480) /* NTSC */
+                if  (track->enc->pix_fmt == PIX_FMT_YUV422P) tag = MKTAG('d','v','5','n');
+                else                                         tag = MKTAG('d','v','c',' ');
+            else if (track->enc->pix_fmt == PIX_FMT_YUV422P) tag = MKTAG('d','v','5','p');
+            else if (track->enc->pix_fmt == PIX_FMT_YUV420P) tag = MKTAG('d','v','c','p');
+            else                                             tag = MKTAG('d','v','p','p');
+        } else if (track->enc->codec_id == CODEC_ID_RAWVIDEO) {
+            tag = codec_get_tag(mov_pix_fmt_tags, track->enc->pix_fmt);
+            if (!tag) // restore tag
+                tag = track->enc->codec_tag;
+        } else {
+            if (track->enc->codec_type == CODEC_TYPE_VIDEO) {
+                tag = codec_get_tag(codec_movvideo_tags, track->enc->codec_id);
+                if (!tag) { // if no mac fcc found, try with Microsoft tags
+                    tag = codec_get_tag(codec_bmp_tags, track->enc->codec_id);
+                    if (tag)
+                        av_log(s, AV_LOG_INFO, "Warning, using MS style video codec tag, "
+                               "the file may be unplayable!\n");
+                }
+            } else if (track->enc->codec_type == CODEC_TYPE_AUDIO) {
+                tag = codec_get_tag(codec_movaudio_tags, track->enc->codec_id);
+                if (!tag) { // if no mac fcc found, try with Microsoft tags
+                    int ms_tag = codec_get_tag(codec_wav_tags, track->enc->codec_id);
+                    if (ms_tag) {
+                        tag = MKTAG('m', 's', ((ms_tag >> 8) & 0xff), (ms_tag & 0xff));
+                        av_log(s, AV_LOG_INFO, "Warning, using MS style audio codec tag, "
+                               "the file may be unplayable!\n");
+                    }
+                }
+            }
         }
     }
-    assert(tag);
     return tag;
 }
 
@@ -613,9 +582,12 @@
     put_byte(pb, strlen(compressor_name));
     put_buffer(pb, compressor_name, 31);
 
-    put_be16(pb, 0x18); /* Reserved */
+    if (track->mode == MODE_MOV && track->enc->bits_per_sample)
+        put_be16(pb, track->enc->bits_per_sample);
+    else
+        put_be16(pb, 0x18); /* Reserved */
     put_be16(pb, 0xffff); /* Reserved */
-    if(track->enc->codec_id == CODEC_ID_MPEG4)
+    if(track->tag == MKTAG('m','p','4','v'))
         mov_write_esds_tag(pb, track);
     else if(track->enc->codec_id == CODEC_ID_H263)
         mov_write_d263_tag(pb);
@@ -623,6 +595,10 @@
         mov_write_svq3_tag(pb);
     else if(track->enc->codec_id == CODEC_ID_H264)
         mov_write_avcc_tag(pb, track);
+    else if(track->enc->codec_id == CODEC_ID_DNXHD)
+        mov_write_avid_tag(pb, track);
+    else if(track->vosLen > 0)
+        mov_write_glbl_tag(pb, track);
 
     return updateSize (pb, pos);
 }
@@ -1173,40 +1149,52 @@
 static int mov_write_udta_tag(ByteIOContext *pb, MOVContext* mov,
                               AVFormatContext *s)
 {
-    offset_t pos = url_ftell(pb);
-    int i;
-
-    put_be32(pb, 0); /* size */
-    put_tag(pb, "udta");
+    int i, req = 0;
 
-    /* iTunes meta data */
-    mov_write_meta_tag(pb, mov, s);
-
-  if(mov->mode == MODE_MOV){ // the title field breaks gtkpod with mp4 and my suspicion is that stuff is not valid in mp4
     /* Requirements */
     for (i=0; i<mov->nb_streams; i++) {
         if(mov->tracks[i].entry <= 0) continue;
         if (mov->tracks[i].enc->codec_id == CODEC_ID_AAC ||
             mov->tracks[i].enc->codec_id == CODEC_ID_MPEG4) {
-            mov_write_string_tag(pb, "\251req", "QuickTime 6.0 or greater", 0);
+            req = 1;
             break;
         }
     }
 
-    mov_write_string_tag(pb, "\251nam", s->title         , 0);
-    mov_write_string_tag(pb, "\251aut", s->author        , 0);
-    mov_write_string_tag(pb, "\251alb", s->album         , 0);
-    mov_write_day_tag(pb, s->year, 0);
-    if(mov->tracks[0].enc && !(mov->tracks[0].enc->flags & CODEC_FLAG_BITEXACT))
-        mov_write_string_tag(pb, "\251enc", LIBAVFORMAT_IDENT, 0);
-    mov_write_string_tag(pb, "\251des", s->comment       , 0);
-    mov_write_string_tag(pb, "\251gen", s->genre         , 0);
-  }
+    if (s->title[0]   || s->author[0] || s->album[0] || s->year ||
+        s->comment[0] || s->genre[0]  || s->track ||
+       (mov->mode == MODE_MOV &&
+      ((mov->tracks[0].enc && !mov->tracks[0].enc->flags & CODEC_FLAG_BITEXACT) || req))) {
+        offset_t pos = url_ftell(pb);
 
-    return updateSize(pb, pos);
+        put_be32(pb, 0); /* size */
+        put_tag(pb, "udta");
+
+        /* iTunes meta data */
+        mov_write_meta_tag(pb, mov, s);
+
+        if(mov->mode == MODE_MOV){ // the title field breaks gtkpod with mp4 and my suspicion is that stuff is not valid in mp4
+            /* Requirements */
+            if (req)
+                mov_write_string_tag(pb, "\251req", "QuickTime 6.0 or greater", 0);
+
+            mov_write_string_tag(pb, "\251nam", s->title         , 0);
+            mov_write_string_tag(pb, "\251aut", s->author        , 0);
+            mov_write_string_tag(pb, "\251alb", s->album         , 0);
+            mov_write_day_tag(pb, s->year, 0);
+            if(mov->tracks[0].enc && !(mov->tracks[0].enc->flags & CODEC_FLAG_BITEXACT))
+                mov_write_string_tag(pb, "\251enc", LIBAVFORMAT_IDENT, 0);
+            mov_write_string_tag(pb, "\251des", s->comment       , 0);
+            mov_write_string_tag(pb, "\251gen", s->genre         , 0);
+        }
+
+        return updateSize(pb, pos);
+    }
+
+    return 0;
 }
 
-static int utf8len(uint8_t *b){
+static int utf8len(const uint8_t *b){
     int len=0;
     int val;
     while(*b){
@@ -1216,7 +1204,7 @@
     return len;
 }
 
-static int ascii_to_wc (ByteIOContext *pb, uint8_t *b)
+static int ascii_to_wc (ByteIOContext *pb, const uint8_t *b)
 {
     int val;
     while(*b){
@@ -1336,7 +1324,7 @@
 
     if (mov->mode == MODE_PSP)
         mov_write_uuidusmt_tag(pb, s);
-    else
+    else if (mov->mode != MODE_3GP && mov->mode != MODE_3G2)
         mov_write_udta_tag(pb, mov, s);
 
     return updateSize(pb, pos);
@@ -1449,11 +1437,11 @@
 
 static int mov_write_header(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     MOVContext *mov = s->priv_data;
     int i;
 
-    if (url_is_streamed(&s->pb)) {
+    if (url_is_streamed(s->pb)) {
         av_log(s, AV_LOG_ERROR, "muxer does not support non seekable output\n");
         return -1;
     }
@@ -1484,17 +1472,20 @@
         track->enc = st->codec;
         track->language = ff_mov_iso639_to_lang(st->language, mov->mode != MODE_MOV);
         track->mode = mov->mode;
+        track->tag = mov_find_codec_tag(s, track);
+        if (!track->tag) {
+            av_log(s, AV_LOG_ERROR, "track %d: could not find tag for codec\n", i);
+            return -1;
+        }
         if(st->codec->codec_type == CODEC_TYPE_VIDEO){
-            track->tag = mov_find_video_codec_tag(s, track);
             track->timescale = st->codec->time_base.den;
             av_set_pts_info(st, 64, 1, st->codec->time_base.den);
-            if (track->timescale > 100000)
-                av_log(NULL, AV_LOG_WARNING,
+            if (track->mode == MODE_MOV && track->timescale > 100000)
+                av_log(s, AV_LOG_WARNING,
                        "WARNING codec timebase is very high. If duration is too long,\n"
                        "file may not be playable by quicktime. Specify a shorter timebase\n"
                        "or choose different container.\n");
         }else if(st->codec->codec_type == CODEC_TYPE_AUDIO){
-            track->tag = mov_find_audio_codec_tag(s, track);
             track->timescale = st->codec->sample_rate;
             av_set_pts_info(st, 64, 1, st->codec->sample_rate);
             if(!st->codec->frame_size){
@@ -1520,13 +1511,13 @@
 static int mov_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
     MOVContext *mov = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     MOVTrack *trk = &mov->tracks[pkt->stream_index];
     AVCodecContext *enc = trk->enc;
     unsigned int samplesInChunk = 0;
     int size= pkt->size;
 
-    if (url_is_streamed(&s->pb)) return 0; /* Can't handle that */
+    if (url_is_streamed(s->pb)) return 0; /* Can't handle that */
     if (!size) return 0; /* Discard 0 sized packets */
 
     if (enc->codec_id == CODEC_ID_AMR_NB) {
@@ -1558,9 +1549,18 @@
     if (enc->codec_id == CODEC_ID_H264 && trk->vosLen > 0 && *(uint8_t *)trk->vosData != 1) {
         /* from x264 or from bytestream h264 */
         /* nal reformating needed */
-        avc_parse_nal_units(&pkt->data, &pkt->size);
+        int ret = ff_avc_parse_nal_units(pkt->data, &pkt->data, &pkt->size);
+        if (ret < 0)
+            return ret;
         assert(pkt->size);
         size = pkt->size;
+    } else if (enc->codec_id == CODEC_ID_DNXHD && !trk->vosLen) {
+        /* copy frame header to create needed atoms */
+        if (size < 640)
+            return -1;
+        trk->vosLen = 640;
+        trk->vosData = av_malloc(trk->vosLen);
+        memcpy(trk->vosData, pkt->data, 640);
     }
 
     if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) {
@@ -1597,7 +1597,7 @@
 static int mov_write_trailer(AVFormatContext *s)
 {
     MOVContext *mov = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int res = 0;
     int i;
 
@@ -1643,6 +1643,7 @@
     mov_write_packet,
     mov_write_trailer,
     .flags = AVFMT_GLOBALHEADER,
+    .codec_tag = (const AVCodecTag*[]){codec_movvideo_tags, codec_movaudio_tags, 0},
 };
 #endif
 #ifdef CONFIG_TGP_MUXER
@@ -1658,6 +1659,7 @@
     mov_write_packet,
     mov_write_trailer,
     .flags = AVFMT_GLOBALHEADER,
+    .codec_tag = (const AVCodecTag*[]){codec_3gp_tags, 0},
 };
 #endif
 #ifdef CONFIG_MP4_MUXER
@@ -1673,6 +1675,7 @@
     mov_write_packet,
     mov_write_trailer,
     .flags = AVFMT_GLOBALHEADER,
+    .codec_tag = (const AVCodecTag*[]){ff_mp4_obj_type, 0},
 };
 #endif
 #ifdef CONFIG_PSP_MUXER
@@ -1688,6 +1691,7 @@
     mov_write_packet,
     mov_write_trailer,
     .flags = AVFMT_GLOBALHEADER,
+    .codec_tag = (const AVCodecTag*[]){ff_mp4_obj_type, 0},
 };
 #endif
 #ifdef CONFIG_TG2_MUXER
@@ -1703,5 +1707,6 @@
     mov_write_packet,
     mov_write_trailer,
     .flags = AVFMT_GLOBALHEADER,
+    .codec_tag = (const AVCodecTag*[]){codec_3gp_tags, 0},
 };
 #endif
diff -u mplayer-1.0~rc2-12/libavformat/mp3.c ffmpeg-free-0.svn20080206/libavformat/mp3.c
--- mplayer-1.0~rc2-12/libavformat/mp3.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mp3.c	2008-02-04 02:01:52.000000000 +0100
@@ -21,6 +21,7 @@
 #include "avformat.h"
 #include "mpegaudio.h"
 #include "avstring.h"
+#include "mpegaudiodecheader.h"
 
 #define ID3v2_HEADER_SIZE 10
 #define ID3v1_TAG_SIZE 128
@@ -189,20 +190,20 @@
     taglen--; /* account for encoding type byte */
     dstlen--; /* Leave space for zero terminator */
 
-    switch(get_byte(&s->pb)) { /* encoding type */
+    switch(get_byte(s->pb)) { /* encoding type */
 
     case 0:  /* ISO-8859-1 (0 - 255 maps directly into unicode) */
         q = dst;
         while(taglen--) {
             uint8_t tmp;
-            PUT_UTF8(get_byte(&s->pb), tmp, if (q - dst < dstlen - 1) *q++ = tmp;)
+            PUT_UTF8(get_byte(s->pb), tmp, if (q - dst < dstlen - 1) *q++ = tmp;)
         }
         *q = '\0';
         break;
 
     case 3:  /* UTF-8 */
         len = FFMIN(taglen, dstlen);
-        get_buffer(&s->pb, dst, len);
+        get_buffer(s->pb, dst, len);
         dst[len] = 0;
         break;
     }
@@ -251,23 +252,23 @@
     }
 
     if(isv34 && flags & 0x40) /* Extended header present, just skip over it */
-        url_fskip(&s->pb, id3v2_get_size(&s->pb, 4));
+        url_fskip(s->pb, id3v2_get_size(s->pb, 4));
 
     while(len >= taghdrlen) {
         if(isv34) {
-            tag  = get_be32(&s->pb);
-            tlen = id3v2_get_size(&s->pb, 4);
-            get_be16(&s->pb); /* flags */
+            tag  = get_be32(s->pb);
+            tlen = id3v2_get_size(s->pb, 4);
+            get_be16(s->pb); /* flags */
         } else {
-            tag  = get_be24(&s->pb);
-            tlen = id3v2_get_size(&s->pb, 3);
+            tag  = get_be24(s->pb);
+            tlen = id3v2_get_size(s->pb, 3);
         }
         len -= taghdrlen + tlen;
 
         if(len < 0)
             break;
 
-        next = url_ftell(&s->pb) + tlen;
+        next = url_ftell(s->pb) + tlen;
 
         switch(tag) {
         case MKBETAG('T', 'I', 'T', '2'):
@@ -297,21 +298,21 @@
             break;
         case 0:
             /* padding, skip to end */
-            url_fskip(&s->pb, len);
+            url_fskip(s->pb, len);
             len = 0;
             continue;
         }
         /* Skip to end of tag */
-        url_fseek(&s->pb, next, SEEK_SET);
+        url_fseek(s->pb, next, SEEK_SET);
     }
 
     if(version == 4 && flags & 0x10) /* Footer preset, always 10 bytes, skip over it */
-        url_fskip(&s->pb, 10);
+        url_fskip(s->pb, 10);
     return;
 
   error:
     av_log(s, AV_LOG_INFO, "ID3v2.%d tag skipped, cannot handle %s\n", version, reason);
-    url_fskip(&s->pb, len);
+    url_fskip(s->pb, len);
 }
 
 static void id3v1_get_string(char *str, int str_size,
@@ -402,9 +403,9 @@
 
     max_frames = 0;
     buf = p->buf;
-    end = buf + FFMIN(4096, p->buf_size - sizeof(uint32_t));
+    end = buf + p->buf_size - sizeof(uint32_t);
 
-    for(; buf < end; buf++) {
+    for(; buf < end; buf= buf2+1) {
         buf2 = buf;
 
         for(frames = 0; buf2 < end; frames++) {
@@ -419,17 +420,66 @@
             first_frames= frames;
     }
     if   (first_frames>=3) return AVPROBE_SCORE_MAX/2+1;
+    else if(max_frames>500)return AVPROBE_SCORE_MAX/2;
     else if(max_frames>=3) return AVPROBE_SCORE_MAX/4;
     else if(max_frames>=1) return 1;
     else                   return 0;
 }
 
+/**
+ * Try to find Xing/Info/VBRI tags and compute duration from info therein
+ */
+static void mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, offset_t base)
+{
+    uint32_t v, spf;
+    int frames = -1; /* Total number of frames in file */
+    const offset_t xing_offtbl[2][2] = {{32, 17}, {17,9}};
+    MPADecodeContext c;
+
+    v = get_be32(s->pb);
+    if(ff_mpa_check_header(v) < 0)
+      return;
+
+    ff_mpegaudio_decode_header(&c, v);
+    if(c.layer != 3)
+        return;
+
+    /* Check for Xing / Info tag */
+    url_fseek(s->pb, xing_offtbl[c.lsf == 1][c.nb_channels == 1], SEEK_CUR);
+    v = get_be32(s->pb);
+    if(v == MKBETAG('X', 'i', 'n', 'g') || v == MKBETAG('I', 'n', 'f', 'o')) {
+        v = get_be32(s->pb);
+        if(v & 0x1)
+            frames = get_be32(s->pb);
+    }
+
+    /* Check for VBRI tag (always 32 bytes after end of mpegaudio header) */
+    url_fseek(s->pb, base + 4 + 32, SEEK_SET);
+    v = get_be32(s->pb);
+    if(v == MKBETAG('V', 'B', 'R', 'I')) {
+        /* Check tag version */
+        if(get_be16(s->pb) == 1) {
+            /* skip delay, quality and total bytes */
+            url_fseek(s->pb, 8, SEEK_CUR);
+            frames = get_be32(s->pb);
+        }
+    }
+
+    if(frames < 0)
+        return;
+
+    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */
+    st->duration = av_rescale_q(frames, (AVRational){spf, c.sample_rate},
+                                st->time_base);
+}
+
 static int mp3_read_header(AVFormatContext *s,
                            AVFormatParameters *ap)
 {
     AVStream *st;
     uint8_t buf[ID3v1_TAG_SIZE];
     int len, ret, filesize;
+    offset_t off;
 
     st = av_new_stream(s, 0);
     if (!st)
@@ -438,23 +488,24 @@
     st->codec->codec_type = CODEC_TYPE_AUDIO;
     st->codec->codec_id = CODEC_ID_MP3;
     st->need_parsing = AVSTREAM_PARSE_FULL;
+    st->start_time = 0;
 
     /* try to get the TAG */
-    if (!url_is_streamed(&s->pb)) {
+    if (!url_is_streamed(s->pb)) {
         /* XXX: change that */
-        filesize = url_fsize(&s->pb);
+        filesize = url_fsize(s->pb);
         if (filesize > 128) {
-            url_fseek(&s->pb, filesize - 128, SEEK_SET);
-            ret = get_buffer(&s->pb, buf, ID3v1_TAG_SIZE);
+            url_fseek(s->pb, filesize - 128, SEEK_SET);
+            ret = get_buffer(s->pb, buf, ID3v1_TAG_SIZE);
             if (ret == ID3v1_TAG_SIZE) {
                 id3v1_parse_tag(s, buf);
             }
-            url_fseek(&s->pb, 0, SEEK_SET);
+            url_fseek(s->pb, 0, SEEK_SET);
         }
     }
 
     /* if ID3v2 header found, skip it */
-    ret = get_buffer(&s->pb, buf, ID3v2_HEADER_SIZE);
+    ret = get_buffer(s->pb, buf, ID3v2_HEADER_SIZE);
     if (ret != ID3v2_HEADER_SIZE)
         return -1;
     if (id3v2_match(buf)) {
@@ -465,9 +516,13 @@
             (buf[9] & 0x7f);
         id3v2_parse(s, len, buf[3], buf[5]);
     } else {
-        url_fseek(&s->pb, 0, SEEK_SET);
+        url_fseek(s->pb, 0, SEEK_SET);
     }
 
+    off = url_ftell(s->pb);
+    mp3_parse_vbr_tags(s, st, off);
+    url_fseek(s->pb, off, SEEK_SET);
+
     /* the parameters will be extracted from the compressed bitstream */
     return 0;
 }
@@ -481,7 +536,7 @@
 
     size= MP3_PACKET_SIZE;
 
-    ret= av_get_packet(&s->pb, pkt, size);
+    ret= av_get_packet(s->pb, pkt, size);
 
     pkt->stream_index = 0;
     if (ret <= 0) {
@@ -503,20 +558,20 @@
 
 static void id3v2_put_size(AVFormatContext *s, int size)
 {
-    put_byte(&s->pb, size >> 21 & 0x7f);
-    put_byte(&s->pb, size >> 14 & 0x7f);
-    put_byte(&s->pb, size >> 7  & 0x7f);
-    put_byte(&s->pb, size       & 0x7f);
+    put_byte(s->pb, size >> 21 & 0x7f);
+    put_byte(s->pb, size >> 14 & 0x7f);
+    put_byte(s->pb, size >> 7  & 0x7f);
+    put_byte(s->pb, size       & 0x7f);
 }
 
-static void id3v2_put_ttag(AVFormatContext *s, char *string, uint32_t tag)
+static void id3v2_put_ttag(AVFormatContext *s, const char *string, uint32_t tag)
 {
     int len = strlen(string);
-    put_be32(&s->pb, tag);
+    put_be32(s->pb, tag);
     id3v2_put_size(s, len + 1);
-    put_be16(&s->pb, 0);
-    put_byte(&s->pb, 3); /* UTF-8 */
-    put_buffer(&s->pb, string, len);
+    put_be16(s->pb, 0);
+    put_byte(s->pb, 3); /* UTF-8 */
+    put_buffer(s->pb, string, len);
 }
 
 
@@ -528,9 +583,12 @@
 {
     int totlen = 0;
     char tracktxt[10];
+    char yeartxt[10];
 
     if(s->track)
-        snprintf(tracktxt, sizeof(tracktxt) - 1, "%d", s->track);
+        snprintf(tracktxt, sizeof(tracktxt), "%d", s->track);
+    if(s->year)
+        snprintf( yeartxt, sizeof(yeartxt) , "%d", s->year );
 
     if(s->title[0])     totlen += 11 + strlen(s->title);
     if(s->author[0])    totlen += 11 + strlen(s->author);
@@ -538,15 +596,16 @@
     if(s->genre[0])     totlen += 11 + strlen(s->genre);
     if(s->copyright[0]) totlen += 11 + strlen(s->copyright);
     if(s->track)        totlen += 11 + strlen(tracktxt);
+    if(s->year)         totlen += 11 + strlen(yeartxt);
     if(!(s->streams[0]->codec->flags & CODEC_FLAG_BITEXACT))
         totlen += strlen(LIBAVFORMAT_IDENT) + 11;
 
     if(totlen == 0)
         return 0;
 
-    put_be32(&s->pb, MKBETAG('I', 'D', '3', 0x04)); /* ID3v2.4 */
-    put_byte(&s->pb, 0);
-    put_byte(&s->pb, 0); /* flags */
+    put_be32(s->pb, MKBETAG('I', 'D', '3', 0x04)); /* ID3v2.4 */
+    put_byte(s->pb, 0);
+    put_byte(s->pb, 0); /* flags */
 
     id3v2_put_size(s, totlen);
 
@@ -556,6 +615,7 @@
     if(s->genre[0])     id3v2_put_ttag(s, s->genre,     MKBETAG('T', 'C', 'O', 'N'));
     if(s->copyright[0]) id3v2_put_ttag(s, s->copyright, MKBETAG('T', 'C', 'O', 'P'));
     if(s->track)        id3v2_put_ttag(s, tracktxt,     MKBETAG('T', 'R', 'C', 'K'));
+    if(s->year)         id3v2_put_ttag(s, yeartxt,      MKBETAG('T', 'Y', 'E', 'R'));
     if(!(s->streams[0]->codec->flags & CODEC_FLAG_BITEXACT))
         id3v2_put_ttag(s, LIBAVFORMAT_IDENT,            MKBETAG('T', 'E', 'N', 'C'));
     return 0;
@@ -563,8 +623,8 @@
 
 static int mp3_write_packet(struct AVFormatContext *s, AVPacket *pkt)
 {
-    put_buffer(&s->pb, pkt->data, pkt->size);
-    put_flush_packet(&s->pb);
+    put_buffer(s->pb, pkt->data, pkt->size);
+    put_flush_packet(s->pb);
     return 0;
 }
 
@@ -575,8 +635,8 @@
     /* write the id3v1 tag */
     if (s->title[0] != '\0') {
         id3v1_create_tag(s, buf);
-        put_buffer(&s->pb, buf, ID3v1_TAG_SIZE);
-        put_flush_packet(&s->pb);
+        put_buffer(s->pb, buf, ID3v1_TAG_SIZE);
+        put_flush_packet(s->pb);
     }
     return 0;
 }
Only in ffmpeg-free-0.svn20080206/libavformat: mpc8.c
diff -u mplayer-1.0~rc2-12/libavformat/mpc.c ffmpeg-free-0.svn20080206/libavformat/mpc.c
--- mplayer-1.0~rc2-12/libavformat/mpc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mpc.c	2007-11-21 08:41:00.000000000 +0100
@@ -55,31 +55,31 @@
     AVStream *st;
     int t;
 
-    t = get_le24(&s->pb);
+    t = get_le24(s->pb);
     if(t != MKTAG('M', 'P', '+', 0)){
         if(t != MKTAG('I', 'D', '3', 0)){
             av_log(s, AV_LOG_ERROR, "Not a Musepack file\n");
             return -1;
         }
         /* skip ID3 tags and try again */
-        url_fskip(&s->pb, 3);
-        t  = get_byte(&s->pb) << 21;
-        t |= get_byte(&s->pb) << 14;
-        t |= get_byte(&s->pb) <<  7;
-        t |= get_byte(&s->pb);
+        url_fskip(s->pb, 3);
+        t  = get_byte(s->pb) << 21;
+        t |= get_byte(s->pb) << 14;
+        t |= get_byte(s->pb) <<  7;
+        t |= get_byte(s->pb);
         av_log(s, AV_LOG_DEBUG, "Skipping %d(%X) bytes of ID3 data\n", t, t);
-        url_fskip(&s->pb, t);
-        if(get_le24(&s->pb) != MKTAG('M', 'P', '+', 0)){
+        url_fskip(s->pb, t);
+        if(get_le24(s->pb) != MKTAG('M', 'P', '+', 0)){
             av_log(s, AV_LOG_ERROR, "Not a Musepack file\n");
             return -1;
         }
     }
-    c->ver = get_byte(&s->pb);
+    c->ver = get_byte(s->pb);
     if(c->ver != 0x07 && c->ver != 0x17){
         av_log(s, AV_LOG_ERROR, "Can demux Musepack SV7, got version %02X\n", c->ver);
         return -1;
     }
-    c->fcount = get_le32(&s->pb);
+    c->fcount = get_le32(s->pb);
     if((int64_t)c->fcount * sizeof(MPCFrame) >= UINT_MAX){
         av_log(s, AV_LOG_ERROR, "Too many frames, seeking is not possible\n");
         return -1;
@@ -100,7 +100,7 @@
 
     st->codec->extradata_size = 16;
     st->codec->extradata = av_mallocz(st->codec->extradata_size+FF_INPUT_BUFFER_PADDING_SIZE);
-    get_buffer(&s->pb, st->codec->extradata, 16);
+    get_buffer(s->pb, st->codec->extradata, 16);
     st->codec->sample_rate = mpc_rate[st->codec->extradata[2] & 3];
     av_set_pts_info(st, 32, MPC_FRAMESIZE, st->codec->sample_rate);
     /* scan for seekpoints */
@@ -120,22 +120,22 @@
         return -1;
 
     if(c->curframe != c->lastframe + 1){
-        url_fseek(&s->pb, c->frames[c->curframe].pos, SEEK_SET);
+        url_fseek(s->pb, c->frames[c->curframe].pos, SEEK_SET);
         c->curbits = c->frames[c->curframe].skip;
     }
     c->lastframe = c->curframe;
     c->curframe++;
     curbits = c->curbits;
-    pos = url_ftell(&s->pb);
-    tmp = get_le32(&s->pb);
+    pos = url_ftell(s->pb);
+    tmp = get_le32(s->pb);
     if(curbits <= 12){
         size2 = (tmp >> (12 - curbits)) & 0xFFFFF;
     }else{
-        tmp = (tmp << 32) | get_le32(&s->pb);
+        tmp = (tmp << 32) | get_le32(s->pb);
         size2 = (tmp >> (44 - curbits)) & 0xFFFFF;
     }
     curbits += 20;
-    url_fseek(&s->pb, pos, SEEK_SET);
+    url_fseek(s->pb, pos, SEEK_SET);
 
     size = ((size2 + curbits + 31) & ~31) >> 3;
     if(cur == c->frames_noted){
@@ -155,9 +155,9 @@
 
     pkt->stream_index = 0;
     pkt->pts = cur;
-    ret = get_buffer(&s->pb, pkt->data + 4, size);
+    ret = get_buffer(s->pb, pkt->data + 4, size);
     if(c->curbits)
-        url_fseek(&s->pb, -4, SEEK_CUR);
+        url_fseek(s->pb, -4, SEEK_CUR);
     if(ret < size){
         av_free_packet(pkt);
         return AVERROR(EIO);
diff -u mplayer-1.0~rc2-12/libavformat/mpeg.c ffmpeg-free-0.svn20080206/libavformat/mpeg.c
--- mplayer-1.0~rc2-12/libavformat/mpeg.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mpeg.c	2008-01-14 17:11:08.000000000 +0100
@@ -32,47 +32,56 @@
 
 #define MAX_SYNC_SIZE 100000
 
-static int cdxa_probe(AVProbeData *p)
-{
-    /* check file header */
-    if (p->buf[0] == 'R' && p->buf[1] == 'I' &&
-        p->buf[2] == 'F' && p->buf[3] == 'F' &&
-        p->buf[8] == 'C' && p->buf[9] == 'D' &&
-        p->buf[10] == 'X' && p->buf[11] == 'A')
-        return AVPROBE_SCORE_MAX;
-    else
-        return 0;
+static int check_pes(uint8_t *p, uint8_t *end){
+    int pes1;
+    int pes2=      (p[3] & 0xC0) == 0x80
+                && (p[4] & 0xC0) != 0x40
+                &&((p[4] & 0xC0) == 0x00 || (p[4]&0xC0)>>2 == (p[6]&0xF0));
+
+    for(p+=3; p<end && *p == 0xFF; p++);
+    if((*p&0xC0) == 0x40) p+=2;
+    if((*p&0xF0) == 0x20){
+        pes1= p[0]&p[2]&p[4]&1;
+        p+=5;
+    }else if((*p&0xF0) == 0x30){
+        pes1= p[0]&p[2]&p[4]&p[5]&p[7]&p[9]&1;
+        p+=10;
+    }else
+        pes1 = *p == 0x0F;
+
+    return pes1||pes2;
 }
 
 static int mpegps_probe(AVProbeData *p)
 {
     uint32_t code= -1;
-    int sys=0, pspack=0, priv1=0, vid=0, audio=0;
+    int sys=0, pspack=0, priv1=0, vid=0, audio=0, invalid=0;
     int i;
     int score=0;
 
-    score = cdxa_probe(p);
-    if (score > 0) return score;
-
-    /* Search for MPEG stream */
     for(i=0; i<p->buf_size; i++){
         code = (code<<8) + p->buf[i];
         if ((code & 0xffffff00) == 0x100) {
+            int pes= check_pes(p->buf+i, p->buf+p->buf_size);
+
             if(code == SYSTEM_HEADER_START_CODE) sys++;
             else if(code == PRIVATE_STREAM_1)    priv1++;
             else if(code == PACK_START_CODE)     pspack++;
-            else if((code & 0xf0) == VIDEO_ID)   vid++;
-            else if((code & 0xe0) == AUDIO_ID)   audio++;
+            else if((code & 0xf0) == VIDEO_ID && pes) vid++;
+            else if((code & 0xe0) == AUDIO_ID && pes) audio++;
+
+            else if((code & 0xf0) == VIDEO_ID && !pes) invalid++;
+            else if((code & 0xe0) == AUDIO_ID && !pes) invalid++;
         }
     }
 
-    if(vid || audio)            /* invalid VDR files nd short PES streams */
+    if(vid+audio > invalid)     /* invalid VDR files nd short PES streams */
         score= AVPROBE_SCORE_MAX/4;
 
 //av_log(NULL, AV_LOG_ERROR, "%d %d %d %d %d len:%d\n", sys, priv1, pspack,vid, audio, p->buf_size);
-    if(sys && sys*9 <= pspack*10)
+    if(sys>invalid && sys*9 <= pspack*10)
         return AVPROBE_SCORE_MAX/2+2; // +1 for .mpg
-    if((priv1 || vid || audio) && (priv1+vid+audio)*9 <= pspack*10)
+    if(priv1 + vid + audio > invalid && (priv1+vid+audio)*9 <= pspack*10)
         return AVPROBE_SCORE_MAX/2+2; // +1 for .mpg
     if((!!vid ^ !!audio) && (audio+vid > 1) && !sys && !pspack && p->buf_size>2048) /* PES stream */
         return AVPROBE_SCORE_MAX/2+2;
@@ -85,32 +94,38 @@
 typedef struct MpegDemuxContext {
     int32_t header_state;
     unsigned char psm_es_type[256];
+    int sofdec;
 } MpegDemuxContext;
 
 static int mpegps_read_header(AVFormatContext *s,
                               AVFormatParameters *ap)
 {
     MpegDemuxContext *m = s->priv_data;
+    const char *sofdec = "Sofdec";
+    int v, i = 0;
+
     m->header_state = 0xff;
     s->ctx_flags |= AVFMTCTX_NOHEADER;
 
+    m->sofdec = -1;
+    do {
+        v = get_byte(s->pb);
+        m->header_state = m->header_state << 8 | v;
+        m->sofdec++;
+    } while (v == sofdec[i] && i++ < 6);
+
     /* no need to do more */
     return 0;
 }
 
 static int64_t get_pts(ByteIOContext *pb, int c)
 {
-    int64_t pts;
-    int val;
+    uint8_t buf[5];
 
-    if (c < 0)
-        c = get_byte(pb);
-    pts = (int64_t)((c >> 1) & 0x07) << 30;
-    val = get_be16(pb);
-    pts |= (int64_t)(val >> 1) << 15;
-    val = get_be16(pb);
-    pts |= (int64_t)(val >> 1);
-    return pts;
+    buf[0] = c<0 ? get_byte(pb) : c;
+    get_buffer(pb, buf+1, 4);
+
+    return ff_parse_pes_pts(buf);
 }
 
 static int find_next_start_code(ByteIOContext *pb, int *size_ptr,
@@ -220,32 +235,46 @@
     int len, size, startcode, c, flags, header_len;
     int pes_ext, ext2_len, id_ext, skip;
     int64_t pts, dts;
-    int64_t last_sync= url_ftell(&s->pb);
+    int64_t last_sync= url_ftell(s->pb);
 
  error_redo:
-        url_fseek(&s->pb, last_sync, SEEK_SET);
+        url_fseek(s->pb, last_sync, SEEK_SET);
  redo:
         /* next start code (should be immediately after) */
         m->header_state = 0xff;
         size = MAX_SYNC_SIZE;
-        startcode = find_next_start_code(&s->pb, &size, &m->header_state);
-        last_sync = url_ftell(&s->pb);
-    //printf("startcode=%x pos=0x%"PRIx64"\n", startcode, url_ftell(&s->pb));
+        startcode = find_next_start_code(s->pb, &size, &m->header_state);
+        last_sync = url_ftell(s->pb);
+    //printf("startcode=%x pos=0x%"PRIx64"\n", startcode, url_ftell(s->pb));
     if (startcode < 0)
         return AVERROR(EIO);
     if (startcode == PACK_START_CODE)
         goto redo;
     if (startcode == SYSTEM_HEADER_START_CODE)
         goto redo;
-    if (startcode == PADDING_STREAM ||
-        startcode == PRIVATE_STREAM_2) {
-        /* skip them */
-        len = get_be16(&s->pb);
-        url_fskip(&s->pb, len);
+    if (startcode == PADDING_STREAM) {
+        url_fskip(s->pb, get_be16(s->pb));
+        goto redo;
+    }
+    if (startcode == PRIVATE_STREAM_2) {
+        len = get_be16(s->pb);
+        if (!m->sofdec) {
+            while (len-- >= 6) {
+                if (get_byte(s->pb) == 'S') {
+                    uint8_t buf[5];
+                    get_buffer(s->pb, buf, sizeof(buf));
+                    m->sofdec = !memcmp(buf, "ofdec", 5);
+                    len -= sizeof(buf);
+                    break;
+                }
+            }
+            m->sofdec -= !m->sofdec;
+        }
+        url_fskip(s->pb, len);
         goto redo;
     }
     if (startcode == PROGRAM_STREAM_MAP) {
-        mpegps_psm_parse(m, &s->pb);
+        mpegps_psm_parse(m, s->pb);
         goto redo;
     }
 
@@ -255,16 +284,16 @@
           (startcode == 0x1bd) || (startcode == 0x1fd)))
         goto redo;
     if (ppos) {
-        *ppos = url_ftell(&s->pb) - 4;
+        *ppos = url_ftell(s->pb) - 4;
     }
-    len = get_be16(&s->pb);
+    len = get_be16(s->pb);
     pts =
     dts = AV_NOPTS_VALUE;
     /* stuffing */
     for(;;) {
         if (len < 1)
             goto error_redo;
-        c = get_byte(&s->pb);
+        c = get_byte(s->pb);
         len--;
         /* XXX: for mpeg1, should test only bit 7 */
         if (c != 0xff)
@@ -272,15 +301,15 @@
     }
     if ((c & 0xc0) == 0x40) {
         /* buffer scale & size */
-        get_byte(&s->pb);
-        c = get_byte(&s->pb);
+        get_byte(s->pb);
+        c = get_byte(s->pb);
         len -= 2;
     }
     if ((c & 0xe0) == 0x20) {
-        dts = pts = get_pts(&s->pb, c);
+        dts = pts = get_pts(s->pb, c);
         len -= 4;
         if (c & 0x10){
-            dts = get_pts(&s->pb, -1);
+            dts = get_pts(s->pb, -1);
             len -= 5;
         }
     } else if ((c & 0xc0) == 0x80) {
@@ -291,22 +320,22 @@
             goto redo;
         }
 #endif
-        flags = get_byte(&s->pb);
-        header_len = get_byte(&s->pb);
+        flags = get_byte(s->pb);
+        header_len = get_byte(s->pb);
         len -= 2;
         if (header_len > len)
             goto error_redo;
         len -= header_len;
         if (flags & 0x80) {
-            dts = pts = get_pts(&s->pb, -1);
+            dts = pts = get_pts(s->pb, -1);
             header_len -= 5;
             if (flags & 0x40) {
-                dts = get_pts(&s->pb, -1);
+                dts = get_pts(s->pb, -1);
                 header_len -= 5;
             }
         }
         if (flags & 0x01) { /* PES extension */
-            pes_ext = get_byte(&s->pb);
+            pes_ext = get_byte(s->pb);
             header_len--;
             if (pes_ext & 0x40) { /* pack header - should be zero in PS */
                 goto error_redo;
@@ -314,14 +343,14 @@
             /* Skip PES private data, program packet sequence counter and P-STD buffer */
             skip = (pes_ext >> 4) & 0xb;
             skip += skip & 0x9;
-            url_fskip(&s->pb, skip);
+            url_fskip(s->pb, skip);
             header_len -= skip;
 
             if (pes_ext & 0x01) { /* PES extension 2 */
-                ext2_len = get_byte(&s->pb);
+                ext2_len = get_byte(s->pb);
                 header_len--;
                 if ((ext2_len & 0x7f) > 0) {
-                    id_ext = get_byte(&s->pb);
+                    id_ext = get_byte(s->pb);
                     if ((id_ext & 0x80) == 0)
                         startcode = ((startcode & 0xff) << 8) | id_ext;
                     header_len--;
@@ -330,23 +359,23 @@
         }
         if(header_len < 0)
             goto error_redo;
-        url_fskip(&s->pb, header_len);
+        url_fskip(s->pb, header_len);
     }
     else if( c!= 0xf )
         goto redo;
 
     if (startcode == PRIVATE_STREAM_1 && !m->psm_es_type[startcode & 0xff]) {
-        startcode = get_byte(&s->pb);
+        startcode = get_byte(s->pb);
         len--;
         if (startcode >= 0x80 && startcode <= 0xcf) {
             /* audio: skip header */
-            get_byte(&s->pb);
-            get_byte(&s->pb);
-            get_byte(&s->pb);
+            get_byte(s->pb);
+            get_byte(s->pb);
+            get_byte(s->pb);
             len -= 3;
             if (startcode >= 0xb0 && startcode <= 0xbf) {
                 /* MLP/TrueHD audio has a 4-byte header */
-                get_byte(&s->pb);
+                get_byte(s->pb);
                 len--;
             }
         }
@@ -356,7 +385,9 @@
     if(dts != AV_NOPTS_VALUE && ppos){
         int i;
         for(i=0; i<s->nb_streams; i++){
-            if(startcode == s->streams[i]->id) {
+            if(startcode == s->streams[i]->id &&
+               !url_is_streamed(s->pb) /* index useless on streams anyway */) {
+                ff_reduce_index(s, i);
                 av_add_index_entry(s->streams[i], *ppos, dts, 0, 0, AVINDEX_KEYFRAME /* FIXME keyframe? */);
             }
         }
@@ -418,8 +449,8 @@
     } else if (startcode >= 0x1e0 && startcode <= 0x1ef) {
         static const unsigned char avs_seqh[4] = { 0, 0, 1, 0xb0 };
         unsigned char buf[8];
-        get_buffer(&s->pb, buf, 8);
-        url_fseek(&s->pb, -8, SEEK_CUR);
+        get_buffer(s->pb, buf, 8);
+        url_fseek(s->pb, -8, SEEK_CUR);
         if(!memcmp(buf, avs_seqh, 4) && (buf[6] != 0 || buf[7] != 1))
             codec_id = CODEC_ID_CAVS;
         else
@@ -427,7 +458,7 @@
         type = CODEC_TYPE_VIDEO;
     } else if (startcode >= 0x1c0 && startcode <= 0x1df) {
         type = CODEC_TYPE_AUDIO;
-        codec_id = CODEC_ID_MP2;
+        codec_id = m->sofdec > 0 ? CODEC_ID_ADPCM_ADX : CODEC_ID_MP2;
     } else if (startcode >= 0x80 && startcode <= 0x87) {
         type = CODEC_TYPE_AUDIO;
         codec_id = CODEC_ID_AC3;
@@ -455,7 +486,7 @@
     } else {
     skip:
         /* skip packet */
-        url_fskip(&s->pb, len);
+        url_fskip(s->pb, len);
         goto redo;
     }
     /* no stream found: add a new stream */
@@ -476,9 +507,9 @@
            audio data */
         if (len <= 3)
             goto skip;
-        get_byte(&s->pb); /* emphasis (1), muse(1), reserved(1), frame number(5) */
-        b1 = get_byte(&s->pb); /* quant (2), freq(2), reserved(1), channels(3) */
-        get_byte(&s->pb); /* dynamic range control (0x80 = off) */
+        get_byte(s->pb); /* emphasis (1), muse(1), reserved(1), frame number(5) */
+        b1 = get_byte(s->pb); /* quant (2), freq(2), reserved(1), channels(3) */
+        get_byte(s->pb); /* dynamic range control (0x80 = off) */
         len -= 3;
         freq = (b1 >> 4) & 3;
         st->codec->sample_rate = lpcm_freq_tab[freq];
@@ -486,7 +517,7 @@
         st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * 2;
     }
     av_new_packet(pkt, len);
-    get_buffer(&s->pb, pkt->data, pkt->size);
+    get_buffer(s->pb, pkt->data, pkt->size);
     pkt->pts = pts;
     pkt->dts = dts;
     pkt->stream_index = st->index;
@@ -513,7 +544,7 @@
 #ifdef DEBUG_SEEK
     printf("read_dts: pos=0x%"PRIx64" next=%d -> ", pos, find_next);
 #endif
-    url_fseek(&s->pb, pos, SEEK_SET);
+    url_fseek(s->pb, pos, SEEK_SET);
     for(;;) {
         len = mpegps_read_pes_header(s, &pos, &startcode, &pts, &dts);
         if (len < 0) {
@@ -526,7 +557,7 @@
             dts != AV_NOPTS_VALUE) {
             break;
         }
-        url_fskip(&s->pb, len);
+        url_fskip(s->pb, len);
     }
 #ifdef DEBUG_SEEK
     printf("pos=0x%"PRIx64" dts=0x%"PRIx64" %0.3f\n", pos, dts, dts / 90000.0);
diff -u mplayer-1.0~rc2-12/libavformat/mpegenc.c ffmpeg-free-0.svn20080206/libavformat/mpegenc.c
--- mplayer-1.0~rc2-12/libavformat/mpegenc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mpegenc.c	2008-01-31 01:27:51.000000000 +0100
@@ -299,9 +299,9 @@
     s->packet_number = 0;
     s->is_vcd =   (ENABLE_MPEG1VCD_MUXER  && ctx->oformat == &mpeg1vcd_muxer);
     s->is_svcd =  (ENABLE_MPEG2SVCD_MUXER && ctx->oformat == &mpeg2svcd_muxer);
-    s->is_mpeg2 = (ENABLE_MPEG2VOB_MUXER  && ctx->oformat == &mpeg2vob_muxer ||
-                   ENABLE_MPEG2DVD_MUXER  && ctx->oformat == &mpeg2dvd_muxer ||
-                   ENABLE_MPEG2SVCD_MUXER && ctx->oformat == &mpeg2svcd_muxer);
+    s->is_mpeg2 = ((ENABLE_MPEG2VOB_MUXER  && ctx->oformat == &mpeg2vob_muxer) ||
+                   (ENABLE_MPEG2DVD_MUXER  && ctx->oformat == &mpeg2dvd_muxer) ||
+                   (ENABLE_MPEG2SVCD_MUXER && ctx->oformat == &mpeg2svcd_muxer));
     s->is_dvd =   (ENABLE_MPEG2DVD_MUXER  && ctx->oformat == &mpeg2dvd_muxer);
 
     if(ctx->packet_size)
@@ -690,19 +690,19 @@
                     size = put_system_header(ctx, buf_ptr, 0);
                     buf_ptr += size;
                     size = buf_ptr - buffer;
-                    put_buffer(&ctx->pb, buffer, size);
+                    put_buffer(ctx->pb, buffer, size);
 
-                    put_be32(&ctx->pb, PRIVATE_STREAM_2);
-                    put_be16(&ctx->pb, 0x03d4);         // length
-                    put_byte(&ctx->pb, 0x00);           // substream ID, 00=PCI
+                    put_be32(ctx->pb, PRIVATE_STREAM_2);
+                    put_be16(ctx->pb, 0x03d4);         // length
+                    put_byte(ctx->pb, 0x00);           // substream ID, 00=PCI
                     for (i = 0; i < 979; i++)
-                        put_byte(&ctx->pb, 0x00);
+                        put_byte(ctx->pb, 0x00);
 
-                    put_be32(&ctx->pb, PRIVATE_STREAM_2);
-                    put_be16(&ctx->pb, 0x03fa);         // length
-                    put_byte(&ctx->pb, 0x01);           // substream ID, 01=DSI
+                    put_be32(ctx->pb, PRIVATE_STREAM_2);
+                    put_be16(ctx->pb, 0x03fa);         // length
+                    put_byte(ctx->pb, 0x01);           // substream ID, 01=DSI
                     for (i = 0; i < 1017; i++)
-                        put_byte(&ctx->pb, 0x00);
+                        put_byte(ctx->pb, 0x00);
 
                     memset(buffer, 0, 128);
                     buf_ptr = buffer;
@@ -725,7 +725,7 @@
         }
     }
     size = buf_ptr - buffer;
-    put_buffer(&ctx->pb, buffer, size);
+    put_buffer(ctx->pb, buffer, size);
 
     packet_size = s->packet_size - size;
 
@@ -830,16 +830,16 @@
 
         nb_frames= get_nb_frames(ctx, stream, payload_size - stuffing_size);
 
-        put_be32(&ctx->pb, startcode);
+        put_be32(ctx->pb, startcode);
 
-        put_be16(&ctx->pb, packet_size);
+        put_be16(ctx->pb, packet_size);
 
         if (!s->is_mpeg2)
             for(i=0;i<stuffing_size;i++)
-                put_byte(&ctx->pb, 0xff);
+                put_byte(ctx->pb, 0xff);
 
         if (s->is_mpeg2) {
-            put_byte(&ctx->pb, 0x80); /* mpeg2 id */
+            put_byte(ctx->pb, 0x80); /* mpeg2 id */
 
             pes_flags=0;
 
@@ -856,64 +856,64 @@
             if (stream->packet_number == 0)
                 pes_flags |= 0x01;
 
-            put_byte(&ctx->pb, pes_flags); /* flags */
-            put_byte(&ctx->pb, header_len - 3 + stuffing_size);
+            put_byte(ctx->pb, pes_flags); /* flags */
+            put_byte(ctx->pb, header_len - 3 + stuffing_size);
 
             if (pes_flags & 0x80)  /*write pts*/
-                put_timestamp(&ctx->pb, (pes_flags & 0x40) ? 0x03 : 0x02, pts);
+                put_timestamp(ctx->pb, (pes_flags & 0x40) ? 0x03 : 0x02, pts);
             if (pes_flags & 0x40)  /*write dts*/
-                put_timestamp(&ctx->pb, 0x01, dts);
+                put_timestamp(ctx->pb, 0x01, dts);
 
             if (pes_flags & 0x01) {  /*write pes extension*/
-                put_byte(&ctx->pb, 0x10); /* flags */
+                put_byte(ctx->pb, 0x10); /* flags */
 
                 /* P-STD buffer info */
                 if (id == AUDIO_ID)
-                    put_be16(&ctx->pb, 0x4000 | stream->max_buffer_size/128);
+                    put_be16(ctx->pb, 0x4000 | stream->max_buffer_size/128);
                 else
-                    put_be16(&ctx->pb, 0x6000 | stream->max_buffer_size/1024);
+                    put_be16(ctx->pb, 0x6000 | stream->max_buffer_size/1024);
             }
 
         } else {
             if (pts != AV_NOPTS_VALUE) {
                 if (dts != pts) {
-                    put_timestamp(&ctx->pb, 0x03, pts);
-                    put_timestamp(&ctx->pb, 0x01, dts);
+                    put_timestamp(ctx->pb, 0x03, pts);
+                    put_timestamp(ctx->pb, 0x01, dts);
                 } else {
-                    put_timestamp(&ctx->pb, 0x02, pts);
+                    put_timestamp(ctx->pb, 0x02, pts);
                 }
             } else {
-                put_byte(&ctx->pb, 0x0f);
+                put_byte(ctx->pb, 0x0f);
             }
         }
 
         if (s->is_mpeg2) {
             /* special stuffing byte that is always written
                to prevent accidental generation of start codes. */
-            put_byte(&ctx->pb, 0xff);
+            put_byte(ctx->pb, 0xff);
 
             for(i=0;i<stuffing_size;i++)
-                put_byte(&ctx->pb, 0xff);
+                put_byte(ctx->pb, 0xff);
         }
 
         if (startcode == PRIVATE_STREAM_1) {
-            put_byte(&ctx->pb, id);
+            put_byte(ctx->pb, id);
             if (id >= 0xa0) {
                 /* LPCM (XXX: check nb_frames) */
-                put_byte(&ctx->pb, 7);
-                put_be16(&ctx->pb, 4); /* skip 3 header bytes */
-                put_byte(&ctx->pb, stream->lpcm_header[0]);
-                put_byte(&ctx->pb, stream->lpcm_header[1]);
-                put_byte(&ctx->pb, stream->lpcm_header[2]);
+                put_byte(ctx->pb, 7);
+                put_be16(ctx->pb, 4); /* skip 3 header bytes */
+                put_byte(ctx->pb, stream->lpcm_header[0]);
+                put_byte(ctx->pb, stream->lpcm_header[1]);
+                put_byte(ctx->pb, stream->lpcm_header[2]);
             } else if (id >= 0x40) {
                 /* AC3 */
-                put_byte(&ctx->pb, nb_frames);
-                put_be16(&ctx->pb, trailer_size+1);
+                put_byte(ctx->pb, nb_frames);
+                put_be16(ctx->pb, trailer_size+1);
             }
         }
 
         /* output data */
-        if(av_fifo_generic_read(&stream->fifo, payload_size - stuffing_size, &put_buffer, &ctx->pb) < 0)
+        if(av_fifo_generic_read(&stream->fifo, payload_size - stuffing_size, &put_buffer, ctx->pb) < 0)
             return -1;
         stream->bytes_to_iframe -= payload_size - stuffing_size;
     }else{
@@ -922,12 +922,12 @@
     }
 
     if (pad_packet_bytes > 0)
-        put_padding_packet(ctx,&ctx->pb, pad_packet_bytes);
+        put_padding_packet(ctx,ctx->pb, pad_packet_bytes);
 
     for(i=0;i<zero_trail_bytes;i++)
-        put_byte(&ctx->pb, 0x00);
+        put_byte(ctx->pb, 0x00);
 
-    put_flush_packet(&ctx->pb);
+    put_flush_packet(ctx->pb);
 
     s->packet_number++;
 
@@ -952,11 +952,11 @@
     int i;
 
     for(i=0;i<s->packet_size;i++)
-        put_byte(&ctx->pb, 0);
+        put_byte(ctx->pb, 0);
 
     s->vcd_padding_bytes_written += s->packet_size;
 
-    put_flush_packet(&ctx->pb);
+    put_flush_packet(ctx->pb);
 
     /* increasing the packet number is correct. The SCR of the following packs
        is calculated from the packet_number and it has to include the padding
@@ -1019,7 +1019,7 @@
     MpegMuxContext *s = ctx->priv_data;
     AVStream *st;
     StreamInfo *stream;
-    int i, avail_space, es_size, trailer_size;
+    int i, avail_space=0, es_size, trailer_size;
     int best_i= -1;
     int best_score= INT_MIN;
     int ignore_constraints=0;
@@ -1206,8 +1206,8 @@
     /* End header according to MPEG1 systems standard. We do not write
        it as it is usually not needed by decoders and because it
        complicates MPEG stream concatenation. */
-    //put_be32(&ctx->pb, ISO_11172_END_CODE);
-    //put_flush_packet(&ctx->pb);
+    //put_be32(ctx->pb, ISO_11172_END_CODE);
+    //put_flush_packet(ctx->pb);
 
     for(i=0;i<ctx->nb_streams;i++) {
         stream = ctx->streams[i]->priv_data;
diff -u mplayer-1.0~rc2-12/libavformat/mpeg.h ffmpeg-free-0.svn20080206/libavformat/mpeg.h
--- mplayer-1.0~rc2-12/libavformat/mpeg.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mpeg.h	2008-01-08 00:32:57.000000000 +0100
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVFORMAT_MPEG_H
-#define AVFORMAT_MPEG_H
+#ifndef FFMPEG_MPEG_H
+#define FFMPEG_MPEG_H
 
 #define PACK_START_CODE             ((unsigned int)0x000001ba)
 #define SYSTEM_HEADER_START_CODE    ((unsigned int)0x000001bb)
@@ -57,4 +57,13 @@
 
 static const int lpcm_freq_tab[4] = { 48000, 96000, 44100, 32000 };
 
-#endif /* AVFORMAT_MPEG_H */
+/**
+ * Parse MPEG-PES five-byte timestamp
+ */
+static inline int64_t ff_parse_pes_pts(uint8_t *buf) {
+    return (int64_t)(*buf & 0x0e) << 29 |
+            (AV_RB16(buf+1) >> 1) << 15 |
+             AV_RB16(buf+3) >> 1;
+}
+
+#endif /* FFMPEG_MPEG_H */
diff -u mplayer-1.0~rc2-12/libavformat/mpegts.c ffmpeg-free-0.svn20080206/libavformat/mpegts.c
--- mplayer-1.0~rc2-12/libavformat/mpegts.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mpegts.c	2008-01-05 00:09:58.000000000 +0100
@@ -37,6 +37,7 @@
 static PESContext* add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type);
 static AVStream* new_pes_av_stream(PESContext *pes, uint32_t code);
 extern void av_set_program_name(AVProgram *program, char *provider_name, char *name);
+extern void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx);
 
 enum MpegTSFilterType {
     MPEGTS_PES,
@@ -261,7 +262,8 @@
     if (tss->section_h_size != -1 && tss->section_index >= tss->section_h_size) {
         tss->end_of_section_reached = 1;
         if (!tss->check_crc ||
-            av_crc(av_crc04C11DB7, -1, tss->section_buf, tss->section_h_size) == 0)
+            av_crc(av_crc_get_table(AV_CRC_32_IEEE), -1,
+                   tss->section_buf, tss->section_h_size) == 0)
             tss->section_cb(tss1, tss->section_buf, tss->section_h_size);
     }
 }
@@ -587,16 +589,18 @@
         case STREAM_TYPE_AUDIO_AC3:
         case STREAM_TYPE_AUDIO_DTS:
         case STREAM_TYPE_SUBTITLE_DVB:
-            if(ts->pids[pid]){
-                assert(ts->pids[pid]->type == MPEGTS_PES);
+            if(ts->pids[pid] && ts->pids[pid]->type == MPEGTS_PES){
                 pes= ts->pids[pid]->u.pes_filter.opaque;
                 st= pes->st;
             }else{
+                if (ts->pids[pid]) mpegts_close_filter(ts, ts->pids[pid]); //wrongly added sdt filter probably
                 pes = add_pes_stream(ts, pid, pcr_pid, stream_type);
                 if (pes)
                     st = new_pes_av_stream(pes, 0);
             }
             add_pid_to_pmt(ts, h->id, pid);
+            if(st)
+                av_program_add_stream_index(ts->stream, h->id, st->index);
             break;
         default:
             /* we ignore the other streams */
@@ -1095,7 +1099,7 @@
 static int handle_packets(MpegTSContext *ts, int nb_packets)
 {
     AVFormatContext *s = ts->stream;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     uint8_t packet[TS_PACKET_SIZE];
     int packet_num, ret;
 
@@ -1177,7 +1181,7 @@
                               AVFormatParameters *ap)
 {
     MpegTSContext *ts = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     uint8_t buf[1024];
     int len;
     int64_t pos;
@@ -1240,7 +1244,7 @@
         nb_pcrs = 0;
         nb_packets = 0;
         for(;;) {
-            ret = read_packet(&s->pb, packet, ts->raw_packet_size);
+            ret = read_packet(s->pb, packet, ts->raw_packet_size);
             if (ret < 0)
                 return -1;
             pid = AV_RB16(packet + 1) & 0x1fff;
@@ -1288,8 +1292,8 @@
 
     if (av_new_packet(pkt, TS_PACKET_SIZE) < 0)
         return AVERROR(ENOMEM);
-    pkt->pos= url_ftell(&s->pb);
-    ret = read_packet(&s->pb, pkt->data, ts->raw_packet_size);
+    pkt->pos= url_ftell(s->pb);
+    ret = read_packet(s->pb, pkt->data, ts->raw_packet_size);
     if (ret < 0) {
         av_free_packet(pkt);
         return ret;
@@ -1298,10 +1302,10 @@
         /* compute exact PCR for each packet */
         if (parse_pcr(&pcr_h, &pcr_l, pkt->data) == 0) {
             /* we read the next PCR (XXX: optimize it by using a bigger buffer */
-            pos = url_ftell(&s->pb);
+            pos = url_ftell(s->pb);
             for(i = 0; i < MAX_PACKET_READAHEAD; i++) {
-                url_fseek(&s->pb, pos + i * ts->raw_packet_size, SEEK_SET);
-                get_buffer(&s->pb, pcr_buf, 12);
+                url_fseek(s->pb, pos + i * ts->raw_packet_size, SEEK_SET);
+                get_buffer(s->pb, pcr_buf, 12);
                 if (parse_pcr(&next_pcr_h, &next_pcr_l, pcr_buf) == 0) {
                     /* XXX: not precise enough */
                     ts->pcr_incr = ((next_pcr_h - pcr_h) * 300 + (next_pcr_l - pcr_l)) /
@@ -1309,7 +1313,7 @@
                     break;
                 }
             }
-            url_fseek(&s->pb, pos, SEEK_SET);
+            url_fseek(s->pb, pos, SEEK_SET);
             /* no next PCR found: we use previous increment */
             ts->cur_pcr = pcr_h * 300 + pcr_l;
         }
@@ -1351,8 +1355,8 @@
     pos = ((*ppos  + ts->raw_packet_size - 1) / ts->raw_packet_size) * ts->raw_packet_size;
     if (find_next) {
         for(;;) {
-            url_fseek(&s->pb, pos, SEEK_SET);
-            if (get_buffer(&s->pb, buf, TS_PACKET_SIZE) != TS_PACKET_SIZE)
+            url_fseek(s->pb, pos, SEEK_SET);
+            if (get_buffer(s->pb, buf, TS_PACKET_SIZE) != TS_PACKET_SIZE)
                 return AV_NOPTS_VALUE;
             if ((pcr_pid < 0 || (AV_RB16(buf + 1) & 0x1fff) == pcr_pid) &&
                 parse_pcr(&timestamp, &pcr_l, buf) == 0) {
@@ -1365,8 +1369,8 @@
             pos -= ts->raw_packet_size;
             if (pos < 0)
                 return AV_NOPTS_VALUE;
-            url_fseek(&s->pb, pos, SEEK_SET);
-            if (get_buffer(&s->pb, buf, TS_PACKET_SIZE) != TS_PACKET_SIZE)
+            url_fseek(s->pb, pos, SEEK_SET);
+            if (get_buffer(s->pb, buf, TS_PACKET_SIZE) != TS_PACKET_SIZE)
                 return AV_NOPTS_VALUE;
             if ((pcr_pid < 0 || (AV_RB16(buf + 1) & 0x1fff) == pcr_pid) &&
                 parse_pcr(&timestamp, &pcr_l, buf) == 0) {
@@ -1387,17 +1391,17 @@
     if(av_seek_frame_binary(s, stream_index, target_ts, flags) < 0)
         return -1;
 
-    pos= url_ftell(&s->pb);
+    pos= url_ftell(s->pb);
 
     for(;;) {
-        url_fseek(&s->pb, pos, SEEK_SET);
-        if (get_buffer(&s->pb, buf, TS_PACKET_SIZE) != TS_PACKET_SIZE)
+        url_fseek(s->pb, pos, SEEK_SET);
+        if (get_buffer(s->pb, buf, TS_PACKET_SIZE) != TS_PACKET_SIZE)
             return -1;
 //        pid = AV_RB16(buf + 1) & 0x1fff;
         if(buf[1] & 0x40) break;
         pos += ts->raw_packet_size;
     }
-    url_fseek(&s->pb, pos, SEEK_SET);
+    url_fseek(s->pb, pos, SEEK_SET);
 
     return 0;
 }
diff -u mplayer-1.0~rc2-12/libavformat/mpegtsenc.c ffmpeg-free-0.svn20080206/libavformat/mpegtsenc.c
--- mplayer-1.0~rc2-12/libavformat/mpegtsenc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mpegtsenc.c	2008-01-05 00:09:58.000000000 +0100
@@ -43,7 +43,7 @@
     unsigned char *q;
     int first, b, len1, left;
 
-    crc = bswap_32(av_crc(av_crc04C11DB7, -1, buf, len - 4));
+    crc = bswap_32(av_crc(av_crc_get_table(AV_CRC_32_IEEE), -1, buf, len - 4));
     buf[len - 4] = (crc >> 24) & 0xff;
     buf[len - 3] = (crc >> 16) & 0xff;
     buf[len - 2] = (crc >> 8) & 0xff;
@@ -353,7 +353,7 @@
 static void section_write_packet(MpegTSSection *s, const uint8_t *packet)
 {
     AVFormatContext *ctx = s->opaque;
-    put_buffer(&ctx->pb, packet, TS_PACKET_SIZE);
+    put_buffer(ctx->pb, packet, TS_PACKET_SIZE);
 }
 
 static int mpegts_write_header(AVFormatContext *s)
@@ -431,7 +431,7 @@
     for(i = 0; i < ts->nb_services; i++) {
         mpegts_write_pmt(s, ts->services[i]);
     }
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
 
     return 0;
 
@@ -608,9 +608,9 @@
         memcpy(buf + TS_PACKET_SIZE - len, payload, len);
         payload += len;
         payload_size -= len;
-        put_buffer(&s->pb, buf, TS_PACKET_SIZE);
+        put_buffer(s->pb, buf, TS_PACKET_SIZE);
     }
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
 }
 
 static int mpegts_write_packet(AVFormatContext *s, AVPacket *pkt)
@@ -668,7 +668,7 @@
                              ts_st->payload_pts, ts_st->payload_dts);
         }
     }
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
 
     for(i = 0; i < ts->nb_services; i++) {
         service = ts->services[i];
diff -u mplayer-1.0~rc2-12/libavformat/mpegts.h ffmpeg-free-0.svn20080206/libavformat/mpegts.h
--- mplayer-1.0~rc2-12/libavformat/mpegts.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mpegts.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVFORMAT_MPEGTS_H
-#define AVFORMAT_MPEGTS_H
+#ifndef FFMPEG_MPEGTS_H
+#define FFMPEG_MPEGTS_H
 
 #include "avformat.h"
 
@@ -65,4 +65,4 @@
                         const uint8_t *buf, int len);
 void mpegts_parse_close(MpegTSContext *ts);
 
-#endif /* AVFORMAT_MPEGTS_H */
+#endif /* FFMPEG_MPEGTS_H */
diff -u mplayer-1.0~rc2-12/libavformat/mpjpeg.c ffmpeg-free-0.svn20080206/libavformat/mpjpeg.c
--- mplayer-1.0~rc2-12/libavformat/mpjpeg.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mpjpeg.c	2007-11-21 08:41:00.000000000 +0100
@@ -29,8 +29,8 @@
     uint8_t buf1[256];
 
     snprintf(buf1, sizeof(buf1), "--%s\n", BOUNDARY_TAG);
-    put_buffer(&s->pb, buf1, strlen(buf1));
-    put_flush_packet(&s->pb);
+    put_buffer(s->pb, buf1, strlen(buf1));
+    put_flush_packet(s->pb);
     return 0;
 }
 
@@ -39,12 +39,12 @@
     uint8_t buf1[256];
 
     snprintf(buf1, sizeof(buf1), "Content-type: image/jpeg\n\n");
-    put_buffer(&s->pb, buf1, strlen(buf1));
-    put_buffer(&s->pb, pkt->data, pkt->size);
+    put_buffer(s->pb, buf1, strlen(buf1));
+    put_buffer(s->pb, pkt->data, pkt->size);
 
     snprintf(buf1, sizeof(buf1), "\n--%s\n", BOUNDARY_TAG);
-    put_buffer(&s->pb, buf1, strlen(buf1));
-    put_flush_packet(&s->pb);
+    put_buffer(s->pb, buf1, strlen(buf1));
+    put_flush_packet(s->pb);
     return 0;
 }
 
diff -u mplayer-1.0~rc2-12/libavformat/mtv.c ffmpeg-free-0.svn20080206/libavformat/mtv.c
--- mplayer-1.0~rc2-12/libavformat/mtv.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mtv.c	2007-11-21 08:41:00.000000000 +0100
@@ -65,7 +65,7 @@
 static int mtv_read_header(AVFormatContext *s, AVFormatParameters *ap)
 {
     MTVDemuxContext    *mtv = s->priv_data;
-    ByteIOContext      *pb  = &s->pb;
+    ByteIOContext      *pb  = s->pb;
     AVStream           *st;
 
 
@@ -131,7 +131,7 @@
 static int mtv_read_packet(AVFormatContext *s, AVPacket *pkt)
 {
     MTVDemuxContext *mtv = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int ret;
 #ifndef WORDS_BIGENDIAN
     int i;
diff -u mplayer-1.0~rc2-12/libavformat/mxf.c ffmpeg-free-0.svn20080206/libavformat/mxf.c
--- mplayer-1.0~rc2-12/libavformat/mxf.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/mxf.c	2008-02-01 15:58:35.000000000 +0100
@@ -67,7 +67,6 @@
 typedef struct {
     UID uid;
     enum MXFMetadataSetType type;
-    UID context_uid;
     UID source_container_ul;
 } MXFCryptoContext;
 
@@ -140,6 +139,8 @@
     int metadata_sets_count;
     AVFormatContext *fc;
     struct AVAES *aesc;
+    uint8_t *local_tags;
+    int local_tags_count;
 } MXFContext;
 
 typedef struct {
@@ -155,8 +156,8 @@
 
 typedef struct {
     UID uid;
+    unsigned matching_len;
     enum CodecID id;
-    enum MXFWrappingScheme wrapping;
 } MXFCodecUL;
 
 typedef struct {
@@ -176,8 +177,10 @@
 static const uint8_t mxf_essence_element_key[]             = { 0x06,0x0e,0x2b,0x34,0x01,0x02,0x01,0x01,0x0d,0x01,0x03,0x01 };
 static const uint8_t mxf_klv_key[]                         = { 0x06,0x0e,0x2b,0x34 };
 /* complete keys to match */
+static const uint8_t mxf_crypto_source_container_ul[]      = { 0x06,0x0e,0x2b,0x34,0x01,0x01,0x01,0x09,0x06,0x01,0x01,0x02,0x02,0x00,0x00,0x00 };
 static const uint8_t mxf_encrypted_triplet_key[]           = { 0x06,0x0e,0x2b,0x34,0x02,0x04,0x01,0x07,0x0d,0x01,0x03,0x01,0x02,0x7e,0x01,0x00 };
 static const uint8_t mxf_encrypted_essence_container[]     = { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x07,0x0d,0x01,0x03,0x01,0x02,0x0b,0x01,0x00 };
+static const uint8_t mxf_sony_mpeg4_extradata[]            = { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0e,0x06,0x06,0x02,0x02,0x01,0x00,0x00 };
 
 #define IS_KLV_KEY(x, y) (!memcmp(x, y, sizeof(y)))
 
@@ -241,7 +244,8 @@
 static int mxf_get_d10_aes3_packet(ByteIOContext *pb, AVStream *st, AVPacket *pkt, int64_t length)
 {
     uint8_t buffer[61444];
-    uint8_t *buf_ptr, *end_ptr, *data_ptr;
+    const uint8_t *buf_ptr, *end_ptr;
+    uint8_t *data_ptr;
     int i;
 
     if (length > 61444) /* worst case PAL 1920 samples 8 channels */
@@ -269,7 +273,7 @@
 {
     static const uint8_t checkv[16] = {0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b};
     MXFContext *mxf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     offset_t end = url_ftell(pb) + klv->length;
     uint64_t size;
     uint64_t orig_size;
@@ -280,6 +284,8 @@
 
     if (!mxf->aesc && s->key && s->keylen == 16) {
         mxf->aesc = av_malloc(av_aes_size);
+        if (!mxf->aesc)
+            return -1;
         av_aes_init(mxf->aesc, s->key, 128, 1);
     }
     // crypto context
@@ -326,8 +332,8 @@
 {
     KLVPacket klv;
 
-    while (!url_feof(&s->pb)) {
-        if (klv_read_packet(&klv, &s->pb) < 0)
+    while (!url_feof(s->pb)) {
+        if (klv_read_packet(&klv, s->pb) < 0)
             return -1;
 #ifdef DEBUG
         PRINT_KEY(s, "read packet", klv.key);
@@ -344,48 +350,66 @@
             int index = mxf_get_stream_index(s, &klv);
             if (index < 0) {
                 av_log(s, AV_LOG_ERROR, "error getting stream index\n");
-                url_fskip(&s->pb, klv.length);
+                url_fskip(s->pb, klv.length);
                 return -1;
             }
             /* check for 8 channels AES3 element */
             if (klv.key[12] == 0x06 && klv.key[13] == 0x01 && klv.key[14] == 0x10) {
-                if (mxf_get_d10_aes3_packet(&s->pb, s->streams[index], pkt, klv.length) < 0) {
+                if (mxf_get_d10_aes3_packet(s->pb, s->streams[index], pkt, klv.length) < 0) {
                     av_log(s, AV_LOG_ERROR, "error reading D-10 aes3 frame\n");
                     return -1;
                 }
             } else
-                av_get_packet(&s->pb, pkt, klv.length);
+                av_get_packet(s->pb, pkt, klv.length);
             pkt->stream_index = index;
             pkt->pos = klv.offset;
             return 0;
         } else
-            url_fskip(&s->pb, klv.length);
+            url_fskip(s->pb, klv.length);
     }
     return AVERROR(EIO);
 }
 
+static int mxf_read_primer_pack(MXFContext *mxf)
+{
+    ByteIOContext *pb = mxf->fc->pb;
+    int item_num = get_be32(pb);
+    int item_len = get_be32(pb);
+
+    if (item_len != 18) {
+        av_log(mxf->fc, AV_LOG_ERROR, "unsupported primer pack item length\n");
+        return -1;
+    }
+    if (item_num > UINT_MAX / item_len)
+        return -1;
+    mxf->local_tags_count = item_num;
+    mxf->local_tags = av_malloc(item_num*item_len);
+    if (!mxf->local_tags)
+        return -1;
+    get_buffer(pb, mxf->local_tags, item_num*item_len);
+    return 0;
+}
+
 static int mxf_add_metadata_set(MXFContext *mxf, void *metadata_set)
 {
     mxf->metadata_sets = av_realloc(mxf->metadata_sets, (mxf->metadata_sets_count + 1) * sizeof(*mxf->metadata_sets));
+    if (!mxf->metadata_sets)
+        return -1;
     mxf->metadata_sets[mxf->metadata_sets_count] = metadata_set;
     mxf->metadata_sets_count++;
     return 0;
 }
 
-static int mxf_read_metadata_cryptographic_context(MXFCryptoContext *cryptocontext, ByteIOContext *pb, int tag)
+static int mxf_read_cryptographic_context(MXFCryptoContext *cryptocontext, ByteIOContext *pb, int tag, int size, UID uid)
 {
-    switch(tag) {
-    case 0xFFFE:
-        get_buffer(pb, cryptocontext->context_uid, 16);
-        break;
-    case 0xFFFD:
+    if (size != 16)
+        return -1;
+    if (IS_KLV_KEY(uid, mxf_crypto_source_container_ul))
         get_buffer(pb, cryptocontext->source_container_ul, 16);
-        break;
-    }
     return 0;
 }
 
-static int mxf_read_metadata_content_storage(MXFContext *mxf, ByteIOContext *pb, int tag)
+static int mxf_read_content_storage(MXFContext *mxf, ByteIOContext *pb, int tag)
 {
     switch (tag) {
     case 0x1901:
@@ -393,6 +417,8 @@
         if (mxf->packages_count >= UINT_MAX / sizeof(UID))
             return -1;
         mxf->packages_refs = av_malloc(mxf->packages_count * sizeof(UID));
+        if (!mxf->packages_refs)
+            return -1;
         url_fskip(pb, 4); /* useless size of objects, always 16 according to specs */
         get_buffer(pb, (uint8_t *)mxf->packages_refs, mxf->packages_count * sizeof(UID));
         break;
@@ -400,7 +426,7 @@
     return 0;
 }
 
-static int mxf_read_metadata_source_clip(MXFStructuralComponent *source_clip, ByteIOContext *pb, int tag)
+static int mxf_read_source_clip(MXFStructuralComponent *source_clip, ByteIOContext *pb, int tag)
 {
     switch(tag) {
     case 0x0202:
@@ -421,7 +447,7 @@
     return 0;
 }
 
-static int mxf_read_metadata_material_package(MXFPackage *package, ByteIOContext *pb, int tag)
+static int mxf_read_material_package(MXFPackage *package, ByteIOContext *pb, int tag)
 {
     switch(tag) {
     case 0x4403:
@@ -429,6 +455,8 @@
         if (package->tracks_count >= UINT_MAX / sizeof(UID))
             return -1;
         package->tracks_refs = av_malloc(package->tracks_count * sizeof(UID));
+        if (!package->tracks_refs)
+            return -1;
         url_fskip(pb, 4); /* useless size of objects, always 16 according to specs */
         get_buffer(pb, (uint8_t *)package->tracks_refs, package->tracks_count * sizeof(UID));
         break;
@@ -436,7 +464,7 @@
     return 0;
 }
 
-static int mxf_read_metadata_track(MXFTrack *track, ByteIOContext *pb, int tag)
+static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)
 {
     switch(tag) {
     case 0x4801:
@@ -456,7 +484,7 @@
     return 0;
 }
 
-static int mxf_read_metadata_sequence(MXFSequence *sequence, ByteIOContext *pb, int tag)
+static int mxf_read_sequence(MXFSequence *sequence, ByteIOContext *pb, int tag)
 {
     switch(tag) {
     case 0x0202:
@@ -470,6 +498,8 @@
         if (sequence->structural_components_count >= UINT_MAX / sizeof(UID))
             return -1;
         sequence->structural_components_refs = av_malloc(sequence->structural_components_count * sizeof(UID));
+        if (!sequence->structural_components_refs)
+            return -1;
         url_fskip(pb, 4); /* useless size of objects, always 16 according to specs */
         get_buffer(pb, (uint8_t *)sequence->structural_components_refs, sequence->structural_components_count * sizeof(UID));
         break;
@@ -477,7 +507,7 @@
     return 0;
 }
 
-static int mxf_read_metadata_source_package(MXFPackage *package, ByteIOContext *pb, int tag)
+static int mxf_read_source_package(MXFPackage *package, ByteIOContext *pb, int tag)
 {
     switch(tag) {
     case 0x4403:
@@ -485,6 +515,8 @@
         if (package->tracks_count >= UINT_MAX / sizeof(UID))
             return -1;
         package->tracks_refs = av_malloc(package->tracks_count * sizeof(UID));
+        if (!package->tracks_refs)
+            return -1;
         url_fskip(pb, 4); /* useless size of objects, always 16 according to specs */
         get_buffer(pb, (uint8_t *)package->tracks_refs, package->tracks_count * sizeof(UID));
         break;
@@ -500,7 +532,7 @@
     return 0;
 }
 
-static void mxf_read_metadata_pixel_layout(ByteIOContext *pb, MXFDescriptor *descriptor)
+static void mxf_read_pixel_layout(ByteIOContext *pb, MXFDescriptor *descriptor)
 {
     int code;
 
@@ -523,7 +555,7 @@
     } while (code != 0); /* SMPTE 377M E.2.46 */
 }
 
-static int mxf_read_metadata_generic_descriptor(MXFDescriptor *descriptor, ByteIOContext *pb, int tag, int size)
+static int mxf_read_generic_descriptor(MXFDescriptor *descriptor, ByteIOContext *pb, int tag, int size, UID uid)
 {
     switch(tag) {
     case 0x3F01:
@@ -531,6 +563,8 @@
         if (descriptor->sub_descriptors_count >= UINT_MAX / sizeof(UID))
             return -1;
         descriptor->sub_descriptors_refs = av_malloc(descriptor->sub_descriptors_count * sizeof(UID));
+        if (!descriptor->sub_descriptors_refs)
+            return -1;
         url_fskip(pb, 4); /* useless size of objects, always 16 according to specs */
         get_buffer(pb, (uint8_t *)descriptor->sub_descriptors_refs, descriptor->sub_descriptors_count * sizeof(UID));
         break;
@@ -567,12 +601,17 @@
         descriptor->bits_per_sample = get_be32(pb);
         break;
     case 0x3401:
-        mxf_read_metadata_pixel_layout(pb, descriptor);
+        mxf_read_pixel_layout(pb, descriptor);
         break;
-    case 0x8201: /* Private tag used by SONY C0023S01.mxf */
-        descriptor->extradata = av_malloc(size);
-        descriptor->extradata_size = size;
-        get_buffer(pb, descriptor->extradata, size);
+    default:
+        /* Private uid used by SONY C0023S01.mxf */
+        if (IS_KLV_KEY(uid, mxf_sony_mpeg4_extradata)) {
+            descriptor->extradata = av_malloc(size);
+            if (!descriptor->extradata)
+                return -1;
+            descriptor->extradata_size = size;
+            get_buffer(pb, descriptor->extradata, size);
+        }
         break;
     }
     return 0;
@@ -588,64 +627,36 @@
 
 static const MXFCodecUL mxf_codec_uls[] = {
     /* PictureEssenceCoding */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x03,0x04,0x01,0x02,0x02,0x01,0x01,0x11,0x00 }, CODEC_ID_MPEG2VIDEO, Frame }, /* MP@ML Long GoP */
-
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x01,0x02,0x02,0x01,0x02,0x01,0x05 }, CODEC_ID_MPEG2VIDEO, Frame }, /* D-10 30Mbps PAL */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x01,0x02,0x02,0x01,0x02,0x01,0x03 }, CODEC_ID_MPEG2VIDEO, Frame }, /* D-10 40Mbps PAL */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x01,0x02,0x02,0x01,0x02,0x01,0x01 }, CODEC_ID_MPEG2VIDEO, Frame }, /* D-10 50Mbps PAL */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x01,0x02,0x02,0x01,0x02,0x01,0x06 }, CODEC_ID_MPEG2VIDEO, Frame }, /* D-10 30Mbps NTSC */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x01,0x02,0x02,0x01,0x02,0x01,0x04 }, CODEC_ID_MPEG2VIDEO, Frame }, /* D-10 40Mbps NTSC */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x01,0x02,0x02,0x01,0x02,0x01,0x02 }, CODEC_ID_MPEG2VIDEO, Frame }, /* D-10 50Mbps NTSC */
-
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x03,0x04,0x01,0x02,0x02,0x01,0x02,0x02,0x00 }, CODEC_ID_MPEG2VIDEO, Frame }, /* 422P@ML I-Frame */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x03,0x04,0x01,0x02,0x02,0x01,0x02,0x03,0x00 }, CODEC_ID_MPEG2VIDEO, Frame }, /* 422P@ML Long GoP */
-
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x03,0x04,0x01,0x02,0x02,0x01,0x03,0x03,0x00 }, CODEC_ID_MPEG2VIDEO, Frame }, /* MP@HL Long GoP */
-
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x03,0x04,0x01,0x02,0x02,0x01,0x04,0x02,0x00 }, CODEC_ID_MPEG2VIDEO, Frame }, /* 422P@HL I-Frame */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x03,0x04,0x01,0x02,0x02,0x01,0x04,0x03,0x00 }, CODEC_ID_MPEG2VIDEO, Frame }, /* 422P@HL Long GoP */
-
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x03,0x04,0x01,0x02,0x02,0x01,0x20,0x02,0x03 },      CODEC_ID_MPEG4, Frame }, /* XDCAM proxy_pal030926.mxf */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x03,0x04,0x01,0x02,0x02,0x01,0x20,0x02,0x04 },      CODEC_ID_MPEG4, Frame }, /* XDCAM Proxy C0023S01.mxf */
-
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x01,0x02,0x02,0x02,0x01,0x02,0x00 },    CODEC_ID_DVVIDEO, Frame }, /* DV25 IEC PAL */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x01,0x02,0x02,0x02,0x02,0x02,0x00 },    CODEC_ID_DVVIDEO, Frame }, /* DVCPRO25 PAL */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x01,0x02,0x02,0x02,0x02,0x04,0x00 },    CODEC_ID_DVVIDEO, Frame }, /* DVCPRO50 PAL */
-
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x07,0x04,0x01,0x02,0x02,0x03,0x01,0x01,0x00 },   CODEC_ID_JPEG2000, Frame }, /* JPEG2000 Codestream */
-
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x01,0x02,0x01,0x7F,0x00,0x00,0x00 },   CODEC_ID_RAWVIDEO, Frame }, /* Uncompressed */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x03,0x04,0x01,0x02,0x02,0x01,0x01,0x11,0x00 }, 14, CODEC_ID_MPEG2VIDEO }, /* MP@ML Long GoP */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x01,0x02,0x02,0x01,0x02,0x01,0x01 }, 14, CODEC_ID_MPEG2VIDEO }, /* D-10 50Mbps PAL */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x03,0x04,0x01,0x02,0x02,0x01,0x03,0x03,0x00 }, 14, CODEC_ID_MPEG2VIDEO }, /* MP@HL Long GoP */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x03,0x04,0x01,0x02,0x02,0x01,0x04,0x02,0x00 }, 14, CODEC_ID_MPEG2VIDEO }, /* 422P@HL I-Frame */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x03,0x04,0x01,0x02,0x02,0x01,0x20,0x02,0x03 }, 14,      CODEC_ID_MPEG4 }, /* XDCAM proxy_pal030926.mxf */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x01,0x02,0x02,0x02,0x01,0x02,0x00 }, 13,    CODEC_ID_DVVIDEO }, /* DV25 IEC PAL */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x07,0x04,0x01,0x02,0x02,0x03,0x01,0x01,0x00 }, 14,   CODEC_ID_JPEG2000 }, /* JPEG2000 Codestream */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x01,0x02,0x01,0x7F,0x00,0x00,0x00 }, 13,   CODEC_ID_RAWVIDEO }, /* Uncompressed */
     /* SoundEssenceCompression */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x02,0x02,0x01,0x00,0x00,0x00,0x00 },  CODEC_ID_PCM_S16LE, Frame }, /* Uncompressed */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x02,0x02,0x01,0x7F,0x00,0x00,0x00 },  CODEC_ID_PCM_S16LE, Frame },
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x07,0x04,0x02,0x02,0x01,0x7E,0x00,0x00,0x00 },  CODEC_ID_PCM_S16BE, Frame }, /* From Omneon MXF file */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x04,0x04,0x02,0x02,0x02,0x03,0x01,0x01,0x00 },   CODEC_ID_PCM_ALAW, Frame }, /* XDCAM Proxy C0023S01.mxf */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x02,0x02,0x02,0x03,0x02,0x01,0x00 },        CODEC_ID_AC3, Frame },
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x02,0x02,0x02,0x03,0x02,0x05,0x00 },        CODEC_ID_MP2, Frame }, /* MP2 or MP3 */
-  //{ { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x02,0x02,0x02,0x03,0x02,0x1C,0x00 },    CODEC_ID_DOLBY_E, Frame }, /* Dolby-E */
-    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },       CODEC_ID_NONE, Frame },
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x02,0x02,0x01,0x00,0x00,0x00,0x00 }, 13,  CODEC_ID_PCM_S16LE }, /* Uncompressed */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x02,0x02,0x01,0x7F,0x00,0x00,0x00 }, 13,  CODEC_ID_PCM_S16LE },
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x07,0x04,0x02,0x02,0x01,0x7E,0x00,0x00,0x00 }, 13,  CODEC_ID_PCM_S16BE }, /* From Omneon MXF file */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x04,0x04,0x02,0x02,0x02,0x03,0x01,0x01,0x00 }, 15,   CODEC_ID_PCM_ALAW }, /* XDCAM Proxy C0023S01.mxf */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x02,0x02,0x02,0x03,0x02,0x01,0x00 }, 15,        CODEC_ID_AC3 },
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x02,0x02,0x02,0x03,0x02,0x05,0x00 }, 15,        CODEC_ID_MP2 }, /* MP2 or MP3 */
+  //{ { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x02,0x02,0x02,0x03,0x02,0x1C,0x00 }, 15,    CODEC_ID_DOLBY_E }, /* Dolby-E */
+    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0,       CODEC_ID_NONE },
 };
 
 static const MXFCodecUL mxf_picture_essence_container_uls[] = {
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x02,0x0D,0x01,0x03,0x01,0x02,0x04,0x60,0x01 }, CODEC_ID_MPEG2VIDEO, Frame }, /* MPEG-ES Frame wrapped */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x02,0x0D,0x01,0x03,0x01,0x02,0x04,0xe0,0x02 }, CODEC_ID_MPEG2VIDEO,  Clip }, /* MPEG-ES Clip wrapped, 0xe0 MPV stream id */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x0D,0x01,0x03,0x01,0x02,0x04,0x61,0x07 }, CODEC_ID_MPEG2VIDEO,  Clip }, /* MPEG-ES Custom wrapped, 0x61 ??? stream id */
-    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },       CODEC_ID_NONE, Frame },
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x02,0x0D,0x01,0x03,0x01,0x02,0x04,0x60,0x01 }, 14, CODEC_ID_MPEG2VIDEO }, /* MPEG-ES Frame wrapped */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x0D,0x01,0x03,0x01,0x02,0x02,0x41,0x01 }, 14,    CODEC_ID_DVVIDEO }, /* DV 625 25mbps */
+    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0,       CODEC_ID_NONE },
 };
 
 static const MXFCodecUL mxf_sound_essence_container_uls[] = {
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x0D,0x01,0x03,0x01,0x02,0x06,0x01,0x00 },  CODEC_ID_PCM_S16LE, Frame }, /* BWF Frame wrapped */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x0D,0x01,0x03,0x01,0x02,0x06,0x03,0x00 },  CODEC_ID_PCM_S16LE, Frame }, /* AES Frame wrapped */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x02,0x0D,0x01,0x03,0x01,0x02,0x04,0x40,0x01 },        CODEC_ID_MP2, Frame }, /* MPEG-ES Frame wrapped, 0x40 ??? stream id */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x02,0x0D,0x01,0x03,0x01,0x02,0x04,0xc0,0x01 },        CODEC_ID_MP2, Frame }, /* MPEG-ES Frame wrapped, 0xc0 MPA stream id */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x02,0x0D,0x01,0x03,0x01,0x02,0x04,0xc0,0x02 },        CODEC_ID_MP2,  Clip }, /* MPEG-ES Clip wrapped, 0xc0 MPA stream id */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x0D,0x01,0x03,0x01,0x02,0x01,0x05,0x01 },  CODEC_ID_PCM_S16LE, Frame }, /* D-10 Mapping 30Mbps PAL Extended Template */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x0D,0x01,0x03,0x01,0x02,0x01,0x03,0x01 },  CODEC_ID_PCM_S16LE, Frame }, /* D-10 Mapping 40Mbps PAL Extended Template */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x0D,0x01,0x03,0x01,0x02,0x01,0x01,0x01 },  CODEC_ID_PCM_S16LE, Frame }, /* D-10 Mapping 50Mbps PAL Extended Template */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x0D,0x01,0x03,0x01,0x02,0x01,0x06,0x01 },  CODEC_ID_PCM_S16LE, Frame }, /* D-10 Mapping 30Mbps NTSC Extended Template */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x0D,0x01,0x03,0x01,0x02,0x01,0x04,0x01 },  CODEC_ID_PCM_S16LE, Frame }, /* D-10 Mapping 40Mbps NTSC Extended Template */
-    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x0D,0x01,0x03,0x01,0x02,0x01,0x02,0x01 },  CODEC_ID_PCM_S16LE, Frame }, /* D-10 Mapping 50Mbps NTSC Extended Template */
-    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },       CODEC_ID_NONE, Frame },
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x0D,0x01,0x03,0x01,0x02,0x06,0x01,0x00 }, 14, CODEC_ID_PCM_S16LE }, /* BWF Frame wrapped */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x02,0x0D,0x01,0x03,0x01,0x02,0x04,0x40,0x01 }, 14,       CODEC_ID_MP2 }, /* MPEG-ES Frame wrapped, 0x40 ??? stream id */
+    { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x0D,0x01,0x03,0x01,0x02,0x01,0x01,0x01 }, 14, CODEC_ID_PCM_S16LE }, /* D-10 Mapping 50Mbps PAL Extended Template */
+    { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },  0,      CODEC_ID_NONE },
 };
 
 /*
@@ -665,7 +676,7 @@
 static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)
 {
     while (uls->id != CODEC_ID_NONE) {
-        if(mxf_match_uid(uls->uid, *uid, 16))
+        if(mxf_match_uid(uls->uid, *uid, uls->matching_len))
             break;
         uls++;
     }
@@ -775,6 +786,10 @@
             continue;
 
         st = av_new_stream(mxf->fc, source_track->track_id);
+        if (!st) {
+            av_log(mxf->fc, AV_LOG_ERROR, "could not allocate stream\n");
+            return -1;
+        }
         st->priv_data = source_track;
         st->duration = component->duration;
         if (st->duration == -1)
@@ -868,8 +883,8 @@
                 st->need_parsing = AVSTREAM_PARSE_FULL;
             }
         }
-        if (container_ul && container_ul->wrapping == Clip) {
-            dprintf(mxf->fc, "stream %d: clip wrapped essence\n", st->index);
+        if (st->codec->codec_type != CODEC_TYPE_DATA && (*essence_container_ul)[15] > 0x01) {
+            av_log(mxf->fc, AV_LOG_WARNING, "only frame wrapped mappings are correctly supported\n");
             st->need_parsing = AVSTREAM_PARSE_FULL;
         }
     }
@@ -877,43 +892,60 @@
 }
 
 static const MXFMetadataReadTableEntry mxf_metadata_read_table[] = {
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x18,0x00 }, mxf_read_metadata_content_storage, 0, AnyType },
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x37,0x00 }, mxf_read_metadata_source_package, sizeof(MXFPackage), SourcePackage },
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x36,0x00 }, mxf_read_metadata_material_package, sizeof(MXFPackage), MaterialPackage },
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x0F,0x00 }, mxf_read_metadata_sequence, sizeof(MXFSequence), Sequence },
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x11,0x00 }, mxf_read_metadata_source_clip, sizeof(MXFStructuralComponent), SourceClip },
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x44,0x00 }, mxf_read_metadata_generic_descriptor, sizeof(MXFDescriptor), MultipleDescriptor },
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x42,0x00 }, mxf_read_metadata_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* Generic Sound */
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x28,0x00 }, mxf_read_metadata_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* CDCI */
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x29,0x00 }, mxf_read_metadata_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* RGBA */
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x51,0x00 }, mxf_read_metadata_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* MPEG 2 Video */
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x48,0x00 }, mxf_read_metadata_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* Wave */
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x47,0x00 }, mxf_read_metadata_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* AES3 */
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x3A,0x00 }, mxf_read_metadata_track, sizeof(MXFTrack), Track }, /* Static Track */
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x3B,0x00 }, mxf_read_metadata_track, sizeof(MXFTrack), Track }, /* Generic Track */
-    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x04,0x01,0x02,0x02,0x00,0x00 }, mxf_read_metadata_cryptographic_context, sizeof(MXFCryptoContext), CryptoContext },
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x05,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x05,0x01,0x00 }, mxf_read_primer_pack },
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x18,0x00 }, mxf_read_content_storage, 0, AnyType },
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x37,0x00 }, mxf_read_source_package, sizeof(MXFPackage), SourcePackage },
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x36,0x00 }, mxf_read_material_package, sizeof(MXFPackage), MaterialPackage },
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x0F,0x00 }, mxf_read_sequence, sizeof(MXFSequence), Sequence },
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x11,0x00 }, mxf_read_source_clip, sizeof(MXFStructuralComponent), SourceClip },
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x44,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), MultipleDescriptor },
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x42,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* Generic Sound */
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x28,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* CDCI */
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x29,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* RGBA */
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x51,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* MPEG 2 Video */
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x48,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* Wave */
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x47,0x00 }, mxf_read_generic_descriptor, sizeof(MXFDescriptor), Descriptor }, /* AES3 */
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x3A,0x00 }, mxf_read_track, sizeof(MXFTrack), Track }, /* Static Track */
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x3B,0x00 }, mxf_read_track, sizeof(MXFTrack), Track }, /* Generic Track */
+    { { 0x06,0x0E,0x2B,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x04,0x01,0x02,0x02,0x00,0x00 }, mxf_read_cryptographic_context, sizeof(MXFCryptoContext), CryptoContext },
     { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }, NULL, 0, AnyType },
 };
 
 static int mxf_read_local_tags(MXFContext *mxf, KLVPacket *klv, int (*read_child)(), int ctx_size, enum MXFMetadataSetType type)
 {
-    ByteIOContext *pb = &mxf->fc->pb;
+    ByteIOContext *pb = mxf->fc->pb;
     MXFMetadataSet *ctx = ctx_size ? av_mallocz(ctx_size) : mxf;
-    uint64_t klv_end= url_ftell(pb) + klv->length;
+    uint64_t klv_end = url_ftell(pb) + klv->length;
 
+    if (!ctx)
+        return -1;
     while (url_ftell(pb) + 4 < klv_end) {
         int tag = get_be16(pb);
         int size = get_be16(pb); /* KLV specified by 0x53 */
-        uint64_t next= url_ftell(pb) + size;
+        uint64_t next = url_ftell(pb) + size;
+        UID uid = {0};
 
         if (!size) { /* ignore empty tag, needed for some files with empty UMID tag */
             av_log(mxf->fc, AV_LOG_ERROR, "local tag 0x%04X with 0 size\n", tag);
             continue;
         }
-        if(ctx_size && tag == 0x3C0A)
+        if (tag > 0x7FFF) { /* dynamic tag */
+            int i;
+            for (i = 0; i < mxf->local_tags_count; i++) {
+                int local_tag = AV_RB16(mxf->local_tags+i*18);
+                if (local_tag == tag) {
+                    memcpy(uid, mxf->local_tags+i*18+2, 16);
+                    dprintf(mxf->fc, "local tag 0x%04X\n", local_tag);
+#ifdef DEBUG
+                    PRINT_KEY(mxf->fc, "uid", uid);
+#endif
+                }
+            }
+        }
+        if (ctx_size && tag == 0x3C0A)
             get_buffer(pb, ctx->uid, 16);
-        else
-            read_child(ctx, pb, tag, size);
+        else if (read_child(ctx, pb, tag, size, uid) < 0)
+            return -1;
 
         url_fseek(pb, next, SEEK_SET);
     }
@@ -926,16 +958,16 @@
     MXFContext *mxf = s->priv_data;
     KLVPacket klv;
 
-    if (!mxf_read_sync(&s->pb, mxf_header_partition_pack_key, 14)) {
+    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {
         av_log(s, AV_LOG_ERROR, "could not find header partition pack key\n");
         return -1;
     }
-    url_fseek(&s->pb, -14, SEEK_CUR);
+    url_fseek(s->pb, -14, SEEK_CUR);
     mxf->fc = s;
-    while (!url_feof(&s->pb)) {
+    while (!url_feof(s->pb)) {
         const MXFMetadataReadTableEntry *metadata;
 
-        if (klv_read_packet(&klv, &s->pb) < 0)
+        if (klv_read_packet(&klv, s->pb) < 0)
             return -1;
 #ifdef DEBUG
         PRINT_KEY(s, "read header", klv.key);
@@ -943,13 +975,14 @@
         if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||
             IS_KLV_KEY(klv.key, mxf_essence_element_key)) {
             /* FIXME avoid seek */
-            url_fseek(&s->pb, klv.offset, SEEK_SET);
+            url_fseek(s->pb, klv.offset, SEEK_SET);
             break;
         }
 
         for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {
             if (IS_KLV_KEY(klv.key, metadata->key)) {
-                if (mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type) < 0) {
+                int (*read)() = klv.key[5] == 0x53 ? mxf_read_local_tags : metadata->read;
+                if (read(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type) < 0) {
                     av_log(s, AV_LOG_ERROR, "error reading header metadata\n");
                     return -1;
                 }
@@ -957,7 +990,7 @@
             }
         }
         if (!metadata->read)
-            url_fskip(&s->pb, klv.length);
+            url_fskip(s->pb, klv.length);
     }
     return mxf_parse_structural_metadata(mxf);
 }
@@ -987,6 +1020,7 @@
     }
     av_freep(&mxf->metadata_sets);
     av_freep(&mxf->aesc);
+    av_freep(&mxf->local_tags);
     return 0;
 }
 
@@ -1018,7 +1052,7 @@
     if (sample_time < 0)
         sample_time = 0;
     seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den);
-    url_fseek(&s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET);
+    url_fseek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET);
     av_update_cur_dts(s, st, sample_time);
     return 0;
 }
diff -u mplayer-1.0~rc2-12/libavformat/network.h ffmpeg-free-0.svn20080206/libavformat/network.h
--- mplayer-1.0~rc2-12/libavformat/network.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/network.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef NETWORK_H
-#define NETWORK_H
+#ifndef FFMPEG_NETWORK_H
+#define FFMPEG_NETWORK_H
 
 #ifdef HAVE_WINSOCK2_H
 #include <winsock2.h>
@@ -66,4 +66,4 @@
 int inet_aton (const char * str, struct in_addr * add);
 #endif
 
-#endif
+#endif /* FFMPEG_NETWORK_H */
diff -u mplayer-1.0~rc2-12/libavformat/nsvdec.c ffmpeg-free-0.svn20080206/libavformat/nsvdec.c
--- mplayer-1.0~rc2-12/libavformat/nsvdec.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/nsvdec.c	2007-11-21 08:41:00.000000000 +0100
@@ -228,7 +228,7 @@
 static int nsv_resync(AVFormatContext *s)
 {
     NSVContext *nsv = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     uint32_t v = 0;
     int i;
 
@@ -275,7 +275,7 @@
 static int nsv_parse_NSVf_header(AVFormatContext *s, AVFormatParameters *ap)
 {
     NSVContext *nsv = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     unsigned int file_size, size;
     int64_t duration;
     int strings_size;
@@ -394,7 +394,7 @@
 static int nsv_parse_NSVs_header(AVFormatContext *s, AVFormatParameters *ap)
 {
     NSVContext *nsv = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     uint32_t vtag, atag;
     uint16_t vwidth, vheight;
     AVRational framerate;
@@ -533,7 +533,7 @@
 static int nsv_read_chunk(AVFormatContext *s, int fill_header)
 {
     NSVContext *nsv = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st[2] = {NULL, NULL};
     NSVStream *nst;
     AVPacket *pkt;
diff -u mplayer-1.0~rc2-12/libavformat/nut.c ffmpeg-free-0.svn20080206/libavformat/nut.c
--- mplayer-1.0~rc2-12/libavformat/nut.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/nut.c	2008-02-04 11:27:32.000000000 +0100
@@ -22,15 +22,11 @@
 #include "nut.h"
 #include "tree.h"
 
-unsigned long av_crc04C11DB7_update(unsigned long checksum, const uint8_t *buf, unsigned int len){
-    return av_crc(av_crc04C11DB7, checksum, buf, len);
-}
-
 void ff_nut_reset_ts(NUTContext *nut, AVRational time_base, int64_t val){
     int i;
     for(i=0; i<nut->avf->nb_streams; i++){
         nut->stream[i].last_pts= av_rescale_rnd(
-            val / nut->time_base_count,
+            val,
             time_base.num * (int64_t)nut->stream[i].time_base->den,
             time_base.den * (int64_t)nut->stream[i].time_base->num,
             AV_ROUND_DOWN);
@@ -44,20 +40,23 @@
 }
 
 int ff_nut_sp_pos_cmp(syncpoint_t *a, syncpoint_t *b){
-    return (a->pos - b->pos>>32) - (b->pos - a->pos>>32);
+    return ((a->pos - b->pos) >> 32) - ((b->pos - a->pos) >> 32);
 }
 
 int ff_nut_sp_pts_cmp(syncpoint_t *a, syncpoint_t *b){
-    return (a->ts - b->ts>>32) - (b->ts - a->ts>>32);
+    return ((a->ts - b->ts) >> 32) - ((b->ts - a->ts) >> 32);
 }
 
 void ff_nut_add_sp(NUTContext *nut, int64_t pos, int64_t back_ptr, int64_t ts){
-    syncpoint_t *sp2, *sp= av_mallocz(sizeof(syncpoint_t));
+    syncpoint_t *sp= av_mallocz(sizeof(syncpoint_t));
+    struct AVTreeNode *node= av_mallocz(av_tree_node_size);
 
     sp->pos= pos;
     sp->back_ptr= back_ptr;
     sp->ts= ts;
-    sp2= av_tree_insert(&nut->syncpoints, sp, ff_nut_sp_pos_cmp);
-    if(sp2 && sp2 != sp)
+    av_tree_insert(&nut->syncpoints, sp, ff_nut_sp_pos_cmp, &node);
+    if(node){
         av_free(sp);
+        av_free(node);
+    }
 }
diff -u mplayer-1.0~rc2-12/libavformat/nutdec.c ffmpeg-free-0.svn20080206/libavformat/nutdec.c
--- mplayer-1.0~rc2-12/libavformat/nutdec.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/nutdec.c	2008-02-04 11:30:38.000000000 +0100
@@ -27,19 +27,8 @@
 #undef NDEBUG
 #include <assert.h>
 
-static uint64_t get_v(ByteIOContext *bc){
-    uint64_t val = 0;
-    int tmp;
-
-    do{
-        tmp = get_byte(bc);
-        val= (val<<7) + (tmp&127);
-    }while(tmp&128);
-    return val;
-}
-
 static int get_str(ByteIOContext *bc, char *string, unsigned int maxlen){
-    unsigned int len= get_v(bc);
+    unsigned int len= ff_get_v(bc);
 
     if(len && maxlen)
         get_buffer(bc, string, FFMIN(len, maxlen));
@@ -58,14 +47,14 @@
 }
 
 static int64_t get_s(ByteIOContext *bc){
-    int64_t v = get_v(bc) + 1;
+    int64_t v = ff_get_v(bc) + 1;
 
     if (v&1) return -(v>>1);
     else     return  (v>>1);
 }
 
 static uint64_t get_fourcc(ByteIOContext *bc){
-    unsigned int len= get_v(bc);
+    unsigned int len= ff_get_v(bc);
 
     if     (len==2) return get_le16(bc);
     else if(len==4) return get_le32(bc);
@@ -74,7 +63,7 @@
 
 #ifdef TRACE
 static inline uint64_t get_v_trace(ByteIOContext *bc, char *file, char *func, int line){
-    uint64_t v= get_v(bc);
+    uint64_t v= ff_get_v(bc);
 
     av_log(NULL, AV_LOG_DEBUG, "get_v %5"PRId64" / %"PRIX64" in %s %s:%d\n", v, v, file, func, line);
     return v;
@@ -93,7 +82,7 @@
     av_log(NULL, AV_LOG_DEBUG, "get_vb %5"PRId64" / %"PRIX64" in %s %s:%d\n", v, v, file, func, line);
     return v;
 }
-#define get_v(bc)  get_v_trace(bc, __FILE__, __PRETTY_FUNCTION__, __LINE__)
+#define ff_get_v(bc)  get_v_trace(bc, __FILE__, __PRETTY_FUNCTION__, __LINE__)
 #define get_s(bc)  get_s_trace(bc, __FILE__, __PRETTY_FUNCTION__, __LINE__)
 #define get_vb(bc)  get_vb_trace(bc, __FILE__, __PRETTY_FUNCTION__, __LINE__)
 #endif
@@ -104,16 +93,16 @@
 //    start= url_ftell(bc) - 8;
 
     startcode= be2me_64(startcode);
-    startcode= av_crc04C11DB7_update(0, &startcode, 8);
+    startcode= ff_crc04C11DB7_update(0, &startcode, 8);
 
-    init_checksum(bc, av_crc04C11DB7_update, startcode);
-    size= get_v(bc);
+    init_checksum(bc, ff_crc04C11DB7_update, startcode);
+    size= ff_get_v(bc);
     if(size > 4096)
         get_be32(bc);
     if(get_checksum(bc) && size > 4096)
         return -1;
 
-    init_checksum(bc, calculate_checksum ? av_crc04C11DB7_update : NULL, 0);
+    init_checksum(bc, calculate_checksum ? ff_crc04C11DB7_update : NULL, 0);
 
     return size;
 }
@@ -171,7 +160,7 @@
 }
 
 #define GET_V(dst, check) \
-    tmp= get_v(bc);\
+    tmp= ff_get_v(bc);\
     if(!(check)){\
         av_log(s, AV_LOG_ERROR, "Error " #dst " is (%"PRId64")\n", tmp);\
         return -1;\
@@ -192,7 +181,7 @@
 
 static int decode_main_header(NUTContext *nut){
     AVFormatContext *s= nut->avf;
-    ByteIOContext *bc = &s->pb;
+    ByteIOContext *bc = s->pb;
     uint64_t tmp, end;
     unsigned int stream_count;
     int i, j, tmp_stream, tmp_mul, tmp_pts, tmp_size, count, tmp_res;
@@ -203,7 +192,7 @@
     GET_V(tmp              , tmp >=2 && tmp <= 3)
     GET_V(stream_count     , tmp > 0 && tmp <=MAX_STREAMS)
 
-    nut->max_distance = get_v(bc);
+    nut->max_distance = ff_get_v(bc);
     if(nut->max_distance > 65536){
         av_log(s, AV_LOG_DEBUG, "max_distance %d\n", nut->max_distance);
         nut->max_distance= 65536;
@@ -224,20 +213,20 @@
     tmp_mul=1;
     tmp_stream=0;
     for(i=0; i<256;){
-        int tmp_flags = get_v(bc);
-        int tmp_fields= get_v(bc);
+        int tmp_flags = ff_get_v(bc);
+        int tmp_fields= ff_get_v(bc);
         if(tmp_fields>0) tmp_pts   = get_s(bc);
-        if(tmp_fields>1) tmp_mul   = get_v(bc);
-        if(tmp_fields>2) tmp_stream= get_v(bc);
-        if(tmp_fields>3) tmp_size  = get_v(bc);
+        if(tmp_fields>1) tmp_mul   = ff_get_v(bc);
+        if(tmp_fields>2) tmp_stream= ff_get_v(bc);
+        if(tmp_fields>3) tmp_size  = ff_get_v(bc);
         else             tmp_size  = 0;
-        if(tmp_fields>4) tmp_res   = get_v(bc);
+        if(tmp_fields>4) tmp_res   = ff_get_v(bc);
         else             tmp_res   = 0;
-        if(tmp_fields>5) count     = get_v(bc);
+        if(tmp_fields>5) count     = ff_get_v(bc);
         else             count     = tmp_mul - tmp_size;
 
         while(tmp_fields-- > 6)
-           get_v(bc);
+           ff_get_v(bc);
 
         if(count == 0 || i+count > 256){
             av_log(s, AV_LOG_ERROR, "illegal count %d at %d\n", count, i);
@@ -279,7 +268,7 @@
 
 static int decode_stream_header(NUTContext *nut){
     AVFormatContext *s= nut->avf;
-    ByteIOContext *bc = &s->pb;
+    ByteIOContext *bc = s->pb;
     StreamContext *stc;
     int class, stream_id;
     uint64_t tmp, end;
@@ -295,7 +284,7 @@
     if (!st)
         return AVERROR(ENOMEM);
 
-    class = get_v(bc);
+    class = ff_get_v(bc);
     tmp = get_fourcc(bc);
     st->codec->codec_tag= tmp;
     switch(class)
@@ -324,10 +313,10 @@
     }
     GET_V(stc->time_base_id    , tmp < nut->time_base_count);
     GET_V(stc->msb_pts_shift   , tmp < 16);
-    stc->max_pts_distance= get_v(bc);
+    stc->max_pts_distance= ff_get_v(bc);
     GET_V(stc->decode_delay    , tmp < 1000); //sanity limit, raise this if Moore's law is true
     st->codec->has_b_frames= stc->decode_delay;
-    get_v(bc); //stream flags
+    ff_get_v(bc); //stream flags
 
     GET_V(st->codec->extradata_size, tmp < (1<<30));
     if(st->codec->extradata_size){
@@ -338,20 +327,16 @@
     if (st->codec->codec_type == CODEC_TYPE_VIDEO){
         GET_V(st->codec->width , tmp > 0)
         GET_V(st->codec->height, tmp > 0)
-        st->codec->sample_aspect_ratio.num= get_v(bc);
-        st->codec->sample_aspect_ratio.den= get_v(bc);
+        st->codec->sample_aspect_ratio.num= ff_get_v(bc);
+        st->codec->sample_aspect_ratio.den= ff_get_v(bc);
         if((!st->codec->sample_aspect_ratio.num) != (!st->codec->sample_aspect_ratio.den)){
-            av_log(s, AV_LOG_ERROR, "invalid aspect ratio\n");
+            av_log(s, AV_LOG_ERROR, "invalid aspect ratio %d/%d\n", st->codec->sample_aspect_ratio.num, st->codec->sample_aspect_ratio.den);
             return -1;
         }
-        get_v(bc); /* csp type */
+        ff_get_v(bc); /* csp type */
     }else if (st->codec->codec_type == CODEC_TYPE_AUDIO){
         GET_V(st->codec->sample_rate , tmp > 0)
-        tmp= get_v(bc); // samplerate_den
-        if(tmp > st->codec->sample_rate){
-            av_log(s, AV_LOG_ERROR, "Bleh, libnut muxed this ;)\n");
-            st->codec->sample_rate= tmp;
-        }
+        ff_get_v(bc); // samplerate_den
         GET_V(st->codec->channels, tmp > 0)
     }
     if(skip_reserved(bc, end) || get_checksum(bc)){
@@ -365,21 +350,22 @@
 
 static int decode_info_header(NUTContext *nut){
     AVFormatContext *s= nut->avf;
-    ByteIOContext *bc = &s->pb;
+    ByteIOContext *bc = s->pb;
     uint64_t tmp;
     unsigned int stream_id_plus1, chapter_start, chapter_len, count;
     int chapter_id, i;
     int64_t value, end;
-    char name[256], str_value[1024], type_str[256], *type= type_str;
+    char name[256], str_value[1024], type_str[256];
+    const char *type;
 
     end= get_packetheader(nut, bc, 1, INFO_STARTCODE);
     end += url_ftell(bc);
 
     GET_V(stream_id_plus1, tmp <= s->nb_streams)
     chapter_id   = get_s(bc);
-    chapter_start= get_v(bc);
-    chapter_len  = get_v(bc);
-    count        = get_v(bc);
+    chapter_start= ff_get_v(bc);
+    chapter_len  = ff_get_v(bc);
+    count        = ff_get_v(bc);
     for(i=0; i<count; i++){
         get_str(bc, name, sizeof(name));
         value= get_s(bc);
@@ -387,14 +373,15 @@
             type= "UTF-8";
             get_str(bc, str_value, sizeof(str_value));
         }else if(value == -2){
-            get_str(bc, type, sizeof(type));
+            get_str(bc, type_str, sizeof(type_str));
+            type= type_str;
             get_str(bc, str_value, sizeof(str_value));
         }else if(value == -3){
             type= "s";
             value= get_s(bc);
         }else if(value == -4){
             type= "t";
-            value= get_v(bc);
+            value= ff_get_v(bc);
         }else if(value < -4){
             type= "r";
             get_s(bc);
@@ -423,7 +410,7 @@
 
 static int decode_syncpoint(NUTContext *nut, int64_t *ts, int64_t *back_ptr){
     AVFormatContext *s= nut->avf;
-    ByteIOContext *bc = &s->pb;
+    ByteIOContext *bc = s->pb;
     int64_t end, tmp;
 
     nut->last_syncpoint_pos= url_ftell(bc)-8;
@@ -431,12 +418,12 @@
     end= get_packetheader(nut, bc, 1, SYNCPOINT_STARTCODE);
     end += url_ftell(bc);
 
-    tmp= get_v(bc);
-    *back_ptr= nut->last_syncpoint_pos - 16*get_v(bc);
+    tmp= ff_get_v(bc);
+    *back_ptr= nut->last_syncpoint_pos - 16*ff_get_v(bc);
     if(*back_ptr < 0)
         return -1;
 
-    ff_nut_reset_ts(nut, nut->time_base[tmp % nut->time_base_count], tmp);
+    ff_nut_reset_ts(nut, nut->time_base[tmp % nut->time_base_count], tmp / nut->time_base_count);
 
     if(skip_reserved(bc, end) || get_checksum(bc)){
         av_log(s, AV_LOG_ERROR, "sync point checksum mismatch\n");
@@ -451,7 +438,7 @@
 
 static int find_and_decode_index(NUTContext *nut){
     AVFormatContext *s= nut->avf;
-    ByteIOContext *bc = &s->pb;
+    ByteIOContext *bc = s->pb;
     uint64_t tmp, end;
     int i, j, syncpoint_count;
     int64_t filesize= url_fsize(bc);
@@ -468,7 +455,7 @@
     end= get_packetheader(nut, bc, 1, INDEX_STARTCODE);
     end += url_ftell(bc);
 
-    get_v(bc); //max_pts
+    ff_get_v(bc); //max_pts
     GET_V(syncpoint_count, tmp < INT_MAX/8 && tmp > 0)
     syncpoints= av_malloc(sizeof(int64_t)*syncpoint_count);
     has_keyframe= av_malloc(sizeof(int8_t)*(syncpoint_count+1));
@@ -481,7 +468,7 @@
     for(i=0; i<s->nb_streams; i++){
         int64_t last_pts= -1;
         for(j=0; j<syncpoint_count;){
-            uint64_t x= get_v(bc);
+            uint64_t x= ff_get_v(bc);
             int type= x&1;
             int n= j;
             x>>=1;
@@ -510,12 +497,12 @@
                 return -1;
             }
             assert(n<=syncpoint_count+1);
-            for(; j<n; j++){
+            for(; j<n && j<syncpoint_count; j++){
                 if(has_keyframe[j]){
-                    uint64_t B, A= get_v(bc);
+                    uint64_t B, A= ff_get_v(bc);
                     if(!A){
-                        A= get_v(bc);
-                        B= get_v(bc);
+                        A= ff_get_v(bc);
+                        B= ff_get_v(bc);
                         //eor_pts[j][i] = last_pts + A + B
                     }else
                         B= 0;
@@ -542,7 +529,7 @@
 static int nut_read_header(AVFormatContext *s, AVFormatParameters *ap)
 {
     NUTContext *nut = s->priv_data;
-    ByteIOContext *bc = &s->pb;
+    ByteIOContext *bc = s->pb;
     int64_t pos;
     int inited_stream_count;
 
@@ -603,7 +590,7 @@
 
 static int decode_frame_header(NUTContext *nut, int64_t *pts, int *stream_id, int frame_code){
     AVFormatContext *s= nut->avf;
-    ByteIOContext *bc = &s->pb;
+    ByteIOContext *bc = s->pb;
     StreamContext *stc;
     int size, flags, size_mul, pts_delta, i, reserved_count;
     uint64_t tmp;
@@ -623,13 +610,13 @@
     if(flags & FLAG_INVALID)
         return -1;
     if(flags & FLAG_CODED)
-        flags ^= get_v(bc);
+        flags ^= ff_get_v(bc);
     if(flags & FLAG_STREAM_ID){
         GET_V(*stream_id, tmp < s->nb_streams)
     }
     stc= &nut->stream[*stream_id];
     if(flags&FLAG_CODED_PTS){
-        int coded_pts= get_v(bc);
+        int coded_pts= ff_get_v(bc);
 //FIXME check last_pts validity?
         if(coded_pts < (1<<stc->msb_pts_shift)){
             *pts=ff_lsb2full(stc, coded_pts);
@@ -638,12 +625,12 @@
     }else
         *pts= stc->last_pts + pts_delta;
     if(flags&FLAG_SIZE_MSB){
-        size += size_mul*get_v(bc);
+        size += size_mul*ff_get_v(bc);
     }
     if(flags&FLAG_RESERVED)
-        reserved_count= get_v(bc);
+        reserved_count= ff_get_v(bc);
     for(i=0; i<reserved_count; i++)
-        get_v(bc);
+        ff_get_v(bc);
     if(flags&FLAG_CHECKSUM){
         get_be32(bc); //FIXME check this
     }else if(size > 2*nut->max_distance || FFABS(stc->last_pts - *pts) > stc->max_pts_distance){
@@ -659,7 +646,7 @@
 
 static int decode_frame(NUTContext *nut, AVPacket *pkt, int frame_code){
     AVFormatContext *s= nut->avf;
-    ByteIOContext *bc = &s->pb;
+    ByteIOContext *bc = s->pb;
     int size, stream_id, discard;
     int64_t pts, last_IP_pts;
     StreamContext *stc;
@@ -695,7 +682,7 @@
 static int nut_read_packet(AVFormatContext *s, AVPacket *pkt)
 {
     NUTContext *nut = s->priv_data;
-    ByteIOContext *bc = &s->pb;
+    ByteIOContext *bc = s->pb;
     int i, frame_code=0, ret, skip;
     int64_t ts, back_ptr;
 
@@ -751,7 +738,7 @@
 
 static int64_t nut_read_timestamp(AVFormatContext *s, int stream_index, int64_t *pos_arg, int64_t pos_limit){
     NUTContext *nut = s->priv_data;
-    ByteIOContext *bc = &s->pb;
+    ByteIOContext *bc = s->pb;
     int64_t pos, pts, back_ptr;
 av_log(s, AV_LOG_DEBUG, "read_timestamp(X,%d,%"PRId64",%"PRId64")\n", stream_index, *pos_arg, pos_limit);
 
@@ -814,8 +801,8 @@
         pos2= sp->back_ptr  - 15;
     }
     av_log(NULL, AV_LOG_DEBUG, "SEEKTO: %"PRId64"\n", pos2);
-    pos= find_startcode(&s->pb, SYNCPOINT_STARTCODE, pos2);
-    url_fseek(&s->pb, pos, SEEK_SET);
+    pos= find_startcode(s->pb, SYNCPOINT_STARTCODE, pos2);
+    url_fseek(s->pb, pos, SEEK_SET);
     av_log(NULL, AV_LOG_DEBUG, "SP: %"PRId64"\n", pos);
     if(pos2 > pos || pos2 + 15 < pos){
         av_log(NULL, AV_LOG_ERROR, "no syncpoint at backptr pos\n");
diff -u mplayer-1.0~rc2-12/libavformat/nutenc.c ffmpeg-free-0.svn20080206/libavformat/nutenc.c
--- mplayer-1.0~rc2-12/libavformat/nutenc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/nutenc.c	2008-02-04 11:48:41.000000000 +0100
@@ -196,14 +196,14 @@
     int forw_ptr= dyn_size + 4*calculate_checksum;
 
     if(forw_ptr > 4096)
-        init_checksum(bc, av_crc04C11DB7_update, 0);
+        init_checksum(bc, ff_crc04C11DB7_update, 0);
     put_be64(bc, startcode);
     put_v(bc, forw_ptr);
     if(forw_ptr > 4096)
         put_le32(bc, get_checksum(bc));
 
     if(calculate_checksum)
-        init_checksum(bc, av_crc04C11DB7_update, 0);
+        init_checksum(bc, ff_crc04C11DB7_update, 0);
     put_buffer(bc, dyn_buf, dyn_size);
     if(calculate_checksum)
         put_le32(bc, get_checksum(bc));
@@ -216,7 +216,7 @@
 
     put_v(bc, 3); /* version */
     put_v(bc, nut->avf->nb_streams);
-    put_v(bc, MAX_DISTANCE);
+    put_v(bc, nut->max_distance);
     put_v(bc, nut->time_base_count);
 
     for(i=0; i<nut->time_base_count; i++){
@@ -317,26 +317,27 @@
     return 0;
 }
 
-static int add_info(ByteIOContext *bc, char *type, char *value){
+static int add_info(ByteIOContext *bc, const char *type, const char *value){
     put_str(bc, type);
     put_s(bc, -1);
     put_str(bc, value);
     return 1;
 }
 
-static void write_globalinfo(NUTContext *nut, ByteIOContext *bc){
+static int write_globalinfo(NUTContext *nut, ByteIOContext *bc){
     AVFormatContext *s= nut->avf;
-    ByteIOContext dyn_bc;
+    ByteIOContext *dyn_bc;
     uint8_t *dyn_buf=NULL;
     int count=0, dyn_size;
-
-    url_open_dyn_buf(&dyn_bc);
-
-    if(s->title    [0]) count+= add_info(&dyn_bc, "Title"    , s->title);
-    if(s->author   [0]) count+= add_info(&dyn_bc, "Author"   , s->author);
-    if(s->copyright[0]) count+= add_info(&dyn_bc, "Copyright", s->copyright);
+    int ret = url_open_dyn_buf(&dyn_bc);
+    if(ret < 0)
+        return ret;
+
+    if(s->title    [0]) count+= add_info(dyn_bc, "Title"    , s->title);
+    if(s->author   [0]) count+= add_info(dyn_bc, "Author"   , s->author);
+    if(s->copyright[0]) count+= add_info(dyn_bc, "Copyright", s->copyright);
     if(!(s->streams[0]->codec->flags & CODEC_FLAG_BITEXACT))
-                        count+= add_info(&dyn_bc, "Encoder"  , LIBAVFORMAT_IDENT);
+                        count+= add_info(dyn_bc, "Encoder"  , LIBAVFORMAT_IDENT);
 
     put_v(bc, 0); //stream_if_plus1
     put_v(bc, 0); //chapter_id
@@ -345,38 +346,46 @@
 
     put_v(bc, count);
 
-    dyn_size= url_close_dyn_buf(&dyn_bc, &dyn_buf);
+    dyn_size= url_close_dyn_buf(dyn_bc, &dyn_buf);
     put_buffer(bc, dyn_buf, dyn_size);
     av_free(dyn_buf);
+    return 0;
 }
 
-static void write_headers(NUTContext *nut, ByteIOContext *bc){
-    ByteIOContext dyn_bc;
-    int i;
-
-    url_open_dyn_buf(&dyn_bc);
-    write_mainheader(nut, &dyn_bc);
-    put_packet(nut, bc, &dyn_bc, 1, MAIN_STARTCODE);
+static int write_headers(NUTContext *nut, ByteIOContext *bc){
+    ByteIOContext *dyn_bc;
+    int i, ret;
+
+    ret = url_open_dyn_buf(&dyn_bc);
+    if(ret < 0)
+        return ret;
+    write_mainheader(nut, dyn_bc);
+    put_packet(nut, bc, dyn_bc, 1, MAIN_STARTCODE);
 
     for (i=0; i < nut->avf->nb_streams; i++){
         AVCodecContext *codec = nut->avf->streams[i]->codec;
 
-        url_open_dyn_buf(&dyn_bc);
-        write_streamheader(nut, &dyn_bc, codec, i);
-        put_packet(nut, bc, &dyn_bc, 1, STREAM_STARTCODE);
+        ret = url_open_dyn_buf(&dyn_bc);
+        if(ret < 0)
+            return ret;
+        write_streamheader(nut, dyn_bc, codec, i);
+        put_packet(nut, bc, dyn_bc, 1, STREAM_STARTCODE);
     }
 
-    url_open_dyn_buf(&dyn_bc);
-    write_globalinfo(nut, &dyn_bc);
-    put_packet(nut, bc, &dyn_bc, 1, INFO_STARTCODE);
+    ret = url_open_dyn_buf(&dyn_bc);
+    if(ret < 0)
+        return ret;
+    write_globalinfo(nut, dyn_bc);
+    put_packet(nut, bc, dyn_bc, 1, INFO_STARTCODE);
 
     nut->last_syncpoint_pos= INT_MIN;
     nut->header_count++;
+    return 0;
 }
 
 static int write_header(AVFormatContext *s){
     NUTContext *nut = s->priv_data;
-    ByteIOContext *bc = &s->pb;
+    ByteIOContext *bc = s->pb;
     int i, j;
 
     nut->avf= s;
@@ -409,6 +418,7 @@
         nut->stream[i].max_pts_distance= FFMAX(1/av_q2d(time_base), 1);
     }
 
+    nut->max_distance = MAX_DISTANCE;
     build_frame_code(s);
     assert(nut->frame_code['N'].flags == FLAG_INVALID);
 
@@ -441,17 +451,18 @@
 static int write_packet(AVFormatContext *s, AVPacket *pkt){
     NUTContext *nut = s->priv_data;
     StreamContext *nus= &nut->stream[pkt->stream_index];
-    ByteIOContext *bc = &s->pb, dyn_bc;
+    ByteIOContext *bc = s->pb, *dyn_bc;
     FrameCode *fc;
     int64_t coded_pts;
     int best_length, frame_code, flags, needed_flags, i;
     int key_frame = !!(pkt->flags & PKT_FLAG_KEY);
     int store_sp=0;
+    int ret;
 
     if(1LL<<(20+3*nut->header_count) <= url_ftell(bc))
         write_headers(nut, bc);
 
-    if(key_frame && !!(nus->last_flags & FLAG_KEY))
+    if(key_frame && !(nus->last_flags & FLAG_KEY))
         store_sp= 1;
 
     if(pkt->size + 30/*FIXME check*/ + url_ftell(bc) >= nut->last_syncpoint_pos + nut->max_distance)
@@ -465,17 +476,24 @@
         ff_nut_reset_ts(nut, *nus->time_base, pkt->dts);
         for(i=0; i<s->nb_streams; i++){
             AVStream *st= s->streams[i];
-            int index= av_index_search_timestamp(st, pkt->dts, AVSEEK_FLAG_BACKWARD);
-            if(index<0) dummy.pos=0;
-            else        dummy.pos= FFMIN(dummy.pos, st->index_entries[index].pos);
+            int64_t dts_tb = av_rescale_rnd(pkt->dts,
+                nus->time_base->num * (int64_t)nut->stream[i].time_base->den,
+                nus->time_base->den * (int64_t)nut->stream[i].time_base->num,
+                AV_ROUND_DOWN);
+            int index= av_index_search_timestamp(st, dts_tb, AVSEEK_FLAG_BACKWARD);
+            if(index>=0) dummy.pos= FFMIN(dummy.pos, st->index_entries[index].pos);
         }
+        if(dummy.pos == INT64_MAX)
+            dummy.pos= 0;
         sp= av_tree_find(nut->syncpoints, &dummy, ff_nut_sp_pos_cmp, NULL);
 
         nut->last_syncpoint_pos= url_ftell(bc);
-        url_open_dyn_buf(&dyn_bc);
-        put_t(nut, nus, &dyn_bc, pkt->dts);
-        put_v(&dyn_bc, sp ? (nut->last_syncpoint_pos - sp->pos)>>4 : 0);
-        put_packet(nut, bc, &dyn_bc, 1, SYNCPOINT_STARTCODE);
+        ret = url_open_dyn_buf(&dyn_bc);
+        if(ret < 0)
+            return ret;
+        put_t(nut, nus, dyn_bc, pkt->dts);
+        put_v(dyn_bc, sp ? (nut->last_syncpoint_pos - sp->pos)>>4 : 0);
+        put_packet(nut, bc, dyn_bc, 1, SYNCPOINT_STARTCODE);
 
         ff_nut_add_sp(nut, nut->last_syncpoint_pos, 0/*unused*/, pkt->dts);
     }
@@ -535,7 +553,7 @@
     flags= fc->flags;
     needed_flags= get_needed_flags(nut, nus, fc, pkt);
 
-    init_checksum(bc, av_crc04C11DB7_update, 0);
+    init_checksum(bc, ff_crc04C11DB7_update, 0);
     put_byte(bc, frame_code);
     if(flags & FLAG_CODED){
         put_v(bc, (flags^needed_flags) & ~(FLAG_CODED));
@@ -566,7 +584,7 @@
 
 static int write_trailer(AVFormatContext *s){
     NUTContext *nut= s->priv_data;
-    ByteIOContext *bc= &s->pb;
+    ByteIOContext *bc= s->pb;
 
     while(nut->header_count<3)
         write_headers(nut, bc);
diff -u mplayer-1.0~rc2-12/libavformat/nut.h ffmpeg-free-0.svn20080206/libavformat/nut.h
--- mplayer-1.0~rc2-12/libavformat/nut.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/nut.h	2007-10-30 01:01:25.000000000 +0100
@@ -19,12 +19,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVFORMAT_NUT_H
-#define AVFORMAT_NUT_H
+#ifndef FFMPEG_NUT_H
+#define FFMPEG_NUT_H
 
 //#include <limits.h>
 #include "avformat.h"
-#include "crc.h"
 //#include "mpegaudio.h"
 #include "riff.h"
 //#include "adler32.h"
@@ -93,11 +92,10 @@
     struct AVTreeNode *syncpoints;
 } NUTContext;
 
-unsigned long av_crc04C11DB7_update(unsigned long checksum, const uint8_t *buf, unsigned int len);
 void ff_nut_reset_ts(NUTContext *nut, AVRational time_base, int64_t val);
 int64_t ff_lsb2full(StreamContext *stream, int64_t lsb);
 int ff_nut_sp_pos_cmp(syncpoint_t *a, syncpoint_t *b);
 int ff_nut_sp_pts_cmp(syncpoint_t *a, syncpoint_t *b);
 void ff_nut_add_sp(NUTContext *nut, int64_t pos, int64_t back_ptr, int64_t ts);
 
-#endif /* AVFORMAT_NUT_H */
+#endif /* FFMPEG_NUT_H */
diff -u mplayer-1.0~rc2-12/libavformat/nuv.c ffmpeg-free-0.svn20080206/libavformat/nuv.c
--- mplayer-1.0~rc2-12/libavformat/nuv.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/nuv.c	2007-11-21 08:41:00.000000000 +0100
@@ -120,7 +120,7 @@
 
 static int nuv_header(AVFormatContext *s, AVFormatParameters *ap) {
     NUVContext *ctx = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     char id_string[12], version_string[5];
     double aspect, fps;
     int is_mythtv, width, height, v_packs, a_packs;
@@ -183,7 +183,7 @@
 
 static int nuv_packet(AVFormatContext *s, AVPacket *pkt) {
     NUVContext *ctx = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     uint8_t hdr[HDRSIZE];
     frametype_t frametype;
     int ret, size;
Only in mplayer-1.0~rc2-12/libavformat: ogg2.c
Only in mplayer-1.0~rc2-12/libavformat: ogg2.h
Only in mplayer-1.0~rc2-12/libavformat: ogg.c
Only in ffmpeg-free-0.svn20080206/libavformat: oggdec.c
Only in ffmpeg-free-0.svn20080206/libavformat: oggdec.h
Only in ffmpeg-free-0.svn20080206/libavformat: oggenc.c
diff -u mplayer-1.0~rc2-12/libavformat/oggparseflac.c ffmpeg-free-0.svn20080206/libavformat/oggparseflac.c
--- mplayer-1.0~rc2-12/libavformat/oggparseflac.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/oggparseflac.c	2007-11-07 21:22:32.000000000 +0100
@@ -21,7 +21,7 @@
 #include <stdlib.h>
 #include "avformat.h"
 #include "bitstream.h"
-#include "ogg2.h"
+#include "oggdec.h"
 
 #define FLAC_STREAMINFO_SIZE 0x22
 
diff -u mplayer-1.0~rc2-12/libavformat/oggparseogm.c ffmpeg-free-0.svn20080206/libavformat/oggparseogm.c
--- mplayer-1.0~rc2-12/libavformat/oggparseogm.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/oggparseogm.c	2008-02-01 16:17:43.000000000 +0100
@@ -27,7 +27,7 @@
 #include "bitstream.h"
 #include "bytestream.h"
 #include "intreadwrite.h"
-#include "ogg2.h"
+#include "oggdec.h"
 #include "riff.h"
 
 static int
@@ -36,7 +36,7 @@
     ogg_t *ogg = s->priv_data;
     ogg_stream_t *os = ogg->streams + idx;
     AVStream *st = s->streams[idx];
-    uint8_t *p = os->buf + os->pstart;
+    const uint8_t *p = os->buf + os->pstart;
     uint64_t time_unit;
     uint64_t spu;
     uint32_t default_len;
@@ -55,6 +55,10 @@
         tag = bytestream_get_le32(&p);
         st->codec->codec_id = codec_get_id(codec_bmp_tags, tag);
         st->codec->codec_tag = tag;
+    } else if (*p == 't') {
+        st->codec->codec_type = CODEC_TYPE_SUBTITLE;
+        st->codec->codec_id = CODEC_ID_TEXT;
+        p += 12;
     } else {
         uint8_t acid[5];
         int cid;
@@ -134,6 +138,9 @@
     uint8_t *p = os->buf + os->pstart;
     int lb;
 
+    if(*p & 8)
+        os->pflags |= PKT_FLAG_KEY;
+
     lb = ((*p & 2) << 1) | ((*p >> 6) & 3);
     os->pstart += lb + 1;
     os->psize -= lb + 1;
@@ -155,6 +162,13 @@
     .packet = ogm_packet
 };
 
+ogg_codec_t ogm_text_codec = {
+    .magic = "\001text",
+    .magicsize = 5,
+    .header = ogm_header,
+    .packet = ogm_packet
+};
+
 ogg_codec_t ogm_old_codec = {
     .magic = "\001Direct Show Samples embedded in Ogg",
     .magicsize = 35,
diff -u mplayer-1.0~rc2-12/libavformat/oggparsetheora.c ffmpeg-free-0.svn20080206/libavformat/oggparsetheora.c
--- mplayer-1.0~rc2-12/libavformat/oggparsetheora.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/oggparsetheora.c	2007-11-11 22:56:18.000000000 +0100
@@ -26,7 +26,7 @@
 #include "avformat.h"
 #include "bitstream.h"
 #include "bswap.h"
-#include "ogg2.h"
+#include "oggdec.h"
 
 typedef struct theora_params {
     int gpshift;
@@ -124,6 +124,9 @@
     uint64_t iframe = gp >> thp->gpshift;
     uint64_t pframe = gp & thp->gpmask;
 
+    if(!pframe)
+        os->pflags |= PKT_FLAG_KEY;
+
     return iframe + pframe;
 }
 
diff -u mplayer-1.0~rc2-12/libavformat/oggparsevorbis.c ffmpeg-free-0.svn20080206/libavformat/oggparsevorbis.c
--- mplayer-1.0~rc2-12/libavformat/oggparsevorbis.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/oggparsevorbis.c	2008-02-01 16:17:32.000000000 +0100
@@ -25,47 +25,41 @@
 #include <stdlib.h>
 #include "avformat.h"
 #include "bitstream.h"
+#include "bytestream.h"
 #include "bswap.h"
-#include "ogg2.h"
+#include "oggdec.h"
 #include "avstring.h"
 
 extern int
 vorbis_comment(AVFormatContext * as, uint8_t *buf, int size)
 {
-    char *p = buf;
-    int s, n, j;
+    const uint8_t *p = buf;
+    const uint8_t *end = buf + size;
+    unsigned s, n, j;
 
-    if (size < 4)
+    if (size < 8) /* must have vendor_length and user_comment_list_length */
         return -1;
 
-    s = AV_RL32(p);
-    p += 4;
-    size -= 4;
+    s = bytestream_get_le32(&p);
 
-    if (size < s + 4)
+    if (end - p < s)
         return -1;
 
     p += s;
-    size -= s;
 
-    n = AV_RL32(p);
-    p += 4;
-    size -= 4;
+    n = bytestream_get_le32(&p);
 
-    while (size >= 4) {
-        char *t, *v;
+    while (p < end && n > 0) {
+        const char *t, *v;
         int tl, vl;
 
-        s = AV_RL32(p);
-        p += 4;
-        size -= 4;
+        s = bytestream_get_le32(&p);
 
-        if (size < s)
+        if (end - p < s)
             break;
 
         t = p;
         p += s;
-        size -= s;
         n--;
 
         v = memchr(t, '=', s);
@@ -102,15 +96,11 @@
                 as->track = atoi(ct);
             else if (!strcmp(tt, "ALBUM"))
                 av_strlcpy(as->album, ct, sizeof(as->album));
-            else if (!strcmp(tt, "GENRE"))
-                av_strlcpy(as->genre, ct, sizeof(as->genre));
-            else if (!strcmp(tt, "DESCRIPTION"))
-                av_strlcpy(as->comment, ct, sizeof(as->comment));
         }
     }
 
-    if (size > 0)
-        av_log(as, AV_LOG_INFO, "%i bytes of comment header remain\n", size);
+    if (p != end)
+        av_log(as, AV_LOG_INFO, "%ti bytes of comment header remain\n", p-end);
     if (n > 0)
         av_log(as, AV_LOG_INFO,
                "truncated comment header, %i comments not found\n", n);
@@ -178,16 +168,40 @@
             return 0;
     }
 
+    if (os->psize < 1)
+        return -1;
+
     priv = os->private;
     priv->len[os->seq] = os->psize;
     priv->packet[os->seq] = av_mallocz(os->psize);
     memcpy(priv->packet[os->seq], os->buf + os->pstart, os->psize);
     if (os->buf[os->pstart] == 1) {
-        uint8_t *p = os->buf + os->pstart + 11; //skip up to the audio channels
-        st->codec->channels = *p++;
-        st->codec->sample_rate = AV_RL32(p);
-        p += 8; //skip maximum and and nominal bitrate
-        st->codec->bit_rate = AV_RL32(p); //Minimum bitrate
+        const uint8_t *p = os->buf + os->pstart + 7; /* skip "\001vorbis" tag */
+        unsigned blocksize, bs0, bs1;
+
+        if (os->psize != 30)
+            return -1;
+
+        if (bytestream_get_le32(&p) != 0) /* vorbis_version */
+            return -1;
+
+        st->codec->channels = bytestream_get_byte(&p);
+        st->codec->sample_rate = bytestream_get_le32(&p);
+        p += 4; // skip maximum bitrate
+        st->codec->bit_rate = bytestream_get_le32(&p); // nominal bitrate
+        p += 4; // skip minimum bitrate
+
+        blocksize = bytestream_get_byte(&p);
+        bs0 = blocksize & 15;
+        bs1 = blocksize >> 4;
+
+        if (bs0 > bs1)
+            return -1;
+        if (bs0 < 6 || bs1 > 13)
+            return -1;
+
+        if (bytestream_get_byte(&p) != 1) /* framing_flag */
+            return -1;
 
         st->codec->codec_type = CODEC_TYPE_AUDIO;
         st->codec->codec_id = CODEC_ID_VORBIS;
@@ -195,7 +209,8 @@
         st->time_base.num = 1;
         st->time_base.den = st->codec->sample_rate;
     } else if (os->buf[os->pstart] == 3) {
-        vorbis_comment (s, os->buf + os->pstart + 7, os->psize - 8);
+        if (os->psize > 8)
+            vorbis_comment (s, os->buf + os->pstart + 7, os->psize - 8);
     } else {
         st->codec->extradata_size =
             fixup_vorbis_headers(s, priv, &st->codec->extradata);
diff -u mplayer-1.0~rc2-12/libavformat/os_support.c ffmpeg-free-0.svn20080206/libavformat/os_support.c
--- mplayer-1.0~rc2-12/libavformat/os_support.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/os_support.c	2007-12-27 02:38:50.000000000 +0100
@@ -23,16 +23,17 @@
 #include "avformat.h"
 #include <unistd.h>
 #include <fcntl.h>
+#include "os_support.h"
 
+#ifdef CONFIG_NETWORK
 #ifndef HAVE_SYS_POLL_H
 #ifdef HAVE_WINSOCK2_H
 #include <winsock2.h>
-#else
+#elif defined (HAVE_SYS_SELECT_H)
 #include <sys/select.h>
 #endif
 #endif
 
-#ifdef CONFIG_NETWORK
 #include "network.h"
 
 #if !defined(HAVE_INET_ATON)
diff -u mplayer-1.0~rc2-12/libavformat/os_support.h ffmpeg-free-0.svn20080206/libavformat/os_support.h
--- mplayer-1.0~rc2-12/libavformat/os_support.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/os_support.h	2008-01-01 23:54:35.000000000 +0100
@@ -19,21 +19,15 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef OS_SUPPORT_H
-#define OS_SUPPORT_H
+#ifndef FFMPEG_OS_SUPPORT_H
+#define FFMPEG_OS_SUPPORT_H
 
 /**
  * @file os_support.h
  * miscellaneous OS support macros and functions.
- *
- * - socklen_t typedef (BeOS, Innotek libc)
- * - usleep() (Win32, BeOS)
- * - lseek() (Win32)
- * - closesocket()
- * - poll() (BeOS, MinGW)
  */
 
-#if defined(__BEOS__) || defined(__INNOTEK_LIBC__)
+#ifndef HAVE_SOCKLEN_T
 typedef int socklen_t;
 #endif
 
@@ -96,4 +90,4 @@
 #endif /* HAVE_SYS_POLL_H */
 #endif /* CONFIG_FFSERVER */
 
-#endif /* OS_SUPPORT_H */
+#endif /* FFMPEG_OS_SUPPORT_H */
diff -u mplayer-1.0~rc2-12/libavformat/psxstr.c ffmpeg-free-0.svn20080206/libavformat/psxstr.c
--- mplayer-1.0~rc2-12/libavformat/psxstr.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/psxstr.c	2007-11-21 08:41:00.000000000 +0100
@@ -125,7 +125,7 @@
 static int str_read_header(AVFormatContext *s,
                            AVFormatParameters *ap)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     StrDemuxContext *str = s->priv_data;
     AVStream *st;
     unsigned char sector[RAW_CD_SECTOR_SIZE];
@@ -249,7 +249,7 @@
 static int str_read_packet(AVFormatContext *s,
                            AVPacket *ret_pkt)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     StrDemuxContext *str = s->priv_data;
     unsigned char sector[RAW_CD_SECTOR_SIZE];
     int channel;
Only in ffmpeg-free-0.svn20080206/libavformat: pva.c
diff -u mplayer-1.0~rc2-12/libavformat/qtpalette.h ffmpeg-free-0.svn20080206/libavformat/qtpalette.h
--- mplayer-1.0~rc2-12/libavformat/qtpalette.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/qtpalette.h	2007-12-03 13:46:20.000000000 +0100
@@ -20,17 +20,19 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef QTPALETTE_H
-#define QTPALETTE_H
+#ifndef FFMPEG_QTPALETTE_H
+#define FFMPEG_QTPALETTE_H
 
-unsigned char ff_qt_default_palette_4[4 * 4] = {
+#include <inttypes.h>
+
+static const uint8_t ff_qt_default_palette_4[4 * 4] = {
   0x93, 0x65, 0x5E, 0x00,
   0xFF, 0xFF, 0xFF, 0x00,
   0xDF, 0xD0, 0xAB, 0x00,
   0x00, 0x00, 0x00, 0x00
 };
 
-unsigned char ff_qt_default_palette_16[16 * 4] = {
+static const uint8_t ff_qt_default_palette_16[16 * 4] = {
   0xFF, 0xFB, 0xFF, 0x00,
   0xEF, 0xD9, 0xBB, 0x00,
   0xE8, 0xC9, 0xB1, 0x00,
@@ -49,7 +51,7 @@
   0x00, 0x00, 0x00, 0x00
 };
 
-unsigned char ff_qt_default_palette_256[256 * 4] = {
+static const uint8_t ff_qt_default_palette_256[256 * 4] = {
   /*   0, 0x00 */  0xFF, 0xFF, 0xFF, 0x00,
   /*   1, 0x01 */  0xFF, 0xFF, 0xCC, 0x00,
   /*   2, 0x02 */  0xFF, 0xFF, 0x99, 0x00,
@@ -308,4 +310,4 @@
   /* 255, 0xFF */  0x00, 0x00, 0x00, 0x00
 };
 
-#endif
+#endif /* FFMPEG_QTPALETTE_H */
diff -u mplayer-1.0~rc2-12/libavformat/raw.c ffmpeg-free-0.svn20080206/libavformat/raw.c
--- mplayer-1.0~rc2-12/libavformat/raw.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/raw.c	2008-01-12 01:24:10.000000000 +0100
@@ -33,8 +33,8 @@
     uint8_t *streaminfo = s->streams[0]->codec->extradata;
     int len = s->streams[0]->codec->extradata_size;
     if(streaminfo != NULL && len > 0) {
-        put_buffer(&s->pb, header, 8);
-        put_buffer(&s->pb, streaminfo, len);
+        put_buffer(s->pb, header, 8);
+        put_buffer(s->pb, streaminfo, len);
     }
     return 0;
 }
@@ -46,16 +46,16 @@
         0x84, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0x1E, 0x00
     };
 
-    put_buffer(&s->pb, header, 8);
-    put_flush_packet(&s->pb);
+    put_buffer(s->pb, header, 8);
+    put_flush_packet(s->pb);
 
     return 0;
 }
 
 static int raw_write_packet(struct AVFormatContext *s, AVPacket *pkt)
 {
-    put_buffer(&s->pb, pkt->data, pkt->size);
-    put_flush_packet(&s->pb);
+    put_buffer(s->pb, pkt->data, pkt->size);
+    put_flush_packet(s->pb);
     return 0;
 }
 #endif //CONFIG_MUXERS
@@ -85,7 +85,10 @@
             av_set_pts_info(st, 64, 1, st->codec->sample_rate);
             break;
         case CODEC_TYPE_VIDEO:
-            av_set_pts_info(st, 64, ap->time_base.num, ap->time_base.den);
+            if(ap->time_base.num)
+                av_set_pts_info(st, 64, ap->time_base.num, ap->time_base.den);
+            else
+                av_set_pts_info(st, 64, 1, 25);
             st->codec->width = ap->width;
             st->codec->height = ap->height;
             st->codec->pix_fmt = ap->pix_fmt;
@@ -102,12 +105,12 @@
 
 static int raw_read_packet(AVFormatContext *s, AVPacket *pkt)
 {
-    int ret, size;
+    int ret, size, bps;
     //    AVStream *st = s->streams[0];
 
     size= RAW_PACKET_SIZE;
 
-    ret= av_get_packet(&s->pb, pkt, size);
+    ret= av_get_packet(s->pb, pkt, size);
 
     pkt->stream_index = 0;
     if (ret <= 0) {
@@ -116,6 +119,12 @@
     /* note: we need to modify the packet size here to handle the last
        packet */
     pkt->size = ret;
+
+    bps= av_get_bits_per_sample(s->streams[0]->codec->codec_id);
+    assert(bps); // if false there IS a bug elsewhere (NOT in this function)
+    pkt->dts=
+    pkt->pts= pkt->pos*8 / (bps * s->streams[0]->codec->channels);
+
     return ret;
 }
 
@@ -128,9 +137,9 @@
     if (av_new_packet(pkt, size) < 0)
         return AVERROR(EIO);
 
-    pkt->pos= url_ftell(&s->pb);
+    pkt->pos= url_ftell(s->pb);
     pkt->stream_index = 0;
-    ret = get_partial_buffer(&s->pb, pkt->data, size);
+    ret = get_partial_buffer(s->pb, pkt->data, size);
     if (ret <= 0) {
         av_free_packet(pkt);
         return AVERROR(EIO);
@@ -144,19 +153,19 @@
 {
     int ret, size, w, h, unk1, unk2;
 
-    if (get_le32(&s->pb) != MKTAG('M', 'J', 'P', 'G'))
+    if (get_le32(s->pb) != MKTAG('M', 'J', 'P', 'G'))
         return AVERROR(EIO); // FIXME
 
-    size = get_le32(&s->pb);
+    size = get_le32(s->pb);
 
-    w = get_le16(&s->pb);
-    h = get_le16(&s->pb);
+    w = get_le16(s->pb);
+    h = get_le16(s->pb);
 
-    url_fskip(&s->pb, 8); // zero + size (padded?)
-    url_fskip(&s->pb, 2);
-    unk1 = get_le16(&s->pb);
-    unk2 = get_le16(&s->pb);
-    url_fskip(&s->pb, 22); // ascii timestamp
+    url_fskip(s->pb, 8); // zero + size (padded?)
+    url_fskip(s->pb, 2);
+    unk1 = get_le16(s->pb);
+    unk2 = get_le16(s->pb);
+    url_fskip(s->pb, 22); // ascii timestamp
 
     av_log(NULL, AV_LOG_DEBUG, "Ingenient packet: size=%d, width=%d, height=%d, unk1=%d unk2=%d\n",
         size, w, h, unk1, unk2);
@@ -164,9 +173,9 @@
     if (av_new_packet(pkt, size) < 0)
         return AVERROR(EIO);
 
-    pkt->pos = url_ftell(&s->pb);
+    pkt->pos = url_ftell(s->pb);
     pkt->stream_index = 0;
-    ret = get_buffer(&s->pb, pkt->data, size);
+    ret = get_buffer(s->pb, pkt->data, size);
     if (ret <= 0) {
         av_free_packet(pkt);
         return AVERROR(EIO);
@@ -206,7 +215,7 @@
 
     /* recompute exact position */
     st->cur_dts = av_rescale(pos, st->time_base.den, byte_rate * (int64_t)st->time_base.num);
-    url_fseek(&s->pb, pos + s->data_offset, SEEK_SET);
+    url_fseek(s->pb, pos + s->data_offset, SEEK_SET);
     return 0;
 }
 
@@ -843,7 +852,9 @@
     if (packet_size < 0)
         return -1;
 
-    ret= av_get_packet(&s->pb, pkt, packet_size);
+    ret= av_get_packet(s->pb, pkt, packet_size);
+    pkt->pts=
+    pkt->dts= pkt->pos / packet_size;
 
     pkt->stream_index = 0;
     if (ret != packet_size) {
diff -u mplayer-1.0~rc2-12/libavformat/raw.h ffmpeg-free-0.svn20080206/libavformat/raw.h
--- mplayer-1.0~rc2-12/libavformat/raw.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/raw.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,12 +19,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVFORMAT_RAW_H
-#define AVFORMAT_RAW_H
+#ifndef FFMPEG_RAW_H
+#define FFMPEG_RAW_H
 
 #include "avformat.h"
 
 int pcm_read_seek(AVFormatContext *s,
                   int stream_index, int64_t timestamp, int flags);
 
-#endif /* AVFORMAT_RAW_H */
+#endif /* FFMPEG_RAW_H */
diff -u mplayer-1.0~rc2-12/libavformat/riff.c ffmpeg-free-0.svn20080206/libavformat/riff.c
--- mplayer-1.0~rc2-12/libavformat/riff.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/riff.c	2008-02-04 13:18:00.000000000 +0100
@@ -87,6 +87,7 @@
     { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'h', 'd') },
     { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 's', 'l') },
     { CODEC_ID_DVVIDEO, MKTAG('d', 'v', '2', '5') },
+    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', '5', '0') },
     { CODEC_ID_MPEG1VIDEO, MKTAG('m', 'p', 'g', '1') },
     { CODEC_ID_MPEG1VIDEO, MKTAG('m', 'p', 'g', '2') },
     { CODEC_ID_MPEG2VIDEO, MKTAG('m', 'p', 'g', '2') },
diff -u mplayer-1.0~rc2-12/libavformat/riff.h ffmpeg-free-0.svn20080206/libavformat/riff.h
--- mplayer-1.0~rc2-12/libavformat/riff.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/riff.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * do NOT include this in end user applications
  */
 
-#ifndef FF_RIFF_H
-#define FF_RIFF_H
+#ifndef FFMPEG_RIFF_H
+#define FFMPEG_RIFF_H
 
 #include "avcodec.h"
 #include "avio.h"
@@ -51,4 +51,4 @@
 enum CodecID codec_get_id(const AVCodecTag *tags, unsigned int tag);
 void ff_parse_specific_params(AVCodecContext *stream, int *au_rate, int *au_ssize, int *au_scale);
 
-#endif
+#endif /* FFMPEG_RIFF_H */
diff -u mplayer-1.0~rc2-12/libavformat/rmdec.c ffmpeg-free-0.svn20080206/libavformat/rmdec.c
--- mplayer-1.0~rc2-12/libavformat/rmdec.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rmdec.c	2008-01-17 21:48:07.000000000 +0100
@@ -50,7 +50,7 @@
                                       int read_all)
 {
     RMContext *rm = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     char buf[256];
     uint32_t version;
     int i;
@@ -188,6 +188,74 @@
     return 0;
 }
 
+int
+ff_rm_read_mdpr_codecdata (AVFormatContext *s, AVStream *st)
+{
+    ByteIOContext *pb = s->pb;
+    unsigned int v;
+    int codec_data_size, size;
+    int64_t codec_pos;
+
+    codec_data_size = get_be32(pb);
+    codec_pos = url_ftell(pb);
+    v = get_be32(pb);
+    if (v == MKTAG(0xfd, 'a', 'r', '.')) {
+        /* ra type header */
+        if (rm_read_audio_stream_info(s, st, 0))
+            return -1;
+    } else {
+        int fps, fps2;
+        if (get_le32(pb) != MKTAG('V', 'I', 'D', 'O')) {
+        fail1:
+            av_log(st->codec, AV_LOG_ERROR, "Unsupported video codec\n");
+            goto skip;
+        }
+        st->codec->codec_tag = get_le32(pb);
+//        av_log(NULL, AV_LOG_DEBUG, "%X %X\n", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));
+        if (   st->codec->codec_tag != MKTAG('R', 'V', '1', '0')
+            && st->codec->codec_tag != MKTAG('R', 'V', '2', '0')
+            && st->codec->codec_tag != MKTAG('R', 'V', '3', '0')
+            && st->codec->codec_tag != MKTAG('R', 'V', '4', '0'))
+            goto fail1;
+        st->codec->width = get_be16(pb);
+        st->codec->height = get_be16(pb);
+        st->codec->time_base.num= 1;
+        fps= get_be16(pb);
+        st->codec->codec_type = CODEC_TYPE_VIDEO;
+        get_be32(pb);
+        fps2= get_be16(pb);
+        get_be16(pb);
+
+        st->codec->extradata_size= codec_data_size - (url_ftell(pb) - codec_pos);
+
+        if(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)st->codec->extradata_size){
+            //check is redundant as get_buffer() will catch this
+            av_log(s, AV_LOG_ERROR, "st->codec->extradata_size too large\n");
+            return -1;
+        }
+        st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+        get_buffer(pb, st->codec->extradata, st->codec->extradata_size);
+
+//        av_log(NULL, AV_LOG_DEBUG, "fps= %d fps2= %d\n", fps, fps2);
+        st->codec->time_base.den = fps * st->codec->time_base.num;
+        switch(((uint8_t*)st->codec->extradata)[4]>>4){
+        case 1: st->codec->codec_id = CODEC_ID_RV10; break;
+        case 2: st->codec->codec_id = CODEC_ID_RV20; break;
+        case 3: st->codec->codec_id = CODEC_ID_RV30; break;
+        case 4: st->codec->codec_id = CODEC_ID_RV40; break;
+        default: goto fail1;
+        }
+    }
+
+skip:
+    /* skip codec info */
+    size = url_ftell(pb) - codec_pos;
+    url_fskip(pb, codec_data_size - size);
+
+    return 0;
+}
+
+
 static int rm_read_header_old(AVFormatContext *s, AVFormatParameters *ap)
 {
     RMContext *rm = s->priv_data;
@@ -204,10 +272,9 @@
 {
     RMContext *rm = s->priv_data;
     AVStream *st;
-    ByteIOContext *pb = &s->pb;
-    unsigned int tag, v;
-    int tag_size, size, codec_data_size, i;
-    int64_t codec_pos;
+    ByteIOContext *pb = s->pb;
+    unsigned int tag;
+    int tag_size, i;
     unsigned int start_time, duration;
     char buf[128];
     int flags = 0;
@@ -279,63 +346,10 @@
             st->duration = duration;
             get_str8(pb, buf, sizeof(buf)); /* desc */
             get_str8(pb, buf, sizeof(buf)); /* mimetype */
-            codec_data_size = get_be32(pb);
-            codec_pos = url_ftell(pb);
             st->codec->codec_type = CODEC_TYPE_DATA;
             av_set_pts_info(st, 64, 1, 1000);
-
-            v = get_be32(pb);
-            if (v == MKTAG(0xfd, 'a', 'r', '.')) {
-                /* ra type header */
-                if (rm_read_audio_stream_info(s, st, 0))
-                    return -1;
-            } else {
-                int fps, fps2;
-                if (get_le32(pb) != MKTAG('V', 'I', 'D', 'O')) {
-                fail1:
-                    av_log(st->codec, AV_LOG_ERROR, "Unsupported video codec\n");
-                    goto skip;
-                }
-                st->codec->codec_tag = get_le32(pb);
-//                av_log(NULL, AV_LOG_DEBUG, "%X %X\n", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));
-                if (   st->codec->codec_tag != MKTAG('R', 'V', '1', '0')
-                    && st->codec->codec_tag != MKTAG('R', 'V', '2', '0')
-                    && st->codec->codec_tag != MKTAG('R', 'V', '3', '0')
-                    && st->codec->codec_tag != MKTAG('R', 'V', '4', '0'))
-                    goto fail1;
-                st->codec->width = get_be16(pb);
-                st->codec->height = get_be16(pb);
-                st->codec->time_base.num= 1;
-                fps= get_be16(pb);
-                st->codec->codec_type = CODEC_TYPE_VIDEO;
-                get_be32(pb);
-                fps2= get_be16(pb);
-                get_be16(pb);
-
-                st->codec->extradata_size= codec_data_size - (url_ftell(pb) - codec_pos);
-
-                if(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)st->codec->extradata_size){
-                    //check is redundant as get_buffer() will catch this
-                    av_log(s, AV_LOG_ERROR, "st->codec->extradata_size too large\n");
-                    return -1;
-                }
-                st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
-                get_buffer(pb, st->codec->extradata, st->codec->extradata_size);
-
-//                av_log(NULL, AV_LOG_DEBUG, "fps= %d fps2= %d\n", fps, fps2);
-                st->codec->time_base.den = fps * st->codec->time_base.num;
-                switch(((uint8_t*)st->codec->extradata)[4]>>4){
-                case 1: st->codec->codec_id = CODEC_ID_RV10; break;
-                case 2: st->codec->codec_id = CODEC_ID_RV20; break;
-                case 3: st->codec->codec_id = CODEC_ID_RV30; break;
-                case 4: st->codec->codec_id = CODEC_ID_RV40; break;
-                default: goto fail1;
-                }
-            }
-skip:
-            /* skip codec info */
-            size = url_ftell(pb) - codec_pos;
-            url_fskip(pb, codec_data_size - size);
+            if (ff_rm_read_mdpr_codecdata(s, st) < 0)
+                return -1;
             break;
         case MKTAG('D', 'A', 'T', 'A'):
             goto header_end;
@@ -350,6 +364,7 @@
     if (!rm->nb_packets && (flags & 4))
         rm->nb_packets = 3600 * 25;
     get_be32(pb); /* next data header */
+    rm->curpic_num = -1;
     return 0;
 
  fail:
@@ -365,6 +380,7 @@
 
     n = get_be16(pb);
     (*len)-=2;
+    n &= 0x7FFF;
     if (n >= 0x4000) {
         return n - 0x4000;
     } else {
@@ -379,7 +395,7 @@
 
 static int sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){
     RMContext *rm = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int len, num, res, i;
     AVStream *st;
     uint32_t state=0xFFFFFFFF;
@@ -433,30 +449,235 @@
     return -1;
 }
 
+static int rm_assemble_video_frame(AVFormatContext *s, RMContext *rm, AVPacket *pkt, int len)
+{
+    ByteIOContext *pb = s->pb;
+    int hdr, seq, pic_num, len2, pos;
+    int type;
+
+    hdr = get_byte(pb); len--;
+    type = hdr >> 6;
+    switch(type){
+    case 0: // slice
+    case 2: // last slice
+        seq = get_byte(pb); len--;
+        len2 = get_num(pb, &len);
+        pos = get_num(pb, &len);
+        pic_num = get_byte(pb); len--;
+        rm->remaining_len = len;
+        break;
+    case 1: //whole frame
+        seq = get_byte(pb); len--;
+        if(av_new_packet(pkt, len + 9) < 0)
+            return AVERROR(EIO);
+        pkt->data[0] = 0;
+        AV_WL32(pkt->data + 1, 1);
+        AV_WL32(pkt->data + 5, 0);
+        get_buffer(pb, pkt->data + 9, len);
+        rm->remaining_len = 0;
+        return 0;
+    case 3: //frame as a part of packet
+        len2 = get_num(pb, &len);
+        pos = get_num(pb, &len);
+        pic_num = get_byte(pb); len--;
+        rm->remaining_len = len - len2;
+        if(av_new_packet(pkt, len2 + 9) < 0)
+            return AVERROR(EIO);
+        pkt->data[0] = 0;
+        AV_WL32(pkt->data + 1, 1);
+        AV_WL32(pkt->data + 5, 0);
+        get_buffer(pb, pkt->data + 9, len2);
+        return 0;
+    }
+    //now we have to deal with single slice
+
+    if((seq & 0x7F) == 1 || rm->curpic_num != pic_num){
+        rm->slices = ((hdr & 0x3F) << 1) + 1;
+        rm->videobufsize = len2 + 8*rm->slices + 1;
+        av_free(rm->videobuf);
+        if(!(rm->videobuf = av_malloc(rm->videobufsize)))
+            return AVERROR(ENOMEM);
+        rm->videobufpos = 8*rm->slices + 1;
+        rm->cur_slice = 0;
+        rm->curpic_num = pic_num;
+        rm->pktpos = url_ftell(pb);
+    }
+    if(type == 2)
+        len = FFMIN(len, pos);
+
+    if(++rm->cur_slice > rm->slices)
+        return 1;
+    AV_WL32(rm->videobuf - 7 + 8*rm->cur_slice, 1);
+    AV_WL32(rm->videobuf - 3 + 8*rm->cur_slice, rm->videobufpos - 8*rm->slices - 1);
+    if(rm->videobufpos + len > rm->videobufsize)
+        return 1;
+    if (get_buffer(pb, rm->videobuf + rm->videobufpos, len) != len)
+        return AVERROR(EIO);
+    rm->videobufpos += len;
+    rm->remaining_len-= len;
+
+    if(type == 2 || (rm->videobufpos) == rm->videobufsize){
+         rm->videobuf[0] = rm->cur_slice-1;
+         if(av_new_packet(pkt, rm->videobufpos - 8*(rm->slices - rm->cur_slice)) < 0)
+             return AVERROR(ENOMEM);
+         memcpy(pkt->data, rm->videobuf, 1 + 8*rm->cur_slice);
+         memcpy(pkt->data + 1 + 8*rm->cur_slice, rm->videobuf + 1 + 8*rm->slices,
+                rm->videobufpos - 1 - 8*rm->slices);
+         pkt->pts = AV_NOPTS_VALUE;
+         pkt->pos = rm->pktpos;
+         return 0;
+    }
+
+    return 1;
+}
+
+static inline void
+rm_ac3_swap_bytes (AVStream *st, AVPacket *pkt)
+{
+    uint8_t *ptr;
+    int j;
+
+    if (st->codec->codec_id == CODEC_ID_AC3) {
+        ptr = pkt->data;
+        for (j=0;j<pkt->size;j+=2) {
+            FFSWAP(int, ptr[0], ptr[1]);
+            ptr += 2;
+        }
+    }
+}
+
+int
+ff_rm_parse_packet (AVFormatContext *s, AVStream *st, int len, AVPacket *pkt,
+                    int *seq, int *flags, int64_t *timestamp)
+{
+    ByteIOContext *pb = s->pb;
+    RMContext *rm = s->priv_data;
+
+    if (st->codec->codec_type == CODEC_TYPE_VIDEO) {
+        rm->current_stream= st->id;
+        if(rm_assemble_video_frame(s, rm, pkt, len) == 1)
+            return -1; //got partial frame
+    } else if (st->codec->codec_type == CODEC_TYPE_AUDIO) {
+        if ((st->codec->codec_id == CODEC_ID_RA_288) ||
+            (st->codec->codec_id == CODEC_ID_COOK) ||
+            (st->codec->codec_id == CODEC_ID_ATRAC3)) {
+            int x;
+            int sps = rm->sub_packet_size;
+            int cfs = rm->coded_framesize;
+            int h = rm->sub_packet_h;
+            int y = rm->sub_packet_cnt;
+            int w = rm->audio_framesize;
+
+            if (*flags & 2)
+                y = rm->sub_packet_cnt = 0;
+            if (!y)
+                rm->audiotimestamp = *timestamp;
+
+            switch(st->codec->codec_id) {
+                case CODEC_ID_RA_288:
+                    for (x = 0; x < h/2; x++)
+                        get_buffer(pb, rm->audiobuf+x*2*w+y*cfs, cfs);
+                    break;
+                case CODEC_ID_ATRAC3:
+                case CODEC_ID_COOK:
+                    for (x = 0; x < w/sps; x++)
+                        get_buffer(pb, rm->audiobuf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);
+                    break;
+            }
+
+            if (++(rm->sub_packet_cnt) < h)
+                return -1;
+            else {
+                rm->sub_packet_cnt = 0;
+                rm->audio_stream_num = st->index;
+                rm->audio_pkt_cnt = h * w / st->codec->block_align - 1;
+                // Release first audio packet
+                av_new_packet(pkt, st->codec->block_align);
+                memcpy(pkt->data, rm->audiobuf, st->codec->block_align);
+                *timestamp = rm->audiotimestamp;
+                *flags = 2; // Mark first packet as keyframe
+            }
+        } else if (st->codec->codec_id == CODEC_ID_AAC) {
+            int x;
+            rm->audio_stream_num = st->index;
+            rm->sub_packet_cnt = (get_be16(pb) & 0xf0) >> 4;
+            if (rm->sub_packet_cnt) {
+                for (x = 0; x < rm->sub_packet_cnt; x++)
+                    rm->sub_packet_lengths[x] = get_be16(pb);
+                // Release first audio packet
+                rm->audio_pkt_cnt = rm->sub_packet_cnt - 1;
+                av_get_packet(pb, pkt, rm->sub_packet_lengths[0]);
+                *flags = 2; // Mark first packet as keyframe
+            }
+        } else {
+            av_get_packet(pb, pkt, len);
+            rm_ac3_swap_bytes(st, pkt);
+        }
+    } else
+        av_get_packet(pb, pkt, len);
+
+    if(  (st->discard >= AVDISCARD_NONKEY && !(*flags&2))
+       || st->discard >= AVDISCARD_ALL){
+        av_free_packet(pkt);
+        return -1;
+    }
+
+    pkt->stream_index = st->index;
+
+#if 0
+    if (st->codec->codec_type == CODEC_TYPE_VIDEO) {
+        if(st->codec->codec_id == CODEC_ID_RV20){
+            int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1);
+            av_log(NULL, AV_LOG_DEBUG, "%d %"PRId64" %d\n", *timestamp, *timestamp*512LL/25, seq);
+
+            seq |= (*timestamp&~0x3FFF);
+            if(seq - *timestamp >  0x2000) seq -= 0x4000;
+            if(seq - *timestamp < -0x2000) seq += 0x4000;
+        }
+    }
+#endif
+
+    pkt->pts= *timestamp;
+    if (*flags & 2)
+        pkt->flags |= PKT_FLAG_KEY;
+
+    return 0;
+}
+
+void
+ff_rm_retrieve_cache (AVFormatContext *s, AVStream *st, AVPacket *pkt)
+{
+    ByteIOContext *pb = s->pb;
+    RMContext *rm = s->priv_data;
+
+    assert (rm->audio_pkt_cnt > 0);
+
+    if (st->codec->codec_id == CODEC_ID_AAC)
+        av_get_packet(pb, pkt, rm->sub_packet_lengths[rm->sub_packet_cnt - rm->audio_pkt_cnt]);
+    else {
+        av_new_packet(pkt, st->codec->block_align);
+        memcpy(pkt->data, rm->audiobuf + st->codec->block_align *
+               (rm->sub_packet_h * rm->audio_framesize / st->codec->block_align - rm->audio_pkt_cnt),
+               st->codec->block_align);
+    }
+    rm->audio_pkt_cnt--;
+    pkt->flags = 0;
+    pkt->stream_index = st->index;
+}
+
 static int rm_read_packet(AVFormatContext *s, AVPacket *pkt)
 {
     RMContext *rm = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st;
-    int i, len, j;
+    int i, len;
     int64_t timestamp, pos;
-    uint8_t *ptr;
     int flags;
 
     if (rm->audio_pkt_cnt) {
         // If there are queued audio packet return them first
         st = s->streams[rm->audio_stream_num];
-        if (st->codec->codec_id == CODEC_ID_AAC)
-            av_get_packet(pb, pkt, rm->sub_packet_lengths[rm->sub_packet_cnt - rm->audio_pkt_cnt]);
-        else {
-        av_new_packet(pkt, st->codec->block_align);
-        memcpy(pkt->data, rm->audiobuf + st->codec->block_align *
-               (rm->sub_packet_h * rm->audio_framesize / st->codec->block_align - rm->audio_pkt_cnt),
-               st->codec->block_align);
-        }
-        rm->audio_pkt_cnt--;
-        pkt->flags = 0;
-        pkt->stream_index = rm->audio_stream_num;
+        ff_rm_retrieve_cache(s, st, pkt);
     } else if (rm->old_format) {
         st = s->streams[0];
         if (st->codec->codec_id == CODEC_ID_RA_288) {
@@ -483,6 +704,7 @@
             }
             pkt->size = len;
         }
+        rm_ac3_swap_bytes(st, pkt);
     } else {
         int seq=1;
 resync:
@@ -491,127 +713,13 @@
             return AVERROR(EIO);
         st = s->streams[i];
 
-        if (st->codec->codec_type == CODEC_TYPE_VIDEO) {
-            int h, pic_num, len2, pos;
-
-            h= get_byte(pb); len--;
-            if(!(h & 0x40)){
-                seq = get_byte(pb); len--;
-            }
-
-            if((h & 0xc0) == 0x40){
-                len2= pos= 0;
-            }else{
-                len2 = get_num(pb, &len);
-                pos = get_num(pb, &len);
-            }
-            /* picture number */
-            pic_num= get_byte(pb); len--;
-            rm->remaining_len= len;
-            rm->current_stream= st->id;
-
-//            av_log(NULL, AV_LOG_DEBUG, "%X len:%d pos:%d len2:%d pic_num:%d\n",h, len, pos, len2, pic_num);
-            if((h & 0xc0) == 0x80)
-                len=pos;
-            if(len2 && len2<len)
-                len=len2;
-            rm->remaining_len-= len;
-            av_get_packet(pb, pkt, len);
-
-        } else if (st->codec->codec_type == CODEC_TYPE_AUDIO) {
-            if ((st->codec->codec_id == CODEC_ID_RA_288) ||
-                (st->codec->codec_id == CODEC_ID_COOK) ||
-                (st->codec->codec_id == CODEC_ID_ATRAC3)) {
-                int x;
-                int sps = rm->sub_packet_size;
-                int cfs = rm->coded_framesize;
-                int h = rm->sub_packet_h;
-                int y = rm->sub_packet_cnt;
-                int w = rm->audio_framesize;
-
-                if (flags & 2)
-                    y = rm->sub_packet_cnt = 0;
-                if (!y)
-                    rm->audiotimestamp = timestamp;
-
-                switch(st->codec->codec_id) {
-                    case CODEC_ID_RA_288:
-                        for (x = 0; x < h/2; x++)
-                            get_buffer(pb, rm->audiobuf+x*2*w+y*cfs, cfs);
-                        break;
-                    case CODEC_ID_ATRAC3:
-                    case CODEC_ID_COOK:
-                        for (x = 0; x < w/sps; x++)
-                            get_buffer(pb, rm->audiobuf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);
-                        break;
-                }
-
-                if (++(rm->sub_packet_cnt) < h)
-                    goto resync;
-                else {
-                    rm->sub_packet_cnt = 0;
-                    rm->audio_stream_num = i;
-                    rm->audio_pkt_cnt = h * w / st->codec->block_align - 1;
-                    // Release first audio packet
-                    av_new_packet(pkt, st->codec->block_align);
-                    memcpy(pkt->data, rm->audiobuf, st->codec->block_align);
-                    timestamp = rm->audiotimestamp;
-                    flags = 2; // Mark first packet as keyframe
-                }
-            } else if (st->codec->codec_id == CODEC_ID_AAC) {
-                int x;
-                rm->audio_stream_num = i;
-                rm->sub_packet_cnt = (get_be16(pb) & 0xf0) >> 4;
-                if (rm->sub_packet_cnt) {
-                    for (x = 0; x < rm->sub_packet_cnt; x++)
-                        rm->sub_packet_lengths[x] = get_be16(pb);
-                    // Release first audio packet
-                    rm->audio_pkt_cnt = rm->sub_packet_cnt - 1;
-                    av_get_packet(pb, pkt, rm->sub_packet_lengths[0]);
-                    flags = 2; // Mark first packet as keyframe
-                }
-            } else
-                av_get_packet(pb, pkt, len);
-
-        } else
-            av_get_packet(pb, pkt, len);
-
-        if(  (st->discard >= AVDISCARD_NONKEY && !(flags&2))
-           || st->discard >= AVDISCARD_ALL){
-            av_free_packet(pkt);
+        if (ff_rm_parse_packet (s, st, len, pkt, &seq, &flags, &timestamp) < 0)
             goto resync;
-        }
-
-        pkt->stream_index = i;
 
-#if 0
-        if (st->codec->codec_type == CODEC_TYPE_VIDEO) {
-            if(st->codec->codec_id == CODEC_ID_RV20){
-                int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1);
-                av_log(NULL, AV_LOG_DEBUG, "%d %"PRId64" %d\n", timestamp, timestamp*512LL/25, seq);
-
-                seq |= (timestamp&~0x3FFF);
-                if(seq - timestamp >  0x2000) seq -= 0x4000;
-                if(seq - timestamp < -0x2000) seq += 0x4000;
-            }
-        }
-#endif
-        pkt->pts= timestamp;
-        if(flags&2){
-            pkt->flags |= PKT_FLAG_KEY;
-            if((seq&0x7F) == 1)
-                av_add_index_entry(st, pos, timestamp, 0, 0, AVINDEX_KEYFRAME);
-        }
+        if((flags&2) && (seq&0x7F) == 1)
+            av_add_index_entry(st, pos, timestamp, 0, 0, AVINDEX_KEYFRAME);
     }
 
-    /* for AC3, needs to swap bytes */
-    if (st->codec->codec_id == CODEC_ID_AC3) {
-        ptr = pkt->data;
-        for(j=0;j<pkt->size;j+=2) {
-            FFSWAP(int, ptr[0], ptr[1]);
-            ptr += 2;
-        }
-    }
     return 0;
 }
 
@@ -620,6 +728,7 @@
     RMContext *rm = s->priv_data;
 
     av_free(rm->audiobuf);
+    av_free(rm->videobuf);
     return 0;
 }
 
@@ -648,7 +757,7 @@
     if(rm->old_format)
         return AV_NOPTS_VALUE;
 
-    url_fseek(&s->pb, pos, SEEK_SET);
+    url_fseek(s->pb, pos, SEEK_SET);
     rm->remaining_len=0;
     for(;;){
         int seq=1;
@@ -660,9 +769,9 @@
 
         st = s->streams[stream_index2];
         if (st->codec->codec_type == CODEC_TYPE_VIDEO) {
-            h= get_byte(&s->pb); len--;
+            h= get_byte(s->pb); len--;
             if(!(h & 0x40)){
-                seq = get_byte(&s->pb); len--;
+                seq = get_byte(s->pb); len--;
             }
         }
 
@@ -673,7 +782,7 @@
                 break;
         }
 
-        url_fskip(&s->pb, len);
+        url_fskip(s->pb, len);
     }
     *ppos = pos;
     return dts;
diff -u mplayer-1.0~rc2-12/libavformat/rmenc.c ffmpeg-free-0.svn20080206/libavformat/rmenc.c
--- mplayer-1.0~rc2-12/libavformat/rmenc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rmenc.c	2007-12-02 18:51:05.000000000 +0100
@@ -45,7 +45,7 @@
                               int data_size, int index_pos)
 {
     RMContext *rm = ctx->priv_data;
-    ByteIOContext *s = &ctx->pb;
+    ByteIOContext *s = ctx->pb;
     StreamInfo *stream;
     unsigned char *data_offset_ptr, *start_ptr;
     const char *desc, *mimetype;
@@ -253,7 +253,7 @@
                                 int length, int key_frame)
 {
     int timestamp;
-    ByteIOContext *s = &ctx->pb;
+    ByteIOContext *s = ctx->pb;
 
     stream->nb_packets++;
     stream->packet_total_size += length;
@@ -308,7 +308,7 @@
     }
 
     rv10_write_header(s, 0, 0);
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
     return 0;
 }
 
@@ -316,7 +316,7 @@
 {
     uint8_t *buf1;
     RMContext *rm = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     StreamInfo *stream = rm->audio_stream;
     int i;
 
@@ -340,7 +340,7 @@
 static int rm_write_video(AVFormatContext *s, const uint8_t *buf, int size, int flags)
 {
     RMContext *rm = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     StreamInfo *stream = rm->video_stream;
     int key_frame = !!(flags & PKT_FLAG_KEY);
 
@@ -349,7 +349,7 @@
     /* Well, I spent some time finding the meaning of these bits. I am
        not sure I understood everything, but it works !! */
 #if 1
-    write_packet_header(s, stream, size + 7, key_frame);
+    write_packet_header(s, stream, size + 7 + (size >= 0x4000)*4, key_frame);
     /* bit 7: '1' if final packet of a frame converted in several packets */
     put_byte(pb, 0x81);
     /* bit 7: '1' if I frame. bits 6..0 : sequence number in current
@@ -359,8 +359,13 @@
     } else {
         put_byte(pb, 0x01);
     }
-    put_be16(pb, 0x4000 + (size)); /* total frame size */
-    put_be16(pb, 0x4000 + (size));              /* offset from the start or the end */
+    if(size >= 0x4000){
+        put_be32(pb, size); /* total frame size */
+        put_be32(pb, size); /* offset from the start or the end */
+    }else{
+        put_be16(pb, 0x4000 | size); /* total frame size */
+        put_be16(pb, 0x4000 | size); /* offset from the start or the end */
+    }
 #else
     /* full frame */
     write_packet_header(s, size + 6);
@@ -390,9 +395,9 @@
 {
     RMContext *rm = s->priv_data;
     int data_size, index_pos, i;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
 
-    if (!url_is_streamed(&s->pb)) {
+    if (!url_is_streamed(s->pb)) {
         /* end of file: finish to write header */
         index_pos = url_fseek(pb, 0, SEEK_CUR);
         data_size = index_pos - rm->data_pos;
diff -u mplayer-1.0~rc2-12/libavformat/rm.h ffmpeg-free-0.svn20080206/libavformat/rm.h
--- mplayer-1.0~rc2-12/libavformat/rm.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rm.h	2008-01-04 14:00:47.000000000 +0100
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef RM_H
-#define RM_H
+#ifndef FFMPEG_RM_H
+#define FFMPEG_RM_H
 
 #include "avformat.h"
 
@@ -46,6 +46,12 @@
     int old_format;
     int current_stream;
     int remaining_len;
+    uint8_t *videobuf; ///< place to store merged video frame
+    int videobufsize;  ///< current assembled frame size
+    int videobufpos;   ///< position for the next slice in the video buffer
+    int curpic_num;    ///< picture number of current frame
+    int cur_slice, slices;
+    int64_t pktpos;    ///< first slice position in file
     /// Audio descrambling matrix parameters
     uint8_t *audiobuf; ///< place to store reordered audio data
     int64_t audiotimestamp; ///< Audio packet timestamp
@@ -57,4 +63,46 @@
     int sub_packet_lengths[16]; /// Length of each aac subpacket
 } RMContext;
 
-#endif /* RM_H */
+/**
+ * Read the MDPR chunk, which contains stream-specific codec initialization
+ * parameters.
+ *
+ * @param s context containing RMContext and ByteIOContext for stream reading
+ * @param st the stream that the MDPR chunk belongs to and where to store the
+ *           parameters read from the chunk into
+ * @return 0 on success, errno codes on error
+ */
+int ff_rm_read_mdpr_codecdata (AVFormatContext *s, AVStream *st);
+
+/**
+ * Parse one rm-stream packet from the input bytestream.
+ *
+ * @param s context containing RMContext and ByteIOContext for stream reading
+ * @param st stream to which the packet to be read belongs
+ * @param len packet length to read from the input
+ * @param pkt packet location to store the parsed packet data
+ * @param seq pointer to an integer containing the sequence number, may be
+ *            updated
+ * @param flags pointer to an integer containing the packet flags, may be
+                updated
+ * @param ts pointer to timestamp, may be updated
+ * @return 0 on success, errno codes on error
+ */
+int ff_rm_parse_packet (AVFormatContext *s, AVStream *st, int len,
+                        AVPacket *pkt, int *seq, int *flags, int64_t *ts);
+
+/**
+ * Retrieve one cached packet from the rm-context. The real container can
+ * store several packets (as interpreted by the codec) in a single container
+ * packet, which means the demuxer holds some back when the first container
+ * packet is parsed and returned. The result is that rm->audio_pkt_cnt is
+ * a positive number, the amount of cached packets. Using this function, each
+ * of those packets can be retrieved sequentially.
+ *
+ * @param s context containing RMContext and ByteIOContext for stream reading
+ * @param st stream that this packet belongs to
+ * @param pkt location to store the packet data
+ */
+void ff_rm_retrieve_cache (AVFormatContext *s, AVStream *st, AVPacket *pkt);
+
+#endif /* FFMPEG_RM_H */
diff -u mplayer-1.0~rc2-12/libavformat/rtp_aac.h ffmpeg-free-0.svn20080206/libavformat/rtp_aac.h
--- mplayer-1.0~rc2-12/libavformat/rtp_aac.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rtp_aac.h	2007-11-24 11:08:02.000000000 +0100
@@ -17,9 +17,11 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-#ifndef RTP_AAC_H
-#define RTP_AAC_H
+#ifndef FFMPEG_RTP_AAC_H
+#define FFMPEG_RTP_AAC_H
+
+#include "avformat.h"
 
 void ff_rtp_send_aac(AVFormatContext *s1, const uint8_t *buff, int size);
 
-#endif /* RTP_AAC_H */
+#endif /* FFMPEG_RTP_AAC_H */
diff -u mplayer-1.0~rc2-12/libavformat/rtp.c ffmpeg-free-0.svn20080206/libavformat/rtp.c
--- mplayer-1.0~rc2-12/libavformat/rtp.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rtp.c	2008-01-06 11:00:04.000000000 +0100
@@ -19,31 +19,25 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include "avformat.h"
-#include "mpegts.h"
 #include "bitstream.h"
 
 #include <unistd.h>
 #include "network.h"
 
 #include "rtp_internal.h"
-#include "rtp_h264.h"
-#include "rtp_mpv.h"
-#include "rtp_aac.h"
 
 //#define DEBUG
 
-
-/* TODO: - add RTCP statistics reporting (should be optional).
-
-         - add support for h263/mpeg4 packetized output : IDEA: send a
-         buffer to 'rtp_write_packet' contains all the packets for ONE
-         frame. Each packet should have a four byte header containing
-         the length in big endian format (same trick as
-         'url_open_dyn_packet_buf')
-*/
-
 /* from http://www.iana.org/assignments/rtp-parameters last updated 05 January 2005 */
-AVRtpPayloadType_t AVRtpPayloadTypes[]=
+static const struct
+{
+    int pt;
+    const char enc_name[50]; /* XXX: why 50 ? */
+    enum CodecType codec_type;
+    enum CodecID codec_id;
+    int clock_rate;
+    int audio_channels;
+} AVRtpPayloadTypes[]=
 {
   {0, "PCMU",        CODEC_TYPE_AUDIO,   CODEC_ID_PCM_MULAW, 8000, 1},
   {1, "Reserved",    CODEC_TYPE_UNKNOWN, CODEC_ID_NONE, -1, -1},
@@ -78,6 +72,7 @@
   {30, "unassigned", CODEC_TYPE_VIDEO,   CODEC_ID_NONE, -1, -1},
   {31, "H261",       CODEC_TYPE_VIDEO,   CODEC_ID_H261, 90000, -1},
   {32, "MPV",        CODEC_TYPE_VIDEO,   CODEC_ID_MPEG1VIDEO, 90000, -1},
+  {32, "MPV",        CODEC_TYPE_VIDEO,   CODEC_ID_MPEG2VIDEO, 90000, -1},
   {33, "MP2T",       CODEC_TYPE_DATA,    CODEC_ID_MPEG2TS, 90000, -1},
   {34, "H263",       CODEC_TYPE_VIDEO,   CODEC_ID_H263, 90000, -1},
   {35, "unassigned", CODEC_TYPE_UNKNOWN, CODEC_ID_NONE, -1, -1},
@@ -176,36 +171,22 @@
   {-1, "",           CODEC_TYPE_UNKNOWN, CODEC_ID_NONE, -1, -1}
 };
 
-/* statistics functions */
-RTPDynamicProtocolHandler *RTPFirstDynamicPayloadHandler= NULL;
-
-static RTPDynamicProtocolHandler mp4v_es_handler= {"MP4V-ES", CODEC_TYPE_VIDEO, CODEC_ID_MPEG4};
-static RTPDynamicProtocolHandler mpeg4_generic_handler= {"mpeg4-generic", CODEC_TYPE_AUDIO, CODEC_ID_AAC};
-
-static void register_dynamic_payload_handler(RTPDynamicProtocolHandler *handler)
-{
-    handler->next= RTPFirstDynamicPayloadHandler;
-    RTPFirstDynamicPayloadHandler= handler;
-}
-
-void av_register_rtp_dynamic_payload_handlers(void)
-{
-    register_dynamic_payload_handler(&mp4v_es_handler);
-    register_dynamic_payload_handler(&mpeg4_generic_handler);
-    register_dynamic_payload_handler(&ff_h264_dynamic_handler);
-}
-
 int rtp_get_codec_info(AVCodecContext *codec, int payload_type)
 {
-    if (AVRtpPayloadTypes[payload_type].codec_id != CODEC_ID_NONE) {
-        codec->codec_type = AVRtpPayloadTypes[payload_type].codec_type;
-        codec->codec_id = AVRtpPayloadTypes[payload_type].codec_id;
-        if (AVRtpPayloadTypes[payload_type].audio_channels > 0)
-            codec->channels = AVRtpPayloadTypes[payload_type].audio_channels;
-        if (AVRtpPayloadTypes[payload_type].clock_rate > 0)
-            codec->sample_rate = AVRtpPayloadTypes[payload_type].clock_rate;
-        return 0;
-    }
+    int i = 0;
+
+    for (i = 0; AVRtpPayloadTypes[i].pt >= 0; i++)
+        if (AVRtpPayloadTypes[i].pt == payload_type) {
+            if (AVRtpPayloadTypes[i].codec_id != CODEC_ID_NONE) {
+                codec->codec_type = AVRtpPayloadTypes[i].codec_type;
+                codec->codec_id = AVRtpPayloadTypes[i].codec_id;
+                if (AVRtpPayloadTypes[i].audio_channels > 0)
+                    codec->channels = AVRtpPayloadTypes[i].audio_channels;
+                if (AVRtpPayloadTypes[i].clock_rate > 0)
+                    codec->sample_rate = AVRtpPayloadTypes[i].clock_rate;
+                return 0;
+            }
+        }
     return -1;
 }
 
@@ -224,814 +205,26 @@
     return payload_type;
 }
 
-static int rtcp_parse_packet(RTPDemuxContext *s, const unsigned char *buf, int len)
-{
-    if (buf[1] != 200)
-        return -1;
-    s->last_rtcp_ntp_time = AV_RB64(buf + 8);
-    if (s->first_rtcp_ntp_time == AV_NOPTS_VALUE)
-        s->first_rtcp_ntp_time = s->last_rtcp_ntp_time;
-    s->last_rtcp_timestamp = AV_RB32(buf + 16);
-    return 0;
-}
-
-#define RTP_SEQ_MOD (1<<16)
-
-/**
-* called on parse open packet
-*/
-static void rtp_init_statistics(RTPStatistics *s, uint16_t base_sequence) // called on parse open packet.
-{
-    memset(s, 0, sizeof(RTPStatistics));
-    s->max_seq= base_sequence;
-    s->probation= 1;
-}
-
-/**
-* called whenever there is a large jump in sequence numbers, or when they get out of probation...
-*/
-static void rtp_init_sequence(RTPStatistics *s, uint16_t seq)
-{
-    s->max_seq= seq;
-    s->cycles= 0;
-    s->base_seq= seq -1;
-    s->bad_seq= RTP_SEQ_MOD + 1;
-    s->received= 0;
-    s->expected_prior= 0;
-    s->received_prior= 0;
-    s->jitter= 0;
-    s->transit= 0;
-}
-
-/**
-* returns 1 if we should handle this packet.
-*/
-static int rtp_valid_packet_in_sequence(RTPStatistics *s, uint16_t seq)
-{
-    uint16_t udelta= seq - s->max_seq;
-    const int MAX_DROPOUT= 3000;
-    const int MAX_MISORDER = 100;
-    const int MIN_SEQUENTIAL = 2;
-
-    /* source not valid until MIN_SEQUENTIAL packets with sequence seq. numbers have been received */
-    if(s->probation)
-    {
-        if(seq==s->max_seq + 1) {
-            s->probation--;
-            s->max_seq= seq;
-            if(s->probation==0) {
-                rtp_init_sequence(s, seq);
-                s->received++;
-                return 1;
-            }
-        } else {
-            s->probation= MIN_SEQUENTIAL - 1;
-            s->max_seq = seq;
-        }
-    } else if (udelta < MAX_DROPOUT) {
-        // in order, with permissible gap
-        if(seq < s->max_seq) {
-            //sequence number wrapped; count antother 64k cycles
-            s->cycles += RTP_SEQ_MOD;
-        }
-        s->max_seq= seq;
-    } else if (udelta <= RTP_SEQ_MOD - MAX_MISORDER) {
-        // sequence made a large jump...
-        if(seq==s->bad_seq) {
-            // two sequential packets-- assume that the other side restarted without telling us; just resync.
-            rtp_init_sequence(s, seq);
-        } else {
-            s->bad_seq= (seq + 1) & (RTP_SEQ_MOD-1);
-            return 0;
-        }
-    } else {
-        // duplicate or reordered packet...
-    }
-    s->received++;
-    return 1;
-}
-
-#if 0
-/**
-* This function is currently unused; without a valid local ntp time, I don't see how we could calculate the
-* difference between the arrival and sent timestamp.  As a result, the jitter and transit statistics values
-* never change.  I left this in in case someone else can see a way. (rdm)
-*/
-static void rtcp_update_jitter(RTPStatistics *s, uint32_t sent_timestamp, uint32_t arrival_timestamp)
-{
-    uint32_t transit= arrival_timestamp - sent_timestamp;
-    int d;
-    s->transit= transit;
-    d= FFABS(transit - s->transit);
-    s->jitter += d - ((s->jitter + 8)>>4);
-}
-#endif
-
-int rtp_check_and_send_back_rr(RTPDemuxContext *s, int count)
-{
-    ByteIOContext pb;
-    uint8_t *buf;
-    int len;
-    int rtcp_bytes;
-    RTPStatistics *stats= &s->statistics;
-    uint32_t lost;
-    uint32_t extended_max;
-    uint32_t expected_interval;
-    uint32_t received_interval;
-    uint32_t lost_interval;
-    uint32_t expected;
-    uint32_t fraction;
-    uint64_t ntp_time= s->last_rtcp_ntp_time; // TODO: Get local ntp time?
-
-    if (!s->rtp_ctx || (count < 1))
-        return -1;
-
-    /* TODO: I think this is way too often; RFC 1889 has algorithm for this */
-    /* XXX: mpeg pts hardcoded. RTCP send every 0.5 seconds */
-    s->octet_count += count;
-    rtcp_bytes = ((s->octet_count - s->last_octet_count) * RTCP_TX_RATIO_NUM) /
-        RTCP_TX_RATIO_DEN;
-    rtcp_bytes /= 50; // mmu_man: that's enough for me... VLC sends much less btw !?
-    if (rtcp_bytes < 28)
-        return -1;
-    s->last_octet_count = s->octet_count;
-
-    if (url_open_dyn_buf(&pb) < 0)
-        return -1;
-
-    // Receiver Report
-    put_byte(&pb, (RTP_VERSION << 6) + 1); /* 1 report block */
-    put_byte(&pb, 201);
-    put_be16(&pb, 7); /* length in words - 1 */
-    put_be32(&pb, s->ssrc); // our own SSRC
-    put_be32(&pb, s->ssrc); // XXX: should be the server's here!
-    // some placeholders we should really fill...
-    // RFC 1889/p64
-    extended_max= stats->cycles + stats->max_seq;
-    expected= extended_max - stats->base_seq + 1;
-    lost= expected - stats->received;
-    lost= FFMIN(lost, 0xffffff); // clamp it since it's only 24 bits...
-    expected_interval= expected - stats->expected_prior;
-    stats->expected_prior= expected;
-    received_interval= stats->received - stats->received_prior;
-    stats->received_prior= stats->received;
-    lost_interval= expected_interval - received_interval;
-    if (expected_interval==0 || lost_interval<=0) fraction= 0;
-    else fraction = (lost_interval<<8)/expected_interval;
-
-    fraction= (fraction<<24) | lost;
-
-    put_be32(&pb, fraction); /* 8 bits of fraction, 24 bits of total packets lost */
-    put_be32(&pb, extended_max); /* max sequence received */
-    put_be32(&pb, stats->jitter>>4); /* jitter */
-
-    if(s->last_rtcp_ntp_time==AV_NOPTS_VALUE)
-    {
-        put_be32(&pb, 0); /* last SR timestamp */
-        put_be32(&pb, 0); /* delay since last SR */
-    } else {
-        uint32_t middle_32_bits= s->last_rtcp_ntp_time>>16; // this is valid, right? do we need to handle 64 bit values special?
-        uint32_t delay_since_last= ntp_time - s->last_rtcp_ntp_time;
-
-        put_be32(&pb, middle_32_bits); /* last SR timestamp */
-        put_be32(&pb, delay_since_last); /* delay since last SR */
-    }
-
-    // CNAME
-    put_byte(&pb, (RTP_VERSION << 6) + 1); /* 1 report block */
-    put_byte(&pb, 202);
-    len = strlen(s->hostname);
-    put_be16(&pb, (6 + len + 3) / 4); /* length in words - 1 */
-    put_be32(&pb, s->ssrc);
-    put_byte(&pb, 0x01);
-    put_byte(&pb, len);
-    put_buffer(&pb, s->hostname, len);
-    // padding
-    for (len = (6 + len) % 4; len % 4; len++) {
-        put_byte(&pb, 0);
-    }
-
-    put_flush_packet(&pb);
-    len = url_close_dyn_buf(&pb, &buf);
-    if ((len > 0) && buf) {
-        int result;
-#if defined(DEBUG)
-        printf("sending %d bytes of RR\n", len);
-#endif
-        result= url_write(s->rtp_ctx, buf, len);
-#if defined(DEBUG)
-        printf("result from url_write: %d\n", result);
-#endif
-        av_free(buf);
-    }
-    return 0;
-}
-
-/**
- * open a new RTP parse context for stream 'st'. 'st' can be NULL for
- * MPEG2TS streams to indicate that they should be demuxed inside the
- * rtp demux (otherwise CODEC_ID_MPEG2TS packets are returned)
- * TODO: change this to not take rtp_payload data, and use the new dynamic payload system.
- */
-RTPDemuxContext *rtp_parse_open(AVFormatContext *s1, AVStream *st, URLContext *rtpc, int payload_type, rtp_payload_data_t *rtp_payload_data)
-{
-    RTPDemuxContext *s;
-
-    s = av_mallocz(sizeof(RTPDemuxContext));
-    if (!s)
-        return NULL;
-    s->payload_type = payload_type;
-    s->last_rtcp_ntp_time = AV_NOPTS_VALUE;
-    s->first_rtcp_ntp_time = AV_NOPTS_VALUE;
-    s->ic = s1;
-    s->st = st;
-    s->rtp_payload_data = rtp_payload_data;
-    rtp_init_statistics(&s->statistics, 0); // do we know the initial sequence from sdp?
-    if (!strcmp(AVRtpPayloadTypes[payload_type].enc_name, "MP2T")) {
-        s->ts = mpegts_parse_open(s->ic);
-        if (s->ts == NULL) {
-            av_free(s);
-            return NULL;
-        }
-    } else {
-        switch(st->codec->codec_id) {
-        case CODEC_ID_MPEG1VIDEO:
-        case CODEC_ID_MPEG2VIDEO:
-        case CODEC_ID_MP2:
-        case CODEC_ID_MP3:
-        case CODEC_ID_MPEG4:
-        case CODEC_ID_H264:
-            st->need_parsing = AVSTREAM_PARSE_FULL;
-            break;
-        default:
-            break;
-        }
-    }
-    // needed to send back RTCP RR in RTSP sessions
-    s->rtp_ctx = rtpc;
-    gethostname(s->hostname, sizeof(s->hostname));
-    return s;
-}
-
-static int rtp_parse_mp4_au(RTPDemuxContext *s, const uint8_t *buf)
-{
-    int au_headers_length, au_header_size, i;
-    GetBitContext getbitcontext;
-    rtp_payload_data_t *infos;
-
-    infos = s->rtp_payload_data;
-
-    if (infos == NULL)
-        return -1;
-
-    /* decode the first 2 bytes where are stored the AUHeader sections
-       length in bits */
-    au_headers_length = AV_RB16(buf);
-
-    if (au_headers_length > RTP_MAX_PACKET_LENGTH)
-      return -1;
-
-    infos->au_headers_length_bytes = (au_headers_length + 7) / 8;
-
-    /* skip AU headers length section (2 bytes) */
-    buf += 2;
-
-    init_get_bits(&getbitcontext, buf, infos->au_headers_length_bytes * 8);
-
-    /* XXX: Wrong if optionnal additional sections are present (cts, dts etc...) */
-    au_header_size = infos->sizelength + infos->indexlength;
-    if (au_header_size <= 0 || (au_headers_length % au_header_size != 0))
-        return -1;
-
-    infos->nb_au_headers = au_headers_length / au_header_size;
-    infos->au_headers = av_malloc(sizeof(struct AUHeaders) * infos->nb_au_headers);
-
-    /* XXX: We handle multiple AU Section as only one (need to fix this for interleaving)
-       In my test, the FAAD decoder does not behave correctly when sending each AU one by one
-       but does when sending the whole as one big packet...  */
-    infos->au_headers[0].size = 0;
-    infos->au_headers[0].index = 0;
-    for (i = 0; i < infos->nb_au_headers; ++i) {
-        infos->au_headers[0].size += get_bits_long(&getbitcontext, infos->sizelength);
-        infos->au_headers[0].index = get_bits_long(&getbitcontext, infos->indexlength);
-    }
-
-    infos->nb_au_headers = 1;
-
-    return 0;
-}
-
-/**
- * This was the second switch in rtp_parse packet.  Normalizes time, if required, sets stream_index, etc.
- */
-static void finalize_packet(RTPDemuxContext *s, AVPacket *pkt, uint32_t timestamp)
-{
-    switch(s->st->codec->codec_id) {
-        case CODEC_ID_MP2:
-        case CODEC_ID_MPEG1VIDEO:
-            if (s->last_rtcp_ntp_time != AV_NOPTS_VALUE) {
-                int64_t addend;
-
-                int delta_timestamp;
-                /* XXX: is it really necessary to unify the timestamp base ? */
-                /* compute pts from timestamp with received ntp_time */
-                delta_timestamp = timestamp - s->last_rtcp_timestamp;
-                /* convert to 90 kHz without overflow */
-                addend = (s->last_rtcp_ntp_time - s->first_rtcp_ntp_time) >> 14;
-                addend = (addend * 5625) >> 14;
-                pkt->pts = addend + delta_timestamp;
-            }
-            break;
-        case CODEC_ID_AAC:
-        case CODEC_ID_H264:
-        case CODEC_ID_MPEG4:
-            pkt->pts = timestamp;
-            break;
-        default:
-            /* no timestamp info yet */
-            break;
-    }
-    pkt->stream_index = s->st->index;
-}
-
-/**
- * Parse an RTP or RTCP packet directly sent as a buffer.
- * @param s RTP parse context.
- * @param pkt returned packet
- * @param buf input buffer or NULL to read the next packets
- * @param len buffer len
- * @return 0 if a packet is returned, 1 if a packet is returned and more can follow
- * (use buf as NULL to read the next). -1 if no packet (error or no more packet).
- */
-int rtp_parse_packet(RTPDemuxContext *s, AVPacket *pkt,
-                     const uint8_t *buf, int len)
-{
-    unsigned int ssrc, h;
-    int payload_type, seq, ret;
-    AVStream *st;
-    uint32_t timestamp;
-    int rv= 0;
-
-    if (!buf) {
-        /* return the next packets, if any */
-        if(s->st && s->parse_packet) {
-            timestamp= 0; ///< Should not be used if buf is NULL, but should be set to the timestamp of the packet returned....
-            rv= s->parse_packet(s, pkt, &timestamp, NULL, 0);
-            finalize_packet(s, pkt, timestamp);
-            return rv;
-        } else {
-            // TODO: Move to a dynamic packet handler (like above)
-            if (s->read_buf_index >= s->read_buf_size)
-                return -1;
-            ret = mpegts_parse_packet(s->ts, pkt, s->buf + s->read_buf_index,
-                                      s->read_buf_size - s->read_buf_index);
-            if (ret < 0)
-                return -1;
-            s->read_buf_index += ret;
-            if (s->read_buf_index < s->read_buf_size)
-                return 1;
-            else
-                return 0;
-        }
-    }
-
-    if (len < 12)
-        return -1;
-
-    if ((buf[0] & 0xc0) != (RTP_VERSION << 6))
-        return -1;
-    if (buf[1] >= 200 && buf[1] <= 204) {
-        rtcp_parse_packet(s, buf, len);
-        return -1;
-    }
-    payload_type = buf[1] & 0x7f;
-    seq  = AV_RB16(buf + 2);
-    timestamp = AV_RB32(buf + 4);
-    ssrc = AV_RB32(buf + 8);
-    /* store the ssrc in the RTPDemuxContext */
-    s->ssrc = ssrc;
-
-    /* NOTE: we can handle only one payload type */
-    if (s->payload_type != payload_type)
-        return -1;
-
-    st = s->st;
-    // only do something with this if all the rtp checks pass...
-    if(!rtp_valid_packet_in_sequence(&s->statistics, seq))
-    {
-        av_log(st?st->codec:NULL, AV_LOG_ERROR, "RTP: PT=%02x: bad cseq %04x expected=%04x\n",
-               payload_type, seq, ((s->seq + 1) & 0xffff));
-        return -1;
-    }
-
-    s->seq = seq;
-    len -= 12;
-    buf += 12;
-
-    if (!st) {
-        /* specific MPEG2TS demux support */
-        ret = mpegts_parse_packet(s->ts, pkt, buf, len);
-        if (ret < 0)
-            return -1;
-        if (ret < len) {
-            s->read_buf_size = len - ret;
-            memcpy(s->buf, buf + ret, s->read_buf_size);
-            s->read_buf_index = 0;
-            return 1;
-        }
-    } else {
-        // at this point, the RTP header has been stripped;  This is ASSUMING that there is only 1 CSRC, which in't wise.
-        switch(st->codec->codec_id) {
-        case CODEC_ID_MP2:
-            /* better than nothing: skip mpeg audio RTP header */
-            if (len <= 4)
-                return -1;
-            h = AV_RB32(buf);
-            len -= 4;
-            buf += 4;
-            av_new_packet(pkt, len);
-            memcpy(pkt->data, buf, len);
-            break;
-        case CODEC_ID_MPEG1VIDEO:
-            /* better than nothing: skip mpeg video RTP header */
-            if (len <= 4)
-                return -1;
-            h = AV_RB32(buf);
-            buf += 4;
-            len -= 4;
-            if (h & (1 << 26)) {
-                /* mpeg2 */
-                if (len <= 4)
-                    return -1;
-                buf += 4;
-                len -= 4;
-            }
-            av_new_packet(pkt, len);
-            memcpy(pkt->data, buf, len);
-            break;
-            // moved from below, verbatim.  this is because this section handles packets, and the lower switch handles
-            // timestamps.
-            // TODO: Put this into a dynamic packet handler...
-        case CODEC_ID_AAC:
-            if (rtp_parse_mp4_au(s, buf))
-                return -1;
-            {
-                rtp_payload_data_t *infos = s->rtp_payload_data;
-                if (infos == NULL)
-                    return -1;
-                buf += infos->au_headers_length_bytes + 2;
-                len -= infos->au_headers_length_bytes + 2;
-
-                /* XXX: Fixme we only handle the case where rtp_parse_mp4_au define
-                    one au_header */
-                av_new_packet(pkt, infos->au_headers[0].size);
-                memcpy(pkt->data, buf, infos->au_headers[0].size);
-                buf += infos->au_headers[0].size;
-                len -= infos->au_headers[0].size;
-            }
-            s->read_buf_size = len;
-            rv= 0;
-            break;
-        default:
-            if(s->parse_packet) {
-                rv= s->parse_packet(s, pkt, &timestamp, buf, len);
-            } else {
-                av_new_packet(pkt, len);
-                memcpy(pkt->data, buf, len);
-            }
-            break;
-        }
-
-        // now perform timestamp things....
-        finalize_packet(s, pkt, timestamp);
-    }
-    return rv;
-}
-
-void rtp_parse_close(RTPDemuxContext *s)
-{
-    // TODO: fold this into the protocol specific data fields.
-    if (!strcmp(AVRtpPayloadTypes[s->payload_type].enc_name, "MP2T")) {
-        mpegts_parse_close(s->ts);
-    }
-    av_free(s);
-}
-
-/* rtp output */
-
-static int rtp_write_header(AVFormatContext *s1)
-{
-    RTPDemuxContext *s = s1->priv_data;
-    int payload_type, max_packet_size, n;
-    AVStream *st;
-
-    if (s1->nb_streams != 1)
-        return -1;
-    st = s1->streams[0];
-
-    payload_type = rtp_get_payload_type(st->codec);
-    if (payload_type < 0)
-        payload_type = RTP_PT_PRIVATE; /* private payload type */
-    s->payload_type = payload_type;
-
-// following 2 FIXMies could be set based on the current time, theres normaly no info leak, as rtp will likely be transmitted immedeatly
-    s->base_timestamp = 0; /* FIXME: was random(), what should this be? */
-    s->timestamp = s->base_timestamp;
-    s->cur_timestamp = 0;
-    s->ssrc = 0; /* FIXME: was random(), what should this be? */
-    s->first_packet = 1;
-    s->first_rtcp_ntp_time = AV_NOPTS_VALUE;
-
-    max_packet_size = url_fget_max_packet_size(&s1->pb);
-    if (max_packet_size <= 12)
-        return AVERROR(EIO);
-    s->max_payload_size = max_packet_size - 12;
-
-    s->max_frames_per_packet = 0;
-    if (s1->max_delay) {
-        if (st->codec->codec_type == CODEC_TYPE_AUDIO) {
-            if (st->codec->frame_size == 0) {
-                av_log(s1, AV_LOG_ERROR, "Cannot respect max delay: frame size = 0\n");
-            } else {
-                s->max_frames_per_packet = av_rescale_rnd(s1->max_delay, st->codec->sample_rate, AV_TIME_BASE * st->codec->frame_size, AV_ROUND_DOWN);
-            }
-        }
-        if (st->codec->codec_type == CODEC_TYPE_VIDEO) {
-            /* FIXME: We should round down here... */
-            s->max_frames_per_packet = av_rescale_q(s1->max_delay, AV_TIME_BASE_Q, st->codec->time_base);
-        }
-    }
-
-    av_set_pts_info(st, 32, 1, 90000);
-    switch(st->codec->codec_id) {
-    case CODEC_ID_MP2:
-    case CODEC_ID_MP3:
-        s->buf_ptr = s->buf + 4;
-        break;
-    case CODEC_ID_MPEG1VIDEO:
-        break;
-    case CODEC_ID_MPEG2TS:
-        n = s->max_payload_size / TS_PACKET_SIZE;
-        if (n < 1)
-            n = 1;
-        s->max_payload_size = n * TS_PACKET_SIZE;
-        s->buf_ptr = s->buf;
-        break;
-    case CODEC_ID_AAC:
-        s->read_buf_index = 0;
-    default:
-        if (st->codec->codec_type == CODEC_TYPE_AUDIO) {
-            av_set_pts_info(st, 32, 1, st->codec->sample_rate);
-        }
-        s->buf_ptr = s->buf;
-        break;
-    }
-
-    return 0;
-}
-
-/* send an rtcp sender report packet */
-static void rtcp_send_sr(AVFormatContext *s1, int64_t ntp_time)
+const char *ff_rtp_enc_name(int payload_type)
 {
-    RTPDemuxContext *s = s1->priv_data;
-    uint32_t rtp_ts;
-
-#if defined(DEBUG)
-    printf("RTCP: %02x %"PRIx64" %x\n", s->payload_type, ntp_time, s->timestamp);
-#endif
-
-    if (s->first_rtcp_ntp_time == AV_NOPTS_VALUE) s->first_rtcp_ntp_time = ntp_time;
-    rtp_ts = av_rescale_q(ntp_time - s->first_rtcp_ntp_time, AV_TIME_BASE_Q,
-                          s1->streams[0]->time_base) + s->base_timestamp;
-    put_byte(&s1->pb, (RTP_VERSION << 6));
-    put_byte(&s1->pb, 200);
-    put_be16(&s1->pb, 6); /* length in words - 1 */
-    put_be32(&s1->pb, s->ssrc);
-    put_be32(&s1->pb, ntp_time / 1000000);
-    put_be32(&s1->pb, ((ntp_time % 1000000) << 32) / 1000000);
-    put_be32(&s1->pb, rtp_ts);
-    put_be32(&s1->pb, s->packet_count);
-    put_be32(&s1->pb, s->octet_count);
-    put_flush_packet(&s1->pb);
-}
+    int i;
 
-/* send an rtp packet. sequence number is incremented, but the caller
-   must update the timestamp itself */
-void ff_rtp_send_data(AVFormatContext *s1, const uint8_t *buf1, int len, int m)
-{
-    RTPDemuxContext *s = s1->priv_data;
-
-#ifdef DEBUG
-    printf("rtp_send_data size=%d\n", len);
-#endif
-
-    /* build the RTP header */
-    put_byte(&s1->pb, (RTP_VERSION << 6));
-    put_byte(&s1->pb, (s->payload_type & 0x7f) | ((m & 0x01) << 7));
-    put_be16(&s1->pb, s->seq);
-    put_be32(&s1->pb, s->timestamp);
-    put_be32(&s1->pb, s->ssrc);
-
-    put_buffer(&s1->pb, buf1, len);
-    put_flush_packet(&s1->pb);
-
-    s->seq++;
-    s->octet_count += len;
-    s->packet_count++;
-}
-
-/* send an integer number of samples and compute time stamp and fill
-   the rtp send buffer before sending. */
-static void rtp_send_samples(AVFormatContext *s1,
-                             const uint8_t *buf1, int size, int sample_size)
-{
-    RTPDemuxContext *s = s1->priv_data;
-    int len, max_packet_size, n;
-
-    max_packet_size = (s->max_payload_size / sample_size) * sample_size;
-    /* not needed, but who nows */
-    if ((size % sample_size) != 0)
-        av_abort();
-    n = 0;
-    while (size > 0) {
-        s->buf_ptr = s->buf;
-        len = FFMIN(max_packet_size, size);
-
-        /* copy data */
-        memcpy(s->buf_ptr, buf1, len);
-        s->buf_ptr += len;
-        buf1 += len;
-        size -= len;
-        s->timestamp = s->cur_timestamp + n / sample_size;
-        ff_rtp_send_data(s1, s->buf, s->buf_ptr - s->buf, 0);
-        n += (s->buf_ptr - s->buf);
-    }
-}
-
-/* NOTE: we suppose that exactly one frame is given as argument here */
-/* XXX: test it */
-static void rtp_send_mpegaudio(AVFormatContext *s1,
-                               const uint8_t *buf1, int size)
-{
-    RTPDemuxContext *s = s1->priv_data;
-    int len, count, max_packet_size;
-
-    max_packet_size = s->max_payload_size;
-
-    /* test if we must flush because not enough space */
-    len = (s->buf_ptr - s->buf);
-    if ((len + size) > max_packet_size) {
-        if (len > 4) {
-            ff_rtp_send_data(s1, s->buf, s->buf_ptr - s->buf, 0);
-            s->buf_ptr = s->buf + 4;
+    for (i = 0; AVRtpPayloadTypes[i].pt >= 0; i++)
+        if (AVRtpPayloadTypes[i].pt == payload_type) {
+            return AVRtpPayloadTypes[i].enc_name;
         }
-    }
-    if (s->buf_ptr == s->buf + 4) {
-        s->timestamp = s->cur_timestamp;
-    }
-
-    /* add the packet */
-    if (size > max_packet_size) {
-        /* big packet: fragment */
-        count = 0;
-        while (size > 0) {
-            len = max_packet_size - 4;
-            if (len > size)
-                len = size;
-            /* build fragmented packet */
-            s->buf[0] = 0;
-            s->buf[1] = 0;
-            s->buf[2] = count >> 8;
-            s->buf[3] = count;
-            memcpy(s->buf + 4, buf1, len);
-            ff_rtp_send_data(s1, s->buf, len + 4, 0);
-            size -= len;
-            buf1 += len;
-            count += len;
-        }
-    } else {
-        if (s->buf_ptr == s->buf + 4) {
-            /* no fragmentation possible */
-            s->buf[0] = 0;
-            s->buf[1] = 0;
-            s->buf[2] = 0;
-            s->buf[3] = 0;
-        }
-        memcpy(s->buf_ptr, buf1, size);
-        s->buf_ptr += size;
-    }
-}
 
-static void rtp_send_raw(AVFormatContext *s1,
-                         const uint8_t *buf1, int size)
-{
-    RTPDemuxContext *s = s1->priv_data;
-    int len, max_packet_size;
-
-    max_packet_size = s->max_payload_size;
-
-    while (size > 0) {
-        len = max_packet_size;
-        if (len > size)
-            len = size;
-
-        s->timestamp = s->cur_timestamp;
-        ff_rtp_send_data(s1, buf1, len, (len == size));
-
-        buf1 += len;
-        size -= len;
-    }
+    return "";
 }
 
-/* NOTE: size is assumed to be an integer multiple of TS_PACKET_SIZE */
-static void rtp_send_mpegts_raw(AVFormatContext *s1,
-                                const uint8_t *buf1, int size)
+enum CodecID ff_rtp_codec_id(const char *buf, enum CodecType codec_type)
 {
-    RTPDemuxContext *s = s1->priv_data;
-    int len, out_len;
+    int i;
 
-    while (size >= TS_PACKET_SIZE) {
-        len = s->max_payload_size - (s->buf_ptr - s->buf);
-        if (len > size)
-            len = size;
-        memcpy(s->buf_ptr, buf1, len);
-        buf1 += len;
-        size -= len;
-        s->buf_ptr += len;
-
-        out_len = s->buf_ptr - s->buf;
-        if (out_len >= s->max_payload_size) {
-            ff_rtp_send_data(s1, s->buf, out_len, 0);
-            s->buf_ptr = s->buf;
+    for (i = 0; AVRtpPayloadTypes[i].pt >= 0; i++)
+        if (!strcmp(buf, AVRtpPayloadTypes[i].enc_name) && (codec_type == AVRtpPayloadTypes[i].codec_type)){
+            return AVRtpPayloadTypes[i].codec_id;
         }
-    }
-}
 
-/* write an RTP packet. 'buf1' must contain a single specific frame. */
-static int rtp_write_packet(AVFormatContext *s1, AVPacket *pkt)
-{
-    RTPDemuxContext *s = s1->priv_data;
-    AVStream *st = s1->streams[0];
-    int rtcp_bytes;
-    int size= pkt->size;
-    uint8_t *buf1= pkt->data;
-
-#ifdef DEBUG
-    printf("%d: write len=%d\n", pkt->stream_index, size);
-#endif
-
-    /* XXX: mpeg pts hardcoded. RTCP send every 0.5 seconds */
-    rtcp_bytes = ((s->octet_count - s->last_octet_count) * RTCP_TX_RATIO_NUM) /
-        RTCP_TX_RATIO_DEN;
-    if (s->first_packet || rtcp_bytes >= 28) {
-        rtcp_send_sr(s1, av_gettime());
-        s->last_octet_count = s->octet_count;
-        s->first_packet = 0;
-    }
-    s->cur_timestamp = s->base_timestamp + pkt->pts;
-
-    switch(st->codec->codec_id) {
-    case CODEC_ID_PCM_MULAW:
-    case CODEC_ID_PCM_ALAW:
-    case CODEC_ID_PCM_U8:
-    case CODEC_ID_PCM_S8:
-        rtp_send_samples(s1, buf1, size, 1 * st->codec->channels);
-        break;
-    case CODEC_ID_PCM_U16BE:
-    case CODEC_ID_PCM_U16LE:
-    case CODEC_ID_PCM_S16BE:
-    case CODEC_ID_PCM_S16LE:
-        rtp_send_samples(s1, buf1, size, 2 * st->codec->channels);
-        break;
-    case CODEC_ID_MP2:
-    case CODEC_ID_MP3:
-        rtp_send_mpegaudio(s1, buf1, size);
-        break;
-    case CODEC_ID_MPEG1VIDEO:
-        ff_rtp_send_mpegvideo(s1, buf1, size);
-        break;
-    case CODEC_ID_AAC:
-        ff_rtp_send_aac(s1, buf1, size);
-        break;
-    case CODEC_ID_MPEG2TS:
-        rtp_send_mpegts_raw(s1, buf1, size);
-        break;
-    default:
-        /* better than nothing : send the codec raw data */
-        rtp_send_raw(s1, buf1, size);
-        break;
-    }
-    return 0;
+    return CODEC_ID_NONE;
 }
-
-AVOutputFormat rtp_muxer = {
-    "rtp",
-    "RTP output format",
-    NULL,
-    NULL,
-    sizeof(RTPDemuxContext),
-    CODEC_ID_PCM_MULAW,
-    CODEC_ID_NONE,
-    rtp_write_header,
-    rtp_write_packet,
-};
Only in ffmpeg-free-0.svn20080206/libavformat: rtpdec.c
Only in ffmpeg-free-0.svn20080206/libavformat: rtpenc.c
Only in ffmpeg-free-0.svn20080206/libavformat: rtpenc_h264.c
diff -u mplayer-1.0~rc2-12/libavformat/rtp.h ffmpeg-free-0.svn20080206/libavformat/rtp.h
--- mplayer-1.0~rc2-12/libavformat/rtp.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rtp.h	2008-01-06 11:00:04.000000000 +0100
@@ -18,8 +18,8 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-#ifndef RTP_H
-#define RTP_H
+#ifndef FFMPEG_RTP_H
+#define FFMPEG_RTP_H
 
 #include "avcodec.h"
 #include "avformat.h"
@@ -27,7 +27,6 @@
 #define RTP_MIN_PACKET_LENGTH 12
 #define RTP_MAX_PACKET_LENGTH 1500 /* XXX: suppress this define */
 
-int rtp_init(void);
 int rtp_get_codec_info(AVCodecContext *codec, int payload_type);
 
 /** return < 0 if unknown payload type */
@@ -86,16 +85,6 @@
     int cur_au_index;
 } rtp_payload_data_t;
 
-typedef struct AVRtpPayloadType_s
-{
-    int pt;
-    const char enc_name[50]; /* XXX: why 50 ? */
-    enum CodecType codec_type;
-    enum CodecID codec_id;
-    int clock_rate;
-    int audio_channels;
-} AVRtpPayloadType_t;
-
 #if 0
 typedef enum {
   RTCP_SR   = 200,
@@ -121,5 +110,4 @@
 } rtcp_sdes_type_t;
 #endif
 
-extern AVRtpPayloadType_t AVRtpPayloadTypes[];
-#endif /* RTP_H */
+#endif /* FFMPEG_RTP_H */
diff -u mplayer-1.0~rc2-12/libavformat/rtp_h264.c ffmpeg-free-0.svn20080206/libavformat/rtp_h264.c
--- mplayer-1.0~rc2-12/libavformat/rtp_h264.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rtp_h264.c	2008-01-18 21:48:32.000000000 +0100
@@ -163,9 +163,11 @@
                               AVPacket * pkt,
                               uint32_t * timestamp,
                               const uint8_t * buf,
-                              int len)
+                              int len, int flags)
 {
+#ifdef DEBUG
     h264_rtp_extra_data *data = s->dynamic_protocol_context;
+#endif
     uint8_t nal = buf[0];
     uint8_t type = (nal & 0x1f);
     int result= 0;
diff -u mplayer-1.0~rc2-12/libavformat/rtp_h264.h ffmpeg-free-0.svn20080206/libavformat/rtp_h264.h
--- mplayer-1.0~rc2-12/libavformat/rtp_h264.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rtp_h264.h	2008-01-21 15:01:57.000000000 +0100
@@ -19,10 +19,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef RTP_H264_H
-#define RTP_H264_H
+#ifndef FFMPEG_RTP_H264_H
+#define FFMPEG_RTP_H264_H
 
 #include "rtp_internal.h"
 
 extern RTPDynamicProtocolHandler ff_h264_dynamic_handler;
-#endif /* RTP_H264_H */
+void ff_rtp_send_h264(AVFormatContext *s1, uint8_t *buf1, int size);
+
+#endif /* FFMPEG_RTP_H264_H */
diff -u mplayer-1.0~rc2-12/libavformat/rtp_internal.h ffmpeg-free-0.svn20080206/libavformat/rtp_internal.h
--- mplayer-1.0~rc2-12/libavformat/rtp_internal.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rtp_internal.h	2008-01-18 21:48:32.000000000 +0100
@@ -20,8 +20,8 @@
  */
 
 // this is a bit of a misnomer, because rtp & rtsp internal structures and prototypes are in here.
-#ifndef RTP_INTERNAL_H
-#define RTP_INTERNAL_H
+#ifndef FFMPEG_RTP_INTERNAL_H
+#define FFMPEG_RTP_INTERNAL_H
 
 #include <stdint.h>
 #include "avcodec.h"
@@ -41,12 +41,21 @@
     uint32_t jitter;            ///< estimated jitter.
 } RTPStatistics;
 
-
+/**
+ * Packet parsing for "private" payloads in the RTP specs.
+ *
+ * @param s stream context
+ * @param pkt packet in which to write the parsed data
+ * @param timestamp pointer in which to write the timestamp of this RTP packet
+ * @param buf pointer to raw RTP packet data
+ * @param len length of buf
+ * @param flags flags from the RTP packet header (PKT_FLAG_*)
+ */
 typedef int (*DynamicPayloadPacketHandlerProc) (struct RTPDemuxContext * s,
                                                 AVPacket * pkt,
                                                 uint32_t *timestamp,
                                                 const uint8_t * buf,
-                                                int len);
+                                                int len, int flags);
 
 typedef struct RTPDynamicProtocolHandler_s {
     // fields from AVRtpDynamicPayloadType_s
@@ -113,8 +122,10 @@
 int rtsp_next_attr_and_value(const char **p, char *attr, int attr_size, char *value, int value_size); ///< from rtsp.c, but used by rtp dynamic protocol handlers.
 
 void ff_rtp_send_data(AVFormatContext *s1, const uint8_t *buf1, int len, int m);
+const char *ff_rtp_enc_name(int payload_type);
+enum CodecID ff_rtp_codec_id(const char *buf, enum CodecType codec_type);
 
 void av_register_rtp_dynamic_payload_handlers(void);
 
-#endif /* RTP_INTERNAL_H */
+#endif /* FFMPEG_RTP_INTERNAL_H */
 
diff -u mplayer-1.0~rc2-12/libavformat/rtp_mpv.h ffmpeg-free-0.svn20080206/libavformat/rtp_mpv.h
--- mplayer-1.0~rc2-12/libavformat/rtp_mpv.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rtp_mpv.h	2007-11-24 11:08:02.000000000 +0100
@@ -17,9 +17,11 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-#ifndef RTP_MPV_H
-#define RTP_MPV_H
+#ifndef FFMPEG_RTP_MPV_H
+#define FFMPEG_RTP_MPV_H
+
+#include "avformat.h"
 
 void ff_rtp_send_mpegvideo(AVFormatContext *s1, const uint8_t *buf1, int size);
 
-#endif /* RTP_MPV_H */
+#endif /* FFMPEG_RTP_MPV_H */
diff -u mplayer-1.0~rc2-12/libavformat/rtpproto.c ffmpeg-free-0.svn20080206/libavformat/rtpproto.c
--- mplayer-1.0~rc2-12/libavformat/rtpproto.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rtpproto.c	2007-11-27 12:42:09.000000000 +0100
@@ -24,6 +24,7 @@
 #include <unistd.h>
 #include <stdarg.h>
 #include "network.h"
+#include "os_support.h"
 #include <fcntl.h>
 
 #define RTP_TX_BUF_SIZE  (64 * 1024)
diff -u mplayer-1.0~rc2-12/libavformat/rtsp.c ffmpeg-free-0.svn20080206/libavformat/rtsp.c
--- mplayer-1.0~rc2-12/libavformat/rtsp.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rtsp.c	2008-01-02 20:40:43.000000000 +0100
@@ -24,6 +24,7 @@
 #include <unistd.h> /* for select() prototype */
 #include "network.h"
 #include "avstring.h"
+#include "rtsp.h"
 
 #include "rtp_internal.h"
 
@@ -76,7 +77,9 @@
 /* XXX: currently, the only way to change the protocols consists in
    changing this variable */
 
+#if LIBAVFORMAT_VERSION_INT < (53 << 16)
 int rtsp_default_protocols = (1 << RTSP_PROTOCOL_RTP_UDP);
+#endif
 
 static int rtsp_probe(AVProbeData *p)
 {
@@ -166,11 +169,7 @@
     } else {
         /* We are in a standard case ( from http://www.iana.org/assignments/rtp-parameters) */
         /* search into AVRtpPayloadTypes[] */
-        for (i = 0; AVRtpPayloadTypes[i].pt >= 0; ++i)
-            if (!strcmp(buf, AVRtpPayloadTypes[i].enc_name) && (codec->codec_type == AVRtpPayloadTypes[i].codec_type)){
-                codec->codec_id = AVRtpPayloadTypes[i].codec_id;
-                break;
-            }
+        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);
     }
 
     c = avcodec_find_decoder(codec->codec_id);
@@ -442,7 +441,7 @@
         get_word(buf1, sizeof(buf1), &p); /* format list */
         rtsp_st->sdp_payload_type = atoi(buf1);
 
-        if (!strcmp(AVRtpPayloadTypes[rtsp_st->sdp_payload_type].enc_name, "MP2T")) {
+        if (!strcmp(ff_rtp_enc_name(rtsp_st->sdp_payload_type), "MP2T")) {
             /* no corresponding stream */
         } else {
             st = av_new_stream(s, 0);
@@ -607,12 +606,19 @@
                      "/", &p);
         if (*p == '/')
             p++;
-        get_word_sep(profile, sizeof(profile), "/;,", &p);
-        lower_transport[0] = '\0';
-        if (*p == '/') {
-            p++;
-            get_word_sep(lower_transport, sizeof(lower_transport),
-                         ";,", &p);
+        if (!strcasecmp (transport_protocol, "rtp")) {
+            get_word_sep(profile, sizeof(profile), "/;,", &p);
+            lower_transport[0] = '\0';
+            /* rtp/avp/<protocol> */
+            if (*p == '/') {
+                p++;
+                get_word_sep(lower_transport, sizeof(lower_transport),
+                             ";,", &p);
+                }
+        } else if (!strcasecmp (transport_protocol, "x-pn-tng")) {
+            /* x-pn-tng/<protocol> */
+            get_word_sep(lower_transport, sizeof(lower_transport), "/;,", &p);
+            profile[0] = '\0';
         }
         if (!strcasecmp(lower_transport, "TCP"))
             th->protocol = RTSP_PROTOCOL_RTP_TCP;
@@ -932,9 +938,9 @@
             /* first try in specified port range */
             if (RTSP_RTP_PORT_MIN != 0) {
                 while(j <= RTSP_RTP_PORT_MAX) {
-                    snprintf(buf, sizeof(buf), "rtp://?localport=%d", j);
+                    snprintf(buf, sizeof(buf), "rtp://%s?localport=%d", host, j);
+                    j += 2; /* we will use two port by rtp stream (rtp and rtcp) */
                     if (url_open(&rtsp_st->rtp_handle, buf, URL_RDWR) == 0) {
-                        j += 2; /* we will use two port by rtp stream (rtp and rtcp) */
                         goto rtp_opened;
                     }
                 }
@@ -1133,7 +1139,7 @@
 
     for(;;) {
         if (url_interrupt_cb())
-            return -1;
+            return AVERROR(EINTR);
         FD_ZERO(&rfds);
         fd_max = -1;
         for(i = 0; i < rt->nb_rtsp_streams; i++) {
@@ -1199,7 +1205,7 @@
         break;
     }
     if (len < 0)
-        return AVERROR(EIO);
+        return len;
     ret = rtp_parse_packet(rtsp_st->rtp_ctx, pkt, buf, len);
     if (ret < 0)
         goto redo;
@@ -1354,7 +1360,7 @@
     /* read the whole sdp file */
     /* XXX: better loading */
     content = av_malloc(SDP_MAX_SIZE);
-    size = get_buffer(&s->pb, content, SDP_MAX_SIZE - 1);
+    size = get_buffer(s->pb, content, SDP_MAX_SIZE - 1);
     if (size <= 0) {
         av_free(content);
         return AVERROR_INVALIDDATA;
@@ -1438,12 +1444,12 @@
     return 0;
 }
 
-/* called from utils.c */
-int redir_open(AVFormatContext **ic_ptr, ByteIOContext *f)
+static int redir_read_header(AVFormatContext *s, AVFormatParameters *ap)
 {
     char buf[4096], *q;
     int c;
     AVFormatContext *ic = NULL;
+    ByteIOContext *f = s->pb;
 
     /* parse each URL and try to open it */
     c = url_fgetc(f);
@@ -1471,11 +1477,13 @@
         if (av_open_input_file(&ic, buf, NULL, 0, NULL) == 0)
             break;
     }
-    *ic_ptr = ic;
     if (!ic)
         return AVERROR(EIO);
-    else
-        return 0;
+
+    *s = *ic;
+    url_fclose(f);
+
+    return 0;
 }
 
 AVInputFormat redir_demuxer = {
@@ -1483,7 +1491,7 @@
     "Redirector format",
     0,
     redir_probe,
-    NULL,
+    redir_read_header,
     NULL,
     NULL,
 };
diff -u mplayer-1.0~rc2-12/libavformat/rtspcodes.h ffmpeg-free-0.svn20080206/libavformat/rtspcodes.h
--- mplayer-1.0~rc2-12/libavformat/rtspcodes.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rtspcodes.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVFORMAT_RTSPCODES_H
-#define AVFORMAT_RTSPCODES_H
+#ifndef FFMPEG_RTSPCODES_H
+#define FFMPEG_RTSPCODES_H
 
 /** RTSP handling */
 enum RTSPStatusCode {
@@ -37,4 +37,4 @@
 RTSP_STATUS_VERSION         =505, /**< RTSP Version not supported */
 };
 
-#endif // AVFORMAT_RTSPCODES_H
+#endif /* FFMPEG_RTSPCODES_H */
diff -u mplayer-1.0~rc2-12/libavformat/rtsp.h ffmpeg-free-0.svn20080206/libavformat/rtsp.h
--- mplayer-1.0~rc2-12/libavformat/rtsp.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/rtsp.h	2008-01-02 20:40:43.000000000 +0100
@@ -18,8 +18,8 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-#ifndef RTSP_H
-#define RTSP_H
+#ifndef FFMPEG_RTSP_H
+#define FFMPEG_RTSP_H
 
 #include <stdint.h>
 #include "avformat.h"
@@ -81,11 +81,13 @@
 int rtsp_init(void);
 void rtsp_parse_line(RTSPHeader *reply, const char *buf);
 
+#if LIBAVFORMAT_VERSION_INT < (53 << 16)
 extern int rtsp_default_protocols;
+#endif
 extern int rtsp_rtp_port_min;
 extern int rtsp_rtp_port_max;
 
 int rtsp_pause(AVFormatContext *s);
 int rtsp_resume(AVFormatContext *s);
 
-#endif /* RTSP_H */
+#endif /* FFMPEG_RTSP_H */
diff -u mplayer-1.0~rc2-12/libavformat/sdp.c ffmpeg-free-0.svn20080206/libavformat/sdp.c
--- mplayer-1.0~rc2-12/libavformat/sdp.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/sdp.c	2008-01-21 15:28:58.000000000 +0100
@@ -20,6 +20,9 @@
 
 #include "avstring.h"
 #include "avformat.h"
+#include "avc.h"
+#include "base64.h"
+#include "rtp.h"
 
 #ifdef CONFIG_RTP_MUXER
 #define MAX_EXTRADATA_SIZE ((INT_MAX - 10) / 2)
@@ -89,6 +92,49 @@
     return port;
 }
 
+#define MAX_PSET_SIZE 1024
+static char *extradata2psets(AVCodecContext *c)
+{
+    char *psets, *p;
+    uint8_t *r;
+    const char *pset_string = "; sprop-parameter-sets=";
+
+    if (c->extradata_size > MAX_EXTRADATA_SIZE) {
+        av_log(c, AV_LOG_ERROR, "Too many extra data!\n");
+
+        return NULL;
+    }
+
+    psets = av_mallocz(MAX_PSET_SIZE);
+    if (psets == NULL) {
+        av_log(c, AV_LOG_ERROR, "Cannot allocate memory for the parameter sets\n");
+        return NULL;
+    }
+    memcpy(psets, pset_string, strlen(pset_string));
+    p = psets + strlen(pset_string);
+    r = ff_avc_find_startcode(c->extradata, c->extradata + c->extradata_size);
+    while (r < c->extradata + c->extradata_size) {
+        uint8_t *r1;
+
+        while (!*(r++));
+        r1 = ff_avc_find_startcode(r, c->extradata + c->extradata_size);
+        if (p != (psets + strlen(pset_string))) {
+            *p = ',';
+            p++;
+        }
+        if (av_base64_encode(p, MAX_PSET_SIZE - (p - psets), r, r1 - r) == NULL) {
+            av_log(c, AV_LOG_ERROR, "Cannot BASE64 encode %d %d!\n", MAX_PSET_SIZE - (p - psets), r1 - r);
+            av_free(psets);
+
+            return NULL;
+        }
+        p += strlen(p);
+        r = r1;
+    }
+
+    return psets;
+}
+
 static void digit_to_char(char *dst, uint8_t src)
 {
     if (src < 10) {
@@ -110,23 +156,23 @@
     return buff;
 }
 
-static char *extradata2config(const uint8_t *extradata, int extradata_size)
+static char *extradata2config(AVCodecContext *c)
 {
     char *config;
 
-    if (extradata_size > MAX_EXTRADATA_SIZE) {
-        av_log(NULL, AV_LOG_ERROR, "Too many extra data!\n");
+    if (c->extradata_size > MAX_EXTRADATA_SIZE) {
+        av_log(c, AV_LOG_ERROR, "Too many extra data!\n");
 
         return NULL;
     }
-    config = av_malloc(10 + extradata_size * 2);
+    config = av_malloc(10 + c->extradata_size * 2);
     if (config == NULL) {
-        av_log(NULL, AV_LOG_ERROR, "Cannot allocate memory for the config info\n");
+        av_log(c, AV_LOG_ERROR, "Cannot allocate memory for the config info\n");
         return NULL;
     }
     memcpy(config, "; config=", 9);
-    data_to_hex(config + 9, extradata, extradata_size);
-    config[9 + extradata_size * 2] = 0;
+    data_to_hex(config + 9, c->extradata, c->extradata_size);
+    config[9 + c->extradata_size * 2] = 0;
 
     return config;
 }
@@ -136,9 +182,18 @@
     char *config = NULL;
 
     switch (c->codec_id) {
+        case CODEC_ID_H264:
+            if (c->extradata_size) {
+                config = extradata2psets(c);
+            }
+            av_strlcatf(buff, size, "a=rtpmap:%d H264/90000\r\n"
+                                    "a=fmtp:%d packetization-mode=1%s\r\n",
+                                     payload_type,
+                                     payload_type, config ? config : "");
+            break;
         case CODEC_ID_MPEG4:
             if (c->extradata_size) {
-                config = extradata2config(c->extradata, c->extradata_size);
+                config = extradata2config(c);
             }
             av_strlcatf(buff, size, "a=rtpmap:%d MP4V-ES/90000\r\n"
                                     "a=fmtp:%d profile-level-id=1%s\r\n",
@@ -147,12 +202,12 @@
             break;
         case CODEC_ID_AAC:
             if (c->extradata_size) {
-                config = extradata2config(c->extradata, c->extradata_size);
+                config = extradata2config(c);
             } else {
                 /* FIXME: maybe we can forge config information based on the
                  *        codec parameters...
                  */
-                av_log(NULL, AV_LOG_ERROR, "AAC with no global headers is currently not supported\n");
+                av_log(c, AV_LOG_ERROR, "AAC with no global headers is currently not supported\n");
                 return NULL;
             }
             if (config == NULL) {
@@ -165,6 +220,24 @@
                                      payload_type, c->sample_rate, c->channels,
                                      payload_type, config);
             break;
+        case CODEC_ID_PCM_S16BE:
+            if (payload_type >= 96)
+                av_strlcatf(buff, size, "a=rtpmap:%d L16/%d/%d\r\n",
+                                         payload_type,
+                                         c->sample_rate, c->channels);
+            break;
+        case CODEC_ID_PCM_MULAW:
+            if (payload_type >= 96)
+                av_strlcatf(buff, size, "a=rtpmap:%d PCMU/%d/%d\r\n",
+                                         payload_type,
+                                         c->sample_rate, c->channels);
+            break;
+        case CODEC_ID_PCM_ALAW:
+            if (payload_type >= 96)
+                av_strlcatf(buff, size, "a=rtpmap:%d PCMA/%d/%d\r\n",
+                                         payload_type,
+                                         c->sample_rate, c->channels);
+            break;
         default:
             /* Nothing special to do, here... */
             break;
diff -u mplayer-1.0~rc2-12/libavformat/segafilm.c ffmpeg-free-0.svn20080206/libavformat/segafilm.c
--- mplayer-1.0~rc2-12/libavformat/segafilm.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/segafilm.c	2007-11-21 08:41:00.000000000 +0100
@@ -76,7 +76,7 @@
                             AVFormatParameters *ap)
 {
     FilmDemuxContext *film = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st;
     unsigned char scratch[256];
     int i;
@@ -204,7 +204,7 @@
                             AVPacket *pkt)
 {
     FilmDemuxContext *film = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     film_sample_t *sample;
     int ret = 0;
     int i;
diff -u mplayer-1.0~rc2-12/libavformat/sierravmd.c ffmpeg-free-0.svn20080206/libavformat/sierravmd.c
--- mplayer-1.0~rc2-12/libavformat/sierravmd.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/sierravmd.c	2008-02-04 13:13:09.000000000 +0100
@@ -72,8 +72,8 @@
                            AVFormatParameters *ap)
 {
     VmdDemuxContext *vmd = s->priv_data;
-    ByteIOContext *pb = &s->pb;
-    AVStream *st, *vst;
+    ByteIOContext *pb = s->pb;
+    AVStream *st = NULL, *vst;
     unsigned int toc_offset;
     unsigned char *raw_frame_table;
     int raw_frame_table_size;
@@ -181,6 +181,7 @@
                 continue;
             switch(type) {
             case 1: /* Audio Chunk */
+                if (!st) break;
                 /* first audio chunk contains several audio buffers */
                 if(current_audio_pts){
                     vmd->frame_table[total_frames].frame_offset = current_offset;
@@ -245,7 +246,7 @@
                            AVPacket *pkt)
 {
     VmdDemuxContext *vmd = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int ret = 0;
     vmd_frame_t *frame;
 
Only in ffmpeg-free-0.svn20080206/libavformat: siff.c
diff -u mplayer-1.0~rc2-12/libavformat/smacker.c ffmpeg-free-0.svn20080206/libavformat/smacker.c
--- mplayer-1.0~rc2-12/libavformat/smacker.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/smacker.c	2007-11-21 08:41:00.000000000 +0100
@@ -98,7 +98,7 @@
 
 static int smacker_read_header(AVFormatContext *s, AVFormatParameters *ap)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     SmackerContext *smk = s->priv_data;
     AVStream *st, *ast[7];
     int i, ret;
@@ -226,35 +226,35 @@
     int palchange = 0;
     int pos;
 
-    if (url_feof(&s->pb) || smk->cur_frame >= smk->frames)
+    if (url_feof(s->pb) || smk->cur_frame >= smk->frames)
         return AVERROR(EIO);
 
     /* if we demuxed all streams, pass another frame */
     if(smk->curstream < 0) {
-        url_fseek(&s->pb, smk->nextpos, 0);
+        url_fseek(s->pb, smk->nextpos, 0);
         frame_size = smk->frm_size[smk->cur_frame] & (~3);
         flags = smk->frm_flags[smk->cur_frame];
         /* handle palette change event */
-        pos = url_ftell(&s->pb);
+        pos = url_ftell(s->pb);
         if(flags & SMACKER_PAL){
             int size, sz, t, off, j, pos;
             uint8_t *pal = smk->pal;
             uint8_t oldpal[768];
 
             memcpy(oldpal, pal, 768);
-            size = get_byte(&s->pb);
+            size = get_byte(s->pb);
             size = size * 4 - 1;
             frame_size -= size;
             frame_size--;
             sz = 0;
-            pos = url_ftell(&s->pb) + size;
+            pos = url_ftell(s->pb) + size;
             while(sz < 256){
-                t = get_byte(&s->pb);
+                t = get_byte(s->pb);
                 if(t & 0x80){ /* skip palette entries */
                     sz += (t & 0x7F) + 1;
                     pal += ((t & 0x7F) + 1) * 3;
                 } else if(t & 0x40){ /* copy with offset */
-                    off = get_byte(&s->pb) * 3;
+                    off = get_byte(s->pb) * 3;
                     j = (t & 0x3F) + 1;
                     while(j-- && sz < 256) {
                         *pal++ = oldpal[off + 0];
@@ -265,12 +265,12 @@
                     }
                 } else { /* new entries */
                     *pal++ = smk_pal[t];
-                    *pal++ = smk_pal[get_byte(&s->pb) & 0x3F];
-                    *pal++ = smk_pal[get_byte(&s->pb) & 0x3F];
+                    *pal++ = smk_pal[get_byte(s->pb) & 0x3F];
+                    *pal++ = smk_pal[get_byte(s->pb) & 0x3F];
                     sz++;
                 }
             }
-            url_fseek(&s->pb, pos, 0);
+            url_fseek(s->pb, pos, 0);
             palchange |= 1;
         }
         flags >>= 1;
@@ -279,13 +279,13 @@
         for(i = 0; i < 7; i++) {
             if(flags & 1) {
                 int size;
-                size = get_le32(&s->pb) - 4;
+                size = get_le32(s->pb) - 4;
                 frame_size -= size;
                 frame_size -= 4;
                 smk->curstream++;
                 smk->bufs[smk->curstream] = av_realloc(smk->bufs[smk->curstream], size);
                 smk->buf_sizes[smk->curstream] = size;
-                ret = get_buffer(&s->pb, smk->bufs[smk->curstream], size);
+                ret = get_buffer(s->pb, smk->bufs[smk->curstream], size);
                 if(ret != size)
                     return AVERROR(EIO);
                 smk->stream_id[smk->curstream] = smk->indexes[i];
@@ -298,13 +298,13 @@
             palchange |= 2;
         pkt->data[0] = palchange;
         memcpy(pkt->data + 1, smk->pal, 768);
-        ret = get_buffer(&s->pb, pkt->data + 769, frame_size);
+        ret = get_buffer(s->pb, pkt->data + 769, frame_size);
         if(ret != frame_size)
             return AVERROR(EIO);
         pkt->stream_index = smk->videoindex;
         pkt->size = ret + 769;
         smk->cur_frame++;
-        smk->nextpos = url_ftell(&s->pb);
+        smk->nextpos = url_ftell(s->pb);
     } else {
         if (av_new_packet(pkt, smk->buf_sizes[smk->curstream]))
             return AVERROR(ENOMEM);
diff -u mplayer-1.0~rc2-12/libavformat/sol.c ffmpeg-free-0.svn20080206/libavformat/sol.c
--- mplayer-1.0~rc2-12/libavformat/sol.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/sol.c	2007-11-21 08:41:00.000000000 +0100
@@ -88,7 +88,7 @@
 {
     int size;
     unsigned int magic,tag;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     unsigned int id, codec, channels, rate, type;
     AVStream *st;
 
@@ -130,9 +130,9 @@
 {
     int ret;
 
-    if (url_feof(&s->pb))
+    if (url_feof(s->pb))
         return AVERROR(EIO);
-    ret= av_get_packet(&s->pb, pkt, MAX_SIZE);
+    ret= av_get_packet(s->pb, pkt, MAX_SIZE);
     pkt->stream_index = 0;
 
     /* note: we need to modify the packet size here to handle the last
diff -u mplayer-1.0~rc2-12/libavformat/swf.c ffmpeg-free-0.svn20080206/libavformat/swf.c
--- mplayer-1.0~rc2-12/libavformat/swf.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/swf.c	2008-01-21 14:43:40.000000000 +0100
@@ -40,6 +40,7 @@
 #define TAG_STREAMHEAD2   45
 #define TAG_VIDEOSTREAM   60
 #define TAG_VIDEOFRAME    61
+#define TAG_FILEATTRIBUTES 69
 
 #define TAG_LONG         0x100
 
@@ -96,7 +97,7 @@
 static void put_swf_tag(AVFormatContext *s, int tag)
 {
     SWFContext *swf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
 
     swf->tag_pos = url_ftell(pb);
     swf->tag = tag;
@@ -112,7 +113,7 @@
 static void put_swf_end_tag(AVFormatContext *s)
 {
     SWFContext *swf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     offset_t pos;
     int tag_len, tag;
 
@@ -244,11 +245,12 @@
 static int swf_write_header(AVFormatContext *s)
 {
     SWFContext *swf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVCodecContext *enc, *audio_enc, *video_enc;
     PutBitContext p;
     uint8_t buf1[256];
     int i, width, height, rate, rate_base;
+    int is_avm2;
 
     swf->audio_in_pos = 0;
     swf->sound_samples = 0;
@@ -305,8 +307,12 @@
         swf->samples_per_frame = (audio_enc->sample_rate * rate_base) / rate;
     }
 
+    is_avm2 = !strcmp("avm2", s->oformat->name);
+
     put_tag(pb, "FWS");
-    if (video_enc && video_enc->codec_id == CODEC_ID_VP6F) {
+    if (is_avm2) {
+        put_byte(pb, 9);
+    } else if (video_enc && video_enc->codec_id == CODEC_ID_VP6F) {
         put_byte(pb, 8); /* version (version 8 and above support VP6 codec) */
     } else if (video_enc && video_enc->codec_id == CODEC_ID_FLV1) {
         put_byte(pb, 6); /* version (version 6 and above support FLV1 codec) */
@@ -321,6 +327,13 @@
     swf->duration_pos = url_ftell(pb);
     put_le16(pb, (uint16_t)(DUMMY_DURATION * (int64_t)rate / rate_base)); /* frame count */
 
+    /* avm2/swf v9 (also v8?) files require a file attribute tag */
+    if (is_avm2) {
+        put_swf_tag(s, TAG_FILEATTRIBUTES);
+        put_le32(pb, 1<<3); /* set ActionScript v3/AVM2 flag */
+        put_swf_end_tag(s);
+    }
+
     /* define a shape with the jpeg inside */
     if (video_enc && (video_enc->codec_id == CODEC_ID_VP6F ||
                        video_enc->codec_id == CODEC_ID_FLV1)) {
@@ -392,16 +405,16 @@
         v |= 0x02; /* 16 bit playback */
         if (audio_enc->channels == 2)
             v |= 0x01; /* stereo playback */
-        put_byte(&s->pb, v);
+        put_byte(s->pb, v);
         v |= 0x20; /* mp3 compressed */
-        put_byte(&s->pb, v);
-        put_le16(&s->pb, swf->samples_per_frame);  /* avg samples per frame */
-        put_le16(&s->pb, 0);
+        put_byte(s->pb, v);
+        put_le16(s->pb, swf->samples_per_frame);  /* avg samples per frame */
+        put_le16(s->pb, 0);
 
         put_swf_end_tag(s);
     }
 
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
     return 0;
 }
 
@@ -409,7 +422,7 @@
                            AVCodecContext *enc, const uint8_t *buf, int size)
 {
     SWFContext *swf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
 
     /* Flash Player limit */
     if (swf->swf_frame_number == 16000) {
@@ -516,7 +529,7 @@
     put_swf_tag(s, TAG_SHOWFRAME);
     put_swf_end_tag(s);
 
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
 
     return 0;
 }
@@ -560,7 +573,7 @@
 static int swf_write_trailer(AVFormatContext *s)
 {
     SWFContext *swf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVCodecContext *enc, *video_enc;
     int file_size, i;
 
@@ -574,10 +587,10 @@
     put_swf_tag(s, TAG_END);
     put_swf_end_tag(s);
 
-    put_flush_packet(&s->pb);
+    put_flush_packet(s->pb);
 
     /* patch file size and number of frames if not streamed */
-    if (!url_is_streamed(&s->pb) && video_enc) {
+    if (!url_is_streamed(s->pb) && video_enc) {
         file_size = url_ftell(pb);
         url_fseek(pb, 4, SEEK_SET);
         put_le32(pb, file_size);
@@ -628,7 +641,7 @@
 static int swf_read_header(AVFormatContext *s, AVFormatParameters *ap)
 {
     SWFContext *swf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int nbits, len, tag;
 
     tag = get_be32(pb) & 0xffffff00;
@@ -655,7 +668,7 @@
 static int swf_read_packet(AVFormatContext *s, AVPacket *pkt)
 {
     SWFContext *swf = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *vst = NULL, *ast = NULL, *st = 0;
     int tag, len, i, frame, v;
 
@@ -671,6 +684,8 @@
             get_byte(pb);
             /* Check for FLV1 */
             vst = av_new_stream(s, ch_id);
+            if (!vst)
+                return -1;
             vst->codec->codec_type = CODEC_TYPE_VIDEO;
             vst->codec->codec_id = codec_get_id(swf_codec_tags, get_byte(pb));
             av_set_pts_info(vst, 64, 256, swf->frame_rate);
@@ -683,6 +698,8 @@
             v = get_byte(pb);
             swf->samples_per_frame = get_le16(pb);
             ast = av_new_stream(s, -1); /* -1 to avoid clash with video stream ch_id */
+            if (!ast)
+                return -1;
             swf->audio_stream_index = ast->index;
             ast->codec->channels = 1 + (v&1);
             ast->codec->codec_type = CODEC_TYPE_AUDIO;
@@ -725,6 +742,8 @@
             }
             if (i == s->nb_streams) {
                 vst = av_new_stream(s, -2); /* -2 to avoid clash with video stream and audio stream */
+                if (!vst)
+                    return -1;
                 vst->codec->codec_type = CODEC_TYPE_VIDEO;
                 vst->codec->codec_id = CODEC_ID_MJPEG;
                 av_set_pts_info(vst, 64, 256, swf->frame_rate);
@@ -781,3 +800,17 @@
     swf_write_trailer,
 };
 #endif
+#ifdef CONFIG_AVM2_MUXER
+AVOutputFormat avm2_muxer = {
+    "avm2",
+    "Flash 9 (AVM2) format",
+    "application/x-shockwave-flash",
+    NULL,
+    sizeof(SWFContext),
+    CODEC_ID_MP3,
+    CODEC_ID_FLV1,
+    swf_write_header,
+    swf_write_packet,
+    swf_write_trailer,
+};
+#endif
diff -u mplayer-1.0~rc2-12/libavformat/tcp.c ffmpeg-free-0.svn20080206/libavformat/tcp.c
--- mplayer-1.0~rc2-12/libavformat/tcp.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/tcp.c	2007-11-21 17:33:06.000000000 +0100
@@ -21,6 +21,7 @@
 #include "avformat.h"
 #include <unistd.h>
 #include "network.h"
+#include "os_support.h"
 #include <sys/time.h>
 
 typedef struct TCPContext {
diff -u mplayer-1.0~rc2-12/libavformat/thp.c ffmpeg-free-0.svn20080206/libavformat/thp.c
--- mplayer-1.0~rc2-12/libavformat/thp.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/thp.c	2007-11-21 08:41:00.000000000 +0100
@@ -57,7 +57,7 @@
 {
     ThpDemuxContext *thp = s->priv_data;
     AVStream *st;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int i;
 
     /* Read the file header.  */
@@ -140,7 +140,7 @@
                             AVPacket *pkt)
 {
     ThpDemuxContext *thp = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int size;
     int ret;
 
diff -u mplayer-1.0~rc2-12/libavformat/tiertexseq.c ffmpeg-free-0.svn20080206/libavformat/tiertexseq.c
--- mplayer-1.0~rc2-12/libavformat/tiertexseq.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/tiertexseq.c	2007-11-21 08:41:00.000000000 +0100
@@ -184,7 +184,7 @@
 {
     int i, rc;
     SeqDemuxContext *seq = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st;
 
     /* init internal buffers */
@@ -241,7 +241,7 @@
 {
     int rc;
     SeqDemuxContext *seq = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
 
     if (!seq->audio_buffer_full) {
         rc = seq_parse_frame_data(seq, pb);
diff -u mplayer-1.0~rc2-12/libavformat/tta.c ffmpeg-free-0.svn20080206/libavformat/tta.c
--- mplayer-1.0~rc2-12/libavformat/tta.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/tta.c	2007-11-21 08:41:00.000000000 +0100
@@ -40,25 +40,25 @@
     int i, channels, bps, samplerate, datalen, framelen;
     uint64_t framepos;
 
-    if (get_le32(&s->pb) != ff_get_fourcc("TTA1"))
+    if (get_le32(s->pb) != ff_get_fourcc("TTA1"))
         return -1; // not tta file
 
-    url_fskip(&s->pb, 2); // FIXME: flags
-    channels = get_le16(&s->pb);
-    bps = get_le16(&s->pb);
-    samplerate = get_le32(&s->pb);
+    url_fskip(s->pb, 2); // FIXME: flags
+    channels = get_le16(s->pb);
+    bps = get_le16(s->pb);
+    samplerate = get_le32(s->pb);
     if(samplerate <= 0 || samplerate > 1000000){
         av_log(s, AV_LOG_ERROR, "nonsense samplerate\n");
         return -1;
     }
 
-    datalen = get_le32(&s->pb);
+    datalen = get_le32(s->pb);
     if(datalen < 0){
         av_log(s, AV_LOG_ERROR, "nonsense datalen\n");
         return -1;
     }
 
-    url_fskip(&s->pb, 4); // header crc
+    url_fskip(s->pb, 4); // header crc
 
     framelen = samplerate*256/245;
     c->totalframes = datalen / framelen + ((datalen % framelen) ? 1 : 0);
@@ -77,14 +77,14 @@
     st->start_time = 0;
     st->duration = datalen;
 
-    framepos = url_ftell(&s->pb) + 4*c->totalframes + 4;
+    framepos = url_ftell(s->pb) + 4*c->totalframes + 4;
 
     for (i = 0; i < c->totalframes; i++) {
-        uint32_t size = get_le32(&s->pb);
+        uint32_t size = get_le32(s->pb);
         av_add_index_entry(st, framepos, i*framelen, size, 0, AVINDEX_KEYFRAME);
         framepos += size;
     }
-    url_fskip(&s->pb, 4); // seektable crc
+    url_fskip(s->pb, 4); // seektable crc
 
     st->codec->codec_type = CODEC_TYPE_AUDIO;
     st->codec->codec_id = CODEC_ID_TTA;
@@ -92,15 +92,15 @@
     st->codec->sample_rate = samplerate;
     st->codec->bits_per_sample = bps;
 
-    st->codec->extradata_size = url_ftell(&s->pb);
+    st->codec->extradata_size = url_ftell(s->pb);
     if(st->codec->extradata_size+FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)st->codec->extradata_size){
         //this check is redundant as get_buffer should fail
         av_log(s, AV_LOG_ERROR, "extradata_size too large\n");
         return -1;
     }
     st->codec->extradata = av_mallocz(st->codec->extradata_size+FF_INPUT_BUFFER_PADDING_SIZE);
-    url_fseek(&s->pb, 0, SEEK_SET);
-    get_buffer(&s->pb, st->codec->extradata, st->codec->extradata_size);
+    url_fseek(s->pb, 0, SEEK_SET);
+    get_buffer(s->pb, st->codec->extradata, st->codec->extradata_size);
 
     return 0;
 }
@@ -117,7 +117,7 @@
 
     size = st->index_entries[c->currentframe].size;
 
-    ret = av_get_packet(&s->pb, pkt, size);
+    ret = av_get_packet(s->pb, pkt, size);
     pkt->dts = st->index_entries[c->currentframe++].timestamp;
     return ret;
 }
@@ -131,7 +131,7 @@
         return -1;
 
     c->currentframe = index;
-    url_fseek(&s->pb, st->index_entries[index].pos, SEEK_SET);
+    url_fseek(s->pb, st->index_entries[index].pos, SEEK_SET);
 
     return 0;
 }
diff -u mplayer-1.0~rc2-12/libavformat/txd.c ffmpeg-free-0.svn20080206/libavformat/txd.c
--- mplayer-1.0~rc2-12/libavformat/txd.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/txd.c	2007-11-21 08:41:00.000000000 +0100
@@ -51,7 +51,7 @@
 }
 
 static int txd_read_packet(AVFormatContext *s, AVPacket *pkt) {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     unsigned int id, chunk_size, marker;
     int ret;
 
@@ -60,7 +60,7 @@
     chunk_size = get_le32(pb);
     marker     = get_le32(pb);
 
-    if (url_feof(&s->pb))
+    if (url_feof(s->pb))
         return AVERROR(EIO);
     if (marker != TXD_MARKER && marker != TXD_MARKER2) {
         av_log(NULL, AV_LOG_ERROR, "marker does not match\n");
@@ -72,7 +72,7 @@
             if (chunk_size > 100)
                 break;
         case TXD_EXTRA:
-            url_fskip(&s->pb, chunk_size);
+            url_fskip(s->pb, chunk_size);
         case TXD_FILE:
         case TXD_TEXTURE:
             goto next_chunk;
@@ -81,7 +81,7 @@
             return AVERROR(EIO);
     }
 
-    ret = av_get_packet(&s->pb, pkt, chunk_size);
+    ret = av_get_packet(s->pb, pkt, chunk_size);
     pkt->stream_index = 0;
 
     return ret <= 0 ? AVERROR(EIO) : ret;
diff -u mplayer-1.0~rc2-12/libavformat/udp.c ffmpeg-free-0.svn20080206/libavformat/udp.c
--- mplayer-1.0~rc2-12/libavformat/udp.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/udp.c	2007-11-21 17:33:06.000000000 +0100
@@ -21,6 +21,7 @@
 #include "avformat.h"
 #include <unistd.h>
 #include "network.h"
+#include "os_support.h"
 
 #ifndef IPV6_ADD_MEMBERSHIP
 #define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP
@@ -34,84 +35,98 @@
     int local_port;
     int reuse_socket;
 #ifndef CONFIG_IPV6
-    struct ip_mreq mreq;
     struct sockaddr_in dest_addr;
 #else
     struct sockaddr_storage dest_addr;
-    size_t dest_addr_len;
 #endif
+    size_t dest_addr_len;
 } UDPContext;
 
 #define UDP_TX_BUF_SIZE 32768
 #define UDP_MAX_PKT_SIZE 65536
 
-#ifdef CONFIG_IPV6
-
-static int udp_ipv6_set_multicast_ttl(int sockfd, int mcastTTL, struct sockaddr *addr) {
+static int udp_set_multicast_ttl(int sockfd, int mcastTTL, struct sockaddr *addr) {
+#ifdef IP_MULTICAST_TTL
     if (addr->sa_family == AF_INET) {
         if (setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_TTL, &mcastTTL, sizeof(mcastTTL)) < 0) {
-            perror("setsockopt(IP_MULTICAST_TTL)");
+            av_log(NULL, AV_LOG_ERROR, "setsockopt(IP_MULTICAST_TTL): %s\n", strerror(errno));
             return -1;
         }
     }
+#endif
+#ifdef CONFIG_IPV6
     if (addr->sa_family == AF_INET6) {
         if (setsockopt(sockfd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &mcastTTL, sizeof(mcastTTL)) < 0) {
-            perror("setsockopt(IPV6_MULTICAST_HOPS)");
+            av_log(NULL, AV_LOG_ERROR, "setsockopt(IPV6_MULTICAST_HOPS): %s\n", strerror(errno));
             return -1;
         }
     }
+#endif
     return 0;
 }
 
-static int udp_ipv6_join_multicast_group(int sockfd, struct sockaddr *addr) {
-    struct ip_mreq   mreq;
-    struct ipv6_mreq mreq6;
+static int udp_join_multicast_group(int sockfd, struct sockaddr *addr) {
+#ifdef IP_ADD_MEMBERSHIP
     if (addr->sa_family == AF_INET) {
+        struct ip_mreq mreq;
+
         mreq.imr_multiaddr.s_addr = ((struct sockaddr_in *)addr)->sin_addr.s_addr;
         mreq.imr_interface.s_addr= INADDR_ANY;
         if (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (const void *)&mreq, sizeof(mreq)) < 0) {
-            perror("setsockopt(IP_ADD_MEMBERSHIP)");
+            av_log(NULL, AV_LOG_ERROR, "setsockopt(IP_ADD_MEMBERSHIP): %s\n", strerror(errno));
             return -1;
         }
     }
+#endif
+#ifdef CONFIG_IPV6
     if (addr->sa_family == AF_INET6) {
+        struct ipv6_mreq mreq6;
+
         memcpy(&mreq6.ipv6mr_multiaddr, &(((struct sockaddr_in6 *)addr)->sin6_addr), sizeof(struct in6_addr));
         mreq6.ipv6mr_interface= 0;
         if (setsockopt(sockfd, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq6, sizeof(mreq6)) < 0) {
-            perror("setsockopt(IPV6_ADD_MEMBERSHIP)");
+            av_log(NULL, AV_LOG_ERROR, "setsockopt(IPV6_ADD_MEMBERSHIP): %s\n", strerror(errno));
             return -1;
         }
     }
+#endif
     return 0;
 }
 
-static int udp_ipv6_leave_multicast_group(int sockfd, struct sockaddr *addr) {
-    struct ip_mreq   mreq;
-    struct ipv6_mreq mreq6;
+static int udp_leave_multicast_group(int sockfd, struct sockaddr *addr) {
+#ifdef IP_DROP_MEMBERSHIP
     if (addr->sa_family == AF_INET) {
+        struct ip_mreq mreq;
+
         mreq.imr_multiaddr.s_addr = ((struct sockaddr_in *)addr)->sin_addr.s_addr;
         mreq.imr_interface.s_addr= INADDR_ANY;
         if (setsockopt(sockfd, IPPROTO_IP, IP_DROP_MEMBERSHIP, (const void *)&mreq, sizeof(mreq)) < 0) {
-            perror("setsockopt(IP_DROP_MEMBERSHIP)");
+            av_log(NULL, AV_LOG_ERROR, "setsockopt(IP_DROP_MEMBERSHIP): %s\n", strerror(errno));
             return -1;
         }
     }
+#endif
+#ifdef CONFIG_IPV6
     if (addr->sa_family == AF_INET6) {
+        struct ipv6_mreq mreq6;
+
         memcpy(&mreq6.ipv6mr_multiaddr, &(((struct sockaddr_in6 *)addr)->sin6_addr), sizeof(struct in6_addr));
         mreq6.ipv6mr_interface= 0;
         if (setsockopt(sockfd, IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP, &mreq6, sizeof(mreq6)) < 0) {
-            perror("setsockopt(IPV6_DROP_MEMBERSHIP)");
+            av_log(NULL, AV_LOG_ERROR, "setsockopt(IPV6_DROP_MEMBERSHIP): %s\n", strerror(errno));
             return -1;
         }
     }
+#endif
     return 0;
 }
 
+#ifdef CONFIG_IPV6
 static struct addrinfo* udp_ipv6_resolve_host(const char *hostname, int port, int type, int family, int flags) {
     struct addrinfo hints, *res = 0;
     int error;
     char sport[16];
-    const char *node = 0, *service = 0;
+    const char *node = 0, *service = "0";
 
     if (port > 0) {
         snprintf(sport, sizeof(sport), "%d", port);
@@ -120,80 +135,54 @@
     if ((hostname) && (hostname[0] != '\0') && (hostname[0] != '?')) {
         node = hostname;
     }
-    if ((node) || (service)) {
-        memset(&hints, 0, sizeof(hints));
-        hints.ai_socktype = type;
-        hints.ai_family   = family;
-        hints.ai_flags = flags;
-        if ((error = getaddrinfo(node, service, &hints, &res))) {
-            av_log(NULL, AV_LOG_ERROR, "udp_ipv6_resolve_host: %s\n", gai_strerror(error));
-        }
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_socktype = type;
+    hints.ai_family   = family;
+    hints.ai_flags = flags;
+    if ((error = getaddrinfo(node, service, &hints, &res))) {
+        av_log(NULL, AV_LOG_ERROR, "udp_ipv6_resolve_host: %s\n", gai_strerror(error));
     }
+
     return res;
 }
 
-static int udp_ipv6_set_remote_url(URLContext *h, const char *uri) {
-    UDPContext *s = h->priv_data;
-    char hostname[256];
-    int port;
+static int udp_set_url(struct sockaddr_storage *addr, const char *hostname, int port) {
     struct addrinfo *res0;
-    url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port, NULL, 0, uri);
+    int addr_len;
+
     res0 = udp_ipv6_resolve_host(hostname, port, SOCK_DGRAM, AF_UNSPEC, 0);
     if (res0 == 0) return AVERROR(EIO);
-    memcpy(&s->dest_addr, res0->ai_addr, res0->ai_addrlen);
-    s->dest_addr_len = res0->ai_addrlen;
+    memcpy(addr, res0->ai_addr, res0->ai_addrlen);
+    addr_len = res0->ai_addrlen;
     freeaddrinfo(res0);
-    return 0;
+
+    return addr_len;
 }
 
-static int udp_ipv6_set_local(URLContext *h) {
-    UDPContext *s = h->priv_data;
+static int udp_socket_create(UDPContext *s, struct sockaddr_storage *addr, int *addr_len)
+{
     int udp_fd = -1;
-    struct sockaddr_storage clientaddr;
-    socklen_t addrlen;
-    char sbuf[NI_MAXSERV];
-    char hbuf[NI_MAXHOST];
     struct addrinfo *res0 = NULL, *res = NULL;
+    int family = AF_UNSPEC;
 
-    if (s->local_port != 0) {
-        res0 = udp_ipv6_resolve_host(0, s->local_port, SOCK_DGRAM, AF_UNSPEC, AI_PASSIVE);
-        if (res0 == 0)
-            goto fail;
-        for (res = res0; res; res=res->ai_next) {
-            udp_fd = socket(res->ai_family, SOCK_DGRAM, 0);
-            if (udp_fd > 0) break;
-            perror("socket");
-        }
-    } else {
-        udp_fd = socket(s->dest_addr.ss_family, SOCK_DGRAM, 0);
-        if (udp_fd < 0)
-            perror("socket");
-    }
-
-    if (udp_fd < 0)
+    if (((struct sockaddr *) &s->dest_addr)->sa_family)
+        family = ((struct sockaddr *) &s->dest_addr)->sa_family;
+    res0 = udp_ipv6_resolve_host(0, s->local_port, SOCK_DGRAM, family, AI_PASSIVE);
+    if (res0 == 0)
         goto fail;
-
-    if (s->local_port != 0) {
-        if (bind(udp_fd, res0->ai_addr, res0->ai_addrlen) < 0) {
-            perror("bind");
-            goto fail;
-        }
-        freeaddrinfo(res0);
-        res0 = NULL;
+    for (res = res0; res; res=res->ai_next) {
+        udp_fd = socket(res->ai_family, SOCK_DGRAM, 0);
+        if (udp_fd > 0) break;
+        av_log(NULL, AV_LOG_ERROR, "socket: %s\n", strerror(errno));
     }
 
-    addrlen = sizeof(clientaddr);
-    if (getsockname(udp_fd, (struct sockaddr *)&clientaddr, &addrlen) < 0) {
-        perror("getsockname");
+    if (udp_fd < 0)
         goto fail;
-    }
 
-    if (getnameinfo((struct sockaddr *)&clientaddr, addrlen, hbuf, sizeof(hbuf),  sbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
-        perror("getnameinfo");
-        goto fail;
-    }
+    memcpy(addr, res->ai_addr, res->ai_addrlen);
+    *addr_len = res->ai_addrlen;
 
-    s->local_port = strtol(sbuf, NULL, 10);
+    freeaddrinfo(res0);
 
     return udp_fd;
 
@@ -205,6 +194,52 @@
     return -1;
 }
 
+static int udp_port(struct sockaddr_storage *addr, int addr_len)
+{
+    char sbuf[NI_MAXSERV];
+    char hbuf[NI_MAXHOST];
+
+    if (getnameinfo((struct sockaddr *)addr, addr_len, hbuf, sizeof(hbuf),  sbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
+        av_log(NULL, AV_LOG_ERROR, "getnameinfo: %s\n", strerror(errno));
+        return -1;
+    }
+
+    return strtol(sbuf, NULL, 10);
+}
+
+#else
+
+static int udp_set_url(struct sockaddr_in *addr, const char *hostname, int port)
+{
+    /* set the destination address */
+    if (resolve_host(&addr->sin_addr, hostname) < 0)
+        return AVERROR(EIO);
+    addr->sin_family = AF_INET;
+    addr->sin_port = htons(port);
+
+    return sizeof(struct sockaddr_in);
+}
+
+static int udp_socket_create(UDPContext *s, struct sockaddr_in *addr, int *addr_len)
+{
+    int fd;
+
+    fd = socket(AF_INET, SOCK_DGRAM, 0);
+    if (fd < 0)
+        return -1;
+
+    addr->sin_family = AF_INET;
+    addr->sin_addr.s_addr = htonl (INADDR_ANY);
+    addr->sin_port = htons(s->local_port);
+    *addr_len = sizeof(struct sockaddr_in);
+
+    return fd;
+}
+
+static int udp_port(struct sockaddr_in *addr, int len)
+{
+    return ntohs(addr->sin_port);
+}
 #endif /* CONFIG_IPV6 */
 
 
@@ -226,9 +261,6 @@
  */
 int udp_set_remote_url(URLContext *h, const char *uri)
 {
-#ifdef CONFIG_IPV6
-    return udp_ipv6_set_remote_url(h, uri);
-#else
     UDPContext *s = h->priv_data;
     char hostname[256];
     int port;
@@ -236,12 +268,12 @@
     url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port, NULL, 0, uri);
 
     /* set the destination address */
-    if (resolve_host(&s->dest_addr.sin_addr, hostname) < 0)
+    s->dest_addr_len = udp_set_url(&s->dest_addr, hostname, port);
+    if (s->dest_addr_len < 0) {
         return AVERROR(EIO);
-    s->dest_addr.sin_family = AF_INET;
-    s->dest_addr.sin_port = htons(port);
+    }
+
     return 0;
-#endif
 }
 
 /**
@@ -277,24 +309,23 @@
     const char *p;
     char buf[256];
 #ifndef CONFIG_IPV6
-    struct sockaddr_in my_addr, my_addr1;
-    int len;
+    struct sockaddr_in my_addr;
+#else
+    struct sockaddr_storage my_addr;
 #endif
+    int len;
 
     h->is_streamed = 1;
     h->max_packet_size = 1472;
 
     is_output = (flags & URL_WRONLY);
 
-    s = av_malloc(sizeof(UDPContext));
+    s = av_mallocz(sizeof(UDPContext));
     if (!s)
         return AVERROR(ENOMEM);
 
     h->priv_data = s;
     s->ttl = 16;
-    s->is_multicast = 0;
-    s->local_port = 0;
-    s->reuse_socket = 0;
     p = strchr(uri, '?');
     if (p) {
         s->is_multicast = find_info_tag(buf, sizeof(buf), "multicast", p);
@@ -325,76 +356,41 @@
     if(!ff_network_init())
         return AVERROR(EIO);
 
-#ifndef CONFIG_IPV6
-    udp_fd = socket(AF_INET, SOCK_DGRAM, 0);
+    if (s->is_multicast && !(h->flags & URL_WRONLY))
+        s->local_port = port;
+    udp_fd = udp_socket_create(s, &my_addr, &len);
     if (udp_fd < 0)
         goto fail;
 
-    my_addr.sin_family = AF_INET;
-    my_addr.sin_addr.s_addr = htonl (INADDR_ANY);
-    if (s->is_multicast && !(h->flags & URL_WRONLY)) {
-        /* special case: the bind must be done on the multicast address port */
-        my_addr.sin_port = s->dest_addr.sin_port;
-    } else {
-        my_addr.sin_port = htons(s->local_port);
-    }
-
     if (s->reuse_socket)
         if (setsockopt (udp_fd, SOL_SOCKET, SO_REUSEADDR, &(s->reuse_socket), sizeof(s->reuse_socket)) != 0)
             goto fail;
 
     /* the bind is needed to give a port to the socket now */
-    if (bind(udp_fd,(struct sockaddr *)&my_addr, sizeof(my_addr)) < 0)
+    if (bind(udp_fd,(struct sockaddr *)&my_addr, len) < 0)
         goto fail;
 
-    len = sizeof(my_addr1);
-    getsockname(udp_fd, (struct sockaddr *)&my_addr1, &len);
-    s->local_port = ntohs(my_addr1.sin_port);
+    len = sizeof(my_addr);
+    getsockname(udp_fd, (struct sockaddr *)&my_addr, &len);
+    s->local_port = udp_port(&my_addr, len);
 
-#ifdef IP_MULTICAST_TTL
     if (s->is_multicast) {
         if (h->flags & URL_WRONLY) {
             /* output */
-            if (setsockopt(udp_fd, IPPROTO_IP, IP_MULTICAST_TTL,
-                           &s->ttl, sizeof(s->ttl)) < 0) {
-                perror("IP_MULTICAST_TTL");
+            if (udp_set_multicast_ttl(udp_fd, s->ttl, (struct sockaddr *)&s->dest_addr) < 0)
                 goto fail;
-            }
         } else {
             /* input */
-            memset(&s->mreq, 0, sizeof(s->mreq));
-            s->mreq.imr_multiaddr = s->dest_addr.sin_addr;
-            s->mreq.imr_interface.s_addr = htonl (INADDR_ANY);
-            if (setsockopt(udp_fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,
-                           &s->mreq, sizeof(s->mreq)) < 0) {
-                perror("rtp: IP_ADD_MEMBERSHIP");
-                goto fail;
-            }
-        }
-    }
-#endif
-#else
-    if (s->is_multicast && !(h->flags & URL_WRONLY))
-        s->local_port = port;
-    udp_fd = udp_ipv6_set_local(h);
-    if (udp_fd < 0)
-        goto fail;
-    if (s->is_multicast) {
-        if (h->flags & URL_WRONLY) {
-            if (udp_ipv6_set_multicast_ttl(udp_fd, s->ttl, (struct sockaddr *)&s->dest_addr) < 0)
-                goto fail;
-        } else {
-            if (udp_ipv6_join_multicast_group(udp_fd, (struct sockaddr *)&s->dest_addr) < 0)
+            if (udp_join_multicast_group(udp_fd, (struct sockaddr *)&s->dest_addr) < 0)
                 goto fail;
         }
     }
-#endif /* CONFIG_IPV6 */
 
     if (is_output) {
         /* limit the tx buf size to limit latency */
         tmp = UDP_TX_BUF_SIZE;
         if (setsockopt(udp_fd, SOL_SOCKET, SO_SNDBUF, &tmp, sizeof(tmp)) < 0) {
-            perror("setsockopt sndbuf");
+            av_log(NULL, AV_LOG_ERROR, "setsockopt(SO_SNDBUF): %s\n", strerror(errno));
             goto fail;
         }
     } else {
@@ -416,18 +412,10 @@
 static int udp_read(URLContext *h, uint8_t *buf, int size)
 {
     UDPContext *s = h->priv_data;
-#ifndef CONFIG_IPV6
-    struct sockaddr_in from;
-#else
-    struct sockaddr_storage from;
-#endif
-    socklen_t from_len;
     int len;
 
     for(;;) {
-        from_len = sizeof(from);
-        len = recvfrom (s->udp_fd, buf, size, 0,
-                        (struct sockaddr *)&from, &from_len);
+        len = recv(s->udp_fd, buf, size, 0);
         if (len < 0) {
             if (ff_neterrno() != FF_NETERROR(EAGAIN) &&
                 ff_neterrno() != FF_NETERROR(EINTR))
@@ -447,11 +435,7 @@
     for(;;) {
         ret = sendto (s->udp_fd, buf, size, 0,
                       (struct sockaddr *) &s->dest_addr,
-#ifndef CONFIG_IPV6
-                      sizeof (s->dest_addr));
-#else
                       s->dest_addr_len);
-#endif
         if (ret < 0) {
             if (ff_neterrno() != FF_NETERROR(EINTR) &&
                 ff_neterrno() != FF_NETERROR(EAGAIN))
@@ -467,19 +451,8 @@
 {
     UDPContext *s = h->priv_data;
 
-#ifndef CONFIG_IPV6
-#ifdef IP_DROP_MEMBERSHIP
-    if (s->is_multicast && !(h->flags & URL_WRONLY)) {
-        if (setsockopt(s->udp_fd, IPPROTO_IP, IP_DROP_MEMBERSHIP,
-                       &s->mreq, sizeof(s->mreq)) < 0) {
-            perror("IP_DROP_MEMBERSHIP");
-        }
-    }
-#endif
-#else
     if (s->is_multicast && !(h->flags & URL_WRONLY))
-        udp_ipv6_leave_multicast_group(s->udp_fd, (struct sockaddr *)&s->dest_addr);
-#endif
+        udp_leave_multicast_group(s->udp_fd, (struct sockaddr *)&s->dest_addr);
     closesocket(s->udp_fd);
     ff_network_close();
     av_free(s);
diff -u mplayer-1.0~rc2-12/libavformat/utils.c ffmpeg-free-0.svn20080206/libavformat/utils.c
--- mplayer-1.0~rc2-12/libavformat/utils.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/utils.c	2008-02-02 23:55:58.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Various utilities for ffmpeg system
+ * various utility functions for use within FFmpeg
  * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
  *
  * This file is part of FFmpeg.
@@ -30,17 +30,29 @@
 
 /**
  * @file libavformat/utils.c
- * Various utility functions for using ffmpeg library.
+ * various utility functions for use within FFmpeg
  */
 
 static void av_frac_init(AVFrac *f, int64_t val, int64_t num, int64_t den);
 static void av_frac_add(AVFrac *f, int64_t incr);
 
-/** head of registered input format linked list. */
+/** head of registered input format linked list */
 AVInputFormat *first_iformat = NULL;
-/** head of registered output format linked list. */
+/** head of registered output format linked list */
 AVOutputFormat *first_oformat = NULL;
 
+AVInputFormat  *av_iformat_next(AVInputFormat  *f)
+{
+    if(f) return f->next;
+    else  return first_iformat;
+}
+
+AVOutputFormat *av_oformat_next(AVOutputFormat *f)
+{
+    if(f) return f->next;
+    else  return first_oformat;
+}
+
 void av_register_input_format(AVInputFormat *format)
 {
     AVInputFormat **p;
@@ -100,7 +112,7 @@
         return guess_format("image2", NULL, NULL);
     }
 #endif
-    /* find the proper file type */
+    /* Find the proper file type. */
     fmt_found = NULL;
     score_max = 0;
     fmt = first_oformat;
@@ -229,8 +241,7 @@
 {
     if (pkt->destruct != av_destruct_packet) {
         uint8_t *data;
-        /* we duplicate the packet and don't forget to put the padding
-           again */
+        /* We duplicate the packet and don't forget to add the padding again. */
         if((unsigned)pkt->size > (unsigned)pkt->size + FF_INPUT_BUFFER_PADDING_SIZE)
             return AVERROR(ENOMEM);
         data = av_malloc(pkt->size + FF_INPUT_BUFFER_PADDING_SIZE);
@@ -311,6 +322,8 @@
 {"track", " set the track number", OFFSET(track), FF_OPT_TYPE_INT, DEFAULT, 0, INT_MAX, E},
 {"year", "set the year", OFFSET(year), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX, E},
 {"analyzeduration", "how many microseconds are analyzed to estimate duration", OFFSET(max_analyze_duration), FF_OPT_TYPE_INT, 3*AV_TIME_BASE, 0, INT_MAX, D},
+{"cryptokey", "decryption key", OFFSET(key), FF_OPT_TYPE_BINARY, 0, 0, 0, D},
+{"indexmem", "max memory used for timestamp index (per stream)", OFFSET(max_index_size), FF_OPT_TYPE_INT, INT_MAX, 0, INT_MAX, D},
 {NULL},
 };
 
@@ -361,8 +374,7 @@
         goto fail;
     }
     ic->iformat = fmt;
-    if (pb)
-        ic->pb = *pb;
+    ic->pb = pb;
     ic->duration = AV_NOPTS_VALUE;
     ic->start_time = AV_NOPTS_VALUE;
     av_strlcpy(ic->filename, filename, sizeof(ic->filename));
@@ -383,7 +395,7 @@
         goto fail;
 
     if (pb && !ic->data_offset)
-        ic->data_offset = url_ftell(&ic->pb);
+        ic->data_offset = url_ftell(ic->pb);
 
     *ic_ptr = ic;
     return 0;
@@ -396,7 +408,7 @@
     return err;
 }
 
-/** Size of probe buffer, for guessing file type from file contents. */
+/** size of probe buffer, for guessing file type from file contents */
 #define PROBE_BUF_MIN 2048
 #define PROBE_BUF_MAX (1<<20)
 
@@ -405,11 +417,10 @@
                        int buf_size,
                        AVFormatParameters *ap)
 {
-    int err, must_open_file, file_opened, probe_size;
+    int err, probe_size;
     AVProbeData probe_data, *pd = &probe_data;
-    ByteIOContext pb1, *pb = &pb1;
+    ByteIOContext *pb = NULL;
 
-    file_opened = 0;
     pd->filename = "";
     if (filename)
         pd->filename = filename;
@@ -417,24 +428,17 @@
     pd->buf_size = 0;
 
     if (!fmt) {
-        /* guess format if no file can be opened  */
+        /* guess format if no file can be opened */
         fmt = av_probe_input_format(pd, 0);
     }
 
-    /* do not open file if the format does not need it. XXX: specific
+    /* Do not open file if the format does not need it. XXX: specific
        hack needed to handle RTSP/TCP */
-    must_open_file = 1;
-    if (fmt && (fmt->flags & AVFMT_NOFILE)) {
-        must_open_file = 0;
-        pb= NULL; //FIXME this or memset(pb, 0, sizeof(ByteIOContext)); otherwise it is uninitialized
-    }
-
-    if (!fmt || must_open_file) {
+    if (!fmt || !(fmt->flags & AVFMT_NOFILE)) {
         /* if no file needed do not try to open one */
-        if ((err=url_fopen(pb, filename, URL_RDONLY)) < 0) {
+        if ((err=url_fopen(&pb, filename, URL_RDONLY)) < 0) {
             goto fail;
         }
-        file_opened = 1;
         if (buf_size > 0) {
             url_setbufsize(pb, buf_size);
         }
@@ -447,8 +451,8 @@
             memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);
             if (url_fseek(pb, 0, SEEK_SET) < 0) {
                 url_fclose(pb);
-                if (url_fopen(pb, filename, URL_RDONLY) < 0) {
-                    file_opened = 0;
+                if (url_fopen(&pb, filename, URL_RDONLY) < 0) {
+                    pb = NULL;
                     err = AVERROR(EIO);
                     goto fail;
                 }
@@ -465,17 +469,7 @@
         goto fail;
     }
 
-    /* XXX: suppress this hack for redirectors */
-#ifdef CONFIG_REDIR_DEMUXER
-    if (!strcmp(fmt->name, "redir")) {
-        int redir_open(AVFormatContext **ic_ptr, ByteIOContext *f);
-        err = redir_open(ic_ptr, pb);
-        url_fclose(pb);
-        return err;
-    }
-#endif
-
-    /* check filename in case of an image number is expected */
+    /* check filename in case an image number is expected */
     if (fmt->flags & AVFMT_NEEDNUMBER) {
         if (!av_filename_number_test(filename)) {
             err = AVERROR_NUMEXPECTED;
@@ -488,7 +482,7 @@
     return 0;
  fail:
     av_freep(&pd->buf);
-    if (file_opened)
+    if (pb)
         url_fclose(pb);
     *ic_ptr = NULL;
     return err;
@@ -499,14 +493,33 @@
 
 int av_read_packet(AVFormatContext *s, AVPacket *pkt)
 {
+    int ret;
+    AVStream *st;
     av_init_packet(pkt);
-    return s->iformat->read_packet(s, pkt);
+    ret= s->iformat->read_packet(s, pkt);
+    if (ret < 0)
+        return ret;
+    st= s->streams[pkt->stream_index];
+
+    switch(st->codec->codec_type){
+    case CODEC_TYPE_VIDEO:
+        if(s->video_codec_id)   st->codec->codec_id= s->video_codec_id;
+        break;
+    case CODEC_TYPE_AUDIO:
+        if(s->audio_codec_id)   st->codec->codec_id= s->audio_codec_id;
+        break;
+    case CODEC_TYPE_SUBTITLE:
+        if(s->subtitle_codec_id)st->codec->codec_id= s->subtitle_codec_id;
+        break;
+    }
+
+    return ret;
 }
 
 /**********************************************************/
 
 /**
- * Get the number of samples of an audio frame. Return (-1) if error.
+ * Get the number of samples of an audio frame. Return -1 on error.
  */
 static int get_audio_frame_size(AVCodecContext *enc, int size)
 {
@@ -533,7 +546,7 @@
 
 
 /**
- * Return the frame duration in seconds, return 0 if not available.
+ * Return the frame duration in seconds. Return 0 if not available.
  */
 static void compute_frame_duration(int *pnum, int *pden, AVStream *st,
                                    AVCodecParserContext *pc, AVPacket *pkt)
@@ -637,7 +650,8 @@
         }
     }
 
-    /* correct timestamps with byte offset if demuxers only have timestamps on packet boundaries */
+    /* correct timestamps with byte offset if demuxers only have timestamps
+       on packet boundaries */
     if(pc && st->need_parsing == AVSTREAM_PARSE_TIMESTAMPS && pkt->size){
         /* this will estimate bitrate based on this frame's duration and size */
         offset = av_rescale(pc->offset, pkt->duration, pkt->size);
@@ -647,10 +661,7 @@
             pkt->dts += offset;
     }
 
-    if(is_intra_only(st->codec))
-        pkt->flags |= PKT_FLAG_KEY;
-
-    /* do we have a video B frame ? */
+    /* do we have a video B-frame ? */
     delay= st->codec->has_b_frames;
     presentation_delayed = 0;
     /* XXX: need has_b_frame, but cannot get it if the codec is
@@ -670,8 +681,8 @@
     /* interpolate PTS and DTS if they are not present */
     if(delay <=1){
         if (presentation_delayed) {
-            /* DTS = decompression time stamp */
-            /* PTS = presentation time stamp */
+            /* DTS = decompression timestamp */
+            /* PTS = presentation timestamp */
             if (pkt->dts == AV_NOPTS_VALUE)
                 pkt->dts = st->last_IP_pts;
             update_initial_timestamps(s, pkt->stream_index, pkt->dts, pkt->pts);
@@ -679,14 +690,14 @@
                 pkt->dts = st->cur_dts;
 
             /* this is tricky: the dts must be incremented by the duration
-            of the frame we are displaying, i.e. the last I or P frame */
+            of the frame we are displaying, i.e. the last I- or P-frame */
             if (st->last_IP_duration == 0)
                 st->last_IP_duration = pkt->duration;
             st->cur_dts = pkt->dts + st->last_IP_duration;
             st->last_IP_duration  = pkt->duration;
             st->last_IP_pts= pkt->pts;
             /* cannot compute PTS if not present (we can compute it only
-            by knowing the futur */
+            by knowing the future */
         } else if(pkt->pts != AV_NOPTS_VALUE || pkt->dts != AV_NOPTS_VALUE || pkt->duration){
             if(pkt->pts != AV_NOPTS_VALUE && pkt->duration){
                 int64_t old_diff= FFABS(st->cur_dts - pkt->duration - pkt->pts);
@@ -726,9 +737,11 @@
 //    av_log(NULL, AV_LOG_ERROR, "OUTdelayed:%d/%d pts:%"PRId64", dts:%"PRId64" cur_dts:%"PRId64"\n", presentation_delayed, delay, pkt->pts, pkt->dts, st->cur_dts);
 
     /* update flags */
-    if (pc) {
+    if(is_intra_only(st->codec))
+        pkt->flags |= PKT_FLAG_KEY;
+    else if (pc) {
         pkt->flags = 0;
-        /* key frame computation */
+        /* keyframe computation */
             if (pc->pict_type == FF_I_TYPE)
                 pkt->flags |= PKT_FLAG_KEY;
     }
@@ -779,6 +792,7 @@
                     compute_pkt_fields(s, st, st->parser, pkt);
 
                     if((s->iformat->flags & AVFMT_GENERIC_INDEX) && pkt->flags & PKT_FLAG_KEY){
+                        ff_reduce_index(s, st->index);
                         av_add_index_entry(st, st->parser->frame_offset, pkt->dts,
                                            0, 0, AVINDEX_KEYFRAME);
                     }
@@ -808,7 +822,7 @@
                             goto got_packet;
                     }
                 }
-                /* no more packets: really terminates parsing */
+                /* no more packets: really terminate parsing */
                 return ret;
             }
 
@@ -826,7 +840,7 @@
             if (st->need_parsing && !st->parser) {
                 st->parser = av_parser_init(st->codec->codec_id);
                 if (!st->parser) {
-                    /* no parser available : just output the raw packets */
+                    /* no parser available: just output the raw packets */
                     st->need_parsing = AVSTREAM_PARSE_NONE;
                 }else if(st->need_parsing == AVSTREAM_PARSE_HEADERS){
                     st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
@@ -996,6 +1010,19 @@
     }
 }
 
+void ff_reduce_index(AVFormatContext *s, int stream_index)
+{
+    AVStream *st= s->streams[stream_index];
+    unsigned int max_entries= s->max_index_size / sizeof(AVIndexEntry);
+
+    if((unsigned)st->nb_index_entries >= max_entries){
+        int i;
+        for(i=0; 2*i<st->nb_index_entries; i++)
+            st->index_entries[i]= st->index_entries[2*i];
+        st->nb_index_entries= i;
+    }
+}
+
 int av_add_index_entry(AVStream *st,
                             int64_t pos, int64_t timestamp, int size, int distance, int flags)
 {
@@ -1096,7 +1123,7 @@
     if(st->index_entries){
         AVIndexEntry *e;
 
-        index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD); //FIXME whole func must be checked for non keyframe entries in index case, especially read_timestamp()
+        index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD); //FIXME whole func must be checked for non-keyframe entries in index case, especially read_timestamp()
         index= FFMAX(index, 0);
         e= &st->index_entries[index];
 
@@ -1131,7 +1158,7 @@
         return -1;
 
     /* do the seek */
-    url_fseek(&s->pb, pos, SEEK_SET);
+    url_fseek(s->pb, pos, SEEK_SET);
 
     av_update_cur_dts(s, st, ts);
 
@@ -1156,7 +1183,7 @@
 
     if(ts_max == AV_NOPTS_VALUE){
         int step= 1024;
-        filesize = url_fsize(&s->pb);
+        filesize = url_fsize(s->pb);
         pos_max = filesize - 1;
         do{
             pos_max -= step;
@@ -1203,7 +1230,8 @@
             // bisection, if interpolation failed to change min or max pos last time
             pos = (pos_min + pos_limit)>>1;
         }else{
-            // linear search if bisection failed, can only happen if there are very few or no keframes between min/max
+            /* linear search if bisection failed, can only happen if there
+               are very few or no keyframes between min/max */
             pos=pos_min;
         }
         if(pos <= pos_min)
@@ -1262,12 +1290,12 @@
 #endif
 
     pos_min = s->data_offset;
-    pos_max = url_fsize(&s->pb) - 1;
+    pos_max = url_fsize(s->pb) - 1;
 
     if     (pos < pos_min) pos= pos_min;
     else if(pos > pos_max) pos= pos_max;
 
-    url_fseek(&s->pb, pos, SEEK_SET);
+    url_fseek(s->pb, pos, SEEK_SET);
 
 #if 0
     av_update_cur_dts(s, st, ts);
@@ -1292,10 +1320,10 @@
 
         if(st->index_entries && st->nb_index_entries){
             ie= &st->index_entries[st->nb_index_entries-1];
-            url_fseek(&s->pb, ie->pos, SEEK_SET);
+            url_fseek(s->pb, ie->pos, SEEK_SET);
             av_update_cur_dts(s, st, ie->timestamp);
         }else
-            url_fseek(&s->pb, 0, SEEK_SET);
+            url_fseek(s->pb, 0, SEEK_SET);
 
         for(i=0;; i++) {
             int ret = av_read_frame(s, &pkt);
@@ -1318,7 +1346,7 @@
             return 0;
     }
     ie = &st->index_entries[index];
-    url_fseek(&s->pb, ie->pos, SEEK_SET);
+    url_fseek(s->pb, ie->pos, SEEK_SET);
 
     av_update_cur_dts(s, st, ie->timestamp);
 
@@ -1398,7 +1426,7 @@
     duration = INT64_MIN;
     for(i = 0;i < ic->nb_streams; i++) {
         st = ic->streams[i];
-        if (st->start_time != AV_NOPTS_VALUE) {
+        if (st->start_time != AV_NOPTS_VALUE && st->time_base.den) {
             start_time1= av_rescale_q(st->start_time, st->time_base, AV_TIME_BASE_Q);
             if (start_time1 < start_time)
                 start_time = start_time1;
@@ -1425,7 +1453,7 @@
     if (duration != INT64_MIN) {
         ic->duration = duration;
         if (ic->file_size > 0) {
-            /* compute the bit rate */
+            /* compute the bitrate */
             ic->bit_rate = (double)ic->file_size * 8.0 * AV_TIME_BASE /
                 (double)ic->duration;
         }
@@ -1510,7 +1538,7 @@
 
     /* we read the first packets to get the first PTS (not fully
        accurate, but it is enough now) */
-    url_fseek(&ic->pb, 0, SEEK_SET);
+    url_fseek(ic->pb, 0, SEEK_SET);
     read_size = 0;
     for(;;) {
         if (read_size >= DURATION_MAX_READ_SIZE)
@@ -1543,7 +1571,7 @@
     if (offset < 0)
         offset = 0;
 
-    url_fseek(&ic->pb, offset, SEEK_SET);
+    url_fseek(ic->pb, offset, SEEK_SET);
     read_size = 0;
     for(;;) {
         if (read_size >= DURATION_MAX_READ_SIZE)
@@ -1569,7 +1597,7 @@
 
     fill_all_stream_timings(ic);
 
-    url_fseek(&ic->pb, old_offset, SEEK_SET);
+    url_fseek(ic->pb, old_offset, SEEK_SET);
     for(i=0; i<ic->nb_streams; i++){
         st= ic->streams[i];
         st->cur_dts= st->first_dts;
@@ -1585,7 +1613,7 @@
     if (ic->iformat->flags & AVFMT_NOFILE) {
         file_size = 0;
     } else {
-        file_size = url_fsize(&ic->pb);
+        file_size = url_fsize(ic->pb);
         if (file_size < 0)
             file_size = 0;
     }
@@ -1593,15 +1621,15 @@
 
     if ((!strcmp(ic->iformat->name, "mpeg") ||
          !strcmp(ic->iformat->name, "mpegts")) &&
-        file_size && !ic->pb.is_streamed) {
+        file_size && !url_is_streamed(ic->pb)) {
         /* get accurate estimate from the PTSes */
         av_estimate_timings_from_pts(ic, old_offset);
     } else if (av_has_duration(ic)) {
-        /* at least one components has timings - we use them for all
+        /* at least one component has timings - we use them for all
            the components */
         fill_all_stream_timings(ic);
     } else {
-        /* less precise: use bit rate info */
+        /* less precise: use bitrate info */
         av_estimate_timings_from_bit_rate(ic);
     }
     av_update_stream_timings(ic);
@@ -1661,7 +1689,7 @@
     switch(st->codec->codec_type) {
     case CODEC_TYPE_VIDEO:
         ret = avcodec_decode_video(st->codec, &picture,
-                                   &got_picture, (uint8_t *)data, size);
+                                   &got_picture, data, size);
         break;
     case CODEC_TYPE_AUDIO:
         data_size = FFMAX(size, AVCODEC_MAX_AUDIO_FRAME_SIZE);
@@ -1669,7 +1697,7 @@
         if (!samples)
             goto fail;
         ret = avcodec_decode_audio2(st->codec, samples,
-                                    &data_size, (uint8_t *)data, size);
+                                    &data_size, data, size);
         av_free(samples);
         break;
     default:
@@ -1750,6 +1778,24 @@
     else        return ((int[]){24,30,60,12,15})[i-60*12]*1000*12;
 }
 
+/*
+ * Is the time base unreliable.
+ * This is a heuristic to balance between quick acceptance of the values in
+ * the headers vs. some extra checks.
+ * Old DivX and Xvid often have nonsense timebases like 1fps or 2fps.
+ * MPEG-2 commonly misuses field repeat flags to store different framerates.
+ * And there are "variable" fps files this needs to detect as well.
+ */
+static int tb_unreliable(AVCodecContext *c){
+    if(   c->time_base.den >= 101L*c->time_base.num
+       || c->time_base.den <    5L*c->time_base.num
+/*       || c->codec_tag == ff_get_fourcc("DIVX")
+       || c->codec_tag == ff_get_fourcc("XVID")*/
+       || c->codec_id == CODEC_ID_MPEG2VIDEO)
+        return 1;
+    return 0;
+}
+
 int av_find_stream_info(AVFormatContext *ic)
 {
     int i, count, ret, read_size, j;
@@ -1758,7 +1804,7 @@
     int64_t last_dts[MAX_STREAMS];
     int duration_count[MAX_STREAMS]={0};
     double (*duration_error)[MAX_STD_TIMEBASES];
-    offset_t old_offset = url_ftell(&ic->pb);
+    offset_t old_offset = url_ftell(ic->pb);
     int64_t codec_info_duration[MAX_STREAMS]={0};
     int codec_info_nb_frames[MAX_STREAMS]={0};
     AVProbeData probe_data[MAX_STREAMS];
@@ -1798,7 +1844,7 @@
             if (!has_codec_parameters(st->codec))
                 break;
             /* variable fps and no guess at the real fps */
-            if(   (st->codec->time_base.den >= 101LL*st->codec->time_base.num || st->codec->codec_id == CODEC_ID_MPEG2VIDEO)
+            if(   tb_unreliable(st->codec)
                && duration_count[i]<20 && st->codec->codec_type == CODEC_TYPE_VIDEO)
                 break;
             if(st->parser && st->parser->parser->split && !st->codec->extradata)
@@ -1896,8 +1942,8 @@
 
         /* if still no information, we try to open the codec and to
            decompress the frame. We try to avoid that in most cases as
-           it takes longer and uses more memory. For MPEG4, we need to
-           decompress for Quicktime. */
+           it takes longer and uses more memory. For MPEG-4, we need to
+           decompress for QuickTime. */
         if (!has_codec_parameters(st->codec) /*&&
             (st->codec->codec_id == CODEC_ID_FLV1 ||
              st->codec->codec_id == CODEC_ID_H264 ||
@@ -1934,8 +1980,8 @@
                 st->codec->codec_tag= avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);
 
             if(duration_count[i]
-               && (st->codec->time_base.num*101LL <= st->codec->time_base.den || st->codec->codec_id == CODEC_ID_MPEG2VIDEO) /*&&
-               //FIXME we should not special case mpeg2, but this needs testing with non mpeg2 ...
+               && tb_unreliable(st->codec) /*&&
+               //FIXME we should not special-case MPEG-2, but this needs testing with non-MPEG-2 ...
                st->time_base.num*duration_sum[i]/duration_count[i]*101LL > st->time_base.den*/){
                 double best_error= 2*av_q2d(st->time_base);
                 best_error= best_error*best_error*duration_count[i]*1000*12*30;
@@ -1990,11 +2036,11 @@
             }
             st->cur_dts= st->first_dts;
         }
-        url_fseek(&ic->pb, ic->data_offset, SEEK_SET);
+        url_fseek(ic->pb, ic->data_offset, SEEK_SET);
     }
 
 #if 0
-    /* correct DTS for b frame streams with no timestamps */
+    /* correct DTS for B-frame streams with no timestamps */
     for(i=0;i<ic->nb_streams;i++) {
         st = ic->streams[i];
         if (st->codec->codec_type == CODEC_TYPE_VIDEO) {
@@ -2030,21 +2076,25 @@
 
 int av_read_play(AVFormatContext *s)
 {
-    if (!s->iformat->read_play)
-        return AVERROR(ENOSYS);
-    return s->iformat->read_play(s);
+    if (s->iformat->read_play)
+        return s->iformat->read_play(s);
+    if (s->pb)
+        return av_url_read_fpause(s->pb, 0);
+    return AVERROR(ENOSYS);
 }
 
 int av_read_pause(AVFormatContext *s)
 {
-    if (!s->iformat->read_pause)
-        return AVERROR(ENOSYS);
-    return s->iformat->read_pause(s);
+    if (s->iformat->read_pause)
+        return s->iformat->read_pause(s);
+    if (s->pb)
+        return av_url_read_fpause(s->pb, 1);
+    return AVERROR(ENOSYS);
 }
 
-void av_close_input_file(AVFormatContext *s)
+void av_close_input_stream(AVFormatContext *s)
 {
-    int i, must_open_file;
+    int i;
     AVStream *st;
 
     /* free previous packet */
@@ -2062,25 +2112,28 @@
         av_free(st->index_entries);
         av_free(st->codec->extradata);
         av_free(st->codec);
+        av_free(st->filename);
         av_free(st);
     }
     for(i=s->nb_programs-1; i>=0; i--) {
         av_freep(&s->programs[i]->provider_name);
         av_freep(&s->programs[i]->name);
+        av_freep(&s->programs[i]->stream_index);
         av_freep(&s->programs[i]);
     }
     flush_packet_queue(s);
-    must_open_file = 1;
-    if (s->iformat->flags & AVFMT_NOFILE) {
-        must_open_file = 0;
-    }
-    if (must_open_file) {
-        url_fclose(&s->pb);
-    }
     av_freep(&s->priv_data);
     av_free(s);
 }
 
+void av_close_input_file(AVFormatContext *s)
+{
+    ByteIOContext *pb = s->iformat->flags & AVFMT_NOFILE ? NULL : s->pb;
+    av_close_input_stream(s);
+    if (pb)
+        url_fclose(pb);
+}
+
 AVStream *av_new_stream(AVFormatContext *s, int id)
 {
     AVStream *st;
@@ -2105,7 +2158,7 @@
     st->cur_dts = AV_NOPTS_VALUE;
     st->first_dts = AV_NOPTS_VALUE;
 
-    /* default pts settings is MPEG like */
+    /* default pts setting is MPEG-like */
     av_set_pts_info(st, 33, 1, 90000);
     st->last_IP_pts = AV_NOPTS_VALUE;
     for(i=0; i<MAX_REORDER_DELAY+1; i++)
@@ -2206,7 +2259,7 @@
             if(st->codec->codec_tag){
                 //FIXME
                 //check that tag + id is in the table
-                //if neither is in the table -> ok
+                //if neither is in the table -> OK
                 //if tag is in the table with another id -> FAIL
                 //if id is in the table with another tag -> FAIL unless strict < ?
             }else
@@ -2304,8 +2357,9 @@
     case CODEC_TYPE_AUDIO:
         frame_size = get_audio_frame_size(st->codec, pkt->size);
 
-        /* HACK/FIXME, we skip the initial 0-size packets as they are most likely equal to the encoder delay,
-           but it would be better if we had the real timestamps from the encoder */
+        /* HACK/FIXME, we skip the initial 0 size packets as they are most
+           likely equal to the encoder delay, but it would be better if we
+           had the real timestamps from the encoder */
         if (frame_size >= 0 && (pkt->size || st->pts.num!=st->pts.den>>1 || st->pts.val)) {
             av_frac_add(&st->pts, (int64_t)st->time_base.den * frame_size);
         }
@@ -2323,7 +2377,7 @@
     int64_t pts_mask = (2LL << (st->pts_wrap_bits-1)) - 1;
 
 //    if(pkt->dts < 0)
-//        pkt->dts= 0;  //this happens for low_delay=0 and b frames, FIXME, needs further invstigation about what we should do here
+//        pkt->dts= 0;  //this happens for low_delay=0 and B-frames, FIXME, needs further investigation about what we should do here
 
     if (pkt->pts != AV_NOPTS_VALUE)
         pkt->pts &= pts_mask;
@@ -2343,7 +2397,7 @@
 
     ret= s->oformat->write_packet(s, pkt);
     if(!ret)
-        ret= url_ferror(&s->pb);
+        ret= url_ferror(s->pb);
     return ret;
 }
 
@@ -2360,7 +2414,7 @@
         this_pktl = av_mallocz(sizeof(AVPacketList));
         this_pktl->pkt= *pkt;
         if(pkt->destruct == av_destruct_packet)
-            pkt->destruct= NULL; // non shared -> must keep original from being freed
+            pkt->destruct= NULL; // not shared -> must keep original from being freed
         else
             av_dup_packet(&this_pktl->pkt);  //shared -> must dup
 
@@ -2401,7 +2455,7 @@
 }
 
 /**
- * Interleaves a AVPacket correctly so it can be muxed.
+ * Interleaves an AVPacket correctly so it can be muxed.
  * @param out the interleaved packet will be output here
  * @param in the input packet
  * @param flush 1 if no further packets are available as input and all
@@ -2444,8 +2498,8 @@
 
         if(ret<0)
             return ret;
-        if(url_ferror(&s->pb))
-            return url_ferror(&s->pb);
+        if(url_ferror(s->pb))
+            return url_ferror(s->pb);
     }
 }
 
@@ -2468,7 +2522,7 @@
 
         if(ret<0)
             goto fail;
-        if(url_ferror(&s->pb))
+        if(url_ferror(s->pb))
             goto fail;
     }
 
@@ -2476,22 +2530,70 @@
         ret = s->oformat->write_trailer(s);
 fail:
     if(ret == 0)
-       ret=url_ferror(&s->pb);
+       ret=url_ferror(s->pb);
     for(i=0;i<s->nb_streams;i++)
         av_freep(&s->streams[i]->priv_data);
     av_freep(&s->priv_data);
     return ret;
 }
 
+void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)
+{
+    int i, j;
+    AVProgram *program=NULL;
+    void *tmp;
+
+    for(i=0; i<ac->nb_programs; i++){
+        if(ac->programs[i]->id != progid)
+            continue;
+        program = ac->programs[i];
+        for(j=0; j<program->nb_stream_indexes; j++)
+            if(program->stream_index[j] == idx)
+                return;
+
+        tmp = av_realloc(program->stream_index, sizeof(unsigned int)*(program->nb_stream_indexes+1));
+        if(!tmp)
+            return;
+        program->stream_index = tmp;
+        program->stream_index[program->nb_stream_indexes++] = idx;
+        return;
+    }
+}
+
 /* "user interface" functions */
+static void dump_stream_format(AVFormatContext *ic, int i, int index, int is_output)
+{
+    char buf[256];
+    int flags = (is_output ? ic->oformat->flags : ic->iformat->flags);
+    AVStream *st = ic->streams[i];
+    int g = ff_gcd(st->time_base.num, st->time_base.den);
+    avcodec_string(buf, sizeof(buf), st->codec, is_output);
+    av_log(NULL, AV_LOG_INFO, "    Stream #%d.%d", index, i);
+    /* the pid is an important information, so we display it */
+    /* XXX: add a generic system */
+    if (flags & AVFMT_SHOW_IDS)
+        av_log(NULL, AV_LOG_INFO, "[0x%x]", st->id);
+    if (strlen(st->language) > 0)
+        av_log(NULL, AV_LOG_INFO, "(%s)", st->language);
+    av_log(NULL, AV_LOG_DEBUG, ", %d/%d", st->time_base.num/g, st->time_base.den/g);
+    av_log(NULL, AV_LOG_INFO, ": %s", buf);
+    if(st->codec->codec_type == CODEC_TYPE_VIDEO){
+        if(st->r_frame_rate.den && st->r_frame_rate.num)
+            av_log(NULL, AV_LOG_INFO, ", %5.2f tb(r)", av_q2d(st->r_frame_rate));
+/*      else if(st->time_base.den && st->time_base.num)
+            av_log(NULL, AV_LOG_INFO, ", %5.2f tb(m)", 1/av_q2d(st->time_base));*/
+        else
+            av_log(NULL, AV_LOG_INFO, ", %5.2f tb(c)", 1/av_q2d(st->codec->time_base));
+    }
+    av_log(NULL, AV_LOG_INFO, "\n");
+}
 
 void dump_format(AVFormatContext *ic,
                  int index,
                  const char *url,
                  int is_output)
 {
-    int i, flags;
-    char buf[256];
+    int i;
 
     av_log(NULL, AV_LOG_INFO, "%s #%d, %s, %s '%s':\n",
             is_output ? "Output" : "Input",
@@ -2529,35 +2631,17 @@
         }
         av_log(NULL, AV_LOG_INFO, "\n");
     }
-    for(i=0;i<ic->nb_streams;i++) {
-        AVStream *st = ic->streams[i];
-        int g= ff_gcd(st->time_base.num, st->time_base.den);
-        avcodec_string(buf, sizeof(buf), st->codec, is_output);
-        av_log(NULL, AV_LOG_INFO, "  Stream #%d.%d", index, i);
-        /* the pid is an important information, so we display it */
-        /* XXX: add a generic system */
-        if (is_output)
-            flags = ic->oformat->flags;
-        else
-            flags = ic->iformat->flags;
-        if (flags & AVFMT_SHOW_IDS) {
-            av_log(NULL, AV_LOG_INFO, "[0x%x]", st->id);
-        }
-        if (strlen(st->language) > 0) {
-            av_log(NULL, AV_LOG_INFO, "(%s)", st->language);
-        }
-        av_log(NULL, AV_LOG_DEBUG, ", %d/%d", st->time_base.num/g, st->time_base.den/g);
-        av_log(NULL, AV_LOG_INFO, ": %s", buf);
-        if(st->codec->codec_type == CODEC_TYPE_VIDEO){
-            if(st->r_frame_rate.den && st->r_frame_rate.num)
-                av_log(NULL, AV_LOG_INFO, ", %5.2f fps(r)", av_q2d(st->r_frame_rate));
-/*            else if(st->time_base.den && st->time_base.num)
-                av_log(NULL, AV_LOG_INFO, ", %5.2f fps(m)", 1/av_q2d(st->time_base));*/
-            else
-                av_log(NULL, AV_LOG_INFO, ", %5.2f fps(c)", 1/av_q2d(st->codec->time_base));
-        }
-        av_log(NULL, AV_LOG_INFO, "\n");
-    }
+    if(ic->nb_programs) {
+        int j, k;
+        for(j=0; j<ic->nb_programs; j++) {
+            av_log(NULL, AV_LOG_INFO, "  Program %d %s\n", ic->programs[j]->id,
+                   ic->programs[j]->name ? ic->programs[j]->name : "");
+            for(k=0; k<ic->programs[j]->nb_stream_indexes; k++)
+                dump_stream_format(ic, ic->programs[j]->stream_index[k], index, is_output);
+         }
+    } else
+    for(i=0;i<ic->nb_streams;i++)
+        dump_stream_format(ic, i, index, is_output);
 }
 
 int parse_image_size(int *width_ptr, int *height_ptr, const char *str)
@@ -2575,7 +2659,7 @@
 }
 
 /**
- * gets the current time in micro seconds.
+ * Gets the current time in microseconds.
  */
 int64_t av_gettime(void)
 {
@@ -2845,7 +2929,7 @@
         PRINT("N/A");
     else
         PRINT("%0.3f", (double)pkt->dts / AV_TIME_BASE);
-    /* PTS may be not known if B frames are present */
+    /* PTS may not be known if B-frames are present. */
     PRINT("  pts=");
     if (pkt->pts == AV_NOPTS_VALUE)
         PRINT("N/A");
@@ -2896,7 +2980,10 @@
     }
 
     /* separate path from hostname */
-    if ((ls = strchr(p, '/')))
+    ls = strchr(p, '/');
+    if(!ls)
+        ls = strchr(p, '?');
+    if(ls)
         av_strlcpy(path, ls, path_size);
     else
         ls = &p[strlen(p)]; // XXX
@@ -2959,7 +3046,7 @@
 }
 
 /**
- * Fractionnal addition to f: f = f + (incr / f->den).
+ * Fractional addition to f: f = f + (incr / f->den).
  *
  * @param f fractional number
  * @param incr increment, can be positive or negative
Only in mplayer-1.0~rc2-12/libavformat: v4l2.c
Only in mplayer-1.0~rc2-12/libavformat: v4l.c
Only in ffmpeg-free-0.svn20080206/libavformat: vc1test.c
diff -u mplayer-1.0~rc2-12/libavformat/vocdec.c ffmpeg-free-0.svn20080206/libavformat/vocdec.c
--- mplayer-1.0~rc2-12/libavformat/vocdec.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/vocdec.c	2007-11-21 08:41:00.000000000 +0100
@@ -39,7 +39,7 @@
 static int voc_read_header(AVFormatContext *s, AVFormatParameters *ap)
 {
     voc_dec_context_t *voc = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int header_size;
     AVStream *st;
 
@@ -64,7 +64,7 @@
 {
     voc_dec_context_t *voc = s->priv_data;
     AVCodecContext *dec = st->codec;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     voc_type_t type;
     int size;
     int sample_rate = 0;
diff -u mplayer-1.0~rc2-12/libavformat/vocenc.c ffmpeg-free-0.svn20080206/libavformat/vocenc.c
--- mplayer-1.0~rc2-12/libavformat/vocenc.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/vocenc.c	2007-11-21 08:41:00.000000000 +0100
@@ -28,7 +28,7 @@
 
 static int voc_write_header(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     const int header_size = 26;
     const int version = 0x0114;
 
@@ -48,7 +48,7 @@
 {
     voc_enc_context_t *voc = s->priv_data;
     AVCodecContext *enc = s->streams[0]->codec;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
 
     if (!voc->param_written) {
         if (enc->codec_tag > 0xFF) {
@@ -84,7 +84,7 @@
 
 static int voc_write_trailer(AVFormatContext *s)
 {
-    put_byte(&s->pb, 0);
+    put_byte(s->pb, 0);
     return 0;
 }
 
diff -u mplayer-1.0~rc2-12/libavformat/voc.h ffmpeg-free-0.svn20080206/libavformat/voc.h
--- mplayer-1.0~rc2-12/libavformat/voc.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/voc.h	2007-10-17 11:37:46.000000000 +0200
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef VOC_H
-#define VOC_H
+#ifndef FFMPEG_VOC_H
+#define FFMPEG_VOC_H
 
 #include "avformat.h"
 #include "riff.h"    /* for CodecTag */
@@ -48,4 +48,4 @@
 int voc_get_packet(AVFormatContext *s, AVPacket *pkt,
                    AVStream *st, int max_size);
 
-#endif
+#endif /* FFMPEG_VOC_H */
diff -u mplayer-1.0~rc2-12/libavformat/wav.c ffmpeg-free-0.svn20080206/libavformat/wav.c
--- mplayer-1.0~rc2-12/libavformat/wav.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/wav.c	2007-11-21 08:41:00.000000000 +0100
@@ -34,7 +34,7 @@
 static int wav_write_header(AVFormatContext *s)
 {
     WAVContext *wav = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     offset_t fmt, fact;
 
     put_tag(pb, "RIFF");
@@ -50,7 +50,7 @@
     end_tag(pb, fmt);
 
     if(s->streams[0]->codec->codec_tag != 0x01 /* hence for all other than PCM */
-       && !url_is_streamed(&s->pb)) {
+       && !url_is_streamed(s->pb)) {
         fact = start_tag(pb, "fact");
         put_le32(pb, 0);
         end_tag(pb, fact);
@@ -70,7 +70,7 @@
 
 static int wav_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     WAVContext *wav = s->priv_data;
     put_buffer(pb, pkt->data, pkt->size);
     if(pkt->pts != AV_NOPTS_VALUE) {
@@ -84,11 +84,11 @@
 
 static int wav_write_trailer(AVFormatContext *s)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     WAVContext *wav = s->priv_data;
     offset_t file_size;
 
-    if (!url_is_streamed(&s->pb)) {
+    if (!url_is_streamed(s->pb)) {
         end_tag(pb, wav->data);
 
         /* update file size */
@@ -156,7 +156,7 @@
 {
     int size;
     unsigned int tag;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st;
     WAVContext *wav = s->priv_data;
 
@@ -199,17 +199,17 @@
     AVStream *st;
     WAVContext *wav = s->priv_data;
 
-    if (url_feof(&s->pb))
+    if (url_feof(s->pb))
         return AVERROR(EIO);
     st = s->streams[0];
 
-    left= wav->data_end - url_ftell(&s->pb);
+    left= wav->data_end - url_ftell(s->pb);
     if(left <= 0){
-        left = find_tag(&(s->pb), MKTAG('d', 'a', 't', 'a'));
+        left = find_tag(s->pb, MKTAG('d', 'a', 't', 'a'));
         if (left < 0) {
             return AVERROR(EIO);
         }
-        wav->data_end= url_ftell(&s->pb) + left;
+        wav->data_end= url_ftell(s->pb) + left;
     }
 
     size = MAX_SIZE;
@@ -219,7 +219,7 @@
         size = (size / st->codec->block_align) * st->codec->block_align;
     }
     size= FFMIN(size, left);
-    ret= av_get_packet(&s->pb, pkt, size);
+    ret= av_get_packet(s->pb, pkt, size);
     if (ret <= 0)
         return AVERROR(EIO);
     pkt->stream_index = 0;
diff -u mplayer-1.0~rc2-12/libavformat/wc3movie.c ffmpeg-free-0.svn20080206/libavformat/wc3movie.c
--- mplayer-1.0~rc2-12/libavformat/wc3movie.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/wc3movie.c	2007-12-01 01:07:51.000000000 +0100
@@ -33,7 +33,7 @@
 
 #define FORM_TAG MKTAG('F', 'O', 'R', 'M')
 #define MOVE_TAG MKTAG('M', 'O', 'V', 'E')
-#define _PC__TAG MKTAG('_', 'P', 'C', '_')
+#define  PC__TAG MKTAG('_', 'P', 'C', '_')
 #define SOND_TAG MKTAG('S', 'O', 'N', 'D')
 #define BNAM_TAG MKTAG('B', 'N', 'A', 'M')
 #define SIZE_TAG MKTAG('S', 'I', 'Z', 'E')
@@ -126,7 +126,7 @@
                            AVFormatParameters *ap)
 {
     Wc3DemuxContext *wc3 = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     unsigned int fourcc_tag;
     unsigned int size;
     AVStream *st;
@@ -165,7 +165,7 @@
             url_fseek(pb, size, SEEK_CUR);
             break;
 
-        case _PC__TAG:
+        case PC__TAG:
             /* need the number of palettes */
             url_fseek(pb, 8, SEEK_CUR);
             if ((ret = get_buffer(pb, preamble, 4)) != 4)
@@ -272,7 +272,7 @@
                            AVPacket *pkt)
 {
     Wc3DemuxContext *wc3 = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     unsigned int fourcc_tag;
     unsigned int size;
     int packet_read = 0;
diff -u mplayer-1.0~rc2-12/libavformat/westwood.c ffmpeg-free-0.svn20080206/libavformat/westwood.c
--- mplayer-1.0~rc2-12/libavformat/westwood.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/westwood.c	2007-11-21 08:41:00.000000000 +0100
@@ -118,7 +118,7 @@
                              AVFormatParameters *ap)
 {
     WsAudDemuxContext *wsaud = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st;
     unsigned char header[AUD_HEADER_SIZE];
 
@@ -160,7 +160,7 @@
                              AVPacket *pkt)
 {
     WsAudDemuxContext *wsaud = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     unsigned char preamble[AUD_CHUNK_PREAMBLE_SIZE];
     unsigned int chunk_size;
     int ret = 0;
@@ -213,7 +213,7 @@
                              AVFormatParameters *ap)
 {
     WsVqaDemuxContext *wsvqa = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVStream *st;
     unsigned char *header;
     unsigned char scratch[VQA_PREAMBLE_SIZE];
@@ -315,7 +315,7 @@
                              AVPacket *pkt)
 {
     WsVqaDemuxContext *wsvqa = s->priv_data;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int ret = -1;
     unsigned char preamble[VQA_PREAMBLE_SIZE];
     unsigned int chunk_type;
diff -u mplayer-1.0~rc2-12/libavformat/wv.c ffmpeg-free-0.svn20080206/libavformat/wv.c
--- mplayer-1.0~rc2-12/libavformat/wv.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/wv.c	2007-11-21 08:41:00.000000000 +0100
@@ -135,7 +135,7 @@
 static int wv_read_header(AVFormatContext *s,
                           AVFormatParameters *ap)
 {
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     WVContext *wc = s->priv_data;
     AVStream *st;
 
@@ -164,17 +164,17 @@
     WVContext *wc = s->priv_data;
     int ret;
 
-    if (url_feof(&s->pb))
+    if (url_feof(s->pb))
         return AVERROR(EIO);
     if(wc->block_parsed){
-        if(wv_read_block_header(s, &s->pb) < 0)
+        if(wv_read_block_header(s, s->pb) < 0)
             return -1;
     }
 
     if(av_new_packet(pkt, wc->blksize + WV_EXTRA_SIZE) < 0)
         return AVERROR(ENOMEM);
     memcpy(pkt->data, wc->extra, WV_EXTRA_SIZE);
-    ret = get_buffer(&s->pb, pkt->data + WV_EXTRA_SIZE, wc->blksize);
+    ret = get_buffer(s->pb, pkt->data + WV_EXTRA_SIZE, wc->blksize);
     if(ret != wc->blksize){
         av_free_packet(pkt);
         return AVERROR(EIO);
@@ -204,18 +204,18 @@
     /* if found, seek there */
     if (index >= 0){
         wc->block_parsed = 1;
-        url_fseek(&s->pb, st->index_entries[index].pos, SEEK_SET);
+        url_fseek(s->pb, st->index_entries[index].pos, SEEK_SET);
         return 0;
     }
     /* if timestamp is out of bounds, return error */
     if(timestamp < 0 || timestamp >= s->duration)
         return -1;
 
-    pos = url_ftell(&s->pb);
+    pos = url_ftell(s->pb);
     do{
         ret = av_read_frame(s, pkt);
         if (ret < 0){
-            url_fseek(&s->pb, pos, SEEK_SET);
+            url_fseek(s->pb, pos, SEEK_SET);
             return -1;
         }
         pts = pkt->pts;
Only in mplayer-1.0~rc2-12/libavformat: x11grab.c
diff -u mplayer-1.0~rc2-12/libavformat/yuv4mpeg.c ffmpeg-free-0.svn20080206/libavformat/yuv4mpeg.c
--- mplayer-1.0~rc2-12/libavformat/yuv4mpeg.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavformat/yuv4mpeg.c	2007-11-21 08:41:00.000000000 +0100
@@ -87,7 +87,7 @@
 static int yuv4_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
     AVStream *st = s->streams[pkt->stream_index];
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     AVPicture *picture;
     int* first_pkt = s->priv_data;
     int width, height, h_chroma_shift, v_chroma_shift;
@@ -190,7 +190,7 @@
     char header[MAX_YUV4_HEADER+10];  // Include headroom for the longest option
     char *tokstart,*tokend,*header_end;
     int i;
-    ByteIOContext *pb = &s->pb;
+    ByteIOContext *pb = s->pb;
     int width=-1, height=-1, raten=0, rated=0, aspectn=0, aspectd=0;
     enum PixelFormat pix_fmt=PIX_FMT_NONE,alt_pix_fmt=PIX_FMT_NONE;
     AVStream *st;
@@ -344,7 +344,7 @@
     struct frame_attributes *s1 = s->priv_data;
 
     for (i=0; i<MAX_FRAME_HEADER; i++) {
-        header[i] = get_byte(&s->pb);
+        header[i] = get_byte(s->pb);
         if (header[i] == '\n') {
             header[i+1] = 0;
             break;
@@ -360,7 +360,7 @@
     if (packet_size < 0)
         return -1;
 
-    if (av_get_packet(&s->pb, pkt, packet_size) != packet_size)
+    if (av_get_packet(s->pb, pkt, packet_size) != packet_size)
         return AVERROR(EIO);
 
     if (s->streams[0]->codec->coded_frame) {
diff -u mplayer-1.0~rc2-12/libavutil/adler32.c ffmpeg-free-0.svn20080206/libavutil/adler32.c
--- mplayer-1.0~rc2-12/libavutil/adler32.c	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/adler32.c	2008-01-10 11:35:37.000000000 +0100
@@ -54,7 +54,7 @@
 #include "log.h"
 #define LEN 7001
 volatile int checksum;
-int main(){
+int main(void){
     int i;
     char data[LEN];
     av_log_level = AV_LOG_DEBUG;
@@ -66,5 +66,6 @@
         STOP_TIMER("adler")
     }
     av_log(NULL, AV_LOG_DEBUG, "%X == 50E6E508\n", checksum);
+    return 0;
 }
 #endif
diff -u mplayer-1.0~rc2-12/libavutil/adler32.h ffmpeg-free-0.svn20080206/libavutil/adler32.h
--- mplayer-1.0~rc2-12/libavutil/adler32.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/adler32.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,12 +18,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef ADLER32_H
-#define ADLER32_H
+#ifndef FFMPEG_ADLER32_H
+#define FFMPEG_ADLER32_H
 
 #include <stdint.h>
 
 unsigned long av_adler32_update(unsigned long adler, const uint8_t *buf,
                                 unsigned int len);
 
-#endif
+#endif /* FFMPEG_ADLER32_H */
diff -u mplayer-1.0~rc2-12/libavutil/aes.c ffmpeg-free-0.svn20080206/libavutil/aes.c
--- mplayer-1.0~rc2-12/libavutil/aes.c	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/aes.c	2008-01-08 23:40:25.000000000 +0100
@@ -194,7 +194,9 @@
 #ifdef TEST
 #include "log.h"
 
-int main(){
+#undef random
+
+int main(void){
     int i,j;
     AVAES ae, ad, b;
     uint8_t rkey[2][16]= {
diff -u mplayer-1.0~rc2-12/libavutil/aes.h ffmpeg-free-0.svn20080206/libavutil/aes.h
--- mplayer-1.0~rc2-12/libavutil/aes.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/aes.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AES_H
-#define AES_H
+#ifndef FFMPEG_AES_H
+#define FFMPEG_AES_H
 
 #include <stdint.h>
 
@@ -44,4 +44,4 @@
  */
 void av_aes_crypt(struct AVAES *a, uint8_t *dst, uint8_t *src, int count, uint8_t *iv, int decrypt);
 
-#endif /* AES_H */
+#endif /* FFMPEG_AES_H */
diff -u mplayer-1.0~rc2-12/libavutil/avstring.h ffmpeg-free-0.svn20080206/libavutil/avstring.h
--- mplayer-1.0~rc2-12/libavutil/avstring.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/avstring.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVUTIL_STRING_H
-#define AVUTIL_STRING_H
+#ifndef FFMPEG_AVSTRING_H
+#define FFMPEG_AVSTRING_H
 
 #include <stddef.h>
 
@@ -87,4 +87,4 @@
  */
 size_t av_strlcatf(char *dst, size_t size, const char *fmt, ...);
 
-#endif /* AVUTIL_STRING_H */
+#endif /* FFMPEG_AVSTRING_H */
diff -u mplayer-1.0~rc2-12/libavutil/avutil.h ffmpeg-free-0.svn20080206/libavutil/avutil.h
--- mplayer-1.0~rc2-12/libavutil/avutil.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/avutil.h	2008-01-28 18:23:57.000000000 +0100
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVUTIL_H
-#define AVUTIL_H
+#ifndef FFMPEG_AVUTIL_H
+#define FFMPEG_AVUTIL_H
 
 /**
  * @file avutil.h
@@ -30,8 +30,8 @@
 #define AV_STRINGIFY(s)         AV_TOSTRING(s)
 #define AV_TOSTRING(s) #s
 
-#define LIBAVUTIL_VERSION_INT   ((49<<16)+(5<<8)+0)
-#define LIBAVUTIL_VERSION       49.5.0
+#define LIBAVUTIL_VERSION_INT   ((49<<16)+(6<<8)+0)
+#define LIBAVUTIL_VERSION       49.6.0
 #define LIBAVUTIL_BUILD         LIBAVUTIL_VERSION_INT
 
 #define LIBAVUTIL_IDENT         "Lavu" AV_STRINGIFY(LIBAVUTIL_VERSION)
@@ -40,7 +40,6 @@
 #include "common.h"
 #include "mathematics.h"
 #include "rational.h"
-#include "integer.h"
 #include "intfloat_readwrite.h"
 #include "log.h"
 
@@ -129,4 +128,4 @@
 #define PIX_FMT_YUV422  PIX_FMT_YUYV422
 #endif
 
-#endif /* AVUTIL_H */
+#endif /* FFMPEG_AVUTIL_H */
diff -u mplayer-1.0~rc2-12/libavutil/base64.c ffmpeg-free-0.svn20080206/libavutil/base64.c
--- mplayer-1.0~rc2-12/libavutil/base64.c	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/base64.c	2008-01-14 23:10:19.000000000 +0100
@@ -29,7 +29,7 @@
 #include "base64.h"
 
 /* ---------------- private code */
-static uint8_t map2[] =
+static const uint8_t map2[] =
 {
     0x3e, 0xff, 0xff, 0xff, 0x3f, 0x34, 0x35, 0x36,
     0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0xff,
@@ -70,7 +70,7 @@
 * fixed edge cases and made it work from data (vs. strings) by ryan.
 *****************************************************************************/
 
-char *av_base64_encode(char * buf, int buf_len, uint8_t * src, int len)
+char *av_base64_encode(char * buf, int buf_len, const uint8_t * src, int len)
 {
     static const char b64[] =
         "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
@@ -83,20 +83,18 @@
         buf_len < len * 4 / 3 + 12)
         return NULL;
     ret = dst = buf;
-    if (len) {                  // special edge case, what should we really do here?
-        while (bytes_remaining) {
-            i_bits = (i_bits << 8) + *src++;
-            bytes_remaining--;
-            i_shift += 8;
-
-            do {
-                *dst++ = b64[(i_bits << 6 >> i_shift) & 0x3f];
-                i_shift -= 6;
-            } while (i_shift > 6 || (bytes_remaining == 0 && i_shift > 0));
-        }
-        while ((dst - ret) & 3)
-            *dst++ = '=';
+    while (bytes_remaining) {
+        i_bits = (i_bits << 8) + *src++;
+        bytes_remaining--;
+        i_shift += 8;
+
+        do {
+            *dst++ = b64[(i_bits << 6 >> i_shift) & 0x3f];
+            i_shift -= 6;
+        } while (i_shift > 6 || (bytes_remaining == 0 && i_shift > 0));
     }
+    while ((dst - ret) & 3)
+        *dst++ = '=';
     *dst = '\0';
 
     return ret;
diff -u mplayer-1.0~rc2-12/libavutil/base64.h ffmpeg-free-0.svn20080206/libavutil/base64.h
--- mplayer-1.0~rc2-12/libavutil/base64.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/base64.h	2007-10-30 16:32:52.000000000 +0100
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVUTIL_BASE64_H
-#define AVUTIL_BASE64_H
+#ifndef FFMPEG_BASE64_H
+#define FFMPEG_BASE64_H
 
 #include <stdint.h>
 
@@ -35,6 +35,6 @@
  * @param src data, not a string
  * @param buf output string
  */
-char *av_base64_encode(char * buf, int buf_len, uint8_t * src, int len);
+char *av_base64_encode(char * buf, int buf_len, const uint8_t * src, int len);
 
-#endif // AVUTIL_BASE64_H
+#endif /* FFMPEG_BASE64_H */
diff -u mplayer-1.0~rc2-12/libavutil/bswap.h ffmpeg-free-0.svn20080206/libavutil/bswap.h
--- mplayer-1.0~rc2-12/libavutil/bswap.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/bswap.h	2007-10-17 11:37:46.000000000 +0200
@@ -23,8 +23,8 @@
  * byte swap.
  */
 
-#ifndef BSWAP_H
-#define BSWAP_H
+#ifndef FFMPEG_BSWAP_H
+#define FFMPEG_BSWAP_H
 
 #include <stdint.h>
 #include "common.h"
@@ -138,4 +138,4 @@
 #define le2me_64(x) (x)
 #endif
 
-#endif /* BSWAP_H */
+#endif /* FFMPEG_BSWAP_H */
diff -u mplayer-1.0~rc2-12/libavutil/common.h ffmpeg-free-0.svn20080206/libavutil/common.h
--- mplayer-1.0~rc2-12/libavutil/common.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/common.h	2008-02-01 02:33:49.000000000 +0100
@@ -23,8 +23,8 @@
  * common internal and external api header.
  */
 
-#ifndef COMMON_H
-#define COMMON_H
+#ifndef FFMPEG_COMMON_H
+#define FFMPEG_COMMON_H
 
 #include <inttypes.h>
 
@@ -96,9 +96,7 @@
 
 static inline int av_log2(unsigned int v)
 {
-    int n;
-
-    n = 0;
+    int n = 0;
     if (v & 0xffff0000) {
         v >>= 16;
         n += 16;
@@ -114,9 +112,7 @@
 
 static inline int av_log2_16bit(unsigned int v)
 {
-    int n;
-
-    n = 0;
+    int n = 0;
     if (v & 0xff00) {
         v >>= 8;
         n += 8;
@@ -366,4 +362,4 @@
 #define STOP_TIMER(id) {}
 #endif
 
-#endif /* COMMON_H */
+#endif /* FFMPEG_COMMON_H */
diff -u mplayer-1.0~rc2-12/libavutil/crc.c ffmpeg-free-0.svn20080206/libavutil/crc.c
--- mplayer-1.0~rc2-12/libavutil/crc.c	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/crc.c	2008-02-01 02:33:16.000000000 +0100
@@ -21,16 +21,21 @@
 #include "common.h"
 #include "crc.h"
 
-#if LIBAVUTIL_VERSION_INT  < (50<<16)
-AVCRC *av_crcEDB88320;
-AVCRC *av_crc04C11DB7;
-AVCRC *av_crc8005    ;
-AVCRC *av_crc07      ;
+#ifdef CONFIG_HARDCODED_TABLES
+#include "crc_data.h"
 #else
-AVCRC av_crcEDB88320[257];
-AVCRC av_crc04C11DB7[257];
-AVCRC av_crc8005    [257];
-AVCRC av_crc07      [257];
+static struct {
+    uint8_t  le;
+    uint8_t  bits;
+    uint32_t poly;
+} av_crc_table_params[AV_CRC_MAX] = {
+    [AV_CRC_8_ATM]      = { 0,  8,       0x07 },
+    [AV_CRC_16_ANSI]    = { 0, 16,     0x8005 },
+    [AV_CRC_16_CCITT]   = { 0, 16,     0x1021 },
+    [AV_CRC_32_IEEE]    = { 0, 32, 0x04C11DB7 },
+    [AV_CRC_32_IEEE_LE] = { 1, 32, 0xEDB88320 },
+};
+static AVCRC av_crc_table[AV_CRC_MAX][257];
 #endif
 
 /**
@@ -80,6 +85,24 @@
 }
 
 /**
+ * Get an initialized standard CRC table.
+ * @param crc_id ID of a standard CRC
+ * @return a pointer to the CRC table or NULL on failure
+ */
+const AVCRC *av_crc_get_table(AVCRCId crc_id){
+#ifndef CONFIG_HARDCODED_TABLES
+    if (!av_crc_table[crc_id][sizeof(av_crc_table[crc_id])/sizeof(av_crc_table[crc_id][0])-1])
+        if (av_crc_init(av_crc_table[crc_id],
+                        av_crc_table_params[crc_id].le,
+                        av_crc_table_params[crc_id].bits,
+                        av_crc_table_params[crc_id].poly,
+                        sizeof(av_crc_table[crc_id])) < 0)
+            return NULL;
+#endif
+    return av_crc_table[crc_id];
+}
+
+/**
  * Calculate the CRC of a block
  * @param crc CRC of previous blocks if any or initial value for CRC.
  * @return CRC updated with the data from the given block
@@ -92,7 +115,7 @@
 #ifndef CONFIG_SMALL
     if(!ctx[256])
         while(buffer<end-3){
-            crc ^= le2me_32(*(uint32_t*)buffer); buffer+=4;
+            crc ^= le2me_32(*(const uint32_t*)buffer); buffer+=4;
             crc =  ctx[3*256 + ( crc     &0xFF)]
                   ^ctx[2*256 + ((crc>>8 )&0xFF)]
                   ^ctx[1*256 + ((crc>>16)&0xFF)]
@@ -107,21 +130,22 @@
 
 #ifdef TEST
 #undef printf
-main(){
+int main(void){
     uint8_t buf[1999];
     int i;
-    int p[4][4]={{1, 32, AV_CRC_32_IEEE_LE, 0x3D5CDD04},
-                 {0, 32, AV_CRC_32_IEEE   , 0xC0F5BAE0},
-                 {0, 16, AV_CRC_16        , 0x1FBB    },
-                 {0,  8, AV_CRC_8_ATM     , 0xE3      },};
-    AVCRC ctx[1 ? 1024:257];
+    int p[4][3]={{AV_CRC_32_IEEE_LE, 0xEDB88320, 0x3D5CDD04},
+                 {AV_CRC_32_IEEE   , 0x04C11DB7, 0xC0F5BAE0},
+                 {AV_CRC_16_ANSI   , 0x8005,     0x1FBB    },
+                 {AV_CRC_8_ATM     , 0x07,       0xE3      },};
+    const AVCRC *ctx;
 
     for(i=0; i<sizeof(buf); i++)
         buf[i]= i+i*i;
 
     for(i=0; i<4; i++){
-        av_crc_init(ctx, p[i][0], p[i][1], p[i][2], sizeof(ctx));
-        printf("crc %08X =%X\n", p[i][2], av_crc(ctx, 0, buf, sizeof(buf)));
+        ctx = av_crc_get_table(p[i][0]);
+        printf("crc %08X =%X\n", p[i][1], av_crc(ctx, 0, buf, sizeof(buf)));
     }
+    return 0;
 }
 #endif
Only in ffmpeg-free-0.svn20080206/libavutil: crc_data.h
diff -u mplayer-1.0~rc2-12/libavutil/crc.h ffmpeg-free-0.svn20080206/libavutil/crc.h
--- mplayer-1.0~rc2-12/libavutil/crc.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/crc.h	2008-01-05 00:09:58.000000000 +0100
@@ -18,35 +18,26 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef CRC_H
-#define CRC_H
+#ifndef FFMPEG_CRC_H
+#define FFMPEG_CRC_H
 
 #include <stdint.h>
 #include <sys/types.h>
 
 typedef uint32_t AVCRC;
 
-#define AV_CRC_8_ATM      0x07
-#define AV_CRC_16         0x8005
-#define AV_CRC_16_CCITT   0x1021
-#define AV_CRC_32_IEEE    0x04C11DB7L
-//! reversed bitorder version of AV_CRC_32_IEEE
-#define AV_CRC_32_IEEE_LE 0xEDB88320L
-
-#if LIBAVUTIL_VERSION_INT  < (50<<16)
-extern AVCRC *av_crcEDB88320;
-extern AVCRC *av_crc04C11DB7;
-extern AVCRC *av_crc8005    ;
-extern AVCRC *av_crc07      ;
-#else
-extern AVCRC av_crcEDB88320[];
-extern AVCRC av_crc04C11DB7[];
-extern AVCRC av_crc8005    [];
-extern AVCRC av_crc07      [];
-#endif
+typedef enum {
+    AV_CRC_8_ATM,
+    AV_CRC_16_ANSI,
+    AV_CRC_16_CCITT,
+    AV_CRC_32_IEEE,
+    AV_CRC_32_IEEE_LE,  /*< reversed bitorder version of AV_CRC_32_IEEE */
+    AV_CRC_MAX,         /*< not part of public API! don't use outside lavu */
+}AVCRCId;
 
 int av_crc_init(AVCRC *ctx, int le, int bits, uint32_t poly, int ctx_size);
+const AVCRC *av_crc_get_table(AVCRCId crc_id);
 uint32_t av_crc(const AVCRC *ctx, uint32_t start_crc, const uint8_t *buffer, size_t length);
 
-#endif /* CRC_H */
+#endif /* FFMPEG_CRC_H */
 
Only in ffmpeg-free-0.svn20080206/libavutil: des.c
Only in ffmpeg-free-0.svn20080206/libavutil: des.h
diff -u mplayer-1.0~rc2-12/libavutil/fifo.h ffmpeg-free-0.svn20080206/libavutil/fifo.h
--- mplayer-1.0~rc2-12/libavutil/fifo.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/fifo.h	2007-10-17 11:37:46.000000000 +0200
@@ -21,8 +21,8 @@
  * A very simple circular buffer FIFO implementation.
  */
 
-#ifndef FIFO_H
-#define FIFO_H
+#ifndef FFMPEG_FIFO_H
+#define FFMPEG_FIFO_H
 
 #include <stdint.h>
 
@@ -99,4 +99,4 @@
         ptr -= f->end - f->buffer;
     return *ptr;
 }
-#endif /* FIFO_H */
+#endif /* FFMPEG_FIFO_H */
diff -u mplayer-1.0~rc2-12/libavutil/integer.c ffmpeg-free-0.svn20080206/libavutil/integer.c
--- mplayer-1.0~rc2-12/libavutil/integer.c	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/integer.c	2008-01-10 11:35:37.000000000 +0100
@@ -156,7 +156,7 @@
     return out;
 }
 
-#if 0
+#ifdef TEST
 #undef NDEBUG
 #include <assert.h>
 
@@ -171,7 +171,7 @@
         7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
 };
 
-main(){
+int main(void){
     int64_t a,b;
 
     for(a=7; a<256*256*256; a+=13215){
@@ -192,5 +192,6 @@
             assert(av_i2int(av_div_i(ai,bi)) == a/b);
         }
     }
+    return 0;
 }
 #endif
diff -u mplayer-1.0~rc2-12/libavutil/integer.h ffmpeg-free-0.svn20080206/libavutil/integer.h
--- mplayer-1.0~rc2-12/libavutil/integer.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/integer.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * @author Michael Niedermayer <michaelni@gmx.at>
  */
 
-#ifndef INTEGER_H
-#define INTEGER_H
+#ifndef FFMPEG_INTEGER_H
+#define FFMPEG_INTEGER_H
 
 #include <stdint.h>
 
@@ -80,4 +80,4 @@
  */
 int64_t av_i2int(AVInteger a);
 
-#endif // INTEGER_H
+#endif /* FFMPEG_INTEGER_H */
diff -u mplayer-1.0~rc2-12/libavutil/internal.h ffmpeg-free-0.svn20080206/libavutil/internal.h
--- mplayer-1.0~rc2-12/libavutil/internal.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/internal.h	2008-01-21 14:33:18.000000000 +0100
@@ -23,8 +23,8 @@
  * common internal api header.
  */
 
-#ifndef INTERNAL_H
-#define INTERNAL_H
+#ifndef FFMPEG_INTERNAL_H
+#define FFMPEG_INTERNAL_H
 
 #if !defined(DEBUG) && !defined(NDEBUG)
 #    define NDEBUG
@@ -118,7 +118,7 @@
 #endif
 
 // Use rip-relative addressing if compiling PIC code on x86-64.
-#if defined(__MINGW32__) || defined(__CYGWIN__) || \
+#if defined(__MINGW32__) || defined(__CYGWIN__) || defined(__DJGPP__) || \
     defined(__OS2__) || (defined (__OpenBSD__) && !defined(__ELF__))
 #    if defined(ARCH_X86_64) && defined(PIC)
 #        define MANGLE(a) "_" #a"(%%rip)"
@@ -178,24 +178,28 @@
 #    define FASTDIV(a,b)   ((a)/(b))
 #endif
 
-extern const uint8_t ff_sqrt_tab[128];
+extern const uint8_t ff_sqrt_tab[256];
 
-static inline int ff_sqrt(int a)
-{
-    int ret=0;
-    int s, b;
+static inline int av_log2_16bit(unsigned int v);
 
-    if(a<128) return ff_sqrt_tab[a];
+static inline unsigned int ff_sqrt(unsigned int a)
+{
+    unsigned int b;
 
-    for(s=30; s>=0; s-=2){
-        ret+=ret;
-        b= (1+2*ret)<<s;
-        if(b<=a){
-            a-=b;
-            ret++;
-        }
+    if(a<255) return (ff_sqrt_tab[a+1]-1)>>4;
+    else if(a<(1<<12)) b= ff_sqrt_tab[a>>4 ]>>2;
+#ifndef CONFIG_SMALL
+    else if(a<(1<<14)) b= ff_sqrt_tab[a>>6 ]>>1;
+    else if(a<(1<<16)) b= ff_sqrt_tab[a>>8 ]   ;
+#endif
+    else{
+        int s= av_log2_16bit(a>>16)>>1;
+        unsigned int c= a>>(s+2);
+        b= ff_sqrt_tab[c>>(s+8)];
+        b= FASTDIV(c,b) + (b<<s);
     }
-    return ret;
+
+    return b - (a<b*b);
 }
 
 #if defined(ARCH_X86)
@@ -252,30 +256,59 @@
 #define strcat strcat_is_forbidden_due_to_security_issues_use_av_strlcat
 #undef  exit
 #define exit exit_is_forbidden
-#if !(defined(LIBAVFORMAT_BUILD) || defined(FRAMEHOOK_H))
+#if !(defined(LIBAVFORMAT_BUILD) || defined(FFMPEG_FRAMEHOOK_H))
 #undef  printf
 #define printf please_use_av_log
 #undef  fprintf
 #define fprintf please_use_av_log
+#undef  puts
+#define puts please_use_av_log
+#undef  perror
+#define perror please_use_av_log_instead_of_perror
 #endif
 
 #define CHECKED_ALLOCZ(p, size)\
 {\
     p= av_mallocz(size);\
     if(p==NULL && (size)!=0){\
-        perror("malloc");\
+        av_log(NULL, AV_LOG_ERROR, "Cannot allocate memory.");\
         goto fail;\
     }\
 }
 
+#ifndef HAVE_LLRINT
+static av_always_inline long long llrint(double x)
+{
+    return rint(x);
+}
+#endif /* HAVE_LLRINT */
+
+#ifndef HAVE_LRINT
+static av_always_inline long int lrint(double x)
+{
+    return rint(x);
+}
+#endif /* HAVE_LRINT */
+
 #ifndef HAVE_LRINTF
-/* XXX: add ISOC specific test to avoid specific BSD testing. */
-/* better than nothing implementation. */
-/* btw, rintf() is existing on fbsd too -- alex */
 static av_always_inline long int lrintf(float x)
 {
     return (int)(rint(x));
 }
 #endif /* HAVE_LRINTF */
 
-#endif /* INTERNAL_H */
+#ifndef HAVE_ROUND
+static av_always_inline double round(double x)
+{
+    return (x > 0) ? floor(x + 0.5) : ceil(x - 0.5);
+}
+#endif /* HAVE_ROUND */
+
+#ifndef HAVE_ROUNDF
+static av_always_inline float roundf(float x)
+{
+    return (x > 0) ? floor(x + 0.5) : ceil(x - 0.5);
+}
+#endif /* HAVE_ROUNDF */
+
+#endif /* FFMPEG_INTERNAL_H */
diff -u mplayer-1.0~rc2-12/libavutil/intfloat_readwrite.h ffmpeg-free-0.svn20080206/libavutil/intfloat_readwrite.h
--- mplayer-1.0~rc2-12/libavutil/intfloat_readwrite.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/intfloat_readwrite.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef INTFLOAT_READWRITE_H
-#define INTFLOAT_READWRITE_H
+#ifndef FFMPEG_INTFLOAT_READWRITE_H
+#define FFMPEG_INTFLOAT_READWRITE_H
 
 #include "common.h"
 
@@ -36,4 +36,4 @@
 int32_t av_flt2int(float d);
 AVExtFloat av_dbl2ext(double d);
 
-#endif /* INTFLOAT_READWRITE_H */
+#endif /* FFMPEG_INTFLOAT_READWRITE_H */
diff -u mplayer-1.0~rc2-12/libavutil/intreadwrite.h ffmpeg-free-0.svn20080206/libavutil/intreadwrite.h
--- mplayer-1.0~rc2-12/libavutil/intreadwrite.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/intreadwrite.h	2008-02-01 04:14:50.000000000 +0100
@@ -16,8 +16,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef INTREADWRITE_H
-#define INTREADWRITE_H
+#ifndef FFMPEG_INTREADWRITE_H
+#define FFMPEG_INTREADWRITE_H
 
 #include <stdint.h>
 #include "bswap.h"
@@ -38,9 +38,9 @@
 
 #else /* __GNUC__ */
 
-#define AV_RN16(a) (*((uint16_t*)(a)))
-#define AV_RN32(a) (*((uint32_t*)(a)))
-#define AV_RN64(a) (*((uint64_t*)(a)))
+#define AV_RN16(a) (*((const uint16_t*)(a)))
+#define AV_RN32(a) (*((const uint32_t*)(a)))
+#define AV_RN64(a) (*((const uint64_t*)(a)))
 
 #define AV_WN16(a, b) *((uint16_t*)(a)) = (b)
 #define AV_WN32(a, b) *((uint32_t*)(a)) = (b)
@@ -49,7 +49,7 @@
 #endif /* !__GNUC__ */
 
 /* endian macros */
-#define AV_RB8(x)     (((uint8_t*)(x))[0])
+#define AV_RB8(x)     (((const uint8_t*)(x))[0])
 #define AV_WB8(p, d)  do { ((uint8_t*)(p))[0] = (d); } while(0)
 
 #define AV_RL8(x)     AV_RB8(x)
@@ -70,29 +70,29 @@
 #  define AV_WL16(p, d) AV_WN16(p, d)
 # endif
 #else /* HAVE_FAST_UNALIGNED */
-#define AV_RB16(x)  ((((uint8_t*)(x))[0] << 8) | ((uint8_t*)(x))[1])
+#define AV_RB16(x)  ((((const uint8_t*)(x))[0] << 8) | ((const uint8_t*)(x))[1])
 #define AV_WB16(p, d) do { \
                     ((uint8_t*)(p))[1] = (d); \
                     ((uint8_t*)(p))[0] = (d)>>8; } while(0)
 
-#define AV_RL16(x)  ((((uint8_t*)(x))[1] << 8) | \
-                      ((uint8_t*)(x))[0])
+#define AV_RL16(x)  ((((const uint8_t*)(x))[1] << 8) | \
+                      ((const uint8_t*)(x))[0])
 #define AV_WL16(p, d) do { \
                     ((uint8_t*)(p))[0] = (d); \
                     ((uint8_t*)(p))[1] = (d)>>8; } while(0)
 #endif
 
-#define AV_RB24(x)  ((((uint8_t*)(x))[0] << 16) | \
-                     (((uint8_t*)(x))[1] <<  8) | \
-                      ((uint8_t*)(x))[2])
+#define AV_RB24(x)  ((((const uint8_t*)(x))[0] << 16) | \
+                     (((const uint8_t*)(x))[1] <<  8) | \
+                      ((const uint8_t*)(x))[2])
 #define AV_WB24(p, d) do { \
                     ((uint8_t*)(p))[2] = (d); \
                     ((uint8_t*)(p))[1] = (d)>>8; \
                     ((uint8_t*)(p))[0] = (d)>>16; } while(0)
 
-#define AV_RL24(x)  ((((uint8_t*)(x))[2] << 16) | \
-                     (((uint8_t*)(x))[1] <<  8) | \
-                      ((uint8_t*)(x))[0])
+#define AV_RL24(x)  ((((const uint8_t*)(x))[2] << 16) | \
+                     (((const uint8_t*)(x))[1] <<  8) | \
+                      ((const uint8_t*)(x))[0])
 #define AV_WL24(p, d) do { \
                     ((uint8_t*)(p))[0] = (d); \
                     ((uint8_t*)(p))[1] = (d)>>8; \
@@ -113,20 +113,20 @@
 #  define AV_WL32(p, d) AV_WN32(p, d)
 # endif
 #else /* HAVE_FAST_UNALIGNED */
-#define AV_RB32(x)  ((((uint8_t*)(x))[0] << 24) | \
-                     (((uint8_t*)(x))[1] << 16) | \
-                     (((uint8_t*)(x))[2] <<  8) | \
-                      ((uint8_t*)(x))[3])
+#define AV_RB32(x)  ((((const uint8_t*)(x))[0] << 24) | \
+                     (((const uint8_t*)(x))[1] << 16) | \
+                     (((const uint8_t*)(x))[2] <<  8) | \
+                      ((const uint8_t*)(x))[3])
 #define AV_WB32(p, d) do { \
                     ((uint8_t*)(p))[3] = (d); \
                     ((uint8_t*)(p))[2] = (d)>>8; \
                     ((uint8_t*)(p))[1] = (d)>>16; \
                     ((uint8_t*)(p))[0] = (d)>>24; } while(0)
 
-#define AV_RL32(x) ((((uint8_t*)(x))[3] << 24) | \
-                    (((uint8_t*)(x))[2] << 16) | \
-                    (((uint8_t*)(x))[1] <<  8) | \
-                     ((uint8_t*)(x))[0])
+#define AV_RL32(x) ((((const uint8_t*)(x))[3] << 24) | \
+                    (((const uint8_t*)(x))[2] << 16) | \
+                    (((const uint8_t*)(x))[1] <<  8) | \
+                     ((const uint8_t*)(x))[0])
 #define AV_WL32(p, d) do { \
                     ((uint8_t*)(p))[0] = (d); \
                     ((uint8_t*)(p))[1] = (d)>>8; \
@@ -149,14 +149,14 @@
 #  define AV_WL64(p, d) AV_WN64(p, d)
 # endif
 #else /* HAVE_FAST_UNALIGNED */
-#define AV_RB64(x)  (((uint64_t)((uint8_t*)(x))[0] << 56) | \
-                     ((uint64_t)((uint8_t*)(x))[1] << 48) | \
-                     ((uint64_t)((uint8_t*)(x))[2] << 40) | \
-                     ((uint64_t)((uint8_t*)(x))[3] << 32) | \
-                     ((uint64_t)((uint8_t*)(x))[4] << 24) | \
-                     ((uint64_t)((uint8_t*)(x))[5] << 16) | \
-                     ((uint64_t)((uint8_t*)(x))[6] <<  8) | \
-                      (uint64_t)((uint8_t*)(x))[7])
+#define AV_RB64(x)  (((uint64_t)((const uint8_t*)(x))[0] << 56) | \
+                     ((uint64_t)((const uint8_t*)(x))[1] << 48) | \
+                     ((uint64_t)((const uint8_t*)(x))[2] << 40) | \
+                     ((uint64_t)((const uint8_t*)(x))[3] << 32) | \
+                     ((uint64_t)((const uint8_t*)(x))[4] << 24) | \
+                     ((uint64_t)((const uint8_t*)(x))[5] << 16) | \
+                     ((uint64_t)((const uint8_t*)(x))[6] <<  8) | \
+                      (uint64_t)((const uint8_t*)(x))[7])
 #define AV_WB64(p, d) do { \
                     ((uint8_t*)(p))[7] = (d);     \
                     ((uint8_t*)(p))[6] = (d)>>8;  \
@@ -167,14 +167,14 @@
                     ((uint8_t*)(p))[1] = (d)>>48; \
                     ((uint8_t*)(p))[0] = (d)>>56; } while(0)
 
-#define AV_RL64(x)  (((uint64_t)((uint8_t*)(x))[7] << 56) | \
-                     ((uint64_t)((uint8_t*)(x))[6] << 48) | \
-                     ((uint64_t)((uint8_t*)(x))[5] << 40) | \
-                     ((uint64_t)((uint8_t*)(x))[4] << 32) | \
-                     ((uint64_t)((uint8_t*)(x))[3] << 24) | \
-                     ((uint64_t)((uint8_t*)(x))[2] << 16) | \
-                     ((uint64_t)((uint8_t*)(x))[1] <<  8) | \
-                      (uint64_t)((uint8_t*)(x))[0])
+#define AV_RL64(x)  (((uint64_t)((const uint8_t*)(x))[7] << 56) | \
+                     ((uint64_t)((const uint8_t*)(x))[6] << 48) | \
+                     ((uint64_t)((const uint8_t*)(x))[5] << 40) | \
+                     ((uint64_t)((const uint8_t*)(x))[4] << 32) | \
+                     ((uint64_t)((const uint8_t*)(x))[3] << 24) | \
+                     ((uint64_t)((const uint8_t*)(x))[2] << 16) | \
+                     ((uint64_t)((const uint8_t*)(x))[1] <<  8) | \
+                      (uint64_t)((const uint8_t*)(x))[0])
 #define AV_WL64(p, d) do { \
                     ((uint8_t*)(p))[0] = (d);     \
                     ((uint8_t*)(p))[1] = (d)>>8;  \
@@ -186,4 +186,4 @@
                     ((uint8_t*)(p))[7] = (d)>>56; } while(0)
 #endif
 
-#endif /* INTREADWRITE_H */
+#endif /* FFMPEG_INTREADWRITE_H */
diff -u mplayer-1.0~rc2-12/libavutil/lls.c ffmpeg-free-0.svn20080206/libavutil/lls.c
--- mplayer-1.0~rc2-12/libavutil/lls.c	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/lls.c	2008-01-31 21:52:14.000000000 +0100
@@ -53,8 +53,8 @@
 
 void av_solve_lls(LLSModel *m, double threshold, int min_order){
     int i,j,k;
-    double (*factor)[MAX_VARS+1]= &m->covariance[1][0];
-    double (*covar )[MAX_VARS+1]= &m->covariance[1][1];
+    double (*factor)[MAX_VARS+1]= (void*)&m->covariance[1][0];
+    double (*covar )[MAX_VARS+1]= (void*)&m->covariance[1][1];
     double  *covar_y            =  m->covariance[0];
     int count= m->indep_count;
 
@@ -113,7 +113,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 
-int main(){
+int main(void){
     LLSModel m;
     int i, order;
 
@@ -121,7 +121,7 @@
 
     for(i=0; i<100; i++){
         double var[4];
-        double eval, variance;
+        double eval;
 #if 0
         var[1] = rand() / (double)RAND_MAX;
         var[2] = rand() / (double)RAND_MAX;
diff -u mplayer-1.0~rc2-12/libavutil/lls.h ffmpeg-free-0.svn20080206/libavutil/lls.h
--- mplayer-1.0~rc2-12/libavutil/lls.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/lls.h	2007-10-17 11:37:46.000000000 +0200
@@ -20,8 +20,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef LLS_H
-#define LLS_H
+#ifndef FFMPEG_LLS_H
+#define FFMPEG_LLS_H
 
 #define MAX_VARS 32
 
@@ -42,4 +42,4 @@
 void av_solve_lls(LLSModel *m, double threshold, int min_order);
 double av_evaluate_lls(LLSModel *m, double *param, int order);
 
-#endif
+#endif /* FFMPEG_LLS_H */
diff -u mplayer-1.0~rc2-12/libavutil/log.c ffmpeg-free-0.svn20080206/libavutil/log.c
--- mplayer-1.0~rc2-12/libavutil/log.c	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/log.c	2007-12-12 22:48:50.000000000 +0100
@@ -45,11 +45,7 @@
     vfprintf(stderr, fmt, vl);
 }
 
-#if LIBAVUTIL_VERSION_INT < (50<<16)
 static void (*av_log_callback)(void*, int, const char*, va_list) = av_log_default_callback;
-#else
-void (*av_vlog)(void*, int, const char*, va_list) = av_log_default_callback;
-#endif
 
 void av_log(void* avcl, int level, const char *fmt, ...)
 {
@@ -59,7 +55,6 @@
     va_end(vl);
 }
 
-#if LIBAVUTIL_VERSION_INT < (50<<16)
 void av_vlog(void* avcl, int level, const char *fmt, va_list vl)
 {
     av_log_callback(avcl, level, fmt, vl);
@@ -79,4 +74,3 @@
 {
     av_log_callback = callback;
 }
-#endif
diff -u mplayer-1.0~rc2-12/libavutil/log.h ffmpeg-free-0.svn20080206/libavutil/log.h
--- mplayer-1.0~rc2-12/libavutil/log.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/log.h	2007-12-12 22:48:50.000000000 +0100
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef LOG_H
-#define LOG_H
+#ifndef FFMPEG_LOG_H
+#define FFMPEG_LOG_H
 
 #include <stdarg.h>
 
@@ -81,7 +81,10 @@
  */
 #define AV_LOG_DEBUG    48
 #endif
+
+#if LIBAVUTIL_VERSION_INT < (50<<16)
 extern int av_log_level;
+#endif
 
 /**
  * Send the specified message to the log if the level is less than or equal to
@@ -103,14 +106,10 @@
 extern void av_log(void*, int level, const char *fmt, ...);
 #endif
 
-#if LIBAVUTIL_VERSION_INT < (50<<16)
 extern void av_vlog(void*, int level, const char *fmt, va_list);
 extern int av_log_get_level(void);
 extern void av_log_set_level(int);
 extern void av_log_set_callback(void (*)(void*, int, const char*, va_list));
 extern void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl);
-#else
-extern void (*av_vlog)(void*, int, const char*, va_list);
-#endif
 
-#endif /* LOG_H */
+#endif /* FFMPEG_LOG_H */
diff -u mplayer-1.0~rc2-12/libavutil/lzo.c ffmpeg-free-0.svn20080206/libavutil/lzo.c
--- mplayer-1.0~rc2-12/libavutil/lzo.c	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/lzo.c	2008-02-01 17:30:51.000000000 +0100
@@ -29,7 +29,7 @@
 //! define if we may read up to 8 bytes beyond the input buffer
 #define INBUF_PADDED 1
 typedef struct LZOContext {
-    uint8_t *in, *in_end;
+    const uint8_t *in, *in_end;
     uint8_t *out_start, *out, *out_end;
     int error;
 } LZOContext;
@@ -84,7 +84,7 @@
  * \param cnt number of bytes to copy, must be >= 0
  */
 static inline void copy(LZOContext *c, int cnt) {
-    register uint8_t *src = c->in;
+    register const uint8_t *src = c->in;
     register uint8_t *dst = c->out;
     if (cnt > c->in_end - src) {
         cnt = FFMAX(c->in_end - src, 0);
@@ -115,7 +115,7 @@
  * thus creating a repeating pattern with a period length of back.
  */
 static inline void copy_backptr(LZOContext *c, int back, int cnt) {
-    register uint8_t *src = &c->out[-back];
+    register const uint8_t *src = &c->out[-back];
     register uint8_t *dst = c->out;
     if (src < c->out_start || src > dst) {
         c->error |= LZO_INVALID_BACKPTR;
@@ -171,12 +171,12 @@
  * make sure all buffers are appropriately padded, in must provide
  * LZO_INPUT_PADDING, out must provide LZO_OUTPUT_PADDING additional bytes
  */
-int lzo1x_decode(void *out, int *outlen, void *in, int *inlen) {
+int lzo1x_decode(void *out, int *outlen, const void *in, int *inlen) {
     int state= 0;
     int x;
     LZOContext c;
     c.in = in;
-    c.in_end = (uint8_t *)in + *inlen;
+    c.in_end = (const uint8_t *)in + *inlen;
     c.out = c.out_start = out;
     c.out_end = (uint8_t *)out + * outlen;
     c.error = 0;
diff -u mplayer-1.0~rc2-12/libavutil/lzo.h ffmpeg-free-0.svn20080206/libavutil/lzo.h
--- mplayer-1.0~rc2-12/libavutil/lzo.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/lzo.h	2008-02-01 17:30:51.000000000 +0100
@@ -19,8 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef LZO_H
-#define LZO_H
+#ifndef FFMPEG_LZO_H
+#define FFMPEG_LZO_H
 
 #define LZO_INPUT_DEPLETED 1
 #define LZO_OUTPUT_FULL 2
@@ -30,6 +30,6 @@
 #define LZO_INPUT_PADDING 8
 #define LZO_OUTPUT_PADDING 12
 
-int lzo1x_decode(void *out, int *outlen, void *in, int *inlen);
+int lzo1x_decode(void *out, int *outlen, const void *in, int *inlen);
 
-#endif
+#endif /* FFMPEG_LZO_H */
diff -u mplayer-1.0~rc2-12/libavutil/Makefile ffmpeg-free-0.svn20080206/libavutil/Makefile
--- mplayer-1.0~rc2-12/libavutil/Makefile	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/Makefile	2008-01-28 00:28:56.000000000 +0100
@@ -4,8 +4,9 @@
        aes.o \
        base64.o \
        crc.o \
-       intfloat_readwrite.o \
+       des.o \
        fifo.o \
+       intfloat_readwrite.o \
        lls.o \
        log.o \
        lzo.o \
@@ -14,6 +15,8 @@
        mem.o \
        random.o \
        rational.o \
+       rc4.o \
+       sha1.o \
        string.o \
        tree.o \
 
@@ -22,8 +25,8 @@
           avutil.h \
           base64.h \
           common.h \
+          crc.h \
           fifo.h \
-          integer.h \
           intfloat_readwrite.h \
           log.h \
           lzo.h \
@@ -32,9 +35,18 @@
           mem.h \
           random.h \
           rational.h \
+          sha1.h
 
 NAME=avutil
 LIBVERSION=$(LAVUVERSION)
 LIBMAJOR=$(LAVUMAJOR)
 
+TESTS = $(addsuffix -test$(EXESUF), adler32 aes crc des lls md5 sha1 softfloat tree)
+
 include ../common.mak
+
+lzo-test$(EXESUF): lzo.c $(LIBNAME)
+	$(CC) $(CFLAGS) $(LDFLAGS) -DTEST -o $@ $^ $(EXTRALIBS) -llzo2
+
+clean::
+	rm -f lzo-test$(EXESUF)
diff -u mplayer-1.0~rc2-12/libavutil/mathematics.c ffmpeg-free-0.svn20080206/libavutil/mathematics.c
--- mplayer-1.0~rc2-12/libavutil/mathematics.c	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/mathematics.c	2008-01-21 14:33:18.000000000 +0100
@@ -26,11 +26,15 @@
 #include "common.h"
 #include "mathematics.h"
 
-const uint8_t ff_sqrt_tab[128]={
-        0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,
-        5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
-        9, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11
+const uint8_t ff_sqrt_tab[256]={
+  0, 16, 23, 28, 32, 36, 40, 43, 46, 48, 51, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 77, 79, 80, 82, 84, 85, 87, 88, 90,
+ 91, 92, 94, 95, 96, 98, 99,100,102,103,104,105,107,108,109,110,111,112,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
+128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,144,145,146,147,148,149,150,151,151,152,153,154,155,156,156,
+157,158,159,160,160,161,162,163,164,164,165,166,167,168,168,169,170,171,171,172,173,174,174,175,176,176,177,178,179,179,180,181,
+182,182,183,184,184,185,186,186,187,188,188,189,190,190,191,192,192,193,194,194,195,196,196,197,198,198,199,200,200,201,202,202,
+203,204,204,205,205,206,207,207,208,208,209,210,210,211,212,212,213,213,214,215,215,216,216,217,218,218,219,219,220,220,221,222,
+222,223,223,224,224,225,226,226,227,227,228,228,229,230,230,231,231,232,232,233,233,234,235,235,236,236,237,237,238,238,239,239,
+240,240,241,242,242,243,243,244,244,245,245,246,246,247,247,248,248,249,249,250,250,251,251,252,252,253,253,254,254,255,255,255
 };
 
 const uint8_t ff_log2_tab[256]={
@@ -110,10 +114,11 @@
     int64_t c= cq.num * (int64_t)bq.den;
     return av_rescale_rnd(a, b, c, AV_ROUND_NEAR_INF);
 }
-#if 0
+
+#ifdef TEST
 #include "integer.h"
 #undef printf
-main(){
+int main(void){
     int64_t a,b,c,d,e;
 
     for(a=7; a<(1LL<<62); a+=a/3+1){
@@ -135,5 +140,6 @@
             }
         }
     }
+    return 0;
 }
 #endif
diff -u mplayer-1.0~rc2-12/libavutil/mathematics.h ffmpeg-free-0.svn20080206/libavutil/mathematics.h
--- mplayer-1.0~rc2-12/libavutil/mathematics.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/mathematics.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef MATHEMATICS_H
-#define MATHEMATICS_H
+#ifndef FFMPEG_MATHEMATICS_H
+#define FFMPEG_MATHEMATICS_H
 
 #include "rational.h"
 
@@ -48,4 +48,4 @@
  */
 int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq);
 
-#endif /* MATHEMATICS_H */
+#endif /* FFMPEG_MATHEMATICS_H */
diff -u mplayer-1.0~rc2-12/libavutil/md5.c ffmpeg-free-0.svn20080206/libavutil/md5.c
--- mplayer-1.0~rc2-12/libavutil/md5.c	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/md5.c	2008-01-30 05:50:09.000000000 +0100
@@ -147,7 +147,7 @@
     while((ctx->len & 63)<56)
         av_md5_update(ctx, "", 1);
 
-    av_md5_update(ctx, &finalcount, 8);
+    av_md5_update(ctx, (uint8_t*)&finalcount, 8);
 
     for(i=0; i<4; i++)
         ((uint32_t*)dst)[i]= le2me_32(ctx->ABCD[3-i]);
@@ -164,7 +164,7 @@
 #ifdef TEST
 #include <stdio.h>
 #undef printf
-main(){
+int main(void){
     uint64_t md5val;
     int i;
     uint8_t in[1000];
@@ -176,5 +176,7 @@
     av_md5_sum( (uint8_t*)&md5val, in,  65); printf("%"PRId64"\n", md5val);
     for(i=0; i<1000; i++) in[i]= i % 127;
     av_md5_sum( (uint8_t*)&md5val, in,  999); printf("%"PRId64"\n", md5val);
+
+    return 0;
 }
 #endif
diff -u mplayer-1.0~rc2-12/libavutil/md5.h ffmpeg-free-0.svn20080206/libavutil/md5.h
--- mplayer-1.0~rc2-12/libavutil/md5.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/md5.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef MD5_H
-#define MD5_H
+#ifndef FFMPEG_MD5_H
+#define FFMPEG_MD5_H
 
 #include <stdint.h>
 
@@ -32,5 +32,5 @@
 void av_md5_final(struct AVMD5 *ctx, uint8_t *dst);
 void av_md5_sum(uint8_t *dst, const uint8_t *src, const int len);
 
-#endif /* MD5_H */
+#endif /* FFMPEG_MD5_H */
 
diff -u mplayer-1.0~rc2-12/libavutil/mem.h ffmpeg-free-0.svn20080206/libavutil/mem.h
--- mplayer-1.0~rc2-12/libavutil/mem.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/mem.h	2008-01-27 21:50:16.000000000 +0100
@@ -23,50 +23,77 @@
  * Memory handling functions.
  */
 
-#ifndef AV_MEM_H
-#define AV_MEM_H
+#ifndef FFMPEG_MEM_H
+#define FFMPEG_MEM_H
 
 #ifdef __GNUC__
   #define DECLARE_ALIGNED(n,t,v)       t v __attribute__ ((aligned (n)))
+  #define DECLARE_ASM_CONST(n,t,v)     static const t v attribute_used __attribute__ ((aligned (n)))
 #else
   #define DECLARE_ALIGNED(n,t,v)      __declspec(align(n)) t v
+  #define DECLARE_ASM_CONST(n,t,v)    __declspec(align(n)) static const t v
 #endif
 
 /**
- * Memory allocation of size byte with alignment suitable for all
- * memory accesses (including vectors if available on the
- * CPU). av_malloc(0) must return a non NULL pointer.
+ * Allocate a block of \p size bytes with alignment suitable for all
+ * memory accesses (including vectors if available on the CPU).
+ * @param size Size in bytes for the memory block to be allocated.
+ * @return Pointer to the allocated block, NULL if it cannot allocate
+ * it.
+ * @see av_mallocz()
  */
 void *av_malloc(unsigned int size);
 
 /**
- * av_realloc semantics (same as glibc): if ptr is NULL and size > 0,
- * identical to malloc(size). If size is zero, it is identical to
- * free(ptr) and NULL is returned.
+ * Allocate or reallocate a block of memory.
+ * If \p ptr is NULL and \p size > 0, allocate a new block. If \p
+ * size is zero, free the memory block pointed by \p ptr.
+ * @param size Size in bytes for the memory block to be allocated or
+ * reallocated.
+ * @param ptr Pointer to a memory block already allocated with
+ * av_malloc(z)() or av_realloc() or NULL.
+ * @return Pointer to a newly reallocated block or NULL if it cannot
+ * reallocate or the function is used to free the memory block.
+ * @see av_fast_realloc()
  */
 void *av_realloc(void *ptr, unsigned int size);
 
 /**
- * Free memory which has been allocated with av_malloc(z)() or av_realloc().
- * NOTE: ptr = NULL is explicetly allowed
- * Note2: it is recommended that you use av_freep() instead
+ * Free a memory block which has been allocated with av_malloc(z)() or
+ * av_realloc().
+ * @param ptr Pointer to the memory block which should be freed.
+ * @note ptr = NULL is explicitly allowed.
+ * @note It is recommended that you use av_freep() instead.
+ * @see av_freep()
  */
 void av_free(void *ptr);
 
+/**
+ * Allocate a block of \p size bytes with alignment suitable for all
+ * memory accesses (including vectors if available on the CPU) and
+ * set to zeroes all the bytes of the block.
+ * @param size Size in bytes for the memory block to be allocated.
+ * @return Pointer to the allocated block, NULL if it cannot allocate
+ * it.
+ * @see av_malloc()
+ */
 void *av_mallocz(unsigned int size);
 
 /**
- * Duplicates the string \p s.
+ * Duplicate the string \p s.
  * @param s String to be duplicated.
  * @return Pointer to a newly allocated string containing a
- * copy of \p s or NULL if it cannot allocate it.
+ * copy of \p s or NULL if it cannot be allocated.
  */
 char *av_strdup(const char *s);
 
 /**
- * Frees memory and sets the pointer to NULL.
- * @param ptr pointer to the pointer which should be freed
+ * Free a memory block which has been allocated with av_malloc(z)() or
+ * av_realloc() and set to NULL the pointer to it.
+ * @param ptr Pointer to the pointer to the memory block which should
+ * be freed.
+ * @see av_free()
  */
 void av_freep(void *ptr);
 
-#endif /* AV_MEM_H */
+#endif /* FFMPEG_MEM_H */
diff -u mplayer-1.0~rc2-12/libavutil/random.h ffmpeg-free-0.svn20080206/libavutil/random.h
--- mplayer-1.0~rc2-12/libavutil/random.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/random.h	2007-10-17 11:37:46.000000000 +0200
@@ -21,8 +21,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AV_RANDOM_H
-#define AV_RANDOM_H
+#ifndef FFMPEG_RANDOM_H
+#define FFMPEG_RANDOM_H
 
 #define AV_RANDOM_N 624
 
@@ -65,5 +65,5 @@
 
 // only available if DEBUG is defined in the .c file
 void av_benchmark_random(void);
-#endif // AV_RANDOM_H
 
+#endif /* FFMPEG_RANDOM_H */
diff -u mplayer-1.0~rc2-12/libavutil/rational.h ffmpeg-free-0.svn20080206/libavutil/rational.h
--- mplayer-1.0~rc2-12/libavutil/rational.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/rational.h	2007-10-17 11:37:46.000000000 +0200
@@ -25,8 +25,8 @@
  * @author Michael Niedermayer <michaelni@gmx.at>
  */
 
-#ifndef RATIONAL_H
-#define RATIONAL_H
+#ifndef FFMPEG_RATIONAL_H
+#define FFMPEG_RATIONAL_H
 
 #include <stdint.h>
 
@@ -112,4 +112,4 @@
  */
 AVRational av_d2q(double d, int max);
 
-#endif // RATIONAL_H
+#endif /* FFMPEG_RATIONAL_H */
Only in ffmpeg-free-0.svn20080206/libavutil: rc4.c
Only in ffmpeg-free-0.svn20080206/libavutil: rc4.h
diff -u mplayer-1.0~rc2-12/libavutil/sha1.c ffmpeg-free-0.svn20080206/libavutil/sha1.c
--- mplayer-1.0~rc2-12/libavutil/sha1.c	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/sha1.c	2008-02-03 22:56:13.000000000 +0100
@@ -29,10 +29,12 @@
     uint32_t state[5];
 } AVSHA1;
 
+const int av_sha1_size = sizeof(AVSHA1);
+
 #define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
 
 /* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
-#define blk0(i) (block[i] = be2me_32(((uint32_t*)buffer)[i]))
+#define blk0(i) (block[i] = be2me_32(((const uint32_t*)buffer)[i]))
 #define blk(i) (block[i] = rol(block[i-3]^block[i-8]^block[i-14]^block[i-16],1))
 
 #define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)    +blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
@@ -43,7 +45,7 @@
 
 /* Hash a single 512-bit block. This is the core of the algorithm. */
 
-static void transform(uint32_t state[5], uint8_t buffer[64]){
+static void transform(uint32_t state[5], const uint8_t buffer[64]){
     uint32_t block[80];
     unsigned int i, a, b, c, d, e;
 
@@ -103,7 +105,7 @@
     ctx->count    = 0;
 }
 
-void av_sha1_update(AVSHA1* ctx, uint8_t* data, unsigned int len){
+void av_sha1_update(AVSHA1* ctx, const uint8_t* data, unsigned int len){
     unsigned int i, j;
 
     j = ctx->count & 63;
@@ -138,7 +140,7 @@
     while ((ctx->count & 63) != 56) {
         av_sha1_update(ctx, "", 1);
     }
-    av_sha1_update(ctx, &finalcount, 8);  /* Should cause a transform() */
+    av_sha1_update(ctx, (uint8_t *)&finalcount, 8); /* Should cause a transform() */
     for(i=0; i<5; i++)
         ((uint32_t*)digest)[i]= be2me_32(ctx->state[i]);
 }
@@ -149,7 +151,7 @@
 #include <stdio.h>
 #undef printf
 
-int main(){
+int main(void){
     int i, k;
     AVSHA1 ctx;
     unsigned char digest[20];
diff -u mplayer-1.0~rc2-12/libavutil/sha1.h ffmpeg-free-0.svn20080206/libavutil/sha1.h
--- mplayer-1.0~rc2-12/libavutil/sha1.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/sha1.h	2008-02-03 22:56:13.000000000 +0100
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AV_SHA1_H
-#define AV_SHA1_H
+#ifndef FFMPEG_SHA1_H
+#define FFMPEG_SHA1_H
 
 #include <stdint.h>
 
@@ -28,6 +28,7 @@
 struct AVSHA1;
 
 void av_sha1_init(struct AVSHA1* context);
-void av_sha1_update(struct AVSHA1* context, uint8_t* data, unsigned int len);
+void av_sha1_update(struct AVSHA1* context, const uint8_t* data, unsigned int len);
 void av_sha1_final(struct AVSHA1* context, uint8_t digest[20]);
-#endif
+
+#endif /* FFMPEG_SHA1_H */
diff -u mplayer-1.0~rc2-12/libavutil/softfloat.c ffmpeg-free-0.svn20080206/libavutil/softfloat.c
--- mplayer-1.0~rc2-12/libavutil/softfloat.c	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/softfloat.c	2007-11-23 01:52:56.000000000 +0100
@@ -27,7 +27,7 @@
 
 #undef printf
 
-int main(){
+int main(void){
     SoftFloat one= av_int2sf(1, 0);
     SoftFloat sf1, sf2;
     double d1, d2;
diff -u mplayer-1.0~rc2-12/libavutil/softfloat.h ffmpeg-free-0.svn20080206/libavutil/softfloat.h
--- mplayer-1.0~rc2-12/libavutil/softfloat.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/softfloat.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVUTIL_SOFTFLOAT_H
-#define AVUTIL_SOFTFLOAT_H
+#ifndef FFMPEG_SOFTFLOAT_H
+#define FFMPEG_SOFTFLOAT_H
 
 #include <stdint.h>
 
@@ -125,4 +125,4 @@
     else           return v.mant >>(-v.exp);
 }
 
-#endif // AVUTIL_SOFTFLOAT_H
+#endif /* FFMPEG_SOFTFLOAT_H */
diff -u mplayer-1.0~rc2-12/libavutil/tree.c ffmpeg-free-0.svn20080206/libavutil/tree.c
--- mplayer-1.0~rc2-12/libavutil/tree.c	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/tree.c	2008-01-23 22:03:21.000000000 +0100
@@ -28,58 +28,97 @@
     int state;
 }AVTreeNode;
 
+const int av_tree_node_size = sizeof(AVTreeNode);
+
 void *av_tree_find(const AVTreeNode *t, void *key, int (*cmp)(void *key, const void *b), void *next[2]){
     if(t){
-        unsigned int v= cmp(t->elem, key);
+        unsigned int v= cmp(key, t->elem);
         if(v){
-            if(next) next[(v>>31)^1]= t->elem;
-            return av_tree_find(t->child[v>>31], key, cmp, next);
+            if(next) next[v>>31]= t->elem;
+            return av_tree_find(t->child[(v>>31)^1], key, cmp, next);
         }else{
+            if(next){
+                av_tree_find(t->child[0], key, cmp, next);
+                av_tree_find(t->child[1], key, cmp, next);
+            }
             return t->elem;
         }
     }
     return NULL;
 }
 
-void *av_tree_insert(AVTreeNode **tp, void *key, int (*cmp)(void *key, const void *b)){
+void *av_tree_insert(AVTreeNode **tp, void *key, int (*cmp)(void *key, const void *b), AVTreeNode **next){
     AVTreeNode *t= *tp;
     if(t){
         unsigned int v= cmp(t->elem, key);
-        if(v){
-            int i= v>>31;
+        void *ret;
+        if(!v){
+            if(*next)
+                return t->elem;
+            else if(t->child[0]||t->child[1]){
+                int i= !t->child[0];
+                void *next_elem[2];
+                av_tree_find(t->child[i], key, cmp, next_elem);
+                key= t->elem= next_elem[i];
+                v= -i;
+            }else{
+                *next= t;
+                *tp=NULL;
+                return NULL;
+            }
+        }
+        ret= av_tree_insert(&t->child[v>>31], key, cmp, next);
+        if(!ret){
+            int i= (v>>31) ^ !!*next;
             AVTreeNode **child= &t->child[i];
-            void *ret= av_tree_insert(child, key, cmp);
-            if(!ret){
-                t->state -= ((int)v>>31)|1;
-                if(!(t->state&1)){
-                    if(t->state){
-                        if((*child)->state*2 == t->state){
-                            *tp= *child;
-                            *child= (*child)->child[i^1];
-                            (*tp)->child[i^1]= t;
-                            t->state= 0;
-                        }else{
-                            *tp= (*child)->child[i^1];
-                            (*child)->child[i^1]= (*tp)->child[i];
-                            (*tp)->child[i]= *child;
-                            *child= (*tp)->child[i^1];
-                            (*tp)->child[i^1]= t;
-
-                            i= (*tp)->state > 0;
-                            (*tp)->child[i  ]->state= 0;
-                            (*tp)->child[i^1]->state= -(*tp)->state;
-                        }
+            t->state += 2*i - 1;
+
+            if(!(t->state&1)){
+                if(t->state){
+                    /* The following code is equivalent to
+                    if((*child)->state*2 == -t->state)
+                        rotate(child, i^1);
+                    rotate(tp, i);
+
+                    with rotate():
+                    static void rotate(AVTreeNode **tp, int i){
+                        AVTreeNode *t= *tp;
+
+                        *tp= t->child[i];
+                        t->child[i]= t->child[i]->child[i^1];
+                        (*tp)->child[i^1]= t;
+                        i= 4*t->state + 2*(*tp)->state + 12;
+                          t  ->state=                     ((0x614586 >> i) & 3)-1;
+                        (*tp)->state= ((*tp)->state>>1) + ((0x400EEA >> i) & 3)-1;
+                    }
+                    but such a rotate function is both bigger and slower
+                    */
+                    if((*child)->state*2 == -t->state){
+                        *tp= (*child)->child[i^1];
+                        (*child)->child[i^1]= (*tp)->child[i];
+                        (*tp)->child[i]= *child;
+                        *child= (*tp)->child[i^1];
+                        (*tp)->child[i^1]= t;
+
+                        (*tp)->child[0]->state= -((*tp)->state>0);
+                        (*tp)->child[1]->state=   (*tp)->state<0 ;
                         (*tp)->state=0;
+                    }else{
+                        *tp= *child;
+                        *child= (*child)->child[i^1];
+                        (*tp)->child[i^1]= t;
+                        if((*tp)->state) t->state  = 0;
+                        else             t->state>>= 1;
+                        (*tp)->state= -t->state;
                     }
-                    return key;
                 }
             }
-            return ret;
-        }else{
-            return t->elem;
+            if(!(*tp)->state ^ !!*next)
+                return key;
         }
+        return ret;
     }else{
-        *tp= av_mallocz(sizeof(AVTreeNode));
+        *tp= *next; *next= NULL;
         (*tp)->elem= key;
         return NULL;
     }
@@ -100,7 +139,7 @@
 #endif
 
 #ifdef TEST
-
+#undef random
 static int check(AVTreeNode *t){
     if(t){
         int left= check(t->child[0]);
@@ -132,19 +171,32 @@
     return a-b;
 }
 
-int main(){
-    int i,j,k;
-    AVTreeNode *root= NULL;
+int main(void){
+    int i,k;
+    AVTreeNode *root= NULL, *node=NULL;
 
     for(i=0; i<10000; i++){
-        int j= (random()%863294);
+        int j= (random()%86294);
         if(check(root) > 999){
             av_log(NULL, AV_LOG_ERROR, "FATAL error %d\n", i);
         print(root, 0);
             return -1;
         }
         av_log(NULL, AV_LOG_ERROR, "inserting %4d\n", j);
-        av_tree_insert(&root, (void*)(j+1), cmp);
+        if(!node)
+            node= av_mallocz(av_tree_node_size);
+        av_tree_insert(&root, (void*)(j+1), cmp, &node);
+
+        j= (random()%86294);
+        k= av_tree_find(root, (void*)(j+1), cmp, NULL);
+        if(k){
+            AVTreeNode *node2=NULL;
+            av_log(NULL, AV_LOG_ERROR, "removing %4d\n", j);
+            av_tree_insert(&root, (void*)(j+1), cmp, &node2);
+            k= av_tree_find(root, (void*)(j+1), cmp, NULL);
+            if(k)
+                av_log(NULL, AV_LOG_ERROR, "removial failure %d\n", i);
+        }
     }
     return 0;
 }
diff -u mplayer-1.0~rc2-12/libavutil/tree.h ffmpeg-free-0.svn20080206/libavutil/tree.h
--- mplayer-1.0~rc2-12/libavutil/tree.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/tree.h	2008-01-04 19:55:14.000000000 +0100
@@ -21,13 +21,16 @@
 /**
  * @file tree.h
  * A tree container.
+ * Insertion, Removial, Finding equal, largest which is smaller than and
+ * smallest which is larger than all have O(log n) worst case time.
  * @author Michael Niedermayer <michaelni@gmx.at>
  */
 
-#ifndef TREE_H
-#define TREE_H
+#ifndef FFMPEG_TREE_H
+#define FFMPEG_TREE_H
 
 struct AVTreeNode;
+extern const int av_tree_node_size;
 
 /**
  * Finds an element.
@@ -41,18 +44,39 @@
 void *av_tree_find(const struct AVTreeNode *root, void *key, int (*cmp)(void *key, const void *b), void *next[2]);
 
 /**
- * Finds a element for which cmp(key, elem)==0, if no such element is found key
- * is inserted into the tree.
+ * Inserts or removes an element.
+ * If *next is NULL then the element supplied will be removed, if no such
+ * element exists behavior is undefined.
+ * If *next is not NULL then the element supplied will be inserted, unless
+ * it already exists in the tree.
  * @param rootp A pointer to a pointer to the root node of the tree. Note that
  *              the root node can change during insertions, this is required
  *              to keep the tree balanced.
+ * @param next Used to allocate and free AVTreeNodes. For insertion the user
+ *             must set it to an allocated and zeroed object of at least
+ *             av_tree_node_size bytes size. av_tree_insert() will set it to
+ *             NULL if it has been consumed.
+ *             For deleting elements *next is set to NULL by the user and
+ *             av_tree_node_size() will set it to the AVTreeNode which was
+ *             used for the removed element.
+ *             This allows the use of flat arrays, which have
+ *             lower overhead compared to many malloced elements.
+ *             You might want to define a function like:
+ *             void *tree_insert(struct AVTreeNode **rootp, void *key, int (*cmp)(void *key, const void *b), AVTreeNode **next){
+ *                 if(!*next) *next= av_mallocz(av_tree_node_size);
+ *                 return av_tree_insert(rootp, key, cmp, next);
+ *             }
+ *             void *tree_remove(struct AVTreeNode **rootp, void *key, int (*cmp)(void *key, const void *b, AVTreeNode **next)){
+ *                 if(*next) av_freep(next);
+ *                 return av_tree_insert(rootp, key, cmp, next);
+ *             }
  *
  * @return If no insertion happened, the found element.
- *         If an insertion happened, then either key or NULL will be returned.
+ *         If an insertion or removial happened, then either key or NULL will be returned.
  *         Which one it is depends on the tree state and the implementation. You
  *         should make no assumptions that it's one or the other in the code.
  */
-void *av_tree_insert(struct AVTreeNode **rootp, void *key, int (*cmp)(void *key, const void *b));
+void *av_tree_insert(struct AVTreeNode **rootp, void *key, int (*cmp)(void *key, const void *b), struct AVTreeNode **next);
 void av_tree_destroy(struct AVTreeNode *t);
 
-#endif /* TREE_H */
+#endif /* FFMPEG_TREE_H */
diff -u mplayer-1.0~rc2-12/libavutil/x86_cpu.h ffmpeg-free-0.svn20080206/libavutil/x86_cpu.h
--- mplayer-1.0~rc2-12/libavutil/x86_cpu.h	2007-10-07 21:49:34.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libavutil/x86_cpu.h	2007-10-17 11:37:46.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef AVUTIL_X86CPU_H
-#define AVUTIL_X86CPU_H
+#ifndef FFMPEG_X86CPU_H
+#define FFMPEG_X86CPU_H
 
 #ifdef ARCH_X86_64
 #  define REG_a "rax"
@@ -65,4 +65,4 @@
 #  define BROKEN_RELOCATIONS 1
 #endif
 
-#endif /* AVUTIL_X86CPU_H */
+#endif /* FFMPEG_X86CPU_H */
diff -u mplayer-1.0~rc2-12/libpostproc/Makefile ffmpeg-free-0.svn20080206/libpostproc/Makefile
--- mplayer-1.0~rc2-12/libpostproc/Makefile	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libpostproc/Makefile	2008-01-14 15:42:29.000000000 +0100
@@ -10,17 +10,11 @@
 LIBVERSION=$(SPPVERSION)
 LIBMAJOR=$(SPPMAJOR)
 
-STATIC_OBJS=postprocess.o
-SHARED_OBJS=postprocess_pic.o
-
 HEADERS = postprocess.h
 
-include ../common.mak
-
-depend dep: postprocess.c
+OBJS = postprocess.o
 
-postprocess_pic.o: postprocess.c
-	$(CC) -c $(CFLAGS) -fomit-frame-pointer -fPIC -DPIC -o $@ $<
+include ../common.mak
 
 uninstall-headers::
 	-rmdir "$(prefix)/include/postproc"
diff -u mplayer-1.0~rc2-12/libpostproc/postprocess_altivec_template.c ffmpeg-free-0.svn20080206/libpostproc/postprocess_altivec_template.c
--- mplayer-1.0~rc2-12/libpostproc/postprocess_altivec_template.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libpostproc/postprocess_altivec_template.c	2007-12-01 23:21:04.000000000 +0100
@@ -194,7 +194,7 @@
     One could remove the recomputation of the perm
     vector by assuming (stride % 16) == 0, unfortunately
     this is not always true. Quite a lot of load/stores
-    can be removed by assuming proper alignement of
+    can be removed by assuming proper alignment of
     src & stride :-(
   */
   uint8_t *src2 = src;
@@ -382,7 +382,7 @@
     One could remove the recomputation of the perm
     vector by assuming (stride % 16) == 0, unfortunately
     this is not always true. Quite a lot of load/stores
-    can be removed by assuming proper alignement of
+    can be removed by assuming proper alignment of
     src & stride :-(
   */
   uint8_t *src2 = src;
@@ -469,7 +469,7 @@
   const vector signed short dornotd = vec_sel((vector signed short)zero,
                                               dclampedfinal,
                                               vec_cmplt(absmE, vqp));
-  /* add/substract to l4 and l5 */
+  /* add/subtract to l4 and l5 */
   const vector signed short vb4minusd = vec_sub(vb4, dornotd);
   const vector signed short vb5plusd = vec_add(vb5, dornotd);
   /* finally, stores */
@@ -506,7 +506,7 @@
     One could remove the recomputation of the perm
     vector by assuming (stride % 16) == 0, unfortunately
     this is not always true. Quite a lot of load/stores
-    can be removed by assuming proper alignement of
+    can be removed by assuming proper alignment of
     src & stride :-(
   */
   uint8_t *srcCopy = src;
diff -u mplayer-1.0~rc2-12/libpostproc/postprocess.c ffmpeg-free-0.svn20080206/libpostproc/postprocess.c
--- mplayer-1.0~rc2-12/libpostproc/postprocess.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libpostproc/postprocess.c	2008-02-02 22:24:54.000000000 +0100
@@ -101,20 +101,17 @@
 //#define NUM_BLOCKS_AT_ONCE 16 //not used yet
 
 #if defined(ARCH_X86)
-static DECLARE_ALIGNED(8, uint64_t attribute_used, w05)= 0x0005000500050005LL;
-static DECLARE_ALIGNED(8, uint64_t attribute_used, w04)= 0x0004000400040004LL;
-static DECLARE_ALIGNED(8, uint64_t attribute_used, w20)= 0x0020002000200020LL;
-static DECLARE_ALIGNED(8, uint64_t attribute_used, b00)= 0x0000000000000000LL;
-static DECLARE_ALIGNED(8, uint64_t attribute_used, b01)= 0x0101010101010101LL;
-static DECLARE_ALIGNED(8, uint64_t attribute_used, b02)= 0x0202020202020202LL;
-static DECLARE_ALIGNED(8, uint64_t attribute_used, b08)= 0x0808080808080808LL;
-static DECLARE_ALIGNED(8, uint64_t attribute_used, b80)= 0x8080808080808080LL;
+DECLARE_ASM_CONST(8, uint64_t, w05)= 0x0005000500050005LL;
+DECLARE_ASM_CONST(8, uint64_t, w04)= 0x0004000400040004LL;
+DECLARE_ASM_CONST(8, uint64_t, w20)= 0x0020002000200020LL;
+DECLARE_ASM_CONST(8, uint64_t, b00)= 0x0000000000000000LL;
+DECLARE_ASM_CONST(8, uint64_t, b01)= 0x0101010101010101LL;
+DECLARE_ASM_CONST(8, uint64_t, b02)= 0x0202020202020202LL;
+DECLARE_ASM_CONST(8, uint64_t, b08)= 0x0808080808080808LL;
+DECLARE_ASM_CONST(8, uint64_t, b80)= 0x8080808080808080LL;
 #endif
 
-static uint8_t clip_table[3*256];
-static uint8_t * const clip_tab= clip_table + 256;
-
-static const int attribute_used deringThreshold= 20;
+DECLARE_ASM_CONST(8, int, deringThreshold)= 20;
 
 
 static struct PPFilter filters[]=
@@ -142,11 +139,11 @@
 
 static const char *replaceTable[]=
 {
-        "default",      "hdeblock:a,vdeblock:a,dering:a",
-        "de",           "hdeblock:a,vdeblock:a,dering:a",
-        "fast",         "x1hdeblock:a,x1vdeblock:a,dering:a",
-        "fa",           "x1hdeblock:a,x1vdeblock:a,dering:a",
-        "ac",           "ha:a:128:7,va:a,dering:a",
+        "default",      "hb:a,vb:a,dr:a",
+        "de",           "hb:a,vb:a,dr:a",
+        "fast",         "h1:a,v1:a,dr:a",
+        "fa",           "h1:a,v1:a,dr:a",
+        "ac",           "ha:a:128:7,va:a,dr:a",
         NULL //End Marker
 };
 
@@ -646,8 +643,8 @@
 
 // minor note: the HAVE_xyz is messed up after that line so do not use it.
 
-static inline void postProcess(uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
-        QP_STORE_T QPs[], int QPStride, int isColor, pp_mode_t *vm, pp_context_t *vc)
+static inline void postProcess(const uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
+        const QP_STORE_T QPs[], int QPStride, int isColor, pp_mode_t *vm, pp_context_t *vc)
 {
         PPContext *c= (PPContext *)vc;
         PPMode *ppMode= (PPMode *)vm;
@@ -697,7 +694,11 @@
 
 /* -pp Command line Help
 */
-char *pp_help=
+#if LIBPOSTPROC_VERSION_INT < (52<<16)
+const char *const pp_help=
+#else
+const char pp_help[] =
+#endif
 "Available postprocessing filters:\n"
 "Filters                        Options\n"
 "short  long name       short   long option     Description\n"
@@ -741,12 +742,12 @@
 "\n"
 ;
 
-pp_mode_t *pp_get_mode_by_name_and_quality(char *name, int quality)
+pp_mode_t *pp_get_mode_by_name_and_quality(const char *name, int quality)
 {
         char temp[GET_MODE_BUFFER_SIZE];
         char *p= temp;
-        const char *filterDelimiters= ",/";
-        const char *optionDelimiters= ":";
+        static const char filterDelimiters[] = ",/";
+        static const char optionDelimiters[] = ":";
         struct PPMode *ppMode;
         char *filterToken;
 
@@ -970,27 +971,17 @@
         reallocAlign((void **)&c->forcedQPTable, 8, mbWidth*sizeof(QP_STORE_T));
 }
 
-static void global_init(void){
-        int i;
-        memset(clip_table, 0, 256);
-        for(i=256; i<512; i++)
-                clip_table[i]= i;
-        memset(clip_table+512, 0, 256);
-}
-
 static const char * context_to_name(void * ptr) {
     return "postproc";
 }
 
-static AVClass av_codec_context_class = { "Postproc", context_to_name, NULL };
+static const AVClass av_codec_context_class = { "Postproc", context_to_name, NULL };
 
 pp_context_t *pp_get_context(int width, int height, int cpuCaps){
         PPContext *c= av_malloc(sizeof(PPContext));
         int stride= (width+15)&(~15);    //assumed / will realloc if needed
         int qpStride= (width+15)/16 + 2; //assumed / will realloc if needed
 
-        global_init();
-
         memset(c, 0, sizeof(PPContext));
         c->av_class = &av_codec_context_class;
         c->cpuCaps= cpuCaps;
@@ -1030,10 +1021,10 @@
         av_free(c);
 }
 
-void  pp_postprocess(uint8_t * src[3], int srcStride[3],
-                 uint8_t * dst[3], int dstStride[3],
+void  pp_postprocess(const uint8_t * src[3], const int srcStride[3],
+                 uint8_t * dst[3], const int dstStride[3],
                  int width, int height,
-                 QP_STORE_T *QP_store,  int QPStride,
+                 const QP_STORE_T *QP_store,  int QPStride,
                  pp_mode_t *vm,  void *vc, int pict_type)
 {
         int mbWidth = (width+15)>>4;
@@ -1055,16 +1046,16 @@
                 QP_store= c->forcedQPTable;
                 absQPStride = QPStride = 0;
                 if(mode->lumMode & FORCE_QUANT)
-                        for(i=0; i<mbWidth; i++) QP_store[i]= mode->forcedQuant;
+                        for(i=0; i<mbWidth; i++) c->forcedQPTable[i]= mode->forcedQuant;
                 else
-                        for(i=0; i<mbWidth; i++) QP_store[i]= 1;
+                        for(i=0; i<mbWidth; i++) c->forcedQPTable[i]= 1;
         }
 
         if(pict_type & PP_PICT_TYPE_QP2){
                 int i;
                 const int count= mbHeight * absQPStride;
                 for(i=0; i<(count>>2); i++){
-                        ((uint32_t*)c->stdQPTable)[i] = (((uint32_t*)QP_store)[i]>>1) & 0x7F7F7F7F;
+                        ((uint32_t*)c->stdQPTable)[i] = (((const uint32_t*)QP_store)[i]>>1) & 0x7F7F7F7F;
                 }
                 for(i<<=2; i<count; i++){
                         c->stdQPTable[i] = QP_store[i]>>1;
@@ -1090,7 +1081,7 @@
                         int i;
                         const int count= mbHeight * QPStride;
                         for(i=0; i<(count>>2); i++){
-                                ((uint32_t*)c->nonBQPTable)[i] = ((uint32_t*)QP_store)[i] & 0x3F3F3F3F;
+                                ((uint32_t*)c->nonBQPTable)[i] = ((const uint32_t*)QP_store)[i] & 0x3F3F3F3F;
                         }
                         for(i<<=2; i<count; i++){
                                 c->nonBQPTable[i] = QP_store[i] & 0x3F;
diff -u mplayer-1.0~rc2-12/libpostproc/postprocess.h ffmpeg-free-0.svn20080206/libpostproc/postprocess.h
--- mplayer-1.0~rc2-12/libpostproc/postprocess.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libpostproc/postprocess.h	2008-02-02 22:24:54.000000000 +0100
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef NEWPOSTPROCESS_H
-#define NEWPOSTPROCESS_H
+#ifndef FFMPEG_POSTPROCESS_H
+#define FFMPEG_POSTPROCESS_H
 
 /**
  * @file postprocess.h
@@ -42,12 +42,16 @@
 typedef void pp_context_t;
 typedef void pp_mode_t;
 
-extern char *pp_help; ///< a simple help text
+#if LIBPOSTPROC_VERSION_INT < (52<<16)
+extern const char *const pp_help; ///< a simple help text
+#else
+extern const char pp_help[]; ///< a simple help text
+#endif
 
-void  pp_postprocess(uint8_t * src[3], int srcStride[3],
-                 uint8_t * dst[3], int dstStride[3],
+void  pp_postprocess(const uint8_t * src[3], const int srcStride[3],
+                 uint8_t * dst[3], const int dstStride[3],
                  int horizontalSize, int verticalSize,
-                 QP_STORE_T *QP_store,  int QP_stride,
+                 const QP_STORE_T *QP_store,  int QP_stride,
                  pp_mode_t *mode, pp_context_t *ppContext, int pict_type);
 
 
@@ -56,7 +60,7 @@
  * name is the string after "-pp" on the command line
  * quality is a number from 0 to PP_QUALITY_MAX
  */
-pp_mode_t *pp_get_mode_by_name_and_quality(char *name, int quality);
+pp_mode_t *pp_get_mode_by_name_and_quality(const char *name, int quality);
 void pp_free_mode(pp_mode_t *mode);
 
 pp_context_t *pp_get_context(int width, int height, int flags);
@@ -75,4 +79,4 @@
 
 #define PP_PICT_TYPE_QP2  0x00000010 ///< MPEG2 style QScale
 
-#endif
+#endif /* FFMPEG_POSTPROCESS_H */
diff -u mplayer-1.0~rc2-12/libpostproc/postprocess_internal.h ffmpeg-free-0.svn20080206/libpostproc/postprocess_internal.h
--- mplayer-1.0~rc2-12/libpostproc/postprocess_internal.h	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libpostproc/postprocess_internal.h	2008-02-02 18:13:40.000000000 +0100
@@ -23,8 +23,8 @@
  * internal api header.
  */
 
-#ifndef POSTPROCESS_INTERNAL_H
-#define POSTPROCESS_INTERNAL_H
+#ifndef FFMPEG_POSTPROCESS_INTERNAL_H
+#define FFMPEG_POSTPROCESS_INTERNAL_H
 
 #include "avutil.h"
 #include "postprocess.h"
@@ -66,27 +66,16 @@
 #define TEMP_NOISE_FILTER               0x100000
 #define FORCE_QUANT                     0x200000
 
-#if ( defined(__PIC__) || defined(__pic__) ) && ! defined(PIC)
-#    define PIC
-#endif
-
 //use if you want a faster postprocessing code
 //cannot differentiate between chroma & luma filters (both on or both off)
 //obviously the -pp option on the command line has no effect except turning the here selected
 //filters on
 //#define COMPILE_TIME_MODE 0x77
 
-#if 1
 static inline int CLIP(int a){
         if(a&256) return ((a)>>31)^(-1);
         else      return a;
 }
-//#define CLIP(a) (((a)&256) ? ((a)>>31)^(-1) : (a))
-#elif 0
-#define CLIP(a) clip_tab[a]
-#else
-#define CLIP(a) (a)
-#endif
 /**
  * Postprocessng filter.
  */
@@ -126,7 +115,7 @@
         /**
          * info on struct for av_log
          */
-        AVClass *av_class;
+        const AVClass *av_class;
 
         uint8_t *tempBlocks; ///<used for the horizontal code
 
@@ -177,13 +166,13 @@
 } PPContext;
 
 
-static inline void linecpy(void *dest, void *src, int lines, int stride)
+static inline void linecpy(void *dest, const void *src, int lines, int stride)
 {
         if (stride > 0) {
                 memcpy(dest, src, lines*stride);
         } else {
-                memcpy(dest+(lines-1)*stride, src+(lines-1)*stride, -lines*stride);
+                memcpy((uint8_t*)dest+(lines-1)*stride, (const uint8_t*)src+(lines-1)*stride, -lines*stride);
         }
 }
 
-#endif // POSTPROCESS_INTERNAL_H
+#endif /* FFMPEG_POSTPROCESS_INTERNAL_H */
diff -u mplayer-1.0~rc2-12/libpostproc/postprocess_template.c ffmpeg-free-0.svn20080206/libpostproc/postprocess_template.c
--- mplayer-1.0~rc2-12/libpostproc/postprocess_template.c	2007-10-07 21:49:38.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libpostproc/postprocess_template.c	2008-02-02 22:24:54.000000000 +0100
@@ -3180,8 +3180,8 @@
 }
 #endif //HAVE_MMX
 
-static void RENAME(postProcess)(uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
-        QP_STORE_T QPs[], int QPStride, int isColor, PPContext *c);
+static void RENAME(postProcess)(const uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
+        const QP_STORE_T QPs[], int QPStride, int isColor, PPContext *c);
 
 /**
  * Copies a block from src to dst and fixes the blacklevel.
@@ -3189,7 +3189,7 @@
  */
 #undef SCALED_CPY
 
-static inline void RENAME(blockCopy)(uint8_t dst[], int dstStride, uint8_t src[], int srcStride,
+static inline void RENAME(blockCopy)(uint8_t dst[], int dstStride, const uint8_t src[], int srcStride,
         int levelFix, int64_t *packedOffsetAndScale)
 {
 #ifndef HAVE_MMX
@@ -3346,8 +3346,8 @@
 /**
  * Filters array of bytes (Y or U or V values)
  */
-static void RENAME(postProcess)(uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
-        QP_STORE_T QPs[], int QPStride, int isColor, PPContext *c2)
+static void RENAME(postProcess)(const uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
+        const QP_STORE_T QPs[], int QPStride, int isColor, PPContext *c2)
 {
         DECLARE_ALIGNED(8, PPContext, c)= *c2; //copy to stack for faster access
         int x,y;
@@ -3462,7 +3462,7 @@
         /* copy & deinterlace first row of blocks */
         y=-BLOCK_SIZE;
         {
-                uint8_t *srcBlock= &(src[y*srcStride]);
+                const uint8_t *srcBlock= &(src[y*srcStride]);
                 uint8_t *dstBlock= tempDst + dstStride;
 
                 // From this point on it is guaranteed that we can read and write 16 lines downward
@@ -3545,13 +3545,13 @@
         for(y=0; y<height; y+=BLOCK_SIZE)
         {
                 //1% speedup if these are here instead of the inner loop
-                uint8_t *srcBlock= &(src[y*srcStride]);
+                const uint8_t *srcBlock= &(src[y*srcStride]);
                 uint8_t *dstBlock= &(dst[y*dstStride]);
 #ifdef HAVE_MMX
                 uint8_t *tempBlock1= c.tempBlocks;
                 uint8_t *tempBlock2= c.tempBlocks + 8;
 #endif
-                int8_t *QPptr= &QPs[(y>>qpVShift)*QPStride];
+                const int8_t *QPptr= &QPs[(y>>qpVShift)*QPStride];
                 int8_t *nonBQPptr= &c.nonBQPTable[(y>>qpVShift)*FFABS(QPStride)];
                 int QP=0;
                 /* can we mess with a 8x16 block from srcBlock/dstBlock downwards and 1 line upwards
diff -u mplayer-1.0~rc2-12/libswscale/Makefile ffmpeg-free-0.svn20080206/libswscale/Makefile
--- mplayer-1.0~rc2-12/libswscale/Makefile	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/Makefile	2007-10-18 11:35:02.000000000 +0200
@@ -21,9 +21,9 @@
 
 include ../common.mak
 
-cs_test: cs_test.o $(LIB)
+cs_test: cs_test.o $(LIBNAME)
 
-swscale-example: swscale-example.o $(LIB)
+swscale-example: swscale-example.o $(LIBNAME)
 swscale-example: EXTRALIBS += -lm
 
 clean::
diff -u mplayer-1.0~rc2-12/libswscale/rgb2rgb.c ffmpeg-free-0.svn20080206/libswscale/rgb2rgb.c
--- mplayer-1.0~rc2-12/libswscale/rgb2rgb.c	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/rgb2rgb.c	2008-01-29 15:58:10.000000000 +0100
@@ -35,18 +35,18 @@
 
 #define FAST_BGR2YV12 // use 7 bit coeffs instead of 15bit
 
-void (*rgb24to32)(const uint8_t *src,uint8_t *dst,long src_size);
-void (*rgb24to16)(const uint8_t *src,uint8_t *dst,long src_size);
-void (*rgb24to15)(const uint8_t *src,uint8_t *dst,long src_size);
-void (*rgb32to24)(const uint8_t *src,uint8_t *dst,long src_size);
-void (*rgb32to16)(const uint8_t *src,uint8_t *dst,long src_size);
-void (*rgb32to15)(const uint8_t *src,uint8_t *dst,long src_size);
-void (*rgb15to16)(const uint8_t *src,uint8_t *dst,long src_size);
-void (*rgb15to24)(const uint8_t *src,uint8_t *dst,long src_size);
-void (*rgb15to32)(const uint8_t *src,uint8_t *dst,long src_size);
-void (*rgb16to15)(const uint8_t *src,uint8_t *dst,long src_size);
-void (*rgb16to24)(const uint8_t *src,uint8_t *dst,long src_size);
-void (*rgb16to32)(const uint8_t *src,uint8_t *dst,long src_size);
+void (*rgb24to32)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb24to16)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb24to15)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb32to24)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb32to16)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb32to15)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb15to16)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb15to24)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb15to32)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb16to15)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb16to24)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb16to32)(const uint8_t *src, uint8_t *dst, long src_size);
 //void (*rgb24tobgr32)(const uint8_t *src, uint8_t *dst, long src_size);
 void (*rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long src_size);
 void (*rgb24tobgr16)(const uint8_t *src, uint8_t *dst, long src_size);
@@ -88,52 +88,39 @@
                      long srcStride3, long dstStride);
 
 #if defined(ARCH_X86) && defined(CONFIG_GPL)
-static const uint64_t mmx_null     __attribute__((aligned(8))) = 0x0000000000000000ULL;
-static const uint64_t mmx_one      __attribute__((aligned(8))) = 0xFFFFFFFFFFFFFFFFULL;
-static const uint64_t mask32b      attribute_used __attribute__((aligned(8))) = 0x000000FF000000FFULL;
-static const uint64_t mask32g      attribute_used __attribute__((aligned(8))) = 0x0000FF000000FF00ULL;
-static const uint64_t mask32r      attribute_used __attribute__((aligned(8))) = 0x00FF000000FF0000ULL;
-static const uint64_t mask32       __attribute__((aligned(8))) = 0x00FFFFFF00FFFFFFULL;
-static const uint64_t mask3216br   __attribute__((aligned(8))) = 0x00F800F800F800F8ULL;
-static const uint64_t mask3216g    __attribute__((aligned(8))) = 0x0000FC000000FC00ULL;
-static const uint64_t mask3215g    __attribute__((aligned(8))) = 0x0000F8000000F800ULL;
-static const uint64_t mul3216      __attribute__((aligned(8))) = 0x2000000420000004ULL;
-static const uint64_t mul3215      __attribute__((aligned(8))) = 0x2000000820000008ULL;
-static const uint64_t mask24b      attribute_used __attribute__((aligned(8))) = 0x00FF0000FF0000FFULL;
-static const uint64_t mask24g      attribute_used __attribute__((aligned(8))) = 0xFF0000FF0000FF00ULL;
-static const uint64_t mask24r      attribute_used __attribute__((aligned(8))) = 0x0000FF0000FF0000ULL;
-static const uint64_t mask24l      __attribute__((aligned(8))) = 0x0000000000FFFFFFULL;
-static const uint64_t mask24h      __attribute__((aligned(8))) = 0x0000FFFFFF000000ULL;
-static const uint64_t mask24hh     __attribute__((aligned(8))) = 0xffff000000000000ULL;
-static const uint64_t mask24hhh    __attribute__((aligned(8))) = 0xffffffff00000000ULL;
-static const uint64_t mask24hhhh   __attribute__((aligned(8))) = 0xffffffffffff0000ULL;
-static const uint64_t mask15b      __attribute__((aligned(8))) = 0x001F001F001F001FULL; /* 00000000 00011111  xxB */
-static const uint64_t mask15rg     __attribute__((aligned(8))) = 0x7FE07FE07FE07FE0ULL; /* 01111111 11100000  RGx */
-static const uint64_t mask15s      __attribute__((aligned(8))) = 0xFFE0FFE0FFE0FFE0ULL;
-static const uint64_t mask15g      __attribute__((aligned(8))) = 0x03E003E003E003E0ULL;
-static const uint64_t mask15r      __attribute__((aligned(8))) = 0x7C007C007C007C00ULL;
+DECLARE_ASM_CONST(8, uint64_t, mmx_null)     = 0x0000000000000000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mmx_one)      = 0xFFFFFFFFFFFFFFFFULL;
+DECLARE_ASM_CONST(8, uint64_t, mask32b)      = 0x000000FF000000FFULL;
+DECLARE_ASM_CONST(8, uint64_t, mask32g)      = 0x0000FF000000FF00ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask32r)      = 0x00FF000000FF0000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask32)       = 0x00FFFFFF00FFFFFFULL;
+DECLARE_ASM_CONST(8, uint64_t, mask3216br)   = 0x00F800F800F800F8ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask3216g)    = 0x0000FC000000FC00ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask3215g)    = 0x0000F8000000F800ULL;
+DECLARE_ASM_CONST(8, uint64_t, mul3216)      = 0x2000000420000004ULL;
+DECLARE_ASM_CONST(8, uint64_t, mul3215)      = 0x2000000820000008ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24b)      = 0x00FF0000FF0000FFULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24g)      = 0xFF0000FF0000FF00ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24r)      = 0x0000FF0000FF0000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24l)      = 0x0000000000FFFFFFULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24h)      = 0x0000FFFFFF000000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24hh)     = 0xffff000000000000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24hhh)    = 0xffffffff00000000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24hhhh)   = 0xffffffffffff0000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask15b)      = 0x001F001F001F001FULL; /* 00000000 00011111  xxB */
+DECLARE_ASM_CONST(8, uint64_t, mask15rg)     = 0x7FE07FE07FE07FE0ULL; /* 01111111 11100000  RGx */
+DECLARE_ASM_CONST(8, uint64_t, mask15s)      = 0xFFE0FFE0FFE0FFE0ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask15g)      = 0x03E003E003E003E0ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask15r)      = 0x7C007C007C007C00ULL;
 #define mask16b mask15b
-static const uint64_t mask16g      __attribute__((aligned(8))) = 0x07E007E007E007E0ULL;
-static const uint64_t mask16r      __attribute__((aligned(8))) = 0xF800F800F800F800ULL;
-static const uint64_t red_16mask   __attribute__((aligned(8))) = 0x0000f8000000f800ULL;
-static const uint64_t green_16mask __attribute__((aligned(8))) = 0x000007e0000007e0ULL;
-static const uint64_t blue_16mask  __attribute__((aligned(8))) = 0x0000001f0000001fULL;
-static const uint64_t red_15mask   __attribute__((aligned(8))) = 0x00007c0000007c00ULL;
-static const uint64_t green_15mask __attribute__((aligned(8))) = 0x000003e0000003e0ULL;
-static const uint64_t blue_15mask  __attribute__((aligned(8))) = 0x0000001f0000001fULL;
-
-#ifdef FAST_BGR2YV12
-static const uint64_t bgr2YCoeff   attribute_used __attribute__((aligned(8))) = 0x000000210041000DULL;
-static const uint64_t bgr2UCoeff   attribute_used __attribute__((aligned(8))) = 0x0000FFEEFFDC0038ULL;
-static const uint64_t bgr2VCoeff   attribute_used __attribute__((aligned(8))) = 0x00000038FFD2FFF8ULL;
-#else
-static const uint64_t bgr2YCoeff   attribute_used __attribute__((aligned(8))) = 0x000020E540830C8BULL;
-static const uint64_t bgr2UCoeff   attribute_used __attribute__((aligned(8))) = 0x0000ED0FDAC23831ULL;
-static const uint64_t bgr2VCoeff   attribute_used __attribute__((aligned(8))) = 0x00003831D0E6F6EAULL;
-#endif
-static const uint64_t bgr2YOffset  attribute_used __attribute__((aligned(8))) = 0x1010101010101010ULL;
-static const uint64_t bgr2UVOffset attribute_used __attribute__((aligned(8))) = 0x8080808080808080ULL;
-static const uint64_t w1111        attribute_used __attribute__((aligned(8))) = 0x0001000100010001ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask16g)      = 0x07E007E007E007E0ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask16r)      = 0xF800F800F800F800ULL;
+DECLARE_ASM_CONST(8, uint64_t, red_16mask)   = 0x0000f8000000f800ULL;
+DECLARE_ASM_CONST(8, uint64_t, green_16mask) = 0x000007e0000007e0ULL;
+DECLARE_ASM_CONST(8, uint64_t, blue_16mask)  = 0x0000001f0000001fULL;
+DECLARE_ASM_CONST(8, uint64_t, red_15mask)   = 0x00007c0000007c00ULL;
+DECLARE_ASM_CONST(8, uint64_t, green_15mask) = 0x000003e0000003e0ULL;
+DECLARE_ASM_CONST(8, uint64_t, blue_15mask)  = 0x0000001f0000001fULL;
 
 #if 0
 static volatile uint64_t __attribute__((aligned(8))) b5Dither;
@@ -231,20 +218,20 @@
 
 /*
     for (i=0; i<num_pixels; i++)
-        ((unsigned *)dst)[i] = ((unsigned *)palette)[ src[i] ];
+        ((unsigned *)dst)[i] = ((unsigned *)palette)[src[i]];
 */
 
     for (i=0; i<num_pixels; i++)
     {
         #ifdef WORDS_BIGENDIAN
-            dst[3]= palette[ src[i]*4+2 ];
-            dst[2]= palette[ src[i]*4+1 ];
-            dst[1]= palette[ src[i]*4+0 ];
+            dst[3]= palette[src[i]*4+2];
+            dst[2]= palette[src[i]*4+1];
+            dst[1]= palette[src[i]*4+0];
         #else
         //FIXME slow?
-            dst[0]= palette[ src[i]*4+2 ];
-            dst[1]= palette[ src[i]*4+1 ];
-            dst[2]= palette[ src[i]*4+0 ];
+            dst[0]= palette[src[i]*4+2];
+            dst[1]= palette[src[i]*4+1];
+            dst[2]= palette[src[i]*4+0];
             //dst[3]= 0; /* do we need this cleansing? */
         #endif
         dst+= 4;
@@ -257,14 +244,14 @@
     for (i=0; i<num_pixels; i++)
     {
         #ifdef WORDS_BIGENDIAN
-            dst[3]= palette[ src[i]*4+0 ];
-            dst[2]= palette[ src[i]*4+1 ];
-            dst[1]= palette[ src[i]*4+2 ];
+            dst[3]= palette[src[i]*4+0];
+            dst[2]= palette[src[i]*4+1];
+            dst[1]= palette[src[i]*4+2];
         #else
             //FIXME slow?
-            dst[0]= palette[ src[i]*4+0 ];
-            dst[1]= palette[ src[i]*4+1 ];
-            dst[2]= palette[ src[i]*4+2 ];
+            dst[0]= palette[src[i]*4+0];
+            dst[1]= palette[src[i]*4+1];
+            dst[2]= palette[src[i]*4+2];
             //dst[3]= 0; /* do we need this cleansing? */
         #endif
 
@@ -281,14 +268,14 @@
 /*
     writes 1 byte o much and might cause alignment issues on some architectures?
     for (i=0; i<num_pixels; i++)
-        ((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];
+        ((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[src[i]];
 */
     for (i=0; i<num_pixels; i++)
     {
         //FIXME slow?
-        dst[0]= palette[ src[i]*4+2 ];
-        dst[1]= palette[ src[i]*4+1 ];
-        dst[2]= palette[ src[i]*4+0 ];
+        dst[0]= palette[src[i]*4+2];
+        dst[1]= palette[src[i]*4+1];
+        dst[2]= palette[src[i]*4+0];
         dst+= 3;
     }
 }
@@ -299,14 +286,14 @@
 /*
     writes 1 byte o much and might cause alignment issues on some architectures?
     for (i=0; i<num_pixels; i++)
-        ((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];
+        ((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[src[i]];
 */
     for (i=0; i<num_pixels; i++)
     {
         //FIXME slow?
-        dst[0]= palette[ src[i]*4+0 ];
-        dst[1]= palette[ src[i]*4+1 ];
-        dst[2]= palette[ src[i]*4+2 ];
+        dst[0]= palette[src[i]*4+0];
+        dst[1]= palette[src[i]*4+1];
+        dst[2]= palette[src[i]*4+2];
         dst+= 3;
     }
 }
@@ -318,13 +305,13 @@
 {
     long i;
     for (i=0; i<num_pixels; i++)
-        ((uint16_t *)dst)[i] = ((uint16_t *)palette)[ src[i] ];
+        ((uint16_t *)dst)[i] = ((uint16_t *)palette)[src[i]];
 }
 void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
 {
     long i;
     for (i=0; i<num_pixels; i++)
-        ((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);
+        ((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[src[i]]);
 }
 
 /**
@@ -334,13 +321,13 @@
 {
     long i;
     for (i=0; i<num_pixels; i++)
-        ((uint16_t *)dst)[i] = ((uint16_t *)palette)[ src[i] ];
+        ((uint16_t *)dst)[i] = ((uint16_t *)palette)[src[i]];
 }
 void palette8tobgr15(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
 {
     long i;
     for (i=0; i<num_pixels; i++)
-        ((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);
+        ((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[src[i]]);
 }
 
 void rgb32tobgr24(const uint8_t *src, uint8_t *dst, long src_size)
diff -u mplayer-1.0~rc2-12/libswscale/rgb2rgb.h ffmpeg-free-0.svn20080206/libswscale/rgb2rgb.h
--- mplayer-1.0~rc2-12/libswscale/rgb2rgb.h	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/rgb2rgb.h	2007-10-18 11:31:47.000000000 +0200
@@ -23,8 +23,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef RGB2RGB_INCLUDED
-#define RGB2RGB_INCLUDED
+#ifndef FFMPEG_RGB2RGB_H
+#define FFMPEG_RGB2RGB_H
 
 #include <inttypes.h>
 
@@ -143,4 +143,4 @@
 
 void sws_rgb2rgb_init(int flags);
 
-#endif
+#endif /* FFMPEG_RGB2RGB_H */
diff -u mplayer-1.0~rc2-12/libswscale/rgb2rgb_template.c ffmpeg-free-0.svn20080206/libswscale/rgb2rgb_template.c
--- mplayer-1.0~rc2-12/libswscale/rgb2rgb_template.c	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/rgb2rgb_template.c	2008-01-29 15:58:10.000000000 +0100
@@ -23,15 +23,15 @@
  * along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  *
- * the C code (not assembly, mmx, ...) of this file can be used
- * under the LGPL license too
+ * The C code (not assembly, mmx, ...) of this file can be used
+ * under the LGPL license.
  */
 
 #include <stddef.h>
 #include <inttypes.h> /* for __WORDSIZE */
 
 #ifndef __WORDSIZE
-// #warning You have misconfigured system and probably will lose performance!
+// #warning You have a misconfigured system and will probably lose performance!
 #define __WORDSIZE MP_WORDSIZE
 #endif
 
@@ -53,7 +53,7 @@
 #define PREFETCH  "prefetch"
 #define PREFETCHW "prefetchw"
 #define PAVGB     "pavgusb"
-#elif defined ( HAVE_MMX2 )
+#elif defined (HAVE_MMX2)
 #define PREFETCH "prefetchnta"
 #define PREFETCHW "prefetcht0"
 #define PAVGB     "pavgb"
@@ -68,7 +68,7 @@
 #endif
 
 #ifdef HAVE_3DNOW
-/* On K6 femms is faster of emms. On K7 femms is directly mapped on emms. */
+/* On K6 femms is faster than emms. On K7 femms is directly mapped on emms. */
 #define EMMS     "femms"
 #else
 #define EMMS     "emms"
@@ -82,7 +82,7 @@
 #define SFENCE " # nop"
 #endif
 
-static inline void RENAME(rgb24to32)(const uint8_t *src,uint8_t *dst,long src_size)
+static inline void RENAME(rgb24to32)(const uint8_t *src, uint8_t *dst, long src_size)
 {
     uint8_t *dest = dst;
     const uint8_t *s = src;
@@ -142,7 +142,7 @@
     }
 }
 
-static inline void RENAME(rgb32to24)(const uint8_t *src,uint8_t *dst,long src_size)
+static inline void RENAME(rgb32to24)(const uint8_t *src, uint8_t *dst, long src_size)
 {
     uint8_t *dest = dst;
     const uint8_t *s = src;
@@ -232,9 +232,9 @@
  Original by Strepto/Astral
  ported to gcc & bugfixed : A'rpi
  MMX2, 3DNOW optimization by Nick Kurshev
- 32bit c version, and and&add trick by Michael Niedermayer
+ 32 bit C version, and and&add trick by Michael Niedermayer
 */
-static inline void RENAME(rgb15to16)(const uint8_t *src,uint8_t *dst,long src_size)
+static inline void RENAME(rgb15to16)(const uint8_t *src, uint8_t *dst, long src_size)
 {
     register const uint8_t* s=src;
     register uint8_t* d=dst;
@@ -283,7 +283,7 @@
     }
 }
 
-static inline void RENAME(rgb16to15)(const uint8_t *src,uint8_t *dst,long src_size)
+static inline void RENAME(rgb16to15)(const uint8_t *src, uint8_t *dst, long src_size)
 {
     register const uint8_t* s=src;
     register uint8_t* d=dst;
@@ -350,7 +350,7 @@
     end = s + src_size;
 #ifdef HAVE_MMX
     mm_end = end - 15;
-#if 1 //is faster only if multiplies are reasonable fast (FIXME figure out on which CPUs this is faster, on Athlon it is slightly faster)
+#if 1 //is faster only if multiplies are reasonably fast (FIXME figure out on which CPUs this is faster, on Athlon it is slightly faster)
     asm volatile(
     "movq           %3, %%mm5   \n\t"
     "movq           %4, %%mm6   \n\t"
@@ -509,7 +509,7 @@
     end = s + src_size;
 #ifdef HAVE_MMX
     mm_end = end - 15;
-#if 1 //is faster only if multiplies are reasonable fast (FIXME figure out on which CPUs this is faster, on Athlon it is slightly faster)
+#if 1 //is faster only if multiplies are reasonably fast (FIXME figure out on which CPUs this is faster, on Athlon it is slightly faster)
     asm volatile(
     "movq           %3, %%mm5   \n\t"
     "movq           %4, %%mm6   \n\t"
@@ -910,12 +910,10 @@
 }
 
 /*
-  I use here less accurate approximation by simply
- left-shifting the input
-  value and filling the low order bits with
- zeroes. This method improves png's
-  compression but this scheme cannot reproduce white exactly, since it does not
-  generate an all-ones maximum value; the net effect is to darken the
+  I use less accurate approximation here by simply left-shifting the input
+  value and filling the low order bits with zeroes. This method improves PNG
+  compression but this scheme cannot reproduce white exactly, since it does
+  not generate an all-ones maximum value; the net effect is to darken the
   image slightly.
 
   The better method should be "left bit replication":
@@ -1271,7 +1269,7 @@
 #endif
     while (s < end)
     {
-#if 0 //slightly slower on athlon
+#if 0 //slightly slower on Athlon
         int bgr= *s++;
         *((uint32_t*)d)++ = ((bgr&0x1F)<<3) + ((bgr&0x3E0)<<6) + ((bgr&0x7C00)<<9);
 #else
@@ -1507,7 +1505,7 @@
     for (y=0; y<height; y++)
     {
 #ifdef HAVE_MMX
-//FIXME handle 2 lines a once (fewer prefetch, reuse some chrom, but very likely limited by mem anyway)
+//FIXME handle 2 lines at once (fewer prefetches, reuse some chroma, but very likely memory-limited anyway)
         asm volatile(
         "xor                 %%"REG_a", %%"REG_a"   \n\t"
         ASMALIGN(4)
@@ -1623,7 +1621,7 @@
         }
 #endif
 #endif
-        if ((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )
+        if ((y&(vertLumPerChroma-1)) == vertLumPerChroma-1)
         {
             usrc += chromStride;
             vsrc += chromStride;
@@ -1639,9 +1637,8 @@
 }
 
 /**
- *
- * height should be a multiple of 2 and width should be a multiple of 16 (if this is a
- * problem for anyone then tell me, and ill fix it)
+ * Height should be a multiple of 2 and width should be a multiple of 16 (if
+ * this is a problem for anyone then tell me, and I will fix it).
  */
 static inline void RENAME(yv12toyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
                                       long width, long height,
@@ -1660,7 +1657,7 @@
     for (y=0; y<height; y++)
     {
 #ifdef HAVE_MMX
-//FIXME handle 2 lines a once (fewer prefetch, reuse some chrom, but very likely limited by mem anyway)
+//FIXME handle 2 lines at once (fewer prefetches, reuse some chroma, but very likely memory-limited anyway)
         asm volatile(
         "xor                %%"REG_a", %%"REG_a"    \n\t"
         ASMALIGN(4)
@@ -1695,7 +1692,7 @@
         : "%"REG_a
         );
 #else
-//FIXME adapt the alpha asm code from yv12->yuy2
+//FIXME adapt the Alpha ASM code from yv12->yuy2
 
 #if __WORDSIZE >= 64
         int i;
@@ -1730,7 +1727,7 @@
         }
 #endif
 #endif
-        if ((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )
+        if ((y&(vertLumPerChroma-1)) == vertLumPerChroma-1)
         {
             usrc += chromStride;
             vsrc += chromStride;
@@ -1746,9 +1743,8 @@
 }
 
 /**
- *
- * height should be a multiple of 2 and width should be a multiple of 16 (if this is a
- * problem for anyone then tell me, and ill fix it)
+ * Height should be a multiple of 2 and width should be a multiple of 16 (if
+ * this is a problem for anyone then tell me, and I will fix it).
  */
 static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
                                       long width, long height,
@@ -1759,8 +1755,7 @@
 }
 
 /**
- *
- * width should be a multiple of 16
+ * Width should be a multiple of 16.
  */
 static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
                                          long width, long height,
@@ -1770,9 +1765,8 @@
 }
 
 /**
- *
- * height should be a multiple of 2 and width should be a multiple of 16 (if this is a
- * problem for anyone then tell me, and ill fix it)
+ * Height should be a multiple of 2 and width should be a multiple of 16 (if
+ * this is a problem for anyone then tell me, and I will fix it).
  */
 static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,
                                       long width, long height,
@@ -2007,10 +2001,10 @@
 }
 
 /**
- *
- * height should be a multiple of 2 and width should be a multiple of 16 (if this is a
- * problem for anyone then tell me, and ill fix it)
- * chrominance data is only taken from every secound line others are ignored FIXME write HQ version
+ * Height should be a multiple of 2 and width should be a multiple of 16 (if
+ * this is a problem for anyone then tell me, and I will fix it).
+ * Chrominance data is only taken from every secound line, others are ignored.
+ * FIXME: Write HQ version.
  */
 static inline void RENAME(uyvytoyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,
                                       long width, long height,
@@ -2133,10 +2127,11 @@
 }
 
 /**
- *
- * height should be a multiple of 2 and width should be a multiple of 2 (if this is a
- * problem for anyone then tell me, and ill fix it)
- * chrominance data is only taken from every secound line others are ignored in the C version FIXME write HQ version
+ * Height should be a multiple of 2 and width should be a multiple of 2 (if
+ * this is a problem for anyone then tell me, and I will fix it).
+ * Chrominance data is only taken from every secound line,
+ * others are ignored in the C version.
+ * FIXME: Write HQ version.
  */
 static inline void RENAME(rgb24toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,
                                        long width, long height,
@@ -2152,8 +2147,8 @@
         {
             asm volatile(
             "mov                        %2, %%"REG_a"   \n\t"
-            "movq     "MANGLE(bgr2YCoeff)", %%mm6       \n\t"
-            "movq          "MANGLE(w1111)", %%mm5       \n\t"
+            "movq  "MANGLE(ff_bgr2YCoeff)", %%mm6       \n\t"
+            "movq       "MANGLE(ff_w1111)", %%mm5       \n\t"
             "pxor                    %%mm7, %%mm7       \n\t"
             "lea (%%"REG_a", %%"REG_a", 2), %%"REG_d"   \n\t"
             ASMALIGN(4)
@@ -2211,7 +2206,7 @@
             "psraw                      $7, %%mm4       \n\t"
 
             "packuswb                %%mm4, %%mm0       \n\t"
-            "paddusb "MANGLE(bgr2YOffset)", %%mm0       \n\t"
+            "paddusb "MANGLE(ff_bgr2YOffset)", %%mm0    \n\t"
 
             MOVNTQ"                  %%mm0, (%1, %%"REG_a") \n\t"
             "add                        $8,      %%"REG_a"  \n\t"
@@ -2225,8 +2220,8 @@
         src -= srcStride*2;
         asm volatile(
         "mov                        %4, %%"REG_a"   \n\t"
-        "movq          "MANGLE(w1111)", %%mm5       \n\t"
-        "movq     "MANGLE(bgr2UCoeff)", %%mm6       \n\t"
+        "movq       "MANGLE(ff_w1111)", %%mm5       \n\t"
+        "movq  "MANGLE(ff_bgr2UCoeff)", %%mm6       \n\t"
         "pxor                    %%mm7, %%mm7       \n\t"
         "lea (%%"REG_a", %%"REG_a", 2), %%"REG_d"   \n\t"
         "add                 %%"REG_d", %%"REG_d"   \n\t"
@@ -2275,8 +2270,8 @@
         "psrlw                      $2, %%mm0       \n\t"
         "psrlw                      $2, %%mm2       \n\t"
 #endif
-        "movq     "MANGLE(bgr2VCoeff)", %%mm1       \n\t"
-        "movq     "MANGLE(bgr2VCoeff)", %%mm3       \n\t"
+        "movq  "MANGLE(ff_bgr2VCoeff)", %%mm1       \n\t"
+        "movq  "MANGLE(ff_bgr2VCoeff)", %%mm3       \n\t"
 
         "pmaddwd                 %%mm0, %%mm1       \n\t"
         "pmaddwd                 %%mm2, %%mm3       \n\t"
@@ -2333,12 +2328,12 @@
         "paddw                   %%mm1, %%mm5       \n\t"
         "paddw                   %%mm3, %%mm2       \n\t"
         "paddw                   %%mm5, %%mm2       \n\t"
-        "movq          "MANGLE(w1111)", %%mm5       \n\t"
+        "movq       "MANGLE(ff_w1111)", %%mm5       \n\t"
         "psrlw                      $2, %%mm4       \n\t"
         "psrlw                      $2, %%mm2       \n\t"
 #endif
-        "movq     "MANGLE(bgr2VCoeff)", %%mm1       \n\t"
-        "movq     "MANGLE(bgr2VCoeff)", %%mm3       \n\t"
+        "movq  "MANGLE(ff_bgr2VCoeff)", %%mm1       \n\t"
+        "movq  "MANGLE(ff_bgr2VCoeff)", %%mm3       \n\t"
 
         "pmaddwd                 %%mm4, %%mm1       \n\t"
         "pmaddwd                 %%mm2, %%mm3       \n\t"
@@ -2362,7 +2357,7 @@
         "punpckldq               %%mm4, %%mm0           \n\t"
         "punpckhdq               %%mm4, %%mm1           \n\t"
         "packsswb                %%mm1, %%mm0           \n\t"
-        "paddb  "MANGLE(bgr2UVOffset)", %%mm0           \n\t"
+        "paddb "MANGLE(ff_bgr2UVOffset)", %%mm0         \n\t"
         "movd                    %%mm0, (%2, %%"REG_a") \n\t"
         "punpckhdq               %%mm0, %%mm0           \n\t"
         "movd                    %%mm0, (%3, %%"REG_a") \n\t"
diff -u mplayer-1.0~rc2-12/libswscale/swscale_altivec_template.c ffmpeg-free-0.svn20080206/libswscale/swscale_altivec_template.c
--- mplayer-1.0~rc2-12/libswscale/swscale_altivec_template.c	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/swscale_altivec_template.c	2008-01-17 12:07:27.000000000 +0100
@@ -27,10 +27,10 @@
 altivec_packIntArrayToCharArray(int *val, uint8_t* dest, int dstW) {
     register int i;
     vector unsigned int altivec_vectorShiftInt19 =
-        vec_add(vec_splat_u32(10),vec_splat_u32(9));
+        vec_add(vec_splat_u32(10), vec_splat_u32(9));
     if ((unsigned long)dest % 16) {
-        /* badly aligned store, we force store alignement */
-        /* and will handle load misalignement on val w/ vec_perm */
+        /* badly aligned store, we force store alignment */
+        /* and will handle load misalignment on val w/ vec_perm */
         vector unsigned char perm1;
         vector signed int v1;
         for (i = 0 ; (i < dstW) &&
@@ -46,10 +46,10 @@
             vector signed int v3 = vec_ld(offset + 32, val);
             vector signed int v4 = vec_ld(offset + 48, val);
             vector signed int v5 = vec_ld(offset + 64, val);
-            vector signed int v12 = vec_perm(v1,v2,perm1);
-            vector signed int v23 = vec_perm(v2,v3,perm1);
-            vector signed int v34 = vec_perm(v3,v4,perm1);
-            vector signed int v45 = vec_perm(v4,v5,perm1);
+            vector signed int v12 = vec_perm(v1, v2, perm1);
+            vector signed int v23 = vec_perm(v2, v3, perm1);
+            vector signed int v34 = vec_perm(v3, v4, perm1);
+            vector signed int v45 = vec_perm(v4, v5, perm1);
 
             vector signed int vA = vec_sra(v12, altivec_vectorShiftInt19);
             vector signed int vB = vec_sra(v23, altivec_vectorShiftInt19);
@@ -137,7 +137,7 @@
                 val[i] += lumSrc[j][i] * lumFilter[j];
             }
         }
-        altivec_packIntArrayToCharArray(val,dest,dstW);
+        altivec_packIntArrayToCharArray(val, dest, dstW);
     }
     if (uDest != 0) {
         int  __attribute__ ((aligned (16))) u[chrDstW];
@@ -203,8 +203,8 @@
                 v[i] += chrSrc[j][i + 2048] * chrFilter[j];
             }
         }
-        altivec_packIntArrayToCharArray(u,uDest,chrDstW);
-        altivec_packIntArrayToCharArray(v,vDest,chrDstW);
+        altivec_packIntArrayToCharArray(u, uDest, chrDstW);
+        altivec_packIntArrayToCharArray(v, vDest, chrDstW);
     }
 }
 
@@ -252,9 +252,9 @@
         // and we're going to use vec_mule, so we chose
         // carefully how to "unpack" the elements into the even slots
         if ((i << 3) % 16)
-            filter_v = vec_mergel(filter_v,(vector signed short)vzero);
+            filter_v = vec_mergel(filter_v, (vector signed short)vzero);
         else
-            filter_v = vec_mergeh(filter_v,(vector signed short)vzero);
+            filter_v = vec_mergeh(filter_v, (vector signed short)vzero);
 
         val_vEven = vec_mule(src_v, filter_v);
         val_s = vec_sums(val_vEven, vzero);
@@ -354,7 +354,7 @@
             src_v0 = src_v1;
         }
 
-        if (j < (filterSize-7)) {
+        if (j < filterSize-7) {
             // loading src_v0 is useless, it's already done above
             //vector unsigned char src_v0 = vec_ld(srcPos + j, src);
             vector unsigned char src_v1, src_vF;
@@ -387,7 +387,7 @@
 static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,
                                               int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) {
     uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;
-    // yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );
+    // yv12toyuy2(src[0], src[1], src[2], dst, c->srcW, srcSliceH, srcStride[0], srcStride[1], dstStride[0]);
     uint8_t *ysrc = src[0];
     uint8_t *usrc = src[1];
     uint8_t *vsrc = src[2];
@@ -401,7 +401,7 @@
     register unsigned int y;
 
     if (width&15) {
-        yv12toyuy2( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride);
+        yv12toyuy2(ysrc, usrc, vsrc, dst, c->srcW, srcSliceH, lumStride, chromStride, dstStride);
         return srcSliceH;
     }
 
@@ -450,7 +450,7 @@
             vec_st(v_yuy2_0, (i << 1), dst);
             vec_st(v_yuy2_1, (i << 1) + 16, dst);
         }
-        if ( (y&(vertLumPerChroma-1))==(vertLumPerChroma-1) ) {
+        if ((y&(vertLumPerChroma-1)) == vertLumPerChroma-1) {
             usrc += chromStride;
             vsrc += chromStride;
         }
@@ -464,7 +464,7 @@
 static inline int yv12touyvy_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,
                                               int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) {
     uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;
-    // yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );
+    // yv12toyuy2(src[0], src[1], src[2], dst, c->srcW, srcSliceH, srcStride[0], srcStride[1], dstStride[0]);
     uint8_t *ysrc = src[0];
     uint8_t *usrc = src[1];
     uint8_t *vsrc = src[2];
@@ -478,7 +478,7 @@
     register unsigned int y;
 
     if (width&15) {
-        yv12touyvy( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride);
+        yv12touyvy(ysrc, usrc, vsrc, dst, c->srcW, srcSliceH, lumStride, chromStride, dstStride);
         return srcSliceH;
     }
 
@@ -527,7 +527,7 @@
             vec_st(v_uyvy_0, (i << 1), dst);
             vec_st(v_uyvy_1, (i << 1) + 16, dst);
         }
-        if ( (y&(vertLumPerChroma-1))==(vertLumPerChroma-1) ) {
+        if ((y&(vertLumPerChroma-1)) == vertLumPerChroma-1) {
             usrc += chromStride;
             vsrc += chromStride;
         }
diff -u mplayer-1.0~rc2-12/libswscale/swscale.c ffmpeg-free-0.svn20080206/libswscale/swscale.c
--- mplayer-1.0~rc2-12/libswscale/swscale.c	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/swscale.c	2008-06-18 12:09:30.000000000 +0200
@@ -180,14 +180,14 @@
 */
 
 #if defined(ARCH_X86) && defined (CONFIG_GPL)
-static uint64_t attribute_used __attribute__((aligned(8))) bF8=       0xF8F8F8F8F8F8F8F8LL;
-static uint64_t attribute_used __attribute__((aligned(8))) bFC=       0xFCFCFCFCFCFCFCFCLL;
-static uint64_t                __attribute__((aligned(8))) w10=       0x0010001000100010LL;
-static uint64_t attribute_used __attribute__((aligned(8))) w02=       0x0002000200020002LL;
-static uint64_t attribute_used __attribute__((aligned(8))) bm00001111=0x00000000FFFFFFFFLL;
-static uint64_t attribute_used __attribute__((aligned(8))) bm00000111=0x0000000000FFFFFFLL;
-static uint64_t attribute_used __attribute__((aligned(8))) bm11111000=0xFFFFFFFFFF000000LL;
-static uint64_t attribute_used __attribute__((aligned(8))) bm01010101=0x00FF00FF00FF00FFLL;
+DECLARE_ASM_CONST(8, uint64_t, bF8)=       0xF8F8F8F8F8F8F8F8LL;
+DECLARE_ASM_CONST(8, uint64_t, bFC)=       0xFCFCFCFCFCFCFCFCLL;
+DECLARE_ASM_CONST(8, uint64_t, w10)=       0x0010001000100010LL;
+DECLARE_ASM_CONST(8, uint64_t, w02)=       0x0002000200020002LL;
+DECLARE_ASM_CONST(8, uint64_t, bm00001111)=0x00000000FFFFFFFFLL;
+DECLARE_ASM_CONST(8, uint64_t, bm00000111)=0x0000000000FFFFFFLL;
+DECLARE_ASM_CONST(8, uint64_t, bm11111000)=0xFFFFFFFFFF000000LL;
+DECLARE_ASM_CONST(8, uint64_t, bm01010101)=0x00FF00FF00FF00FFLL;
 
 static volatile uint64_t attribute_used __attribute__((aligned(8))) b5Dither;
 static volatile uint64_t attribute_used __attribute__((aligned(8))) g5Dither;
@@ -202,29 +202,29 @@
         0x0602060206020602LL,
         0x0004000400040004LL,};
 
-static uint64_t                __attribute__((aligned(8))) b16Mask=   0x001F001F001F001FLL;
-static uint64_t attribute_used __attribute__((aligned(8))) g16Mask=   0x07E007E007E007E0LL;
-static uint64_t attribute_used __attribute__((aligned(8))) r16Mask=   0xF800F800F800F800LL;
-static uint64_t                __attribute__((aligned(8))) b15Mask=   0x001F001F001F001FLL;
-static uint64_t attribute_used __attribute__((aligned(8))) g15Mask=   0x03E003E003E003E0LL;
-static uint64_t attribute_used __attribute__((aligned(8))) r15Mask=   0x7C007C007C007C00LL;
-
-static uint64_t attribute_used __attribute__((aligned(8))) M24A=      0x00FF0000FF0000FFLL;
-static uint64_t attribute_used __attribute__((aligned(8))) M24B=      0xFF0000FF0000FF00LL;
-static uint64_t attribute_used __attribute__((aligned(8))) M24C=      0x0000FF0000FF0000LL;
+DECLARE_ASM_CONST(8, uint64_t, b16Mask)=   0x001F001F001F001FLL;
+DECLARE_ASM_CONST(8, uint64_t, g16Mask)=   0x07E007E007E007E0LL;
+DECLARE_ASM_CONST(8, uint64_t, r16Mask)=   0xF800F800F800F800LL;
+DECLARE_ASM_CONST(8, uint64_t, b15Mask)=   0x001F001F001F001FLL;
+DECLARE_ASM_CONST(8, uint64_t, g15Mask)=   0x03E003E003E003E0LL;
+DECLARE_ASM_CONST(8, uint64_t, r15Mask)=   0x7C007C007C007C00LL;
+
+DECLARE_ALIGNED(8, const uint64_t, ff_M24A)         = 0x00FF0000FF0000FFLL;
+DECLARE_ALIGNED(8, const uint64_t, ff_M24B)         = 0xFF0000FF0000FF00LL;
+DECLARE_ALIGNED(8, const uint64_t, ff_M24C)         = 0x0000FF0000FF0000LL;
 
 #ifdef FAST_BGR2YV12
-static const uint64_t bgr2YCoeff   attribute_used __attribute__((aligned(8))) = 0x000000210041000DULL;
-static const uint64_t bgr2UCoeff   attribute_used __attribute__((aligned(8))) = 0x0000FFEEFFDC0038ULL;
-static const uint64_t bgr2VCoeff   attribute_used __attribute__((aligned(8))) = 0x00000038FFD2FFF8ULL;
+DECLARE_ALIGNED(8, const uint64_t, ff_bgr2YCoeff)   = 0x000000210041000DULL;
+DECLARE_ALIGNED(8, const uint64_t, ff_bgr2UCoeff)   = 0x0000FFEEFFDC0038ULL;
+DECLARE_ALIGNED(8, const uint64_t, ff_bgr2VCoeff)   = 0x00000038FFD2FFF8ULL;
 #else
-static const uint64_t bgr2YCoeff   attribute_used __attribute__((aligned(8))) = 0x000020E540830C8BULL;
-static const uint64_t bgr2UCoeff   attribute_used __attribute__((aligned(8))) = 0x0000ED0FDAC23831ULL;
-static const uint64_t bgr2VCoeff   attribute_used __attribute__((aligned(8))) = 0x00003831D0E6F6EAULL;
+DECLARE_ALIGNED(8, const uint64_t, ff_bgr2YCoeff)   = 0x000020E540830C8BULL;
+DECLARE_ALIGNED(8, const uint64_t, ff_bgr2UCoeff)   = 0x0000ED0FDAC23831ULL;
+DECLARE_ALIGNED(8, const uint64_t, ff_bgr2VCoeff)   = 0x00003831D0E6F6EAULL;
 #endif /* FAST_BGR2YV12 */
-static const uint64_t bgr2YOffset  attribute_used __attribute__((aligned(8))) = 0x1010101010101010ULL;
-static const uint64_t bgr2UVOffset attribute_used __attribute__((aligned(8))) = 0x8080808080808080ULL;
-static const uint64_t w1111        attribute_used __attribute__((aligned(8))) = 0x0001000100010001ULL;
+DECLARE_ALIGNED(8, const uint64_t, ff_bgr2YOffset)  = 0x1010101010101010ULL;
+DECLARE_ALIGNED(8, const uint64_t, ff_bgr2UVOffset) = 0x8080808080808080ULL;
+DECLARE_ALIGNED(8, const uint64_t, ff_w1111)        = 0x0001000100010001ULL;
 #endif /* defined(ARCH_X86) */
 
 // clipping helper table for C implementations:
@@ -367,7 +367,7 @@
 {
     volatile int i= bF8+bFC+w10+
     bm00001111+bm00000111+bm11111000+b16Mask+g16Mask+r16Mask+b15Mask+g15Mask+r15Mask+
-    M24A+M24B+M24C+w02 + b5Dither+g5Dither+r5Dither+g6Dither+dither4[0]+dither8[0]+bm01010101;
+    ff_M24A+ff_M24B+ff_M24C+w02 + b5Dither+g5Dither+r5Dither+g6Dither+dither4[0]+dither8[0]+bm01010101;
     if (i) i=0;
 }
 #endif
@@ -388,7 +388,7 @@
         dest[i]= av_clip_uint8(val>>19);
     }
 
-    if (uDest != NULL)
+    if (uDest)
         for (i=0; i<chrDstW; i++)
         {
             int u=1<<18;
@@ -421,7 +421,7 @@
         dest[i]= av_clip_uint8(val>>19);
     }
 
-    if (uDest == NULL)
+    if (!uDest)
         return;
 
     if (dstFormat == PIX_FMT_NV12)
@@ -1357,7 +1357,7 @@
     return 0;
 }
 
-#ifdef COMPILE_MMX2
+#if defined (COMPILE_MMX2) && !defined(ARCH_X86_64)
 static void initMMX2HScaler(int dstW, int xInc, uint8_t *funnyCode, int16_t *filter, int32_t *filterPos, int numSplits)
 {
     uint8_t *fragmentA;
@@ -1543,7 +1543,7 @@
 
 #if defined(RUNTIME_CPUDETECT) && defined (CONFIG_GPL)
 #if defined(ARCH_X86)
-    // ordered per speed fasterst first
+    // ordered per speed fastest first
     if (flags & SWS_CPU_CAPS_MMX2)
         return swScale_MMX2;
     else if (flags & SWS_CPU_CAPS_3DNOW)
@@ -1597,9 +1597,9 @@
     }
     dst = dstParam[1] + dstStride[1]*srcSliceY/2;
     if (c->dstFormat == PIX_FMT_NV12)
-        interleaveBytes( src[1],src[2],dst,c->srcW/2,srcSliceH/2,srcStride[1],srcStride[2],dstStride[0] );
+        interleaveBytes(src[1], src[2], dst, c->srcW/2, srcSliceH/2, srcStride[1], srcStride[2], dstStride[0]);
     else
-        interleaveBytes( src[2],src[1],dst,c->srcW/2,srcSliceH/2,srcStride[2],srcStride[1],dstStride[0] );
+        interleaveBytes(src[2], src[1], dst, c->srcW/2, srcSliceH/2, srcStride[2], srcStride[1], dstStride[0]);
 
     return srcSliceH;
 }
@@ -1608,7 +1608,7 @@
                                int srcSliceH, uint8_t* dstParam[], int dstStride[]){
     uint8_t *dst=dstParam[0] + dstStride[0]*srcSliceY;
 
-    yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );
+    yv12toyuy2(src[0], src[1], src[2], dst, c->srcW, srcSliceH, srcStride[0], srcStride[1], dstStride[0]);
 
     return srcSliceH;
 }
@@ -1617,7 +1617,7 @@
                                int srcSliceH, uint8_t* dstParam[], int dstStride[]){
     uint8_t *dst=dstParam[0] + dstStride[0]*srcSliceY;
 
-    yv12touyvy( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );
+    yv12touyvy(src[0], src[1], src[2], dst, c->srcW, srcSliceH, srcStride[0], srcStride[1], dstStride[0]);
 
     return srcSliceH;
 }
@@ -1681,7 +1681,7 @@
 
     if(conv)
     {
-        if (dstStride[0]*srcBpp == srcStride[0]*dstBpp)
+        if (dstStride[0]*srcBpp == srcStride[0]*dstBpp && srcStride[0] > 0)
             conv(src[0], dst[0] + dstStride[0]*srcSliceY, srcSliceH*srcStride[0]);
         else
         {
@@ -2050,7 +2050,7 @@
 #endif
 #endif /* RUNTIME_CPUDETECT */
     if (clip_table[512] != 255) globalInit();
-    if (rgb15to16 == NULL) sws_rgb2rgb_init(flags);
+    if (!rgb15to16) sws_rgb2rgb_init(flags);
 
     unscaled = (srcW == dstW && srcH == dstH);
     needsDither= (isBGR(dstFormat) || isRGB(dstFormat))
@@ -2097,14 +2097,14 @@
     c->vRounder= 4* 0x0001000100010001ULL;
 
     usesHFilter= usesVFilter= 0;
-    if (dstFilter->lumV!=NULL && dstFilter->lumV->length>1) usesVFilter=1;
-    if (dstFilter->lumH!=NULL && dstFilter->lumH->length>1) usesHFilter=1;
-    if (dstFilter->chrV!=NULL && dstFilter->chrV->length>1) usesVFilter=1;
-    if (dstFilter->chrH!=NULL && dstFilter->chrH->length>1) usesHFilter=1;
-    if (srcFilter->lumV!=NULL && srcFilter->lumV->length>1) usesVFilter=1;
-    if (srcFilter->lumH!=NULL && srcFilter->lumH->length>1) usesHFilter=1;
-    if (srcFilter->chrV!=NULL && srcFilter->chrV->length>1) usesVFilter=1;
-    if (srcFilter->chrH!=NULL && srcFilter->chrH->length>1) usesHFilter=1;
+    if (dstFilter->lumV && dstFilter->lumV->length>1) usesVFilter=1;
+    if (dstFilter->lumH && dstFilter->lumH->length>1) usesHFilter=1;
+    if (dstFilter->chrV && dstFilter->chrV->length>1) usesVFilter=1;
+    if (dstFilter->chrH && dstFilter->chrH->length>1) usesHFilter=1;
+    if (srcFilter->lumV && srcFilter->lumV->length>1) usesVFilter=1;
+    if (srcFilter->lumH && srcFilter->lumH->length>1) usesHFilter=1;
+    if (srcFilter->chrV && srcFilter->chrV->length>1) usesVFilter=1;
+    if (srcFilter->chrH && srcFilter->chrH->length>1) usesHFilter=1;
 
     getSubSampleFactors(&c->chrSrcHSubSample, &c->chrSrcVSubSample, srcFormat);
     getSubSampleFactors(&c->chrDstHSubSample, &c->chrDstVSubSample, dstFormat);
@@ -2158,7 +2158,7 @@
         }
 #endif
 
-        if ( srcFormat==PIX_FMT_YUV410P && dstFormat==PIX_FMT_YUV420P )
+        if (srcFormat==PIX_FMT_YUV410P && dstFormat==PIX_FMT_YUV420P)
         {
             c->swScale= yvu9toyv12Wrapper;
         }
@@ -2214,7 +2214,7 @@
         /* simple copy */
         if (  srcFormat == dstFormat
             || (isPlanarYUV(srcFormat) && isGray(dstFormat))
-            || (isPlanarYUV(dstFormat) && isGray(srcFormat)) )
+            || (isPlanarYUV(dstFormat) && isGray(srcFormat)))
         {
             c->swScale= simpleCopy;
         }
@@ -2300,7 +2300,7 @@
                    srcFilter->chrH, dstFilter->chrH, c->param);
 
 #define MAX_FUNNY_CODE_SIZE 10000
-#if defined(COMPILE_MMX2)
+#if defined (COMPILE_MMX2) && !defined(ARCH_X86_64)
 // can't downscale !!!
         if (c->canMMX2BeUsed && (flags & SWS_FAST_BILINEAR))
         {
@@ -2373,7 +2373,7 @@
         nextSlice>>= c->chrSrcVSubSample;
         nextSlice<<= c->chrSrcVSubSample;
         if (c->vLumFilterPos[i   ] + c->vLumBufSize < nextSlice)
-            c->vLumBufSize= nextSlice - c->vLumFilterPos[i   ];
+            c->vLumBufSize= nextSlice - c->vLumFilterPos[i];
         if (c->vChrFilterPos[chrI] + c->vChrBufSize < (nextSlice>>c->chrSrcVSubSample))
             c->vChrBufSize= (nextSlice>>c->chrSrcVSubSample) - c->vChrFilterPos[chrI];
     }
@@ -2489,7 +2489,7 @@
         {
             if (c->vLumFilterSize==1 && c->vChrFilterSize==2)
                 av_log(c, AV_LOG_VERBOSE, "SwScaler: using 1-tap %s \"scaler\" for vertical luminance scaling (BGR)\n"
-                       "SwScaler:       2-tap scaler for vertical chrominance scaling (BGR)\n",(flags & SWS_CPU_CAPS_MMX) ? "MMX" : "C");
+                       "SwScaler:       2-tap scaler for vertical chrominance scaling (BGR)\n", (flags & SWS_CPU_CAPS_MMX) ? "MMX" : "C");
             else if (c->vLumFilterSize==2 && c->vChrFilterSize==2)
                 av_log(c, AV_LOG_VERBOSE, "SwScaler: using 2-tap linear %s scaler for vertical scaling (BGR)\n", (flags & SWS_CPU_CAPS_MMX) ? "MMX" : "C");
             else
@@ -2521,7 +2521,7 @@
 }
 
 /**
- * swscale warper, so we don't need to export the SwsContext.
+ * swscale wrapper, so we don't need to export the SwsContext.
  * assumes planar YUV to be in YUV order instead of YVU
  */
 int sws_scale(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,
@@ -2575,7 +2575,7 @@
 }
 
 /**
- * swscale warper, so we don't need to export the SwsContext
+ * swscale wrapper, so we don't need to export the SwsContext
  */
 int sws_scale_ordered(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,
                       int srcSliceH, uint8_t* dst[], int dstStride[]){
@@ -2657,7 +2657,7 @@
     for (i=0; i<length; i++)
     {
         double dist= i-middle;
-        coeff[i]= exp( -dist*dist/(2*variance*variance) ) / sqrt(2*variance*PI);
+        coeff[i]= exp(-dist*dist/(2*variance*variance)) / sqrt(2*variance*PI);
     }
 
     sws_normalizeVec(vec, 1.0);
@@ -2959,18 +2959,23 @@
                                         int dstW, int dstH, int dstFormat, int flags,
                                         SwsFilter *srcFilter, SwsFilter *dstFilter, double *param)
 {
-    if (context != NULL) {
-        if ((context->srcW != srcW) || (context->srcH != srcH) ||
-            (context->srcFormat != srcFormat) ||
-            (context->dstW != dstW) || (context->dstH != dstH) ||
-            (context->dstFormat != dstFormat) || (context->flags != flags) ||
-            (context->param != param))
+    static const double default_param[2] = {SWS_PARAM_DEFAULT, SWS_PARAM_DEFAULT};
+
+    if (!param)
+        param = default_param;
+
+    if (context) {
+        if (context->srcW != srcW || context->srcH != srcH ||
+            context->srcFormat != srcFormat ||
+            context->dstW != dstW || context->dstH != dstH ||
+            context->dstFormat != dstFormat || context->flags != flags ||
+            context->param[0] != param[0] || context->param[1] != param[1])
         {
             sws_freeContext(context);
             context = NULL;
         }
     }
-    if (context == NULL) {
+    if (!context) {
         return sws_getContext(srcW, srcH, srcFormat,
                               dstW, dstH, dstFormat, flags,
                               srcFilter, dstFilter, param);
diff -u mplayer-1.0~rc2-12/libswscale/swscale-example.c ffmpeg-free-0.svn20080206/libswscale/swscale-example.c
--- mplayer-1.0~rc2-12/libswscale/swscale-example.c	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/swscale-example.c	2008-01-17 16:49:31.000000000 +0100
@@ -76,7 +76,7 @@
         src[i]= (uint8_t*) malloc(srcStride[i]*srcH);
         dst[i]= (uint8_t*) malloc(dstStride[i]*dstH);
         out[i]= (uint8_t*) malloc(refStride[i]*h);
-        if ((src[i] == NULL) || (dst[i] == NULL) || (out[i] == NULL)) {
+        if (!src[i] || !dst[i] || !out[i]) {
             perror("Malloc");
             res = -1;
 
@@ -86,7 +86,7 @@
 
     dstContext = outContext = NULL;
     srcContext= sws_getContext(w, h, PIX_FMT_YUV420P, srcW, srcH, srcFormat, flags, NULL, NULL, NULL);
-    if (srcContext == NULL) {
+    if (!srcContext) {
         fprintf(stderr, "Failed to get %s ---> %s\n",
                 sws_format_name(PIX_FMT_YUV420P),
                 sws_format_name(srcFormat));
@@ -95,7 +95,7 @@
         goto end;
     }
     dstContext= sws_getContext(srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, NULL, NULL, NULL);
-    if (dstContext == NULL) {
+    if (!dstContext) {
         fprintf(stderr, "Failed to get %s ---> %s\n",
                 sws_format_name(srcFormat),
                 sws_format_name(dstFormat));
@@ -104,7 +104,7 @@
         goto end;
     }
     outContext= sws_getContext(dstW, dstH, dstFormat, w, h, PIX_FMT_YUV420P, flags, NULL, NULL, NULL);
-    if (outContext == NULL) {
+    if (!outContext) {
         fprintf(stderr, "Failed to get %s ---> %s\n",
                 sws_format_name(dstFormat),
                 sws_format_name(PIX_FMT_YUV420P));
@@ -217,13 +217,13 @@
 #else
     sws_rgb2rgb_init(0);
 #endif
-    sws_scale(sws, rgb_src, rgb_stride, 0, H   , src, stride);
+    sws_scale(sws, rgb_src, rgb_stride, 0, H, src, stride);
 
 #if defined(ARCH_X86)
     asm volatile ("emms\n\t");
 #endif
 
-    selfTest(src,  stride, W, H);
+    selfTest(src, stride, W, H);
 
     return 123;
 }
diff -u mplayer-1.0~rc2-12/libswscale/swscale.h ffmpeg-free-0.svn20080206/libswscale/swscale.h
--- mplayer-1.0~rc2-12/libswscale/swscale.h	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/swscale.h	2007-10-18 11:30:33.000000000 +0200
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef SWSCALE_H
-#define SWSCALE_H
+#ifndef FFMPEG_SWSCALE_H
+#define FFMPEG_SWSCALE_H
 
 /**
  * @file swscale.h
@@ -138,4 +138,4 @@
                                         int dstW, int dstH, int dstFormat, int flags,
                                         SwsFilter *srcFilter, SwsFilter *dstFilter, double *param);
 
-#endif
+#endif /* FFMPEG_SWSCALE_H */
diff -u mplayer-1.0~rc2-12/libswscale/swscale_internal.h ffmpeg-free-0.svn20080206/libswscale/swscale_internal.h
--- mplayer-1.0~rc2-12/libswscale/swscale_internal.h	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/swscale_internal.h	2007-12-21 12:47:09.000000000 +0100
@@ -18,8 +18,10 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef SWSCALE_INTERNAL_H
-#define SWSCALE_INTERNAL_H
+#ifndef FFMPEG_SWSCALE_INTERNAL_H
+#define FFMPEG_SWSCALE_INTERNAL_H
+
+#include "config.h"
 
 #ifdef HAVE_ALTIVEC_H
 #include <altivec.h>
@@ -40,8 +42,8 @@
     AVClass *av_class;
 
     /**
-     *
-     * Note the src,dst,srcStride,dstStride will be copied, in the sws_scale() warper so they can freely be modified here
+     * Note that src, dst, srcStride, dstStride will be copied in the
+     * sws_scale() wrapper so they can be freely modified here.
      */
     SwsFunc swScale;
     int srcW, srcH, dstH;
@@ -181,6 +183,13 @@
 SwsFunc yuv2rgb_get_func_ptr (SwsContext *c);
 int yuv2rgb_c_init_tables (SwsContext *c, const int inv_table[4], int fullRange, int brightness, int contrast, int saturation);
 
+void yuv2rgb_altivec_init_tables (SwsContext *c, const int inv_table[4],int brightness,int contrast, int saturation);
+SwsFunc yuv2rgb_init_altivec (SwsContext *c);
+void altivec_yuv2packedX (SwsContext *c,
+                          int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,
+                          int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,
+                          uint8_t *dest, int dstW, int dstY);
+
 char *sws_format_name(int format);
 
 //FIXME replace this with something faster
@@ -263,4 +272,4 @@
     }
 }
 
-#endif
+#endif /* FFMPEG_SWSCALE_INTERNAL_H */
diff -u mplayer-1.0~rc2-12/libswscale/swscale_template.c ffmpeg-free-0.svn20080206/libswscale/swscale_template.c
--- mplayer-1.0~rc2-12/libswscale/swscale_template.c	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/swscale_template.c	2008-01-29 15:58:10.000000000 +0100
@@ -39,7 +39,7 @@
 #ifdef HAVE_3DNOW
 #define PREFETCH  "prefetch"
 #define PREFETCHW "prefetchw"
-#elif defined ( HAVE_MMX2 )
+#elif defined (HAVE_MMX2)
 #define PREFETCH "prefetchnta"
 #define PREFETCHW "prefetcht0"
 #else
@@ -855,8 +855,8 @@
 
 #define WRITEBGR24MMX2(dst, dstw, index) \
     /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\
-    "movq "MANGLE(M24A)", %%mm0 \n\t"\
-    "movq "MANGLE(M24C)", %%mm7 \n\t"\
+    "movq "MANGLE(ff_M24A)", %%mm0 \n\t"\
+    "movq "MANGLE(ff_M24C)", %%mm7 \n\t"\
     "pshufw $0x50, %%mm2, %%mm1 \n\t" /* B3 B2 B3 B2  B1 B0 B1 B0 */\
     "pshufw $0x50, %%mm4, %%mm3 \n\t" /* G3 G2 G3 G2  G1 G0 G1 G0 */\
     "pshufw $0x00, %%mm5, %%mm6 \n\t" /* R1 R0 R1 R0  R1 R0 R1 R0 */\
@@ -875,7 +875,7 @@
     "pshufw $0x55, %%mm4, %%mm3 \n\t" /* G4 G3 G4 G3  G4 G3 G4 G3 */\
     "pshufw $0xA5, %%mm5, %%mm6 \n\t" /* R5 R4 R5 R4  R3 R2 R3 R2 */\
 \
-    "pand "MANGLE(M24B)", %%mm1 \n\t" /* B5       B4        B3    */\
+    "pand "MANGLE(ff_M24B)", %%mm1 \n\t" /* B5       B4        B3    */\
     "pand   %%mm7, %%mm3        \n\t" /*       G4        G3       */\
     "pand   %%mm0, %%mm6        \n\t" /*    R4        R3       R2 */\
 \
@@ -889,7 +889,7 @@
 \
     "pand   %%mm7, %%mm1        \n\t" /*       B7        B6       */\
     "pand   %%mm0, %%mm3        \n\t" /*    G7        G6       G5 */\
-    "pand "MANGLE(M24B)", %%mm6 \n\t" /* R7       R6        R5    */\
+    "pand "MANGLE(ff_M24B)", %%mm6 \n\t" /* R7       R6        R5    */\
 \
     "por    %%mm1, %%mm3        \n\t"\
     "por    %%mm3, %%mm6        \n\t"\
@@ -957,7 +957,7 @@
             chrFilter, chrSrc, chrFilterSize,
             dest, uDest, vDest, dstW, chrDstW);
 #endif //!HAVE_ALTIVEC
-#endif
+#endif /* HAVE_MMX */
 }
 
 static inline void RENAME(yuv2nv12X)(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,
@@ -973,7 +973,7 @@
                                     uint8_t *dest, uint8_t *uDest, uint8_t *vDest, long dstW, long chrDstW)
 {
 #ifdef HAVE_MMX
-    if (uDest != NULL)
+    if (uDest)
     {
         asm volatile(
             YSCALEYUV2YV121
@@ -1010,7 +1010,7 @@
         dest[i]= val;
     }
 
-    if (uDest != NULL)
+    if (uDest)
         for (i=0; i<chrDstW; i++)
         {
             int u=chrSrc[i]>>7;
@@ -1161,7 +1161,7 @@
             return;
         }
     }
-#endif
+#endif /* HAVE_MMX */
 #ifdef HAVE_ALTIVEC
     /* The following list of supported dstFormat values should
        match what's found in the body of altivec_yuv2packedX() */
@@ -1333,7 +1333,7 @@
             : "%"REG_a
             );
             break;
-#endif
+#endif /* HAVE_MMX */
         case PIX_FMT_BGR32:
 #ifndef HAVE_MMX
         case PIX_FMT_RGB32:
@@ -1513,7 +1513,7 @@
     }
 
 #ifdef HAVE_MMX
-    if ( uvalpha < 2048 ) // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster
+    if (uvalpha < 2048) // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster
     {
         switch(dstFormat)
         {
@@ -1691,8 +1691,8 @@
             return;
         }
     }
-#endif
-    if ( uvalpha < 2048 )
+#endif /* HAVE_MMX */
+    if (uvalpha < 2048)
     {
         YSCALE_YUV_2_ANYRGB_C(YSCALE_YUV_2_RGB1_C, YSCALE_YUV_2_PACKED1_C)
     }else{
@@ -1831,7 +1831,7 @@
         int g= (((uint32_t*)src)[i]>>8)&0xFF;
         int r= (((uint32_t*)src)[i]>>16)&0xFF;
 
-        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
+        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);
     }
 }
 
@@ -1859,8 +1859,8 @@
 #ifdef HAVE_MMX
     asm volatile(
     "mov                        %2, %%"REG_a"   \n\t"
-    "movq     "MANGLE(bgr2YCoeff)", %%mm6       \n\t"
-    "movq          "MANGLE(w1111)", %%mm5       \n\t"
+    "movq  "MANGLE(ff_bgr2YCoeff)", %%mm6       \n\t"
+    "movq       "MANGLE(ff_w1111)", %%mm5       \n\t"
     "pxor                    %%mm7, %%mm7       \n\t"
     "lea (%%"REG_a", %%"REG_a", 2), %%"REG_d"   \n\t"
     ASMALIGN(4)
@@ -1918,7 +1918,7 @@
     "psraw                      $7, %%mm4       \n\t"
 
     "packuswb                %%mm4, %%mm0       \n\t"
-    "paddusb "MANGLE(bgr2YOffset)", %%mm0       \n\t"
+    "paddusb "MANGLE(ff_bgr2YOffset)", %%mm0    \n\t"
 
     "movq                    %%mm0, (%1, %%"REG_a") \n\t"
     "add                        $8, %%"REG_a"   \n\t"
@@ -1934,9 +1934,9 @@
         int g= src[i*3+1];
         int r= src[i*3+2];
 
-        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
+        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);
     }
-#endif
+#endif /* HAVE_MMX */
 }
 
 static inline void RENAME(bgr24ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, long width)
@@ -1944,8 +1944,8 @@
 #ifdef HAVE_MMX
     asm volatile(
     "mov                        %3, %%"REG_a"   \n\t"
-    "movq          "MANGLE(w1111)", %%mm5       \n\t"
-    "movq     "MANGLE(bgr2UCoeff)", %%mm6       \n\t"
+    "movq       "MANGLE(ff_w1111)", %%mm5       \n\t"
+    "movq  "MANGLE(ff_bgr2UCoeff)", %%mm6       \n\t"
     "pxor                    %%mm7, %%mm7       \n\t"
     "lea (%%"REG_a", %%"REG_a", 2), %%"REG_d"   \n\t"
     "add                 %%"REG_d", %%"REG_d"   \n\t"
@@ -1977,8 +1977,8 @@
     "psrlw                      $1, %%mm0       \n\t"
     "psrlw                      $1, %%mm2       \n\t"
 #endif
-    "movq     "MANGLE(bgr2VCoeff)", %%mm1       \n\t"
-    "movq     "MANGLE(bgr2VCoeff)", %%mm3       \n\t"
+    "movq  "MANGLE(ff_bgr2VCoeff)", %%mm1       \n\t"
+    "movq  "MANGLE(ff_bgr2VCoeff)", %%mm3       \n\t"
 
     "pmaddwd                 %%mm0, %%mm1       \n\t"
     "pmaddwd                 %%mm2, %%mm3       \n\t"
@@ -2019,12 +2019,12 @@
     "punpcklbw              %%mm7, %%mm5       \n\t"
     "punpcklbw              %%mm7, %%mm2       \n\t"
     "paddw                  %%mm5, %%mm2       \n\t"
-    "movq         "MANGLE(w1111)", %%mm5       \n\t"
+    "movq      "MANGLE(ff_w1111)", %%mm5       \n\t"
     "psrlw                     $2, %%mm4       \n\t"
     "psrlw                     $2, %%mm2       \n\t"
 #endif
-    "movq    "MANGLE(bgr2VCoeff)", %%mm1       \n\t"
-    "movq    "MANGLE(bgr2VCoeff)", %%mm3       \n\t"
+    "movq "MANGLE(ff_bgr2VCoeff)", %%mm1       \n\t"
+    "movq "MANGLE(ff_bgr2VCoeff)", %%mm3       \n\t"
 
     "pmaddwd                %%mm4, %%mm1       \n\t"
     "pmaddwd                %%mm2, %%mm3       \n\t"
@@ -2048,7 +2048,7 @@
     "punpckldq              %%mm4, %%mm0       \n\t"
     "punpckhdq              %%mm4, %%mm1       \n\t"
     "packsswb               %%mm1, %%mm0       \n\t"
-    "paddb "MANGLE(bgr2UVOffset)", %%mm0       \n\t"
+    "paddb "MANGLE(ff_bgr2UVOffset)", %%mm0    \n\t"
 
     "movd                   %%mm0, (%1, %%"REG_a")  \n\t"
     "punpckhdq              %%mm0, %%mm0            \n\t"
@@ -2069,11 +2069,11 @@
         dstU[i]= ((RU*r + GU*g + BU*b)>>(RGB2YUV_SHIFT+1)) + 128;
         dstV[i]= ((RV*r + GV*g + BV*b)>>(RGB2YUV_SHIFT+1)) + 128;
     }
-#endif
+#endif /* HAVE_MMX */
     assert(src1 == src2);
 }
 
-static inline void RENAME(bgr16ToY)(uint8_t *dst, uint8_t *src, int width)
+static inline void RENAME(rgb16ToY)(uint8_t *dst, uint8_t *src, int width)
 {
     int i;
     for (i=0; i<width; i++)
@@ -2087,7 +2087,7 @@
     }
 }
 
-static inline void RENAME(bgr16ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
+static inline void RENAME(rgb16ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
 {
     int i;
     assert(src1==src2);
@@ -2109,7 +2109,7 @@
     }
 }
 
-static inline void RENAME(bgr15ToY)(uint8_t *dst, uint8_t *src, int width)
+static inline void RENAME(rgb15ToY)(uint8_t *dst, uint8_t *src, int width)
 {
     int i;
     for (i=0; i<width; i++)
@@ -2123,7 +2123,7 @@
     }
 }
 
-static inline void RENAME(bgr15ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
+static inline void RENAME(rgb15ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
 {
     int i;
     assert(src1==src2);
@@ -2155,7 +2155,7 @@
         int g= (((uint32_t*)src)[i]>>8)&0xFF;
         int b= (((uint32_t*)src)[i]>>16)&0xFF;
 
-        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
+        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);
     }
 }
 
@@ -2187,7 +2187,7 @@
         int g= src[i*3+1];
         int b= src[i*3+2];
 
-        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
+        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);
     }
 }
 
@@ -2206,7 +2206,7 @@
     }
 }
 
-static inline void RENAME(rgb16ToY)(uint8_t *dst, uint8_t *src, int width)
+static inline void RENAME(bgr16ToY)(uint8_t *dst, uint8_t *src, int width)
 {
     int i;
     for (i=0; i<width; i++)
@@ -2220,7 +2220,7 @@
     }
 }
 
-static inline void RENAME(rgb16ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
+static inline void RENAME(bgr16ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
 {
     int i;
     assert(src1 == src2);
@@ -2239,7 +2239,7 @@
     }
 }
 
-static inline void RENAME(rgb15ToY)(uint8_t *dst, uint8_t *src, int width)
+static inline void RENAME(bgr15ToY)(uint8_t *dst, uint8_t *src, int width)
 {
     int i;
     for (i=0; i<width; i++)
@@ -2253,7 +2253,7 @@
     }
 }
 
-static inline void RENAME(rgb15ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
+static inline void RENAME(bgr15ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
 {
     int i;
     assert(src1 == src2);
@@ -2476,8 +2476,8 @@
         dst[i] = av_clip(val>>7, 0, (1<<15)-1); // the cubic equation does overflow ...
         //dst[i] = val>>7;
     }
-#endif
-#endif
+#endif /* HAVE_ALTIVEC */
+#endif /* HAVE_MMX */
 }
       // *** horizontal scale Y line to temp buffer
 static inline void RENAME(hyscale)(uint16_t *dst, long dstWidth, uint8_t *src, int srcW, int xInc,
@@ -2594,7 +2594,7 @@
             "add               %%"REG_a", %%"REG_D" \n\t"\
             "xor               %%"REG_a", %%"REG_a" \n\t"\
 
-#endif
+#endif /* ARCH_X86_64 */
 
 FUNNY_Y_CODE
 FUNNY_Y_CODE
@@ -2622,7 +2622,7 @@
         }
         else
         {
-#endif
+#endif /* HAVE_MMX2 */
         long xInc_shr16 = xInc >> 16;
         uint16_t xInc_mask = xInc & 0xffff;
         //NO MMX just normal asm ...
@@ -2678,7 +2678,7 @@
             dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;
             xpos+=xInc;
         }
-#endif
+#endif /* defined(ARCH_X86) */
     }
 }
 
@@ -2812,7 +2812,7 @@
             "add          %%"REG_a", %%"REG_D"  \n\t"\
             "xor          %%"REG_a", %%"REG_a"  \n\t"\
 
-#endif
+#endif /* ARCH_X86_64 */
 
 FUNNY_UV_CODE
 FUNNY_UV_CODE
@@ -2853,7 +2853,7 @@
         }
         else
         {
-#endif
+#endif /* HAVE_MMX2 */
             long xInc_shr16 = (long) (xInc >> 16);
             uint16_t xInc_mask = xInc & 0xffff;
             asm volatile(
@@ -2891,7 +2891,7 @@
 
 /* GCC-3.3 makes MPlayer crash on IA-32 machines when using "g" operand here,
    which is needed to support GCC-4.0 */
-#if defined(ARCH_X86_64) && ((__GNUC__ > 3) || ( __GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#if defined(ARCH_X86_64) && ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
             :: "m" (src1), "m" (dst), "g" ((long)dstWidth), "m" (xInc_shr16), "m" (xInc_mask),
 #else
             :: "m" (src1), "m" (dst), "m" ((long)dstWidth), "m" (xInc_shr16), "m" (xInc_mask),
@@ -2917,7 +2917,7 @@
             */
             xpos+=xInc;
         }
-#endif
+#endif /* defined(ARCH_X86) */
     }
 }
 
@@ -3077,8 +3077,8 @@
                 lastInChrBuf++;
             }
             //wrap buf index around to stay inside the ring buffer
-            if (lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;
-            if (chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;
+            if (lumBufIndex >= vLumBufSize) lumBufIndex-= vLumBufSize;
+            if (chrBufIndex >= vChrBufSize) chrBufIndex-= vChrBufSize;
         }
         else // not enough lines left in this slice -> load the rest in the buffer
         {
@@ -3118,8 +3118,8 @@
                 lastInChrBuf++;
             }
             //wrap buf index around to stay inside the ring buffer
-            if (lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;
-            if (chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;
+            if (lumBufIndex >= vLumBufSize) lumBufIndex-= vLumBufSize;
+            if (chrBufIndex >= vChrBufSize) chrBufIndex-= vChrBufSize;
             break; //we can't output a dstY line so let's try with the next slice
         }
 
diff -u mplayer-1.0~rc2-12/libswscale/yuv2rgb_altivec.c ffmpeg-free-0.svn20080206/libswscale/yuv2rgb_altivec.c
--- mplayer-1.0~rc2-12/libswscale/yuv2rgb_altivec.c	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/yuv2rgb_altivec.c	2008-01-17 09:57:15.000000000 +0100
@@ -762,7 +762,7 @@
         vector signed short vec;
     } buf;
 
-    buf.tmp[0] =  ( (0xffffLL) * contrast>>8 )>>9;                      //cy
+    buf.tmp[0] =  ((0xffffLL) * contrast>>8)>>9;                        //cy
     buf.tmp[1] =  -256*brightness;                                      //oy
     buf.tmp[2] =  (inv_table[0]>>3) *(contrast>>16)*(saturation>>16);   //crv
     buf.tmp[3] =  (inv_table[1]>>3) *(contrast>>16)*(saturation>>16);   //cbu
diff -u mplayer-1.0~rc2-12/libswscale/yuv2rgb_bfin.c ffmpeg-free-0.svn20080206/libswscale/yuv2rgb_bfin.c
--- mplayer-1.0~rc2-12/libswscale/yuv2rgb_bfin.c	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/yuv2rgb_bfin.c	2008-01-17 11:24:14.000000000 +0100
@@ -110,12 +110,12 @@
 
     for (i=0;i<h2;i++) {
 
-        lcscf (py,pu,pv,op,w,&c->oy);
+        lcscf (py, pu, pv, op, w, &c->oy);
 
         py += instrides[0];
         op += outstrides[0];
 
-        lcscf (py,pu,pv,op,w,&c->oy);
+        lcscf (py, pu, pv, op, w, &c->oy);
 
         py += instrides[0];
         pu += instrides[1];
@@ -132,7 +132,7 @@
                                int srcSliceY, int srcSliceH,
                                uint8_t **oplanes, int *outstrides)
 {
-    return core_yuv420_rgb (c,in,instrides,srcSliceY,srcSliceH,oplanes,outstrides,
+    return core_yuv420_rgb (c, in, instrides, srcSliceY, srcSliceH, oplanes, outstrides,
                             ff_bfin_yuv2rgb555_line, 1, 555);
 }
 
@@ -141,7 +141,7 @@
                                int srcSliceY, int srcSliceH,
                                uint8_t **oplanes, int *outstrides)
 {
-    return core_yuv420_rgb (c,in,instrides,srcSliceY,srcSliceH,oplanes,outstrides,
+    return core_yuv420_rgb (c, in, instrides, srcSliceY, srcSliceH, oplanes, outstrides,
                             ff_bfin_yuv2rgb555_line, 0, 555);
 }
 
@@ -150,7 +150,7 @@
                               int srcSliceY, int srcSliceH,
                               uint8_t **oplanes, int *outstrides)
 {
-    return core_yuv420_rgb (c,in,instrides,srcSliceY,srcSliceH,oplanes,outstrides,
+    return core_yuv420_rgb (c, in, instrides, srcSliceY, srcSliceH, oplanes, outstrides,
                             ff_bfin_yuv2rgb24_line, 1, 888);
 }
 
@@ -159,7 +159,7 @@
                               int srcSliceY, int srcSliceH,
                               uint8_t **oplanes, int *outstrides)
 {
-    return core_yuv420_rgb (c,in,instrides,srcSliceY,srcSliceH,oplanes,outstrides,
+    return core_yuv420_rgb (c, in, instrides, srcSliceY, srcSliceH, oplanes, outstrides,
                             ff_bfin_yuv2rgb24_line, 0, 888);
 }
 
@@ -168,7 +168,7 @@
                                int srcSliceY, int srcSliceH,
                                uint8_t **oplanes, int *outstrides)
 {
-    return core_yuv420_rgb (c,in,instrides,srcSliceY,srcSliceH,oplanes,outstrides,
+    return core_yuv420_rgb (c, in, instrides, srcSliceY, srcSliceH, oplanes, outstrides,
                             ff_bfin_yuv2rgb565_line, 1, 565);
 }
 
@@ -177,7 +177,7 @@
                                int srcSliceY, int srcSliceH,
                                uint8_t **oplanes, int *outstrides)
 {
-    return core_yuv420_rgb (c,in,instrides,srcSliceY,srcSliceH,oplanes,outstrides,
+    return core_yuv420_rgb (c, in, instrides, srcSliceY, srcSliceH, oplanes, outstrides,
                             ff_bfin_yuv2rgb565_line, 0, 565);
 }
 
diff -u mplayer-1.0~rc2-12/libswscale/yuv2rgb.c ffmpeg-free-0.svn20080206/libswscale/yuv2rgb.c
--- mplayer-1.0~rc2-12/libswscale/yuv2rgb.c	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/yuv2rgb.c	2008-01-29 15:58:10.000000000 +0100
@@ -159,13 +159,9 @@
 #ifdef HAVE_MMX
 
 /* hope these constant values are cache line aligned */
-static uint64_t attribute_used __attribute__((aligned(8))) mmx_00ffw   = 0x00ff00ff00ff00ffULL;
-static uint64_t attribute_used __attribute__((aligned(8))) mmx_redmask = 0xf8f8f8f8f8f8f8f8ULL;
-static uint64_t attribute_used __attribute__((aligned(8))) mmx_grnmask = 0xfcfcfcfcfcfcfcfcULL;
-
-static uint64_t attribute_used __attribute__((aligned(8))) M24A=   0x00FF0000FF0000FFULL;
-static uint64_t attribute_used __attribute__((aligned(8))) M24B=   0xFF0000FF0000FF00ULL;
-static uint64_t attribute_used __attribute__((aligned(8))) M24C=   0x0000FF0000FF0000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mmx_00ffw)   = 0x00ff00ff00ff00ffULL;
+DECLARE_ASM_CONST(8, uint64_t, mmx_redmask) = 0xf8f8f8f8f8f8f8f8ULL;
+DECLARE_ASM_CONST(8, uint64_t, mmx_grnmask) = 0xfcfcfcfcfcfcfcfcULL;
 
 // the volatile is required because gcc otherwise optimizes some writes away not knowing that these
 // are read in the asm block
diff -u mplayer-1.0~rc2-12/libswscale/yuv2rgb_template.c ffmpeg-free-0.svn20080206/libswscale/yuv2rgb_template.c
--- mplayer-1.0~rc2-12/libswscale/yuv2rgb_template.c	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/yuv2rgb_template.c	2008-01-29 15:58:10.000000000 +0100
@@ -338,8 +338,8 @@
 YUV2RGB
         /* mm0=B, %%mm2=G, %%mm1=R */
 #ifdef HAVE_MMX2
-        "movq "MANGLE(M24A)", %%mm4     \n\t"
-        "movq "MANGLE(M24C)", %%mm7     \n\t"
+        "movq "MANGLE(ff_M24A)", %%mm4     \n\t"
+        "movq "MANGLE(ff_M24C)", %%mm7     \n\t"
         "pshufw $0x50, %%mm0, %%mm5     \n\t" /* B3 B2 B3 B2  B1 B0 B1 B0 */
         "pshufw $0x50, %%mm2, %%mm3     \n\t" /* G3 G2 G3 G2  G1 G0 G1 G0 */
         "pshufw $0x00, %%mm1, %%mm6     \n\t" /* R1 R0 R1 R0  R1 R0 R1 R0 */
@@ -358,7 +358,7 @@
         "pshufw $0x55, %%mm2, %%mm3     \n\t" /* G4 G3 G4 G3  G4 G3 G4 G3 */
         "pshufw $0xA5, %%mm1, %%mm6     \n\t" /* R5 R4 R5 R4  R3 R2 R3 R2 */
 
-        "pand "MANGLE(M24B)", %%mm5     \n\t" /* B5       B4        B3    */
+        "pand "MANGLE(ff_M24B)", %%mm5     \n\t" /* B5       B4        B3    */
         "pand          %%mm7, %%mm3     \n\t" /*       G4        G3       */
         "pand          %%mm4, %%mm6     \n\t" /*    R4        R3       R2 */
 
@@ -373,7 +373,7 @@
 
         "pand          %%mm7, %%mm5     \n\t" /*       B7        B6       */
         "pand          %%mm4, %%mm3     \n\t" /*    G7        G6       G5 */
-        "pand "MANGLE(M24B)", %%mm6     \n\t" /* R7       R6        R5    */
+        "pand "MANGLE(ff_M24B)", %%mm6     \n\t" /* R7       R6        R5    */
         "movd 4 (%3, %0), %%mm1;" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */
 \
         "por          %%mm5, %%mm3      \n\t"
diff -u mplayer-1.0~rc2-12/libswscale/yuv2rgb_vis.c ffmpeg-free-0.svn20080206/libswscale/yuv2rgb_vis.c
--- mplayer-1.0~rc2-12/libswscale/yuv2rgb_vis.c	2007-10-07 21:49:31.000000000 +0200
+++ ffmpeg-free-0.svn20080206/libswscale/yuv2rgb_vis.c	2008-01-17 11:24:14.000000000 +0100
@@ -188,7 +188,7 @@
     c->sparc_coeffs[8]=c->ubCoeff;
     c->sparc_coeffs[9]=c->ugCoeff;
 
-    c->sparc_coeffs[0]=(((int16_t)c->yOffset*(int16_t)c->yCoeff>>11) & 0xffff) * 0x0001000100010001ULL;
+    c->sparc_coeffs[0]=(((int16_t)c->yOffset*(int16_t)c->yCoeff >>11) & 0xffff) * 0x0001000100010001ULL;
     c->sparc_coeffs[1]=(((int16_t)c->uOffset*(int16_t)c->ubCoeff>>11) & 0xffff) * 0x0001000100010001ULL;
     c->sparc_coeffs[2]=(((int16_t)c->uOffset*(int16_t)c->ugCoeff>>11) & 0xffff) * 0x0001000100010001ULL;
     c->sparc_coeffs[3]=(((int16_t)c->vOffset*(int16_t)c->vgCoeff>>11) & 0xffff) * 0x0001000100010001ULL;
